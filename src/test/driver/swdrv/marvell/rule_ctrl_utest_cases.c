/*
 *  rule_ctrl_utest_cases.c
 *  rule_ctrl
 *
 *  Created by yehjunying on 2011/4/29.
 *  Copyright 2011 __MyCompanyName__. All rights reserved.
 *
 */

#include "utest.h"

/*------------------------------------------------------------------------------
 * Help Functions
 *------------------------------------------------------------------------------
 */

typedef struct
{
    BOOL_T debug;
} RULE_CTRL_UT_OPTION_T;

typedef struct
{
    UI32_T total_number;
    UI32_T active_number;
    UI32_T unactive_number;
} RULE_CTRL_UT_RULE_STAT;

typedef struct
{
    UI8_T  src_mac[6];
    UI8_T  src_mac_mask[6];
    UI32_T src_ip;
    UI32_T src_ip_mask;
} RULE_CTRL_UT_VALIDATE_RULE_PATTERN_T;

static RULE_CTRL_UT_OPTION_T rule_ctrl_ut_option;

UI32_T
RULE_CTRL_UT_Proc_UPort_To_Device_Id(
    UI32_T unit,
    UI32_T port)
{
    UI32_T module_id;
    UI32_T device_id;
    UI32_T phy_port;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(unit, port,
                                                        &module_id,
                                                        &device_id,
                                                        &phy_port))
    {
        assert(0);
    }

    return device_id;
}

BOOL_T
RULE_CTRL_UT_Proc_IsDeviceExist(
    UI32_T device_id)
{
    UI32_T num_of_device;

    num_of_device = DEVRM_PMGR_GetNumberOfChips();

    assert(0 != num_of_device);

    return (device_id < num_of_device) ? TRUE : FALSE;
}

RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_UT_Proc_Get_Next_Ifindex(
    UI32_T *ifindex_p)
{
    if (0 == *ifindex_p)
    {
        *ifindex_p = 1;
        return RULE_TYPE_OK;
    }

    if (*ifindex_p < SYS_ADPT_TOTAL_NBR_OF_LPORT)
    {
        (*ifindex_p) ++;
        return RULE_TYPE_OK;
    }

    if (SYS_ADPT_TOTAL_NBR_OF_LPORT == *ifindex_p)
    {
        *ifindex_p = SYS_ADPT_CPU_1_IF_INDEX_NUMBER;
        return RULE_TYPE_OK;
    }

    if (SYS_ADPT_CPU_1_IF_INDEX_NUMBER == *ifindex_p)
    {
        *ifindex_p = SYS_ADPT_CRAFT_INTERFACE_IFINDEX;
        return RULE_TYPE_OK;
    }

    *ifindex_p = 0xffffffff;
    return RULE_TYPE_FAIL;
}

RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_UT_Proc_Ifindex_To_Interface(
    UI32_T ifindex,
    RULE_TYPE_INTERFACE_INFO_T *interface_p)
{
    return RULE_CTRL_Ifindex_To_Interface(ifindex, interface_p);
}

RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_UT_Proc_Interface_To_Ifindex(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p,
    UI32_T *ifindex_p)
{
    return RULE_CTRL_Interface_To_Ifindex(interface_p, ifindex_p);
}

UI32_T
RULE_CTRL_UT_Proc_Convert_Dflt_Rule_Type_To_Vgid(
    UI32_T remapped_pkt_type,
    RULE_TYPE_DEFAULT_ACE_T type)
{
    return (RULE_TYPE_PACKET_MAX_TYPE - remapped_pkt_type);
}

UI32_T
RULE_CTRL_UT_Proc_Get_Absolute_Rule_Priority(
    UI32_T device_id,
    UI32_T dev_rule_id)
{
    DEVRM_PCE_T *pce;

    BOOL_T result;

    result = DEVRM_GetPce(device_id, dev_rule_id, &pce);

    assert(TRUE == result);

    return 0xffff - pce->hw_idx;
}

BOOL_T
RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(
    UI32_T device_id,
    DEVRM_PCE_T *pce)
{
    CPSS_PCL_RULE_SIZE_ENT              ruleSize;
    GT_U32                              ruleIndex;

    GT_BOOL                             valid;
    CPSS_PCL_RULE_SIZE_ENT              ruleSizeOut;

    GT_STATUS                           rc;

    assert(NULL != pce);

    ruleSize = DEVRM_GetRuleSize(pce->pce_type);
    ruleIndex = DEVRM_Translate_PCEIDwithType(pce->pce_type, pce->hw_idx);

    rc = cpssDxChPclRuleAnyStateGet(device_id, ruleSize, ruleIndex, &valid,
                                                                  &ruleSizeOut);

    if (GT_OK == rc && GT_TRUE == valid)
    {
        assert(ruleSize == ruleSizeOut);
    }

    if (rc != GT_OK)
    {
        return FALSE;
    }

    return valid == GT_TRUE ? TRUE : FALSE;
}

RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_UT_Proc_Get_Sdk_Rule(
    UI32_T device_id,
    DEVRM_PCE_T *pce,
    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT *ruleFormatPtr,
    CPSS_DXCH_PCL_RULE_FORMAT_UNT *maskPtr,
    CPSS_DXCH_PCL_RULE_FORMAT_UNT *patternPtr,
    CPSS_DXCH_PCL_ACTION_STC *actionPtr)
{
    CPSS_PCL_RULE_SIZE_ENT              ruleSize;
    GT_U32                              ruleIndex;
    GT_STATUS                           rc;

    if (FALSE == RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(device_id, pce))
    {
        return RULE_TYPE_FAIL;
    }

    ruleSize = DEVRM_GetRuleSize(pce->pce_type);
    ruleIndex = DEVRM_Translate_PCEIDwithType(pce->pce_type, pce->hw_idx);

    rc = _cpssDxChPclRuleGet(device_id, ruleSize, ruleIndex, ruleFormatPtr, maskPtr,
                                                         patternPtr, actionPtr);

    return (rc == GT_OK) ? RULE_TYPE_OK : RULE_TYPE_FAIL;
}

RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_UT_Proc_Get_Sdk_Meter(
    UI32_T device_id,
    DEVRM_PCE_T *pce,
    CPSS_DXCH3_POLICER_METERING_ENTRY_STC *entry_p)
{
    CPSS_DXCH_POLICER_STAGE_TYPE_ENT stage;
    GT_STATUS rc;

    assert(NULL != pce);
    assert(NULL != entry_p);

    DEVRM_GetPolicerStageFromPce(device_id, pce, &stage);

    rc = cpssDxCh3PolicerMeteringEntryGet(device_id, stage, pce->policer_idx, entry_p);

    return (GT_OK == rc) ? RULE_TYPE_OK : RULE_TYPE_FAIL;
}

RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_UT_Proc_Get_Sdk_Billing_Entry(
    UI32_T device_id,
    DEVRM_PCE_T *pce,
    CPSS_DXCH3_POLICER_BILLING_ENTRY_STC *entry_p)
{
    CPSS_DXCH_POLICER_STAGE_TYPE_ENT stage;
    GT_STATUS rc;

    assert(NULL != pce);
    assert(NULL != entry_p);

    DEVRM_GetPolicerStageFromPce(device_id, pce, &stage);

    rc = cpssDxCh3PolicerBillingEntryGet(device_id, stage, pce->policer_idx,
                                                             GT_FALSE, entry_p);

    return (GT_OK == rc) ? RULE_TYPE_OK : RULE_TYPE_FAIL;
}

void
RULE_CTRL_UT_Proc_Set_Billing_Counter(
    UI32_T device_id,
    UI32_T dev_rule_id,
    UI32_T greenCntr,
    UI32_T yellowCntr,
    UI32_T redCntr)
{
    DEVRM_PCE_T                             *pce;
    CPSS_DXCH_POLICER_STAGE_TYPE_ENT        policer_stage;
    CPSS_DXCH3_POLICER_BILLING_ENTRY_STC    billingCntr;
    GT_STATUS                               rc;

    BOOL_T                                  b_result;

    b_result = DEVRM_GetPce(device_id, dev_rule_id, &pce);
    assert(TRUE == b_result);

    b_result = DEVRM_GetPolicerStageFromPce(device_id, pce, &policer_stage);
    assert(TRUE == b_result);

    assert(0 <= pce->policer_idx);

    rc = cpssDxCh3PolicerBillingEntryGet(device_id, policer_stage, pce->policer_idx,
                                                        GT_FALSE, &billingCntr);
    assert(GT_OK == rc);

    billingCntr.greenCntr.l[0] = greenCntr;
    billingCntr.yellowCntr.l[0] = yellowCntr;
    billingCntr.redCntr.l[0] = redCntr;

    rc = cpssDxCh3PolicerBillingEntrySet(device_id, policer_stage, pce->policer_idx,
                                                                  &billingCntr);
    assert(GT_OK == rc);
}

#pragma mark Generic Help Functions

/*------------------------------------------------------------------------------
 * Generic Generic Help Functions
 *------------------------------------------------------------------------------
 */

void
RULE_CTRL_UT_Proc_Validate_Rule();

RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_INSTANCE_TYPE_T inst_type,
    UI32_T id,
    RULE_TYPE_CLASS_INSTANCE_PTR_T *class_inst_pp)
{
    RULE_TYPE_INTERFACE_INFO_T interface;

    assert(NULL != interface_p);
    assert(NULL != class_inst_pp);

    memcpy(&interface, interface_p, sizeof(interface));

    {
        RULE_TYPE_RETURN_TYPE_T result;

        DEVRM_PCL_LOOKUP_NUMBER_T lookup_num;

        result = RULE_CTRL_Priv_ConvertPacketTypeToToDirectionLookupNum(remapped_pkt_type, &interface.direction, &lookup_num);

        assert(RULE_TYPE_OK == result);
    }

    //
    // Get first child if remapped_pkt_type matched
    //
    if (NULL == *class_inst_pp)
    {
        RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

        RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

        RULE_TYPE_CLASS_INSTANCE_PTR_T agg_class_inst_p;
        RULE_TYPE_CLASS_INSTANCE_OBJECT_T agg_class_inst_obj;

        RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T agg_class_inst_iter;

        RULE_CTRL_INSTANCE_TYPE_ID_T param;

        if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
        assert(NULL != if_entry_p);

        RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                  &if_class_obj);

        memset(&param, 0, sizeof(param));
        param.type = inst_type;
        param.id = id;

        agg_class_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                          RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                          &param);
        if (NULL == agg_class_inst_p)
        {
            return RULE_TYPE_FAIL;
        }

        RULE_CTRL_IN_Priv_ConstructClassInstanceObject(agg_class_inst_p, &agg_class_inst_obj);

        agg_class_inst_obj.get_element_iterator(&agg_class_inst_obj, &agg_class_inst_iter);

        *class_inst_pp = (RULE_TYPE_CLASS_INSTANCE_PTR_T) agg_class_inst_iter.first(&agg_class_inst_iter);
    }
    else
    {
        RULE_TYPE_SHM_POINTER_T next;

        next = (*class_inst_pp)->super.links.next;

        if (RULE_TYPE_NIL != next.type)
        {
            *class_inst_pp = RULE_CTRL_IN_Ptr2Instance(next);
        }
        else
        {
            *class_inst_pp = NULL;
        }
    }

    return (NULL != *class_inst_pp) ? RULE_TYPE_OK : RULE_TYPE_FAIL;
}

static BOOL_T
RULE_CTRL_UT_Proc_Is_Rule_Instance(
    RULE_TYPE_INSTANCE_PTR_T in,
    void *cookie)
{
    assert(NULL != in);

    return (RULE_CTRL_IS_RULE_INSTANCE_TYPE(in->type)) ? TRUE : FALSE;
}

UI32_T
RULE_CTRL_UT_Proc_Count_Of_Rule_Instance(
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p)
{
    return RULE_CTRL_IN_Priv_CountIf((RULE_TYPE_INSTANCE_PTR_T)class_inst_p,
                                     RULE_CTRL_UT_Proc_Is_Rule_Instance, NULL);
}

RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    RULE_TYPE_RULE_INSTANCE_PTR_T *rule_inst_pp)
{
    assert(NULL != class_inst_p);
    assert(NULL != rule_inst_pp);

    if (NULL == *rule_inst_pp)
    {
        RULE_TYPE_CLASS_INSTANCE_OBJECT_T class_inst_obj;
        RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T class_inst_iter;

        RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_inst_p,
                                                       &class_inst_obj);

        class_inst_obj.get_element_iterator(&class_inst_obj, &class_inst_iter);

        *rule_inst_pp = (RULE_TYPE_RULE_INSTANCE_PTR_T) class_inst_iter.first(&class_inst_iter);
    }
    else
    {
        RULE_TYPE_SHM_POINTER_T next;

        next = (*rule_inst_pp)->super.links.next;

        if (RULE_TYPE_NIL != next.type)
        {
            *rule_inst_pp = RULE_CTRL_IN_Ptr2Instance(next);
        }
        else
        {
            *rule_inst_pp = NULL;
        }
    }

    return (NULL != *rule_inst_pp) ? RULE_TYPE_OK : RULE_TYPE_FAIL;
}

RULE_CTRL_RULE_ENTRY_PTR_T
RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(
    RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p)
{
    return RULE_CTRL_Priv_GetRuleEntryOfRule(rule_inst_p);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Dest_Mac_Address(
    const DEVRM_AceEntry_T *rule_pattern_p,
    const UI8_T *data_p,
    const UI8_T *mask_p)
{
    assert(NULL != rule_pattern_p);
    assert(NULL != data_p);
    assert(NULL != mask_p);

    assert(rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_MACDA);
    assert(0 == memcmp(rule_pattern_p->dstmac_data, data_p, SYS_ADPT_MAC_ADDR_LEN));
    assert(0 == memcmp(rule_pattern_p->dstmac_mask, mask_p, SYS_ADPT_MAC_ADDR_LEN));
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Dest_Mac_Address(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    assert(NULL != rule_pattern_p);

    assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_MACDA));
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Source_Mac_Address(
    const DEVRM_AceEntry_T *rule_pattern_p,
    const UI8_T *data_p,
    const UI8_T *mask_p)
{
    assert(NULL != rule_pattern_p);
    assert(NULL != data_p);
    assert(NULL != mask_p);

    assert(rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_MACSA);
    assert(0 == memcmp(rule_pattern_p->srcmac_data, data_p, SYS_ADPT_MAC_ADDR_LEN));
    assert(0 == memcmp(rule_pattern_p->srcmac_mask, mask_p, SYS_ADPT_MAC_ADDR_LEN));
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Source_Mac_Address(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    assert(NULL != rule_pattern_p);

    assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_MACSA));
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ether_Type(
    const DEVRM_AceEntry_T *rule_pattern_p,
    UI16_T data,
    UI16_T mask)
{
    assert(NULL != rule_pattern_p);

    assert(rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_ETHER);
    assert(rule_pattern_p->ethertype_data == data);
    assert(rule_pattern_p->ethertype_mask == mask);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ether_Type(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    assert(NULL != rule_pattern_p);

    assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_ETHER));
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ether_Type(rule_pattern_p, 0x0800, 0xffff);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ip(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    assert(NULL != rule_pattern_p);

    if (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_ETHER)
    {
        assert((rule_pattern_p->ethertype_data & rule_pattern_p->ethertype_mask) != 0x0800);
    }
    else
    {
        assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_ETHER));
    }
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ether_Type(rule_pattern_p, 0x86dd, 0xffff);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ipv6(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    assert(NULL != rule_pattern_p);

    if (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_ETHER)
    {
        assert((rule_pattern_p->ethertype_data & rule_pattern_p->ethertype_mask) != 0x86dd);
    }
    else
    {
        assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_ETHER));
    }
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_IpFragment(
    const DEVRM_AceEntry_T *rule_pattern_p,
    UI8_T data,
    UI8_T mask)
{
    assert(NULL != rule_pattern_p);

    assert(rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPFRAG);
    assert(rule_pattern_p->ip_fragment_data == (data & mask));
    assert(rule_pattern_p->ip_fragment_mask == mask);
}


void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Vlan(
    const DEVRM_AceEntry_T *rule_pattern_p,
    UI16_T data,
    UI16_T mask)
{
    assert(NULL != rule_pattern_p);

    assert(rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_VID);
    assert(rule_pattern_p->outvlan_data == (data & mask));
    assert(rule_pattern_p->outvlan_mask == mask);

    //{{{{{
    assert(rule_pattern_p->invlan_data == (data & mask));
    assert(rule_pattern_p->invlan_mask == mask);
    //}}}}}
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Vlan(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    assert(NULL != rule_pattern_p);

    assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_VID));
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Cos(
    const DEVRM_AceEntry_T *rule_pattern_p,
    UI8_T data,
    UI8_T mask)
{
    assert(NULL != rule_pattern_p);

    assert(rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_VTAGUP);
    assert(rule_pattern_p->vtagup_data == (data & mask));
    assert(rule_pattern_p->vtagup_mask == mask);

    assert(rule_pattern_p->is_tagged == 1);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Cos(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    assert(NULL != rule_pattern_p);

    assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_VTAGUP));
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Protocol(
    const DEVRM_AceEntry_T *rule_pattern_p,
    UI8_T data,
    UI8_T mask)
{
    assert(NULL != rule_pattern_p);

    assert(rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPPROTOCOL);
    assert(rule_pattern_p->ipprotocol_data == (data & mask));
    assert(rule_pattern_p->ipprotocol_mask == mask);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ip_Protocol(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    assert(NULL != rule_pattern_p);

    assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPPROTOCOL));
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Dscp(
    const DEVRM_AceEntry_T *rule_pattern_p,
    UI8_T data,
    UI8_T mask)
{
    assert(NULL != rule_pattern_p);

    assert(rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_DSCP);
    assert(rule_pattern_p->dscp_data == (data & mask));
    assert(rule_pattern_p->dscp_mask == mask);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ip_Dscp(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    assert(NULL != rule_pattern_p);

    assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_DSCP));
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6_Next_Header(
    const DEVRM_AceEntry_T *rule_pattern_p,
    UI8_T data,
    UI8_T mask)
{
    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Protocol(rule_pattern_p, data, mask);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ipv6_Next_Header(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ip_Protocol(rule_pattern_p);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Icmp(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    enum
    {
        RULE_CTRL_PROTOCOL_ICMP = 1,
    };

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Protocol(rule_pattern_p,
                                                              RULE_CTRL_PROTOCOL_ICMP,
                                                              0xff);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Icmp(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    enum
    {
        RULE_CTRL_PROTOCOL_ICMP = 1,
    };

    assert(NULL != rule_pattern_p);

    if (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPPROTOCOL)
    {
        assert((rule_pattern_p->ipprotocol_data & rule_pattern_p->ipprotocol_mask) != RULE_CTRL_PROTOCOL_ICMP);
    }
    else
    {
        assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPPROTOCOL));
    }
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Udp(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Protocol(rule_pattern_p,
                                                              RULE_TYPE_ACL_UDP_PROTOCOL,
                                                              0xff);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Udp(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    assert(NULL != rule_pattern_p);

    if (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPPROTOCOL)
    {
        assert((rule_pattern_p->ipprotocol_data & rule_pattern_p->ipprotocol_mask) != RULE_TYPE_ACL_UDP_PROTOCOL);
    }
    else
    {
        assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPPROTOCOL));
    }
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Tcp(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Protocol(rule_pattern_p,
                                                              RULE_TYPE_ACL_TCP_PROTOCOL,
                                                              0xff);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Tcp(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    assert(NULL != rule_pattern_p);

    if (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPPROTOCOL)
    {
        assert((rule_pattern_p->ipprotocol_data & rule_pattern_p->ipprotocol_mask) != RULE_TYPE_ACL_TCP_PROTOCOL);
    }
    else
    {
        assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPPROTOCOL));
    }
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Dest_Address(
    const DEVRM_AceEntry_T *rule_pattern_p,
    UI32_T data,
    UI32_T mask)
{
    assert(NULL != rule_pattern_p);

    assert(rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPV4DIP);
    assert(rule_pattern_p->dstip_data == (data & mask));
    assert(rule_pattern_p->dstip_mask == mask);

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip(rule_pattern_p);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ip_Dest_Address(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    assert(NULL != rule_pattern_p);

    assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPV4DIP));
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Source_Address(
    const DEVRM_AceEntry_T *rule_pattern_p,
    UI32_T data,
    UI32_T mask)
{
    assert(NULL != rule_pattern_p);

    assert(rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPV4SIP);
    assert(rule_pattern_p->srcip_data == (data & mask));
    assert(rule_pattern_p->srcip_mask == mask);

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip(rule_pattern_p);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ip_Source_Address(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    assert(NULL != rule_pattern_p);

    assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPV4SIP));
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6_Dest_Address(
    const DEVRM_AceEntry_T *rule_pattern_p,
    const UI8_T *data_p,
    const UI8_T *mask_p)
{
    assert(NULL != rule_pattern_p);
    assert(NULL != data_p);
    assert(NULL != mask_p);

#if (SYS_ADPT_ACL_MAX_DST_IPV6_PREFIX_LEN == 8)
    assert(rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPV6DIPUPPER);
#else
    assert(rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPV6DIP);
#endif
    assert(0 == memcmp(rule_pattern_p->dstip6_data, data_p, SYS_ADPT_IPV6_ADDR_LEN));
    assert(0 == memcmp(rule_pattern_p->dstip6_mask, mask_p, SYS_ADPT_IPV6_ADDR_LEN));

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6(rule_pattern_p);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ipv6_Dest_Address(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    assert(NULL != rule_pattern_p);

#if (SYS_ADPT_ACL_MAX_DST_IPV6_PREFIX_LEN == 8)
    assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPV6DIPUPPER));
#else
    assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPV6DIP));
#endif
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6_Source_Address(
    const DEVRM_AceEntry_T *rule_pattern_p,
    const UI8_T *data_p,
    const UI8_T *mask_p)
{
    assert(NULL != rule_pattern_p);
    assert(NULL != data_p);
    assert(NULL != mask_p);

    assert(rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPV6SIP);
    assert(0 == memcmp(rule_pattern_p->srcip6_data, data_p, SYS_ADPT_IPV6_ADDR_LEN));
    assert(0 == memcmp(rule_pattern_p->srcip6_mask, mask_p, SYS_ADPT_IPV6_ADDR_LEN));

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6(rule_pattern_p);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ipv6_Source_Address(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    assert(NULL != rule_pattern_p);

    assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPV6SIP));
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_L4_Dest_Port(
    const DEVRM_AceEntry_T *rule_pattern_p,
    UI16_T data,
    UI16_T mask)
{
    ASSERT(NULL != rule_pattern_p);

    assert(rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_L4DSTPORT);
    assert(rule_pattern_p->l4_dstport_data == data);
    assert(rule_pattern_p->l4_dstport_mask == mask);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_L4_Dest_Port(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    ASSERT(NULL != rule_pattern_p);

    assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_L4DSTPORT));
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_L4_Source_Port(
    const DEVRM_AceEntry_T *rule_pattern_p,
    UI16_T data,
    UI16_T mask)
{
    ASSERT(NULL != rule_pattern_p);

    assert(rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_L4SRCPORT);
    assert(rule_pattern_p->l4_srcport_data == data);
    assert(rule_pattern_p->l4_srcport_mask == mask);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_L4_Source_Port(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    ASSERT(NULL != rule_pattern_p);

    assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_L4SRCPORT));
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Tcp_Control_Flags(
    const DEVRM_AceEntry_T *rule_pattern_p,
    UI8_T data,
    UI8_T mask)
{
    ASSERT(NULL != rule_pattern_p);

    assert(rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_TCPCONTROL);
    assert(rule_pattern_p->tcpcontrol_data == data);
    assert(rule_pattern_p->tcpcontrol_mask == mask);

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Tcp(rule_pattern_p);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Tcp_Control_Flags(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    ASSERT(NULL != rule_pattern_p);

    assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_TCPCONTROL));
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Icmp_Type(
    const DEVRM_AceEntry_T *rule_pattern_p,
    UI8_T data,
    UI8_T mask)
{
    ASSERT(NULL != rule_pattern_p);

    assert(rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_ICMPTYPE);
    assert(rule_pattern_p->icmptype_data == data);
    assert(rule_pattern_p->icmptype_mask == mask);

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Icmp(rule_pattern_p);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Icmp_Type(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    ASSERT(NULL != rule_pattern_p);

    assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_ICMPTYPE));
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Icmpv6(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    enum
    {
        RULE_CTRL_PROT_ICMP6 = 58
    };

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6_Next_Header(rule_pattern_p, RULE_CTRL_PROT_ICMP6, 0xff);
    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6(rule_pattern_p);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Icmpv6(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    enum
    {
        RULE_CTRL_PROT_ICMP6 = 58
    };

    if (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPPROTOCOL)
    {
        assert((rule_pattern_p->ipprotocol_data & rule_pattern_p->ipprotocol_mask) != RULE_CTRL_PROT_ICMP6);
    }
    else
    {
        assert(0 == (rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_IPPROTOCOL));
    }
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Icmpv6_Type(
    const DEVRM_AceEntry_T *rule_pattern_p,
    UI8_T data,
    UI8_T mask)
{
    ASSERT(NULL != rule_pattern_p);

    assert(rule_pattern_p->entry_qualify & DEVRM_FIELD_QUALIFY_MASK_ICMPTYPE);
    assert(rule_pattern_p->icmptype_data == data);
    assert(rule_pattern_p->icmptype_mask == mask);

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Icmpv6(rule_pattern_p);
}

void
RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Icmpv6_Type(
    const DEVRM_AceEntry_T *rule_pattern_p)
{
    /* The same position with ICMP6 type
     */
    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_L4_Source_Port(rule_pattern_p);
}

void
RULE_CTRL_UT_Proc_Create_ACL(
    const char *acl_name,
    RULE_TYPE_AclType_T acl_type,
    UI32_T *acl_index)
{
    RULE_TYPE_RETURN_TYPE_T result;

    result = RULE_OM_CreateAcl(acl_name, acl_type);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetAclIdByName(acl_name, acl_index);
    assert(RULE_TYPE_OK == result);

#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)
    result = RULE_CTRL_ReserveResourceOnCreateAcl(*acl_index);
    assert(RULE_TYPE_OK == result);
#endif // SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT
}

void
RULE_CTRL_UT_Proc_Delete_ACL(
    const char *acl_name)
{
    UI32_T acl_index;
    RULE_TYPE_RETURN_TYPE_T result;

    result = RULE_OM_GetAclIdByName(acl_name, &acl_index);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_DelAcl(acl_index);
    assert(RULE_TYPE_OK == result);

#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)
    result = RULE_CTRL_ReleaseResourceOnDeleteAcl();
    assert(RULE_TYPE_OK == result);
#endif // SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT
}

typedef enum
{
    RULE_CTRL_UT_COMPRESS_DISABLE = 0,  // create ACL which can NOT be compressed
    RULE_CTRL_UT_COMPRESS_ENABLE,       // create ACE which can be compressed
    RULE_CTRL_UT_COMPRESS_DEFAULT = RULE_CTRL_UT_COMPRESS_ENABLE,
} RULE_CTRL_UT_COMPRESS_OPTION_T;

void
RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace(
    const char *acl_name,
    RULE_TYPE_AclType_T acl_type,
    UI32_T number_of_ace,
    RULE_CTRL_UT_COMPRESS_OPTION_T compress,
    UI32_T *acl_index)
{
/* Note:
 * 1. if compress == RULE_CTRL_UT_COMPRESS_DISABLE
 *      the ace access type will be deny + permit + deny +... + deny
 */
    UI32_T i;
    RULE_TYPE_Ace_Entry_T ace_entry;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CTRL_UT_Proc_Create_ACL(acl_name, acl_type, acl_index);

    if (0 < number_of_ace)
    {
        assert(number_of_ace <= (255*255));

        for (i = 0; i < (number_of_ace - 1); ++ i)
        {
            UI8_T  a3, a4;

            UI8_T  ipv4_addr[SYS_TYPE_IPV4_ADDR_LEN];
            UI8_T  ipv4_addr_mask[SYS_TYPE_IPV4_ADDR_LEN];

            UI8_T  mac_addr[SYS_TYPE_MAC_ADDR_LEN];
            UI8_T  mac_addr_mask[SYS_TYPE_MAC_ADDR_LEN];

            char   ipv6_addr[L_INET_MAX_IPADDR_STR_LEN + 1];

            ace_entry.ace_type = acl_type;
            result = RULE_OM_InitAce(&ace_entry);
            assert(result == RULE_TYPE_OK);

            if (RULE_CTRL_UT_COMPRESS_DISABLE == compress)
            {
                ace_entry.access = (i & 1) ?
                                   RULE_TYPE_ACE_PERMIT : RULE_TYPE_ACE_DENY;
            }

            a3 = (i + 1) / 255;
            a4 = (i + 1) % 255;

            SET_MAC(mac_addr, 0, 0, 0, 0, a3, a4);
            SET_MAC(mac_addr_mask, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff);

            SET_IPV4(ipv4_addr, 192, 168, a3, a4);
            SET_IPV4(ipv4_addr_mask, 255, 255, 255, 255);

            snprintf(ipv6_addr, sizeof(ipv6_addr), "%02x%02x::", (UI8_T)a3, (UI8_T)a4);
            ipv6_addr[ sizeof(ipv6_addr)-1 ] = '\0';

            switch (acl_type)
            {
                case RULE_TYPE_MAC_ACL:
                    RULE_OM_UT_Proc_SetAceDstMacAddress(&ace_entry, mac_addr, mac_addr_mask);
                    RULE_OM_UT_Proc_SetAceSrcMacAddress(&ace_entry, mac_addr, mac_addr_mask);
                    break;

                case RULE_TYPE_IP_STD_ACL:
                    RULE_OM_UT_Proc_SetAceSrcIpAddress(&ace_entry, ipv4_addr, ipv4_addr_mask);
                    break;

                case RULE_TYPE_IP_EXT_ACL:
                    RULE_OM_UT_Proc_SetAceDstIpAddress(&ace_entry, ipv4_addr, ipv4_addr_mask);
                    RULE_OM_UT_Proc_SetAceSrcIpAddress(&ace_entry, ipv4_addr, ipv4_addr_mask);
                    break;

                case RULE_TYPE_IPV6_STD_ACL:
                    RULE_OM_UT_Proc_SetAceSrcIpv6Address(&ace_entry, ipv6_addr);
                    break;

                case RULE_TYPE_IPV6_EXT_ACL:
#if (SYS_CPNT_ACL_IPV6_EXT_SRC_IP_ADDR == TRUE)
                    RULE_OM_UT_Proc_SetAceSrcIpv6Address(&ace_entry, ipv6_addr);
#endif

#if (SYS_CPNT_ACL_IPV6_EXT_DST_IP_ADDR == TRUE)
                    RULE_OM_UT_Proc_SetAceDstIpv6Address(&ace_entry, ipv6_addr);
#endif

//#if (SYS_CPNT_ACL_IPV6_EXT_FLOW_LABEL == TRUE)
//                    RULE_OM_UT_Proc_SetAceFlowLabel(&ace_entry, 1234);
//#endif
                    break;

                default:
                    assert(0);
                    break;
            }

            result = RULE_OM_AddAce2Acl(*acl_index, acl_type, &ace_entry);
            assert(RULE_TYPE_OK == result);
        }

        ace_entry.ace_type = acl_type;
        result = RULE_OM_InitAce(&ace_entry);
        assert(result == RULE_TYPE_OK);

        ace_entry.access = RULE_TYPE_ACE_DENY;

        result = RULE_OM_AddAce2Acl(*acl_index, acl_type, &ace_entry);
        assert(RULE_TYPE_OK == result);
    }
}

void
RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace_Without_Match_Any_Ace(
    const char *acl_name,
    RULE_TYPE_AclType_T acl_type,
    UI32_T number_of_ace,
    RULE_CTRL_UT_COMPRESS_OPTION_T compress,
    UI32_T *acl_index)
{
    UI32_T i;
    RULE_TYPE_Ace_Entry_T ace_entry;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CTRL_UT_Proc_Create_ACL(acl_name, acl_type, acl_index);

    if (0 < number_of_ace)
    {
        assert(number_of_ace <= (255*255));

        for (i = 0; i < number_of_ace; ++ i)
        {
            UI8_T  a3, a4;

            UI8_T  ipv4_addr[SYS_TYPE_IPV4_ADDR_LEN];
            UI8_T  ipv4_addr_mask[SYS_TYPE_IPV4_ADDR_LEN];

            UI8_T  mac_addr[SYS_TYPE_MAC_ADDR_LEN];
            UI8_T  mac_addr_mask[SYS_TYPE_MAC_ADDR_LEN];

            char   ipv6_addr[L_INET_MAX_IPADDR_STR_LEN + 1];

            ace_entry.ace_type = acl_type;
            result = RULE_OM_InitAce(&ace_entry);
            assert(result == RULE_TYPE_OK);

            if (RULE_CTRL_UT_COMPRESS_DISABLE == compress)
            {
                ace_entry.access = (i & 1) ?
                                   RULE_TYPE_ACE_PERMIT : RULE_TYPE_ACE_DENY;
            }

            a3 = (i + 1) / 255;
            a4 = (i + 1) % 255;

            SET_MAC(mac_addr, 0, 0, 0, 0, a3, a4);
            SET_MAC(mac_addr_mask, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff);

            SET_IPV4(ipv4_addr, 192, 168, a3, a4);
            SET_IPV4(ipv4_addr_mask, 255, 255, 255, 255);

            snprintf(ipv6_addr, sizeof(ipv6_addr), "%02x%02x::", (UI8_T)a3, (UI8_T)a4);
            ipv6_addr[ sizeof(ipv6_addr)-1 ] = '\0';

            switch (acl_type)
            {
                case RULE_TYPE_MAC_ACL:
                    RULE_OM_UT_Proc_SetAceDstMacAddress(&ace_entry, mac_addr, mac_addr_mask);
                    RULE_OM_UT_Proc_SetAceSrcMacAddress(&ace_entry, mac_addr, mac_addr_mask);
                    break;

                case RULE_TYPE_IP_STD_ACL:
                    RULE_OM_UT_Proc_SetAceSrcIpAddress(&ace_entry, ipv4_addr, ipv4_addr_mask);
                    break;

                case RULE_TYPE_IP_EXT_ACL:
                    RULE_OM_UT_Proc_SetAceDstIpAddress(&ace_entry, ipv4_addr, ipv4_addr_mask);
                    RULE_OM_UT_Proc_SetAceSrcIpAddress(&ace_entry, ipv4_addr, ipv4_addr_mask);
                    break;

                case RULE_TYPE_IPV6_STD_ACL:
                    RULE_OM_UT_Proc_SetAceSrcIpv6Address(&ace_entry, ipv6_addr);
                    break;

                case RULE_TYPE_IPV6_EXT_ACL:
#if (SYS_CPNT_ACL_IPV6_EXT_SRC_IP_ADDR == TRUE)
                    RULE_OM_UT_Proc_SetAceSrcIpv6Address(&ace_entry, ipv6_addr);
#endif

#if (SYS_CPNT_ACL_IPV6_EXT_DST_IP_ADDR == TRUE)
                    RULE_OM_UT_Proc_SetAceDstIpv6Address(&ace_entry, ipv6_addr);
#endif

//#if (SYS_CPNT_ACL_IPV6_EXT_FLOW_LABEL == TRUE)
//                    RULE_OM_UT_Proc_SetAceFlowLabel(&ace_entry, 1234);
//#endif
                    break;

                default:
                    assert(0);
                    break;
            }

            result = RULE_OM_AddAce2Acl(*acl_index, acl_type, &ace_entry);
            assert(RULE_TYPE_OK == result);
        }
    }
}

void
RULE_CTRL_UT_Proc_Add_ACL_Into_Class_Map(
    UI32_T class_map_index,
    const char *acl_name,
    RULE_TYPE_AclType_T acl_type,
    UI32_T number_of_ace,
    RULE_CTRL_UT_COMPRESS_OPTION_T compress,
    UI32_T *acl_index_p)
{
    RULE_TYPE_RETURN_TYPE_T         result;

    UI32_T                          acl_index;

    RULE_TYPE_UI_ClassMapElement_T  class_element;
    UI32_T                          class_index;

    RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace(acl_name, acl_type, number_of_ace, compress, &acl_index);

    if (NULL != acl_index_p)
    {
        *acl_index_p = acl_index;
    }

    memset(&class_element, 0, sizeof(class_element));

    class_element.class_type = RULE_TYPE_CLASS_ACL;
    strncpy(class_element.element.acl_name, acl_name, sizeof(class_element.element.acl_name)-1);
    class_element.element.acl_name[ sizeof(class_element.element.acl_name)-1 ] = '\0';

    result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
    assert(RULE_TYPE_OK == result);
    assert(acl_index == class_index);
}

void
RULE_CTRL_UT_Proc_Add_MF_Into_Class_Map(
    UI32_T class_map_index,
    RULE_TYPE_MfType_T mf_type,
    UI32_T mf_value,
    UI32_T *mf_index_p)
{
    RULE_TYPE_RETURN_TYPE_T         result;

    RULE_TYPE_UI_ClassMapElement_T  class_element;
    UI32_T                          class_index;

    memset(&class_element, 0, sizeof(class_element));

    class_element.class_type = RULE_TYPE_CLASS_MF;
    class_element.element.mf_entry.mf_type  = mf_type;
    class_element.element.mf_entry.mf_value = mf_value;

    result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
    assert(RULE_TYPE_OK == result);

    if (NULL != mf_index_p)
    {
        *mf_index_p = class_index;
    }
}

void
RULE_CTRL_UT_Proc_Create_Policy_Class_Map_With_Match_ACL(
    const char *policy_map_name,
    RULE_TYPE_MatchType_T match_type)
{
    const char                      *class_map_name = "c1";
    const char                      *acl_name = "a1";

    UI32_T                          policy_map_index;
    UI32_T                          class_map_index;
    UI32_T                          acl_index;

    RULE_TYPE_AclType_T             acl_type = RULE_TYPE_IP_EXT_ACL;

    RULE_TYPE_Ace_Entry_T           ace_entry;

    RULE_TYPE_UI_ClassMapElement_T  class_element;
    UI32_T                          class_index;

    RULE_TYPE_UI_Action_T           ui_action;
    RULE_TYPE_TBParamEntry_T        meter;

    UI32_T                          ui32_result;

    ui32_result = RULE_OM_Create_PolicyMap(policy_map_name, &policy_map_index);
    assert(RULE_TYPE_OK == ui32_result);

    ui32_result = RULE_OM_Create_ClassMap(class_map_name, match_type, &class_map_index);
    assert(RULE_TYPE_OK == ui32_result);

    //
    // Match ACL
    //

    ui32_result = RULE_OM_CreateAcl(acl_name, acl_type);
    assert(RULE_TYPE_OK == ui32_result);

    ui32_result = RULE_OM_GetAclIdByName(acl_name, &acl_index);
    assert(RULE_TYPE_OK == ui32_result);


    ace_entry.ace_type = RULE_TYPE_IP_EXT_ACL;
    RULE_OM_InitAce(&ace_entry);

    ace_entry.u.ip.aceSourceIpAddr = 0x01020304;
    ace_entry.u.ip.aceSourceIpAddrBitmask = 0xffffffff;

    ui32_result = RULE_OM_AddAce2Acl(acl_index, acl_type, &ace_entry);
    assert(RULE_TYPE_OK == ui32_result);

    ace_entry.u.ip.aceSourceIpAddr = 0x05060708;
    ace_entry.u.ip.aceSourceIpAddrBitmask = 0xffffffff;

    ui32_result = RULE_OM_AddAce2Acl(acl_index, acl_type, &ace_entry);
    assert(RULE_TYPE_OK == ui32_result);

    ace_entry.u.ip.aceSourceIpAddr = 0x090a0b0c;
    ace_entry.u.ip.aceSourceIpAddrBitmask = 0xffffffff;

    ui32_result = RULE_OM_AddAce2Acl(acl_index, acl_type, &ace_entry);
    assert(RULE_TYPE_OK == ui32_result);

#if (SYS_CPNT_ACL_MAC_IP_MIX == TRUE)
    ace_entry.u.mac.aceSourceMacAddr[0] = 1;
    memset(&ace_entry.u.mac.aceSourceMacAddrBitmask,
           0xff, sizeof(ace_entry.u.mac.aceSourceMacAddrBitmask));

    ace_entry.u.ip.aceSourceIpAddr = 0x090a0bff;
    ace_entry.u.ip.aceSourceIpAddrBitmask = 0xffffffff;

    ui32_result = RULE_OM_AddAce2Acl(acl_index, acl_type, &ace_entry);
    assert(RULE_TYPE_OK == ui32_result);
#endif /* #if (SYS_CPNT_ACL_MAC_IP_MIX == TRUE) */
    class_element.class_type = RULE_TYPE_CLASS_ACL;
    strncpy(class_element.element.acl_name, acl_name, sizeof(class_element.element.acl_name)-1);
    class_element.element.acl_name[ sizeof(class_element.element.acl_name)-1 ] = '\0';

    ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
    assert(RULE_TYPE_OK == ui32_result);

    //
    // Action, meter configuration
    // This function be used for many common test cases, so use 'common' action
    //

    memset(&ui_action, 0, sizeof(ui_action));

    ui_action.in_action_type        = IN_ACTION_INVALID;
    ui_action.out_action_type       = OUT_ACTION_INVALID;
    ui_action.confirm_action_type   = CONFIRM_ACTION_TRANSMIT;
    ui_action.class_action_type     = CLASS_ACTION_INVALID;
    ui_action.exceed_action_type    = EXCEED_ACTION_TRANSMIT;
    ui_action.violate_action_type   = VIOLATE_ACTION_DROP;

    meter.meter_model = RULE_TYPE_METER_MODE_SRTCM_COLOR_AWARE;
    meter.rate = 84;
    meter.burst_size = 4000;
    meter.peak_burst_size = 4000;

    ui32_result = RULE_OM_Add_PolicyMapElement_To_PolicyMap(policy_map_index, class_map_index);
    assert(RULE_TYPE_OK == ui32_result);

    ui32_result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter);
    assert(RULE_TYPE_OK == ui32_result);

    ui32_result = RULE_OM_SetUIActionEntry(policy_map_index, class_map_index, &ui_action);
    assert(RULE_TYPE_OK == ui32_result);
}

void
RULE_CTRL_UT_Proc_Create_Policy_Class_Map_With_Match_MF_ACE(
    const char *policy_map_name,
    RULE_TYPE_MatchType_T match_type)
{
    enum
    {
        MAX_CLASS_MAP_IN_POLICY_MAP = 3,
    };

    UI32_T                          policy_map_index;

    UI32_T                          ui32_result;
    UI32_T                          i;

    ui32_result = RULE_OM_Create_PolicyMap(policy_map_name, &policy_map_index);
    assert(RULE_TYPE_OK == ui32_result);

    for (i = 0; i < MAX_CLASS_MAP_IN_POLICY_MAP; ++ i)
    {
        UI32_T                          class_map_index;

        RULE_TYPE_UI_ClassMapElement_T  class_element;
        UI32_T                          class_index;

        RULE_TYPE_UI_Action_T           ui_action;
        RULE_TYPE_TBParamEntry_T        meter;

        char                            class_map_name[SYS_ADPT_DIFFSERV_MAX_NAME_LENGTH + 1];

        snprintf(class_map_name, sizeof(class_map_name), "c%lu", i);

        ui32_result = RULE_OM_Create_ClassMap(class_map_name, match_type, &class_map_index);
        assert(RULE_TYPE_OK == ui32_result);

        //
        // Match MF
        //

        class_element.class_type = RULE_TYPE_CLASS_MF;
        class_element.element.mf_entry.mf_type  = RULE_TYPE_MF_VLAN;
        class_element.element.mf_entry.mf_value = 1001;

        ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
        assert(RULE_TYPE_OK == ui32_result);

        class_element.class_type = RULE_TYPE_CLASS_MF;
        class_element.element.mf_entry.mf_type  = RULE_TYPE_MF_DSCP;
        class_element.element.mf_entry.mf_value = 42;

        ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
        assert(RULE_TYPE_OK == ui32_result);

        //
        // Action, meter configuration
        // This function be used for many common test cases, so use 'common' action
        //

        memset(&ui_action, 0, sizeof(ui_action));

        ui_action.in_action_type        = IN_ACTION_INVALID;
        ui_action.out_action_type       = OUT_ACTION_INVALID;
        ui_action.confirm_action_type   = CONFIRM_ACTION_TRANSMIT;
        ui_action.class_action_type     = CLASS_ACTION_INVALID;
        ui_action.exceed_action_type    = EXCEED_ACTION_TRANSMIT;
        ui_action.violate_action_type   = VIOLATE_ACTION_DROP;

        meter.meter_model = RULE_TYPE_METER_MODE_SRTCM_COLOR_AWARE;
        meter.rate = 84;
        meter.burst_size = 4000;
        meter.peak_burst_size = 4000;

        ui32_result = RULE_OM_Add_PolicyMapElement_To_PolicyMap(policy_map_index, class_map_index);
        assert(RULE_TYPE_OK == ui32_result);

        ui32_result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter);
        assert(RULE_TYPE_OK == ui32_result);

        ui32_result = RULE_OM_SetUIActionEntry(policy_map_index, class_map_index, &ui_action);
        assert(RULE_TYPE_OK == ui32_result);
    }
}

void
RULE_CTRL_UT_Proc_Create_Policy_Class_Map_With_Match_MF_ACE_Ingress_Only(
    const char *policy_map_name,
    RULE_TYPE_MatchType_T match_type)
{
    enum
    {
        MAX_CLASS_MAP_IN_POLICY_MAP = 3,
    };

    UI32_T                          policy_map_index;

    UI32_T                          ui32_result;
    UI32_T                          i;

    ui32_result = RULE_OM_Create_PolicyMap(policy_map_name, &policy_map_index);
    assert(RULE_TYPE_OK == ui32_result);

    for (i = 0; i < MAX_CLASS_MAP_IN_POLICY_MAP; ++ i)
    {
        UI32_T                          class_map_index;

        RULE_TYPE_UI_ClassMapElement_T  class_element;
        UI32_T                          class_index;

        RULE_TYPE_UI_Action_T           ui_action;
        RULE_TYPE_TBParamEntry_T        meter;

        char                            class_map_name[SYS_ADPT_DIFFSERV_MAX_NAME_LENGTH + 1];

        snprintf(class_map_name, sizeof(class_map_name), "c%lu", i);

        ui32_result = RULE_OM_Create_ClassMap(class_map_name, match_type, &class_map_index);
        assert(RULE_TYPE_OK == ui32_result);

        //
        // Match MF
        //

        class_element.class_type = RULE_TYPE_CLASS_MF;
        class_element.element.mf_entry.mf_type  = RULE_TYPE_MF_VLAN;
        class_element.element.mf_entry.mf_value = 1001;

        ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
        assert(RULE_TYPE_OK == ui32_result);

        class_element.class_type = RULE_TYPE_CLASS_MF;
        class_element.element.mf_entry.mf_type  = RULE_TYPE_MF_DSCP;
        class_element.element.mf_entry.mf_value = 42;

        ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
        assert(RULE_TYPE_OK == ui32_result);

        //
        // Action, meter configuration
        // This function be used for many common test cases, so use 'common' action
        //

        memset(&ui_action, 0, sizeof(ui_action));

        ui_action.in_action_type        = IN_ACTION_INVALID;
        ui_action.out_action_type       = OUT_ACTION_INVALID;
        ui_action.confirm_action_type   = CONFIRM_ACTION_TRANSMIT;
        ui_action.class_action_type     = CLASS_ACTION_INVALID;
        ui_action.exceed_action_type  = EXCEED_ACTION_REMARK_DSCP_TRANSMIT;
        ui_action.exceed_action_value = 32;
        ui_action.violate_action_type = VIOLATE_ACTION_REMARK_DSCP_TRANSMIT;
        ui_action.violate_action_value = 63;

        meter.meter_model = RULE_TYPE_METER_MODE_SRTCM_COLOR_AWARE;
        meter.rate = 84;
        meter.burst_size = 4000;
        meter.peak_burst_size = 4000;

        ui32_result = RULE_OM_Add_PolicyMapElement_To_PolicyMap(policy_map_index, class_map_index);
        assert(RULE_TYPE_OK == ui32_result);

        ui32_result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter);
        assert(RULE_TYPE_OK == ui32_result);

        ui32_result = RULE_OM_SetUIActionEntry(policy_map_index, class_map_index, &ui_action);
        assert(RULE_TYPE_OK == ui32_result);
    }
}

void
RULE_CTRL_UT_Proc_Create_Policy_Match_Any_Class_Map_With_Match_ACL_MF(
    const char *policy_map_name)
{
    enum
    {
        MAX_ACE_IN_ACL = 5,
    };

    RULE_TYPE_MatchType_T           match_type = RULE_TYPE_CLASS_MAP_MATCH_ANY;

    RULE_TYPE_RETURN_TYPE_T         ui32_result;

    UI32_T                          policy_map_index;

    RULE_TYPE_UI_ClassMapElement_T  class_element;
    UI32_T                          class_index;

    RULE_TYPE_UI_Action_T           ui_action;
    RULE_TYPE_TBParamEntry_T        meter;

    ui32_result = RULE_OM_Create_PolicyMap(policy_map_name, &policy_map_index);
    assert(RULE_TYPE_OK == ui32_result);

    {
        const char                      *class_map_name = "c1";
        UI32_T                          class_map_index;

        ui32_result = RULE_OM_Create_ClassMap(class_map_name, match_type, &class_map_index);
        assert(RULE_TYPE_OK == ui32_result);

        //
        // Match ACL
        //
        {
            const char                      *acl_name = "a1";
            UI32_T                          acl_index;

            RULE_TYPE_AclType_T             acl_type = RULE_TYPE_IP_EXT_ACL;

            RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace(acl_name, acl_type,
                                                     MAX_ACE_IN_ACL,
                                                     RULE_CTRL_UT_COMPRESS_DEFAULT,
                                                     &acl_index);

            class_element.class_type = RULE_TYPE_CLASS_ACL;
            strncpy(class_element.element.acl_name, acl_name, sizeof(class_element.element.acl_name)-1);
            class_element.element.acl_name[ sizeof(class_element.element.acl_name)-1 ] = '\0';

            ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
            assert(RULE_TYPE_OK == ui32_result);
        }

        //
        // Match MF
        //
        {
            class_element.class_type = RULE_TYPE_CLASS_MF;
            class_element.element.mf_entry.mf_type  = RULE_TYPE_MF_VLAN;
            class_element.element.mf_entry.mf_value = 1001;

            ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
            assert(RULE_TYPE_OK == ui32_result);

            //
            // Match MF
            //

            class_element.class_type = RULE_TYPE_CLASS_MF;
            class_element.element.mf_entry.mf_type  = RULE_TYPE_MF_VLAN;
            class_element.element.mf_entry.mf_value = 2001;

            ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
            assert(RULE_TYPE_OK == ui32_result);

            //
            // Match MF
            //

            class_element.class_type = RULE_TYPE_CLASS_MF;
            class_element.element.mf_entry.mf_type  = RULE_TYPE_MF_VLAN;
            class_element.element.mf_entry.mf_value = 3001;
        }

        ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
        assert(RULE_TYPE_OK == ui32_result);

        //
        // Match ACL
        //
        {
            const char                      *acl_name = "a2";
            UI32_T                          acl_index;

            RULE_TYPE_AclType_T             acl_type = RULE_TYPE_IP_EXT_ACL;

            RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace(acl_name, acl_type,
                                                     MAX_ACE_IN_ACL,
                                                     RULE_CTRL_UT_COMPRESS_DEFAULT,
                                                     &acl_index);

            class_element.class_type = RULE_TYPE_CLASS_ACL;
            strncpy(class_element.element.acl_name, acl_name, sizeof(class_element.element.acl_name)-1);
            class_element.element.acl_name[ sizeof(class_element.element.acl_name)-1 ] = '\0';

            ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
            assert(RULE_TYPE_OK == ui32_result);
        }

        //
        // Match MF
        //

        class_element.class_type = RULE_TYPE_CLASS_MF;
        class_element.element.mf_entry.mf_type  = RULE_TYPE_MF_DSCP;
        class_element.element.mf_entry.mf_value = 42;

        ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
        assert(RULE_TYPE_OK == ui32_result);

        //
        // Action, meter configuration
        //

        ui_action.in_action_type        = IN_ACTION_INVALID;
        ui_action.out_action_type       = OUT_ACTION_INVALID;
        ui_action.confirm_action_type   = CONFIRM_ACTION_TRANSMIT;
        ui_action.class_action_type     = CLASS_ACTION_INVALID;
        ui_action.exceed_action_type    = EXCEED_ACTION_DROP;
        ui_action.violate_action_type   = VIOLATE_ACTION_DROP;

        meter.meter_model = RULE_TYPE_METER_MODE_FLOW;
        meter.rate = 84;
        meter.burst_size = 4000;
        meter.peak_burst_size = 4000;

        ui32_result = RULE_OM_Add_PolicyMapElement_To_PolicyMap(policy_map_index, class_map_index);
        assert(RULE_TYPE_OK == ui32_result);

        ui32_result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter);
        assert(RULE_TYPE_OK == ui32_result);

        ui32_result = RULE_OM_SetUIActionEntry(policy_map_index, class_map_index, &ui_action);
        assert(RULE_TYPE_OK == ui32_result);
    }

    {
        const char                      *class_map_name = "c2";
        UI32_T                          class_map_index;

        ui32_result = RULE_OM_Create_ClassMap(class_map_name, match_type, &class_map_index);
        assert(RULE_TYPE_OK == ui32_result);

        //
        // Match ACL
        //
        {
            const char                      *acl_name = "a3";
            UI32_T                          acl_index;

            RULE_TYPE_AclType_T             acl_type = RULE_TYPE_IP_EXT_ACL;

            RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace(acl_name, acl_type,
                                                     MAX_ACE_IN_ACL,
                                                     RULE_CTRL_UT_COMPRESS_DEFAULT,
                                                     &acl_index);

            class_element.class_type = RULE_TYPE_CLASS_ACL;
            strncpy(class_element.element.acl_name, acl_name, sizeof(class_element.element.acl_name)-1);
            class_element.element.acl_name[ sizeof(class_element.element.acl_name)-1 ] = '\0';

            ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
            assert(RULE_TYPE_OK == ui32_result);
        }

        //
        // Match MF
        //

        class_element.class_type = RULE_TYPE_CLASS_MF;
        class_element.element.mf_entry.mf_type  = RULE_TYPE_MF_VLAN;
        class_element.element.mf_entry.mf_value = 1001;

        ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
        assert(RULE_TYPE_OK == ui32_result);

        //
        // Match ACL
        //
        {
            const char                      *acl_name = "a4";
            UI32_T                          acl_index;

            RULE_TYPE_AclType_T             acl_type = RULE_TYPE_IP_EXT_ACL;

            RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace(acl_name, acl_type,
                                                     MAX_ACE_IN_ACL,
                                                     RULE_CTRL_UT_COMPRESS_DEFAULT,
                                                     &acl_index);

            class_element.class_type = RULE_TYPE_CLASS_ACL;
            strncpy(class_element.element.acl_name, acl_name, sizeof(class_element.element.acl_name)-1);
            class_element.element.acl_name[ sizeof(class_element.element.acl_name)-1 ] = '\0';

            ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
            assert(RULE_TYPE_OK == ui32_result);
        }

        class_element.class_type = RULE_TYPE_CLASS_MF;
        class_element.element.mf_entry.mf_type  = RULE_TYPE_MF_DSCP;
        class_element.element.mf_entry.mf_value = 42;

        ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
        assert(RULE_TYPE_OK == ui32_result);

        //
        // Action, meter configuration
        //

        ui_action.in_action_type        = IN_ACTION_INVALID;
        ui_action.out_action_type       = OUT_ACTION_INVALID;
        ui_action.confirm_action_type   = CONFIRM_ACTION_TRANSMIT;
        ui_action.class_action_type     = CLASS_ACTION_INVALID;
        ui_action.exceed_action_type    = EXCEED_ACTION_DROP;
        ui_action.violate_action_type   = VIOLATE_ACTION_DROP;

        meter.meter_model = RULE_TYPE_METER_MODE_TRTCM_COLOR_AWARE;
        meter.rate = 84;
        meter.burst_size = 4000;
        meter.peak_burst_size = 4001;
        meter.peak_rate = 4001;

        ui32_result = RULE_OM_Add_PolicyMapElement_To_PolicyMap(policy_map_index, class_map_index);
        assert(RULE_TYPE_OK == ui32_result);

        ui32_result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter);
        assert(RULE_TYPE_OK == ui32_result);

        ui32_result = RULE_OM_SetUIActionEntry(policy_map_index, class_map_index, &ui_action);
        assert(RULE_TYPE_OK == ui32_result);
    }
}

void
RULE_CTRL_UT_Proc_Create_Policy_Match_All_Class_Map_With_Match_ACL_MF(
    const char *policy_map_name)
{
    enum
    {
        MAX_ACE_IN_ACL = 5,
    };

    RULE_TYPE_MatchType_T           match_type = RULE_TYPE_CLASS_MAP_MATCH_ALL;

    RULE_TYPE_RETURN_TYPE_T         ui32_result;

    UI32_T                          policy_map_index;

    RULE_TYPE_UI_ClassMapElement_T  class_element;
    UI32_T                          class_index;

    RULE_TYPE_UI_Action_T           ui_action;
    RULE_TYPE_TBParamEntry_T        meter;

    ui32_result = RULE_OM_Create_PolicyMap(policy_map_name, &policy_map_index);
    assert(RULE_TYPE_OK == ui32_result);

    {
        const char                      *class_map_name = "c1";
        UI32_T                          class_map_index;

        ui32_result = RULE_OM_Create_ClassMap(class_map_name, match_type, &class_map_index);
        assert(RULE_TYPE_OK == ui32_result);

        //
        // Match ACL
        //
        {
            const char                      *acl_name = "a1";
            UI32_T                          acl_index;

            RULE_TYPE_AclType_T             acl_type = RULE_TYPE_IP_EXT_ACL;

            RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace(acl_name, acl_type,
                                                     MAX_ACE_IN_ACL,
                                                     RULE_CTRL_UT_COMPRESS_DEFAULT,
                                                     &acl_index);

            class_element.class_type = RULE_TYPE_CLASS_ACL;
            strncpy(class_element.element.acl_name, acl_name, sizeof(class_element.element.acl_name)-1);
            class_element.element.acl_name[ sizeof(class_element.element.acl_name)-1 ] = '\0';

            ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
            assert(RULE_TYPE_OK == ui32_result);
        }

        //
        // Match MF
        //

        class_element.class_type = RULE_TYPE_CLASS_MF;
        class_element.element.mf_entry.mf_type  = RULE_TYPE_MF_DSCP;
        class_element.element.mf_entry.mf_value = 42;

        ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
        assert(RULE_TYPE_OK == ui32_result);

        //
        // Action, meter configuration
        //

        ui_action.in_action_type        = IN_ACTION_INVALID;
        ui_action.out_action_type       = OUT_ACTION_INVALID;
        ui_action.confirm_action_type   = CONFIRM_ACTION_TRANSMIT;
        ui_action.class_action_type     = CLASS_ACTION_INVALID;
        ui_action.exceed_action_type    = EXCEED_ACTION_DROP;
        ui_action.violate_action_type   = VIOLATE_ACTION_DROP;

        meter.meter_model = RULE_TYPE_METER_MODE_FLOW;
        meter.rate = 84;
        meter.burst_size = 4000;
        meter.peak_burst_size = 4000;

        ui32_result = RULE_OM_Add_PolicyMapElement_To_PolicyMap(policy_map_index, class_map_index);
        assert(RULE_TYPE_OK == ui32_result);

        ui32_result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter);
        assert(RULE_TYPE_OK == ui32_result);

        ui32_result = RULE_OM_SetUIActionEntry(policy_map_index, class_map_index, &ui_action);
        assert(RULE_TYPE_OK == ui32_result);
    }

    {
        const char                      *class_map_name = "c2";
        UI32_T                          class_map_index;

        ui32_result = RULE_OM_Create_ClassMap(class_map_name, match_type, &class_map_index);
        assert(RULE_TYPE_OK == ui32_result);

        //
        // Match ACL
        //
        {
            const char                      *acl_name = "a3";
            UI32_T                          acl_index;

            RULE_TYPE_AclType_T             acl_type = RULE_TYPE_IP_EXT_ACL;

            RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace(acl_name, acl_type,
                                                     MAX_ACE_IN_ACL,
                                                     RULE_CTRL_UT_COMPRESS_DEFAULT,
                                                     &acl_index);

            class_element.class_type = RULE_TYPE_CLASS_ACL;
            strncpy(class_element.element.acl_name, acl_name, sizeof(class_element.element.acl_name)-1);
            class_element.element.acl_name[ sizeof(class_element.element.acl_name)-1 ] = '\0';

            ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
            assert(RULE_TYPE_OK == ui32_result);
        }

        //
        // Match MF
        //

        class_element.class_type = RULE_TYPE_CLASS_MF;
        class_element.element.mf_entry.mf_type  = RULE_TYPE_MF_VLAN;
        class_element.element.mf_entry.mf_value = 1001;

        ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
        assert(RULE_TYPE_OK == ui32_result);

        class_element.class_type = RULE_TYPE_CLASS_MF;
        class_element.element.mf_entry.mf_type  = RULE_TYPE_MF_DSCP;
        class_element.element.mf_entry.mf_value = 42;

        ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
        assert(RULE_TYPE_OK == ui32_result);

        //
        // Action, meter configuration
        //

        ui_action.in_action_type        = IN_ACTION_INVALID;
        ui_action.out_action_type       = OUT_ACTION_INVALID;
        ui_action.confirm_action_type   = CONFIRM_ACTION_TRANSMIT;
        ui_action.class_action_type     = CLASS_ACTION_INVALID;
        ui_action.exceed_action_type    = EXCEED_ACTION_DROP;
        ui_action.violate_action_type   = VIOLATE_ACTION_DROP;

        meter.meter_model = RULE_TYPE_METER_MODE_TRTCM_COLOR_AWARE;
        meter.rate = 84;
        meter.burst_size = 4000;
        meter.peak_burst_size = 4001;
        meter.peak_rate = 4001;

        ui32_result = RULE_OM_Add_PolicyMapElement_To_PolicyMap(policy_map_index, class_map_index);
        assert(RULE_TYPE_OK == ui32_result);

        ui32_result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter);
        assert(RULE_TYPE_OK == ui32_result);

        ui32_result = RULE_OM_SetUIActionEntry(policy_map_index, class_map_index, &ui_action);
        assert(RULE_TYPE_OK == ui32_result);
    }
}

// policy-map p1
//   class c1, match a1
//   class c2, match a1
//   class c3, match a1
//   ...
void
RULE_CTRL_UT_Proc_Create_Policy_Map_With_Max_Class_Map_With_Match_Same_ACL(
    const char *policy_map_name)
{
    UI32_T policy_map_index;
    UI32_T class_map_index;
    UI32_T acl_index;

    RULE_TYPE_MatchType_T match_type = RULE_TYPE_CLASS_MAP_MATCH_ANY;
    RULE_TYPE_AclType_T   acl_type = RULE_TYPE_IP_EXT_ACL;

    RULE_TYPE_Ace_Entry_T ace_entry;

    UI32_T                          class_map_name_id;
    char                            class_map_name[ SYS_ADPT_DIFFSERV_MAX_NAME_LENGTH+1 ];
    RULE_TYPE_UI_ClassMapElement_T  class_element;
    UI32_T                          class_index;

    const char                      *acl_name = "a1";

    RULE_TYPE_UI_Action_T           ui_action;
    RULE_TYPE_TBParamEntry_T        meter;

    UI32_T ui32_result;


    /* create policy map
     */
    ui32_result = RULE_OM_Create_PolicyMap(policy_map_name, &policy_map_index);
    assert(RULE_TYPE_OK == ui32_result);

    /* create ACL
     */
    ui32_result = RULE_OM_CreateAcl(acl_name, acl_type);
    assert(RULE_TYPE_OK == ui32_result);

    ui32_result = RULE_OM_GetAclIdByName(acl_name, &acl_index);
    assert(RULE_TYPE_OK == ui32_result);


    ace_entry.ace_type = RULE_TYPE_IP_EXT_ACL;
    RULE_OM_InitAce(&ace_entry);

    ace_entry.u.ip.aceSourceIpAddr = 0x01020304;
    ace_entry.u.ip.aceSourceIpAddrBitmask = 0xffffffff;

    ui32_result = RULE_OM_AddAce2Acl(acl_index, acl_type, &ace_entry);
    assert(RULE_TYPE_OK == ui32_result);

    ace_entry.u.ip.aceSourceIpAddr = 0x05060708;
    ace_entry.u.ip.aceSourceIpAddrBitmask = 0xffffffff;

    ui32_result = RULE_OM_AddAce2Acl(acl_index, acl_type, &ace_entry);
    assert(RULE_TYPE_OK == ui32_result);

    /* crate class map and bind an ACL
     */
    for (class_map_name_id = 1; ; ++class_map_name_id)
    {
        snprintf(class_map_name, sizeof(class_map_name), "c%lu", class_map_name_id);

        ui32_result = RULE_OM_Create_ClassMap(class_map_name, match_type, &class_map_index);
        assert(RULE_TYPE_OK == ui32_result);

        class_element.class_type = RULE_TYPE_CLASS_ACL;
        strncpy(class_element.element.acl_name, acl_name, sizeof(class_element.element.acl_name)-1);
        class_element.element.acl_name[ sizeof(class_element.element.acl_name)-1 ] = '\0';

        ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
        assert(RULE_TYPE_OK == ui32_result);

        memset(&ui_action, 0, sizeof(ui_action));

        ui_action.in_action_type      = IN_ACTION_INVALID;
        ui_action.out_action_type     = OUT_ACTION_INVALID;
        ui_action.confirm_action_type = CONFIRM_ACTION_TRANSMIT;
        ui_action.class_action_type   = CLASS_ACTION_INVALID;
        ui_action.exceed_action_type  = EXCEED_ACTION_REMARK_DSCP_TRANSMIT;
        ui_action.exceed_action_value = 32;
        ui_action.violate_action_type = VIOLATE_ACTION_REMARK_DSCP_TRANSMIT;
        ui_action.violate_action_value = 63;


        meter.meter_model = RULE_TYPE_METER_MODE_TRTCM_COLOR_BLIND;
        meter.rate = 84;
        meter.burst_size = 4000;
        meter.peak_rate = 4001;
        meter.peak_burst_size = 4001;

        ui32_result = RULE_OM_Add_PolicyMapElement_To_PolicyMap(policy_map_index, class_map_index);
        if (RULE_TYPE_OK != ui32_result)
        {
            break;
        }

        ui32_result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter);
        assert(RULE_TYPE_OK == ui32_result);

        ui32_result = RULE_OM_SetUIActionEntry(policy_map_index, class_map_index, &ui_action);
        assert(RULE_TYPE_OK == ui32_result);
    }

    assert(1 < class_map_name_id);
}

// policy-map p1
//   class c1, match a1
//   class c2, match a2
//   class c3, match a3
//   ...
void
RULE_CTRL_UT_Proc_Create_Policy_Map_With_Max_Class_Map_With_Match_Diff_ACL(
    const char *policy_map_name)
{
    UI32_T policy_map_index;
    UI32_T class_map_index;
    UI32_T acl_index;

    RULE_TYPE_MatchType_T match_type = RULE_TYPE_CLASS_MAP_MATCH_ANY;
    RULE_TYPE_AclType_T   acl_type = RULE_TYPE_IP_EXT_ACL;

    RULE_TYPE_Ace_Entry_T ace_entry;

    UI32_T                          class_map_name_id;

    char                            class_map_name[ SYS_ADPT_DIFFSERV_MAX_NAME_LENGTH+1 ];
    RULE_TYPE_UI_ClassMapElement_T  class_element;
    UI32_T                          class_index;

    char                            acl_name[ SYS_ADPT_DIFFSERV_MAX_NAME_LENGTH+1 ];

    RULE_TYPE_UI_Action_T           ui_action;
    RULE_TYPE_TBParamEntry_T        meter;

    UI32_T ui32_result;

    /* create policy map
     */
    ui32_result = RULE_OM_Create_PolicyMap(policy_map_name, &policy_map_index);
    assert(RULE_TYPE_OK == ui32_result);

    /* crate class map, ACL and bind together
     */
    for (class_map_name_id = 1; ; ++class_map_name_id)
    {
        /* create ACL
         */
        snprintf(acl_name, sizeof(acl_name), "a%lu", class_map_name_id);

        ui32_result = RULE_OM_CreateAcl(acl_name, acl_type);
        //assert(RULE_TYPE_OK == ui32_result);
        if (RULE_TYPE_OK != ui32_result)
        {
            break;
        }

        ui32_result = RULE_OM_GetAclIdByName(acl_name, &acl_index);
        assert(RULE_TYPE_OK == ui32_result);

        ace_entry.ace_type = RULE_TYPE_IP_EXT_ACL;
        RULE_OM_InitAce(&ace_entry);

        ace_entry.u.ip.aceSourceIpAddr = 0x01020304;
        ace_entry.u.ip.aceSourceIpAddrBitmask = 0xffffffff;

        ui32_result = RULE_OM_AddAce2Acl(acl_index, acl_type, &ace_entry);
        assert(RULE_TYPE_OK == ui32_result);


        ace_entry.u.ip.aceSourceIpAddr = 0x05060708;
        ace_entry.u.ip.aceSourceIpAddrBitmask = 0xffffffff;

        ui32_result = RULE_OM_AddAce2Acl(acl_index, acl_type, &ace_entry);
        assert(RULE_TYPE_OK == ui32_result);


        /* Create class map
         */
        snprintf(class_map_name, sizeof(class_map_name), "c%lu", class_map_name_id);

        ui32_result = RULE_OM_Create_ClassMap(class_map_name, match_type, &class_map_index);
        assert(RULE_TYPE_OK == ui32_result);

        class_element.class_type = RULE_TYPE_CLASS_ACL;
        strncpy(class_element.element.acl_name, acl_name, sizeof(class_element.element.acl_name)-1);
        class_element.element.acl_name[ sizeof(class_element.element.acl_name)-1 ] = '\0';

        /* Add ACL into class map
         */
        ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
        assert(RULE_TYPE_OK == ui32_result);

        memset(&ui_action, 0, sizeof(ui_action));

        ui_action.in_action_type    = IN_ACTION_INVALID;
        ui_action.out_action_type   = OUT_ACTION_INVALID;
        ui_action.confirm_action_type = CONFIRM_ACTION_TRANSMIT;
        ui_action.class_action_type  = CLASS_ACTION_INVALID;
        ui_action.exceed_action_type = EXCEED_ACTION_REMARK_DSCP_TRANSMIT;
        ui_action.exceed_action_value = 32;
        ui_action.violate_action_type = VIOLATE_ACTION_REMARK_DSCP_TRANSMIT;
        ui_action.violate_action_value = 63;


        meter.meter_model = RULE_TYPE_METER_MODE_SRTCM_COLOR_BLIND;
        meter.rate = 84;
        meter.burst_size = 4000;
        meter.peak_burst_size = 4000;

        /* Add class-map, meter, and action into policy-map
         */
        ui32_result = RULE_OM_Add_PolicyMapElement_To_PolicyMap(policy_map_index, class_map_index);
        if (RULE_TYPE_OK != ui32_result)
        {
            break;
        }

        ui32_result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter);
        assert(RULE_TYPE_OK == ui32_result);

        ui32_result = RULE_OM_SetUIActionEntry(policy_map_index, class_map_index, &ui_action);
        assert(RULE_TYPE_OK == ui32_result);
    }

    assert(1 < class_map_name_id);
}

RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_UT_Proc_Bind_ACL(
    UI32_T ifindex,
    RULE_TYPE_InOutDirection_T direction,
    UI32_T acl_index,
    UI16_T time_range_index,
    RULE_TYPE_COUNTER_ENABLE_T counter_enable)
{
    RULE_TYPE_RETURN_TYPE_T result;

    result = RULE_CTRL_SetAcl(ifindex,
                              direction,
                              acl_index,
                              TRUE, time_range_index, counter_enable);

    if (RULE_TYPE_OK == result)
    {
        RULE_TYPE_RETURN_TYPE_T result_2;

#if 0 /* FIXME: time range */
        if (time_range_index != RULE_TYPE_UNDEF_TIME_RANGE)
        {
            RULE_OM_CountTimeRangeRefCounter(time_range_index, RULE_TYPE_TIME_RANGE_REF_COUNT_PLUS);
        }
#endif /* 0 */

        result_2 = RULE_OM_SetAcl(ifindex, direction, acl_index, RULE_TYPE_UNDEF_TIME_RANGE, (UI8_T *)"", counter_enable);
        assert(RULE_TYPE_OK == result_2);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();

    return result;
}

RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_UT_Proc_UnBind_ACL(
    UI32_T ifindex,
    RULE_TYPE_InOutDirection_T direction,
    UI32_T acl_index,
    UI16_T time_range_index,
    RULE_TYPE_COUNTER_ENABLE_T counter_enable)
{
    RULE_TYPE_RETURN_TYPE_T result;

    result = RULE_CTRL_SetAcl(ifindex,
                              direction,
                              acl_index,
                              FALSE, time_range_index, counter_enable);

    if (RULE_TYPE_OK == result)
    {
        RULE_TYPE_RETURN_TYPE_T result_2;

#if 0 /* FIXME: time range */
        if (time_range_index != RULE_TYPE_UNDEF_TIME_RANGE)
        {
            RULE_OM_CountTimeRangeRefCounter(time_range_index, RULE_TYPE_TIME_RANGE_REF_COUNT_MINUS);
        }
#endif /* 0 */

        result_2 = RULE_OM_ResetAcl(ifindex, direction, acl_index);
        assert(RULE_TYPE_OK == result_2);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();

    return result;
}

void
RULE_CTRL_UT_Proc_Bind_Policy_Map(
    UI32_T ifindex,
    RULE_TYPE_InOutDirection_T direction,
    UI32_T policy_map_index)
{
    RULE_TYPE_RETURN_TYPE_T result;

    result = RULE_CTRL_SetPolicyMap(ifindex, direction, policy_map_index, TRUE);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_BindPort2PolicyMap(ifindex, direction, policy_map_index);
    assert(RULE_TYPE_OK == result);
}

void
RULE_CTRL_UT_Proc_UnBind_Policy_Map(
    UI32_T ifindex,
    RULE_TYPE_InOutDirection_T direction,
    UI32_T policy_map_index)
{
    RULE_TYPE_RETURN_TYPE_T result;

    result = RULE_CTRL_SetPolicyMap(ifindex, direction, policy_map_index, FALSE);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_UnBindPort2PolicyMap(ifindex, direction, policy_map_index);
    assert(RULE_TYPE_OK == result);
}

typedef enum
{
    RULE_CTRL_UT_PROC_BIND_POLICY_CLASS_MAP_FLAG_ADD_RULE = TRUE,
    RULE_CTRL_UT_PROC_BIND_POLICY_CLASS_MAP_FLAG_DEL_RULE = FALSE,
    RULE_CTRL_UT_PROC_BIND_POLICY_CLASS_MAP_FLAG_TEST_RULE = 3,
} RULE_CTRL_UT_PROC_BIND_POLICY_CLASS_MAP_FLAG_T;

void
RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(
    UI32_T ifindex,
    RULE_TYPE_InOutDirection_T direction,
    RULE_CTRL_UT_PROC_BIND_POLICY_CLASS_MAP_FLAG_T flag,
    const char *policy_map_name)
{
    UI32_T policy_map_index;

    UI32_T ui32_result;

    ui32_result = RULE_OM_GetPolicyMapIdByName(policy_map_name, &policy_map_index);
    assert(RULE_TYPE_OK == ui32_result);

    if (RULE_CTRL_UT_PROC_BIND_POLICY_CLASS_MAP_FLAG_ADD_RULE == flag)
    {
        RULE_CTRL_UT_Proc_Bind_Policy_Map(ifindex, direction, policy_map_index);

    }
    else if (RULE_CTRL_UT_PROC_BIND_POLICY_CLASS_MAP_FLAG_DEL_RULE == flag)
    {
        RULE_CTRL_UT_Proc_UnBind_Policy_Map(ifindex, direction, policy_map_index);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_UT_Proc_Set_Counter_Stub(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p,
    RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p,
    void *cookie)
{
    UI32_T *count = cookie;

    RULE_CTRL_UT_Proc_Set_Billing_Counter(rule_inst_p->dev_rule_info.device,
                                          rule_inst_p->dev_rule_info.rule_id,
                                          *count,
                                          *count,
                                          *count);
    return 0;
}

int
RULE_CTRL_UT_Proc_Set_Count(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    UI32_T count)
{
#if (SYS_CPNT_QOS_V2_SOFTWARE_BUNDLE_RATE_CONTROL == TRUE)
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;

    RULE_CTRL_INSTANCE_TYPE_ID_T param;

    UI32_T                  class_map_index;
    UI32_T                  i;
    UI32_T                  ci;
    RULE_TYPE_PolicyMap_T   policy_map;

    assert(NULL != interface_p);

    if_entry_p = RULE_CTRL_Priv_GetIfEntry(interface_p);
    assert(NULL != if_entry_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                              &if_class_obj);

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_POLICY_MAP;

    policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                       RULE_CTRL_Priv_IsClassInstanceMatchType,
                                                                                       &param);
    while (NULL != policy_map_inst_p)
    {

        result = RULE_OM_GetPolicyMap(policy_map_inst_p->id, &policy_map);
        assert(RULE_TYPE_OK == result);

        for (i = 0; i < _countof(policy_map.bundle_group); ++i)
        {
            RULE_TYPE_BundleGroup_T *bundle_group_p = &policy_map.bundle_group[i];

            if (TRUE != bundle_group_p->valid_status)
            {
                continue;
            }

            for (ci = 0; ci < bundle_group_p->class_map_count; ++ci)
            {
                class_map_index = bundle_group_p->class_map_index_list[ci];

                RULE_CTRL_LocalEachRuleInClassMap(interface_p,
                                                  policy_map_inst_p,
                                                  class_map_index,
                                                  RULE_CTRL_UT_Proc_Set_Counter_Stub,
                                                  &count);
            }
        }

        policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetNextSiblingIf((RULE_TYPE_INSTANCE_PTR_T)policy_map_inst_p,
                                                                                            RULE_CTRL_Priv_IsClassInstanceMatchType,
                                                                                            &param);
    }
#endif // SYS_CPNT_QOS_V2_SOFTWARE_BUNDLE_RATE_CONTROL

    return 0;
}

/*------------------------------------------------------------------------------
 * Validation Functions
 *------------------------------------------------------------------------------
 */

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_ACL_ACE_Rule_Pattern(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p,
    RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_Ace_Entry_T om_ace_entry;
    RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

    assert(NULL != ace_inst_p);
    assert(NULL != rule_inst_p);

    rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
    assert(NULL != rule_entry_p);

    result = RULE_OM_GetAceByIndex(ace_inst_p->id, &om_ace_entry);
    assert(RULE_TYPE_OK == result);

    switch (om_ace_entry.ace_type)
    {
        case RULE_TYPE_MAC_ACL:
        {
            const RULE_TYPE_MacAce_Entry_T *mac_ace_p = &om_ace_entry.u.mac;

            if (TRUE != RULE_CTRL_LocalIsNullMac(mac_ace_p->aceSourceMacAddrBitmask))
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Source_Mac_Address(&rule_entry_p->rule_pattern,
                                                                                 mac_ace_p->aceSourceMacAddr,
                                                                                 mac_ace_p->aceSourceMacAddrBitmask);
            }
            else
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Source_Mac_Address(&rule_entry_p->rule_pattern);
            }

            if (TRUE != RULE_CTRL_LocalIsNullMac(mac_ace_p->aceDestMacAddrBitmask))
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Source_Mac_Address(&rule_entry_p->rule_pattern,
                                                                                 mac_ace_p->aceDestMacAddr,
                                                                                 mac_ace_p->aceDestMacAddrBitmask);
            }
            else
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Dest_Mac_Address(&rule_entry_p->rule_pattern);
            }

            if (VAL_diffServMacAceVidOp_equal == mac_ace_p->aceVidOp)
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Vlan(&rule_entry_p->rule_pattern,
                                                                   mac_ace_p->aceMinVid,
                                                                   mac_ace_p->aceVidBitmask);
            }
            else
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Vlan(&rule_entry_p->rule_pattern);
            }

            if (VAL_diffServMacAceEtherTypeOp_equal == mac_ace_p->aceEtherTypeOp)
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ether_Type(&rule_entry_p->rule_pattern,
                                                                         mac_ace_p->aceMinEtherType,
                                                                         mac_ace_p->aceEtherTypeBitmask);
            }
            else
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ether_Type(&rule_entry_p->rule_pattern);
            }

            if (VAL_diffServMacAceCosOp_equal == mac_ace_p->aceCosOp)
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Cos(&rule_entry_p->rule_pattern,
                                                                  mac_ace_p->aceMinCos,
                                                                  mac_ace_p->aceCosBitmask);
            }
            else
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Cos(&rule_entry_p->rule_pattern);
            }

            if (VAL_diffServMacAceSourcePortOp_equal == mac_ace_p->aceSourcePortOp)
            {
                printf("%s %d: add validate code here !!\r\n", __FUNCTION__, __LINE__);
            }
            break;
        }

        case RULE_TYPE_IP_STD_ACL:
        case RULE_TYPE_IP_EXT_ACL:
        {
            const RULE_TYPE_IpAce_Entry_T *ip_ace_p = &om_ace_entry.u.ip;

            if (RULE_TYPE_ACL_IP_BITMASK_ANY != ip_ace_p->aceSourceIpAddrBitmask)
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Source_Address(&rule_entry_p->rule_pattern,
                                                                                ip_ace_p->aceSourceIpAddr,
                                                                                ip_ace_p->aceSourceIpAddrBitmask);
            }
            else
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ip_Source_Address(&rule_entry_p->rule_pattern);
            }

            if (RULE_TYPE_ACL_IP_BITMASK_ANY != ip_ace_p->aceDestIpAddrBitmask)
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Dest_Address(&rule_entry_p->rule_pattern,
                                                                              ip_ace_p->aceDestIpAddr,
                                                                              ip_ace_p->aceDestIpAddrBitmask);
            }
            else
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ip_Dest_Address(&rule_entry_p->rule_pattern);
            }

            if (RULE_TYPE_UNDEF_IP_PROTOCOL != ip_ace_p->aceProtocol)
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Protocol(&rule_entry_p->rule_pattern,
                                                                          ip_ace_p->aceProtocol,
                                                                          0xff);
            }
            else
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ip_Protocol(&rule_entry_p->rule_pattern);
            }

            if (RULE_TYPE_UNDEF_IP_PRECEDENCE != ip_ace_p->acePrec)
            {
                printf("%s %d: add validate code here !!\r\n", __FUNCTION__, __LINE__);
            }

            if (RULE_TYPE_UNDEF_IP_DSCP != ip_ace_p->aceDscp)
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Dscp(&rule_entry_p->rule_pattern,
                                                                      ip_ace_p->aceDscp,
                                                                      63);
            }
            else
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ip_Dscp(&rule_entry_p->rule_pattern);
            }

            if (VAL_diffServIpAceSourcePortOp_equal == ip_ace_p->aceSourcePortOp)
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_L4_Source_Port(&rule_entry_p->rule_pattern,
                                                                             ip_ace_p->aceMinSourcePort,
                                                                             ip_ace_p->aceSourcePortBitmask);
            }
            else
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_L4_Source_Port(&rule_entry_p->rule_pattern);
            }

            if (VAL_diffServIpAceDestPortOp_equal == ip_ace_p->aceDestPortOp)
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_L4_Dest_Port(&rule_entry_p->rule_pattern,
                                                                           ip_ace_p->aceMinDestPort,
                                                                           ip_ace_p->aceDestPortBitmask);
            }
            else
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_L4_Dest_Port(&rule_entry_p->rule_pattern);
            }

            if (0 != ip_ace_p->aceControlCodeBitmask)
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Tcp_Control_Flags(&rule_entry_p->rule_pattern,
                                                                                ip_ace_p->aceControlCode,
                                                                                ip_ace_p->aceControlCodeBitmask);
            }
            else
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Tcp_Control_Flags(&rule_entry_p->rule_pattern);
            }

            if (RULE_TYPE_UNDEF_ICMP_TYPE != ip_ace_p->aceIcmpType)
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Icmp_Type(&rule_entry_p->rule_pattern,
                                                                        ip_ace_p->aceIcmpType,
                                                                        0xff);
            }
            else
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Icmp_Type(&rule_entry_p->rule_pattern);
            }
            break;
        }

        case RULE_TYPE_IPV6_STD_ACL:
        case RULE_TYPE_IPV6_EXT_ACL:
        {
#define IS_NOT_ZERO_IP6_ADDR(addr) \
(!(addr[0]==0 && addr[1]==0 && addr[2]==0 && addr[3]==0 &&      \
addr[4]==0 && addr[5]==0 && addr[6]==0 && addr[7]==0 &&      \
addr[8]==0 && addr[9]==0 && addr[10]==0 && addr[11]==0 &&    \
addr[12]==0 && addr[13]==0 && addr[14]==0 && addr[15]==0))

            const RULE_TYPE_Ipv6Ace_Entry_T *ipv6_ace_p = &om_ace_entry.u.ipv6;
            UI8_T mask[SYS_ADPT_IPV6_ADDR_LEN];

            if (RULE_TYPE_UNDEF_IPV6_DSCP != ipv6_ace_p->aceDscp)
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Dscp(&rule_entry_p->rule_pattern,
                                                                      ipv6_ace_p->aceDscp,
                                                                      63);
            }
            else
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ip_Dscp(&rule_entry_p->rule_pattern);
            }

            //
            // destination IP address
            //
            memcpy(mask, ipv6_ace_p->aceDestIpAddrBitmask, SYS_ADPT_IPV6_ADDR_LEN);

            if (IS_NOT_ZERO_IP6_ADDR(mask))
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6_Dest_Address(&rule_entry_p->rule_pattern,
                                                                                ipv6_ace_p->aceDestIpAddr,
                                                                                mask);
            }
            else
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ipv6_Dest_Address(&rule_entry_p->rule_pattern);
            }

            //
            // source IP address
            //
            memcpy(mask, ipv6_ace_p->aceSourceIpAddrBitmask, SYS_ADPT_IPV6_ADDR_LEN);


            if (IS_NOT_ZERO_IP6_ADDR(mask))
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6_Source_Address(&rule_entry_p->rule_pattern,
                                                                                  ipv6_ace_p->aceSourceIpAddr,
                                                                                  mask);
            }
            else
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ipv6_Source_Address(&rule_entry_p->rule_pattern);
            }

            if (RULE_TYPE_UNDEF_IPV6_NEXT_HEADER != ipv6_ace_p->aceNextHeader)
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6_Next_Header(&rule_entry_p->rule_pattern,
                                                                               ipv6_ace_p->aceNextHeader,
                                                                               0xff);
            }
            else
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ipv6_Next_Header(&rule_entry_p->rule_pattern);
            }

#undef IS_NOT_ZERO_IP6_ADDR
            break;
        }

        default:
            assert(0);
            break;
    }

    {
        DEVRM_PCE_T *pce;

        BOOL_T b_result;

        b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                rule_inst_p->dev_rule_info.rule_id,
                                &pce);

        if (TRUE == rule_inst_p->active)
        {
            assert(TRUE == b_result);
        }
        else
        {
            assert(TRUE != b_result);
        }
    }
}

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_ACL_ACE_Rule_Action(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p,
    RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p)
{
    RULE_TYPE_RETURN_TYPE_T result;

    DEVRM_PCE_T *pce;

    BOOL_T b_result;

    assert(NULL != interface_p);
    assert(NULL != acl_inst_p);
    assert(NULL != ace_inst_p);
    assert(NULL != rule_inst_p);

    if (TRUE == rule_inst_p->active)
    {
        RULE_TYPE_AceAction_T access;
        RULE_TYPE_Ace_Entry_T ace_entry;

        CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
        CPSS_DXCH_PCL_RULE_FORMAT_UNT mask;
        CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern;
        CPSS_DXCH_PCL_ACTION_STC action;

        result = RULE_OM_GetAceByIndex(ace_inst_p->id, &ace_entry);
        assert(RULE_TYPE_OK == result);

        access = ace_entry.access;

        b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                rule_inst_p->dev_rule_info.rule_id,
                                &pce);
        assert(TRUE == b_result);
        assert(NULL != pce);

        result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                pce,
                                                &ruleFormat, &mask, &pattern, &action);
        assert(RULE_TYPE_OK == result);

        switch (access)
        {
            case RULE_TYPE_ACE_PERMIT:
                assert(CPSS_PACKET_CMD_FORWARD_E == action.pktCmd);
                break;

            case RULE_TYPE_ACE_DENY:
                assert(CPSS_PACKET_CMD_DROP_HARD_E == action.pktCmd);
                break;

            default:
                assert(FALSE);
        }

        //
        // Counter
        //
        if (RULE_TYPE_COUNTER_ENABLE == acl_inst_p->counter_enable)
        {
            CPSS_DXCH3_POLICER_METERING_ENTRY_STC meter;
            CPSS_DXCH3_POLICER_BILLING_ENTRY_STC billingCntr;

            assert(0 < pce->policer_idx);

            result = RULE_CTRL_UT_Proc_Get_Sdk_Meter(rule_inst_p->dev_rule_info.device,
                                                     pce,
                                                     &meter);

            assert(CPSS_POLICER_COLOR_BLIND_E == meter.meterColorMode);
            assert(0 == meter.tokenBucketParams.srTcmParams.cir);

            assert(CPSS_DXCH3_POLICER_NON_CONFORM_CMD_NO_CHANGE_E == meter.redPcktCmd);
            assert(CPSS_DXCH3_POLICER_NON_CONFORM_CMD_NO_CHANGE_E == meter.yellowPcktCmd);


            result = RULE_CTRL_UT_Proc_Get_Sdk_Billing_Entry(rule_inst_p->dev_rule_info.device,
                                                             pce,
                                                             &billingCntr);
            assert(RULE_TYPE_OK == result);
            assert(CPSS_DXCH3_POLICER_BILLING_CNTR_PACKET_E == billingCntr.billingCntrMode);
        }
        else
        {
            assert(-1 == pce->policer_idx);
        }

        //
        // Mirror
        //
        {
            RULE_TYPE_Acl_T *acl_entry_p;

            acl_entry_p = RULE_OM_LocalGetAclByIndex(acl_inst_p->id);
            assert(NULL != acl_entry_p);

            if (RULE_TYPE_MIRROR_ENABLE == acl_entry_p->mirror.enable)
            {
                if (RULE_TYPE_ACE_PERMIT == access)
                {
                    //
                    // Enable mirror on ingress direction only
                    //
                    if (RULE_TYPE_INBOUND == interface_p->direction)
                    {
                        assert(GT_TRUE == action.mirror.mirrorToRxAnalyzerPort);
                        assert(CPSS_NET_INGRESS_MIRRORED_TO_ANLYZER_E == action.mirror.cpuCode);
                    }
                    else
                    {
                        assert(GT_TRUE != action.mirror.mirrorToRxAnalyzerPort);
                        assert(CPSS_NET_INGRESS_MIRRORED_TO_ANLYZER_E != action.mirror.cpuCode);
                    }
                }
            }
            else
            {
                assert(GT_TRUE != action.mirror.mirrorToRxAnalyzerPort);
                assert(CPSS_NET_INGRESS_MIRRORED_TO_ANLYZER_E != action.mirror.cpuCode);
            }
        }

        //
        // Oter ...
        //
        assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
        assert(GT_FALSE == action.vlan.nestedVlan);
        assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
    }
    else
    {
        b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                rule_inst_p->dev_rule_info.rule_id,
                                &pce);
        assert(TRUE != b_result);
    }
}

/// Note: This function have side effect
// After call this function the counter of rule will be changed
// It will cause the UPPER layer can not except result well
//
void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_ACL_ACE_Rule_Set_Clear_Counter(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p,
    RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p)
{
    assert(NULL != interface_p);
    assert(NULL != acl_inst_p);
    assert(NULL != ace_inst_p);
    assert(NULL != rule_inst_p);

    if (TRUE == rule_inst_p->active &&
        RULE_TYPE_COUNTER_ENABLE == acl_inst_p->counter_enable)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        UI32_T greenCntr, yellowCntr, redCntr;
        UI32_T read_greenCntr, read_yellowCntr, read_redCntr;

        BOOL_T b_result;

        greenCntr   = rand() % 1000;
        yellowCntr  = rand() % 1000;
        redCntr     = rand() % 1000;

        RULE_CTRL_UT_Proc_Set_Billing_Counter(rule_inst_p->dev_rule_info.device,
                                              rule_inst_p->dev_rule_info.rule_id,
                                              greenCntr, yellowCntr, redCntr);

        //
        // Via RULE CTRL API
        //
        {
            UI32_T ifindex;

            RULE_TYPE_Ace_Entry_T ace_entry;

            result = RULE_CTRL_Interface_To_Ifindex(interface_p, &ifindex);
            result = RULE_CTRL_GetAclRuleCounter(ifindex,
                                                 interface_p->direction,
                                                 acl_inst_p->id,
                                                 ace_inst_p->id,
                                                 &ace_entry);

            assert(RULE_TYPE_OK == result);

            assert(ace_entry.counter.total_packets == (greenCntr + yellowCntr + redCntr));
        }

        b_result = DEVRM_PMGR_GetCounter(rule_inst_p->dev_rule_info.device,
                                         rule_inst_p->dev_rule_info.pcl_id,
                                         rule_inst_p->dev_rule_info.rule_id,
                                         &read_greenCntr,
                                         &read_yellowCntr,
                                         &read_redCntr);

        assert(TRUE == b_result);

        assert((read_greenCntr + read_yellowCntr + read_redCntr) ==
                                            (greenCntr + yellowCntr + redCntr));

        //
        // Via RULE CTRL API
        //
        {
            UI32_T ifindex;

            RULE_TYPE_Ace_Entry_T ace_entry;

            result = RULE_CTRL_Interface_To_Ifindex(interface_p, &ifindex);
            result = RULE_CTRL_ClearAclRuleCounter(ifindex,
                                                   interface_p->direction,
                                                   acl_inst_p->id,
                                                   ace_inst_p->id);

            assert(RULE_TYPE_OK == result);

            result = RULE_CTRL_GetAclRuleCounter(ifindex,
                                                 interface_p->direction,
                                                 acl_inst_p->id,
                                                 ace_inst_p->id,
                                                 &ace_entry);

            assert(RULE_TYPE_OK == result);

            assert(ace_entry.counter.total_packets == 0);
        }
    }
}

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_ACL_ACE(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p)
{
    enum
    {
        MY_UNIT = 1
    };

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T ace_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T rule_inst_iter;

    RULE_TYPE_Ace_Entry_T ace_entry;

    assert(NULL != interface_p);
    assert(NULL != acl_inst_p);
    assert(NULL != ace_inst_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(ace_inst_p, &ace_inst_obj);
    ace_inst_obj.get_element_iterator(&ace_inst_obj, &rule_inst_iter);

    //
    // ace should exist
    //
    result = RULE_OM_GetAceByIndex(ace_inst_p->id, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // ace should have rule
    //
    assert(0 < rule_inst_iter.count(&rule_inst_iter));

    for (rule_inst_iter.first(&rule_inst_iter);
         NULL != rule_inst_iter.get_instance(&rule_inst_iter);
         rule_inst_iter.next(&rule_inst_iter))
    {
        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        BOOL_T is_active = TRUE;

        rule_inst_p = (RULE_TYPE_RULE_INSTANCE_PTR_T)rule_inst_iter.get_instance(&rule_inst_iter);

#if (SYS_CPNT_TIME_BASED_ACL == TRUE)
        //FIXME: time_range
//        is_active = RULE_CTRL_LocalCheckRuleInActiveByTimeRange(ace_entry.time_range_index,
//                                                                acl_inst_p->time_range_index);
//        assert(is_active == rule_inst_p->active);

#else
        is_active = TRUE;
        assert(is_active == rule_inst_p->active);
#endif

        if (MY_UNIT == rule_inst_p->dev_rule_info.unit)
        {
            RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_ACL_ACE_Rule_Pattern(interface_p,
                                                                                      acl_inst_p,
                                                                                      ace_inst_p,
                                                                                      rule_inst_p);

            RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_ACL_ACE_Rule_Action(interface_p,
                                                                                     acl_inst_p,
                                                                                     ace_inst_p,
                                                                                     rule_inst_p);

            RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_ACL_ACE_Rule_Set_Clear_Counter(interface_p,
                                                                                                acl_inst_p,
                                                                                                ace_inst_p,
                                                                                                rule_inst_p);
        }
    }
}

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_ACL(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T acl_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T ace_inst_iter;

    UI32_T ifindex;

    UI32_T acl_index;
    UI8_T time_range_name[SYS_ADPT_TIME_RANGE_MAX_NAME_LENGTH+1] = {0};
    RULE_TYPE_COUNTER_ENABLE_T counter_enable;

    RULE_TYPE_Acl_T acl_entry;

    assert(NULL != interface_p);
    assert(NULL != acl_inst_p);

    result = RULE_CTRL_Interface_To_Ifindex(interface_p, &ifindex);
    assert(RULE_TYPE_OK == result);

    /// Get type of template
    // The type of instance shall be same as the template
    //
    result = RULE_OM_GetAclByIndex(acl_inst_p->id, &acl_entry);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetPortAclIndex(ifindex,
                                     acl_entry.acl_type,
                                     interface_p->direction == RULE_TYPE_INBOUND ? TRUE : FALSE,
                                     &acl_index,
                                     time_range_name,
                                     &counter_enable);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetAclByIndex(acl_index, &acl_entry);
    assert(RULE_TYPE_OK == result);

#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
    if (TRUE == acl_entry.flag_aggregate_done &&
        0 != acl_entry.aggregate_acl_index)
    {
        acl_index = acl_entry.aggregate_acl_index;

        result = RULE_OM_GetAclByIndex(acl_index, &acl_entry);
        assert(RULE_TYPE_OK == result);
    }
#endif // SYS_CPNT_ACL_AUTO_COMPRESS_ACE

    assert(acl_index == acl_inst_p->id);

    //
    // Check instance on port entry
    //
    {
        RULE_TYPE_CLASS_INSTANCE_PTR_T temp_acl_inst_p;

        temp_acl_inst_p = RULE_CTRL_Priv_GetAclInstanceById(interface_p, acl_index);

        assert(NULL != temp_acl_inst_p);
        assert(temp_acl_inst_p == acl_inst_p);
    }

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(acl_inst_p, &acl_inst_obj);

    acl_inst_obj.get_element_iterator(&acl_inst_obj, &ace_inst_iter);

    assert(ace_inst_iter.count(&ace_inst_iter) == acl_entry.ace_count);



    for (ace_inst_iter.first(&ace_inst_iter);
         NULL != ace_inst_iter.get_instance(&ace_inst_iter);
         ace_inst_iter.next(&ace_inst_iter))
    {
        RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p;

        ace_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)ace_inst_iter.get_instance(&ace_inst_iter);

        RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_ACL_ACE(interface_p, acl_inst_p, ace_inst_p);
    }

}

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Qos_ACE_Rule_Pattern(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p,
    RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p)
{
    assert(NULL != policy_map_inst_p);
    assert(NULL != class_map_inst_p);
    assert(NULL != ace_inst_p);
    assert(NULL != rule_inst_p);

    RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_ACL_ACE_Rule_Pattern(interface_p,
                                                                              NULL,
                                                                              ace_inst_p,
                                                                              rule_inst_p);
}

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Qos_ACE_Rule_Meter(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p,
    RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_PolicyElement_T policy_element;

    DEVRM_PCE_T *pce;

    BOOL_T b_result;

    assert(NULL != policy_map_inst_p);
    assert(NULL != class_map_inst_p);
    assert(NULL != ace_inst_p);
    assert(NULL != rule_inst_p);

    b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                            rule_inst_p->dev_rule_info.rule_id,
                            &pce);
    assert(TRUE == b_result);

    result = RULE_OM_GetPolicyMapElementFromPolicyMapByClassMap(policy_map_inst_p->id,
                                                                class_map_inst_p->id,
                                                                &policy_element);
    assert(RULE_TYPE_OK == result);

    if (0 != policy_element.meter_index)
    {
        RULE_TYPE_TBParamEntry_T meter_entry;

        CPSS_DXCH3_POLICER_METERING_ENTRY_STC   policer_entry;
        CPSS_DXCH3_POLICER_BILLING_ENTRY_STC    billingCntr;

        assert(0 < pce->policer_idx);

        result = RULE_OM_GetMeterEntryByIndex(policy_element.meter_index, &meter_entry);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Get_Sdk_Meter(rule_inst_p->dev_rule_info.device,
                                        pce,
                                        &policer_entry);

        if (RULE_TYPE_METER_MODE_TRTCM_COLOR_BLIND == meter_entry.meter_model)
        {
            assert(CPSS_DXCH3_POLICER_METER_MODE_TR_TCM_E == policer_entry.meterMode);
            assert(CPSS_POLICER_COLOR_BLIND_E == policer_entry.meterColorMode);

            assert(meter_entry.rate == policer_entry.tokenBucketParams.trTcmParams.cir);
            assert(meter_entry.burst_size + 7 / 8 == policer_entry.tokenBucketParams.trTcmParams.cbs);
            assert(meter_entry.peak_rate == policer_entry.tokenBucketParams.trTcmParams.pir);
            assert(meter_entry.peak_burst_size + 7 / 8 == policer_entry.tokenBucketParams.trTcmParams.pbs);
        }
        else if (RULE_TYPE_METER_MODE_TRTCM_COLOR_AWARE == meter_entry.meter_model)
        {
            assert(CPSS_DXCH3_POLICER_METER_MODE_TR_TCM_E == policer_entry.meterMode);
            assert(CPSS_POLICER_COLOR_AWARE_E == policer_entry.meterColorMode);

            assert(meter_entry.rate == policer_entry.tokenBucketParams.trTcmParams.cir);
            assert(meter_entry.burst_size + 7 / 8 == policer_entry.tokenBucketParams.trTcmParams.cbs);
            assert(meter_entry.peak_rate == policer_entry.tokenBucketParams.trTcmParams.pir);
            assert(meter_entry.peak_burst_size + 7 / 8 == policer_entry.tokenBucketParams.trTcmParams.pbs);
        }
        else if (RULE_TYPE_METER_MODE_SRTCM_COLOR_BLIND == meter_entry.meter_model)
        {
            assert(CPSS_DXCH3_POLICER_METER_MODE_SR_TCM_E == policer_entry.meterMode);
            assert(CPSS_POLICER_COLOR_BLIND_E == policer_entry.meterColorMode);

            assert(meter_entry.rate == policer_entry.tokenBucketParams.srTcmParams.cir);
            assert(meter_entry.burst_size + 7 / 8 == policer_entry.tokenBucketParams.srTcmParams.cbs);
            assert(meter_entry.peak_burst_size + 7 / 8 == policer_entry.tokenBucketParams.srTcmParams.ebs);
        }
        else if (RULE_TYPE_METER_MODE_SRTCM_COLOR_AWARE == meter_entry.meter_model)
        {
            assert(CPSS_DXCH3_POLICER_METER_MODE_SR_TCM_E == policer_entry.meterMode);
            assert(CPSS_POLICER_COLOR_AWARE_E == policer_entry.meterColorMode);

            assert(meter_entry.rate == policer_entry.tokenBucketParams.srTcmParams.cir);
            assert(meter_entry.burst_size + 7 / 8 == policer_entry.tokenBucketParams.srTcmParams.cbs);
            assert(meter_entry.peak_burst_size + 7 / 8 == policer_entry.tokenBucketParams.srTcmParams.ebs);
        }
        else if (RULE_TYPE_METER_MODE_DEFAULT == meter_entry.meter_model ||
                 RULE_TYPE_METER_MODE_FLOW == meter_entry.meter_model)
        {
            assert(CPSS_DXCH3_POLICER_METER_MODE_SR_TCM_E == policer_entry.meterMode);
            assert(CPSS_POLICER_COLOR_BLIND_E == policer_entry.meterColorMode);

            assert(meter_entry.rate == policer_entry.tokenBucketParams.srTcmParams.cir);
            assert(meter_entry.burst_size + 7 / 8 == policer_entry.tokenBucketParams.srTcmParams.cbs);
        }
        else
        {
            assert(0);
        }

        RULE_CTRL_UT_Proc_Get_Sdk_Billing_Entry(rule_inst_p->dev_rule_info.device,
                                                pce,
                                                &billingCntr);

        assert(CPSS_DXCH3_POLICER_BILLING_CNTR_1_BYTE_E == billingCntr.billingCntrMode);
    }
    else
    {
        assert(-1 == pce->policer_idx);
    }
}

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Qos_ACE_Rule_Action(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p,
    RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_PolicyElement_T policy_element;
    RULE_TYPE_Action_T action;

    DEVRM_PCE_T *pce;

    BOOL_T b_result;

    assert(NULL != policy_map_inst_p);
    assert(NULL != class_map_inst_p);
    assert(NULL != ace_inst_p);
    assert(NULL != rule_inst_p);

    b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                            rule_inst_p->dev_rule_info.rule_id,
                            &pce);
    assert(TRUE == b_result);

    result = RULE_OM_GetPolicyMapElementFromPolicyMapByClassMap(policy_map_inst_p->id,
                                                                class_map_inst_p->id,
                                                                &policy_element);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetActionEntryByIndex(policy_element.action_index, &action);
    assert(RULE_TYPE_OK == result);

    {
        CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
        CPSS_DXCH_PCL_RULE_FORMAT_UNT mask;
        CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern;
        CPSS_DXCH_PCL_ACTION_STC action;

        result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                pce,
                                                &ruleFormat, &mask, &pattern, &action);
        assert(RULE_TYPE_OK == result);

        assert(CPSS_PACKET_CMD_FORWARD_E == action.pktCmd);

        assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
        assert(GT_FALSE == action.vlan.nestedVlan);
        assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
    }

    //
    // FIXME: Miss in-profile action !!
    //

    //
    // Policer relational action
    //
    if (action.action_bitmap & RULE_TYPE_ACTION_YELLOW_DROP)
    {
        assert((0 != policy_element.meter_index && 0 < pce->policer_idx) ||
               (0 == policy_element.meter_index && -1 == pce->policer_idx));

        if (0 != policy_element.meter_index)
        {
            CPSS_DXCH3_POLICER_METERING_ENTRY_STC   policer_entry;

            assert(0 < pce->policer_idx);

            RULE_CTRL_UT_Proc_Get_Sdk_Meter(rule_inst_p->dev_rule_info.device,
                                            pce,
                                            &policer_entry);

            assert(CPSS_DXCH3_POLICER_NON_CONFORM_CMD_DROP_E == policer_entry.yellowPcktCmd);
        }
    }

    if (action.action_bitmap & RULE_TYPE_ACTION_YELLOW_PKT_NEW_DSCP)
    {
        assert((0 != policy_element.meter_index && 0 < pce->policer_idx) ||
               (0 == policy_element.meter_index && -1 == pce->policer_idx));

        if (0 != policy_element.meter_index)
        {
            CPSS_DXCH3_POLICER_METERING_ENTRY_STC   policer_entry;

            assert(0 < pce->policer_idx);

            RULE_CTRL_UT_Proc_Get_Sdk_Meter(rule_inst_p->dev_rule_info.device,
                                            pce,
                                            &policer_entry);

            if ((action.action_bitmap & RULE_TYPE_ACTION_YELLOW_PKT_NEW_DSCP) &&
                (action.action_bitmap & RULE_TYPE_ACTION_RED_PKT_NEW_DSCP))
            {
                assert(CPSS_DXCH3_POLICER_NON_CONFORM_CMD_REMARK_E == policer_entry.yellowPcktCmd);

                //
                // FIXME: The check is not working when share meter for multiple PCE
                // Need to improve it.
                //
//                assert(0 < pce_p->qos_remarking_idx);
            }
            else
            {
                assert(CPSS_DXCH3_POLICER_NON_CONFORM_CMD_REMARK_BY_ENTRY_E == policer_entry.yellowPcktCmd);
            }

            assert(CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E == policer_entry.modifyDscp);
        }
    }

    if (action.action_bitmap & RULE_TYPE_ACTION_RED_DROP)
    {
        assert((0 != policy_element.meter_index && 0 < pce->policer_idx) ||
               (0 == policy_element.meter_index && -1 == pce->policer_idx));

        if (0 != policy_element.meter_index)
        {
            CPSS_DXCH3_POLICER_METERING_ENTRY_STC   policer_entry;

            assert(0 < pce->policer_idx);

            RULE_CTRL_UT_Proc_Get_Sdk_Meter(rule_inst_p->dev_rule_info.device,
                                            pce,
                                            &policer_entry);

            assert(CPSS_DXCH3_POLICER_NON_CONFORM_CMD_DROP_E == policer_entry.redPcktCmd);
        }
    }

    if (action.action_bitmap & RULE_TYPE_ACTION_RED_PKT_NEW_DSCP)
    {
        assert((0 != policy_element.meter_index && 0 < pce->policer_idx) ||
               (0 == policy_element.meter_index && -1 == pce->policer_idx));

        if (0 != policy_element.meter_index)
        {
            CPSS_DXCH3_POLICER_METERING_ENTRY_STC   policer_entry;

            assert(0 < pce->policer_idx);

            RULE_CTRL_UT_Proc_Get_Sdk_Meter(rule_inst_p->dev_rule_info.device,
                                            pce,
                                            &policer_entry);

            if ((action.action_bitmap & RULE_TYPE_ACTION_YELLOW_PKT_NEW_DSCP) &&
                (action.action_bitmap & RULE_TYPE_ACTION_RED_PKT_NEW_DSCP))
            {
                assert(CPSS_DXCH3_POLICER_NON_CONFORM_CMD_REMARK_E == policer_entry.redPcktCmd);

                //
                // FIXME: The check is not working when share meter for multiple PCE
                // Need to improve it.
                //
//                assert(0 < pce_p->qos_remarking_idx);
            }
            else
            {
                assert(CPSS_DXCH3_POLICER_NON_CONFORM_CMD_REMARK_BY_ENTRY_E == policer_entry.redPcktCmd);
            }

            assert(CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E == policer_entry.modifyDscp);
        }
    }

}

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Qos_ACE(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p)
{
    enum
    {
        MY_UNIT = 1
    };

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T ace_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T rule_inst_iter;

    RULE_TYPE_Ace_Entry_T ace_entry;

    assert(NULL != policy_map_inst_p);
    assert(NULL != class_map_inst_p);
    assert(NULL != ace_inst_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(ace_inst_p, &ace_inst_obj);
    ace_inst_obj.get_element_iterator(&ace_inst_obj, &rule_inst_iter);

    //
    // ace should exist
    //
    result = RULE_OM_GetAceByIndex(ace_inst_p->id, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // ace should have rule
    //
    assert(0 < rule_inst_iter.count(&rule_inst_iter));

    for (rule_inst_iter.first(&rule_inst_iter);
         NULL != rule_inst_iter.get_instance(&rule_inst_iter);
         rule_inst_iter.next(&rule_inst_iter))
    {
        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;

        rule_inst_p = (RULE_TYPE_RULE_INSTANCE_PTR_T)rule_inst_iter.get_instance(&rule_inst_iter);

        assert(TRUE == rule_inst_p->active);

        if (MY_UNIT == rule_inst_p->dev_rule_info.unit)
        {
            RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Qos_ACE_Rule_Pattern(interface_p,
                                                                                      policy_map_inst_p,
                                                                                      class_map_inst_p,
                                                                                      ace_inst_p,
                                                                                      rule_inst_p);

            RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Qos_ACE_Rule_Meter(interface_p,
                                                                                    policy_map_inst_p,
                                                                                    class_map_inst_p,
                                                                                    ace_inst_p,
                                                                                    rule_inst_p);

            RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Qos_ACE_Rule_Action(interface_p,
                                                                                     policy_map_inst_p,
                                                                                     class_map_inst_p,
                                                                                     ace_inst_p,
                                                                                     rule_inst_p);
        }
    }
}

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Policy_Map_Class_Map_MF(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T mf_ace_inst_p)
{
    RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Qos_ACE(interface_p,
                                                                 policy_map_inst_p,
                                                                 class_map_inst_p,
                                                                 mf_ace_inst_p);
}

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Policy_Map_Class_Map_ACL(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T acl_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T ace_inst_iter;

    RULE_TYPE_Acl_T acl_entry;

    assert(NULL != policy_map_inst_p);
    assert(NULL != class_map_inst_p);
    assert(NULL != acl_inst_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(acl_inst_p, &acl_inst_obj);
    acl_inst_obj.get_element_iterator(&acl_inst_obj, &ace_inst_iter);

    //
    // acl should exist
    //
    result = RULE_OM_GetAclByIndex(acl_inst_p->id, &acl_entry);
    assert(RULE_TYPE_OK == result);

#if (SYS_CPNT_DIFFSERV_USE_DENY_ACE_IN_ACL == TRUE)
    //
    // number of ace should equal number of ace instance
    //
    assert(acl_entry.ace_count == ace_inst_iter.count(&ace_inst_iter));
#else
    {
        UI32_T ace_count;

        UI32_T ace_index;
        RULE_TYPE_AclType_T ace_type;
        RULE_TYPE_Ace_Entry_T ace_entry;

        for (ace_index = 0, ace_count = 0;
             RULE_TYPE_OK == RULE_OM_GetNextAceByAcl(acl_inst_p->id, &ace_type, &ace_index, &ace_entry);)
        {
            if (RULE_TYPE_ACE_PERMIT == ace_entry.access)
            {
                ace_count ++;
            }
        }

        //
        // number of ace should equal number of ace instance
        //
        assert(ace_count == ace_inst_iter.count(&ace_inst_iter));
    }
#endif // SYS_CPNT_DIFFSERV_USE_DENY_ACE_IN_ACL

    for (ace_inst_iter.first(&ace_inst_iter);
         NULL != ace_inst_iter.get_instance(&ace_inst_iter);
         ace_inst_iter.next(&ace_inst_iter))
    {
        RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p;

        ace_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)ace_inst_iter.get_instance(&ace_inst_iter);

        RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Qos_ACE(interface_p,
                                                                     policy_map_inst_p,
                                                                     class_map_inst_p,
                                                                     ace_inst_p);
    }

}

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Policy_Map_Class_Map(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T class_map_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T acl_mf_ace_inst_iter;

    RULE_TYPE_PolicyElement_T policy_element;
    RULE_TYPE_ClassMap_T      class_map;

    assert(NULL != policy_map_inst_p);
    assert(NULL != class_map_inst_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_map_inst_p,
                                                   &class_map_inst_obj);
    class_map_inst_obj.get_element_iterator(&class_map_inst_obj, &acl_mf_ace_inst_iter);

    //
    // class-map should exist
    //
    result = RULE_OM_GetClassMap(class_map_inst_p->id, &class_map);
    assert(RULE_TYPE_OK == result);

    //
    // class-map should active
    //
    assert(0 != class_map.row_status);

    //
    // class-map should exist in policy-map
    //
    result = RULE_OM_GetPolicyMapElementFromPolicyMapByClassMap(policy_map_inst_p->id,
                                                                class_map_inst_p->id,
                                                                &policy_element);
    assert(RULE_TYPE_OK == result);

    if (RULE_TYPE_CLASS_MAP_MATCH_ANY == class_map.class_map_match_type)
    {
        //
        // number of class-map element should equal number of class-map instance's children element
        //
        assert(class_map.class_element_count == acl_mf_ace_inst_iter.count(&acl_mf_ace_inst_iter));

        for (acl_mf_ace_inst_iter.first(&acl_mf_ace_inst_iter);
             NULL != acl_mf_ace_inst_iter.get_instance(&acl_mf_ace_inst_iter);
             acl_mf_ace_inst_iter.next(&acl_mf_ace_inst_iter))
        {
            RULE_TYPE_CLASS_INSTANCE_PTR_T acl_mf_ace_inst_p;

            acl_mf_ace_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)acl_mf_ace_inst_iter.get_instance(&acl_mf_ace_inst_iter);

            if (RULE_TYPE_INST_MF_ACE == acl_mf_ace_inst_p->super.type)
            {
                RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Policy_Map_Class_Map_MF(interface_p,
                                                                                             policy_map_inst_p,
                                                                                             class_map_inst_p,
                                                                                             acl_mf_ace_inst_p);
            }
            else if (RULE_TYPE_INST_ACL == acl_mf_ace_inst_p->super.type)
            {
                RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Policy_Map_Class_Map_ACL(interface_p,
                                                                                              policy_map_inst_p,
                                                                                              class_map_inst_p,
                                                                                              acl_mf_ace_inst_p);
            }
            else
            {
                assert(0);
            }
        }
    }

#if (SYS_CPNT_QOS_V2_CLASS_MAP_MATCH_ALL == TRUE)
    else if (RULE_TYPE_CLASS_MAP_MATCH_ALL == class_map.class_map_match_type)
    {
        RULE_TYPE_Acl_T acl_entry;

        result = RULE_OM_GetAclByIndex(class_map.class_ext.aggregate_index, &acl_entry);
        assert(RULE_TYPE_OK == result);

        //
        // only 1 agg acl under class-map
        //
        assert(1 == acl_mf_ace_inst_iter.count(&acl_mf_ace_inst_iter));

        for (acl_mf_ace_inst_iter.first(&acl_mf_ace_inst_iter);
             NULL != acl_mf_ace_inst_iter.get_instance(&acl_mf_ace_inst_iter);
             acl_mf_ace_inst_iter.next(&acl_mf_ace_inst_iter))
        {
            RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;

            acl_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)acl_mf_ace_inst_iter.get_instance(&acl_mf_ace_inst_iter);

            RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Policy_Map_Class_Map_ACL(interface_p,
                                                                                          policy_map_inst_p,
                                                                                          class_map_inst_p,
                                                                                          acl_inst_p);
        }
    }
#endif /* SYS_CPNT_QOS_V2_CLASS_MAP_MATCH_ALL */
    else
    {
        assert(0);
    }
}

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Policy_Map(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T policy_map_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T class_map_inst_iter;

    UI32_T ifindex;

    RULE_TYPE_PolicyMap_T policy_map;

    assert(NULL != policy_map_inst_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(policy_map_inst_p, &policy_map_inst_obj);
    policy_map_inst_obj.get_element_iterator(&policy_map_inst_obj, &class_map_inst_iter);

    //
    // policy-map should exist
    //
    result = RULE_OM_GetPolicyMapByIndex(policy_map_inst_p->id, &policy_map);
    assert(RULE_TYPE_OK == result);

    //
    // policy-map should have bound on interface
    //
    {
        RULE_TYPE_PortEntry_T *port_entry_p;

        result = RULE_CTRL_Interface_To_Ifindex(interface_p, &ifindex);
        assert(RULE_TYPE_OK == result);

        port_entry_p = RULE_OM_LocalGetPortEntryByIfIndex(ifindex, interface_p->direction);
        assert(NULL != port_entry_p);

        assert(port_entry_p->policy_map_index == policy_map_inst_p->id);
    }

    //
    // number of policy-map element should equal number of policy-map instance's children element
    //
    assert(policy_map.element_count == class_map_inst_iter.count(&class_map_inst_iter));

    //
    // check each children element ...
    //
    for (class_map_inst_iter.first(&class_map_inst_iter);
         NULL != class_map_inst_iter.get_instance(&class_map_inst_iter);
         class_map_inst_iter.next(&class_map_inst_iter))
    {
        RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p;

        class_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)class_map_inst_iter.get_instance(&class_map_inst_iter);

        assert(TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(class_map_inst_p->super.type));

        RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Policy_Map_Class_Map(interface_p,
                                                                                  policy_map_inst_p,
                                                                                  class_map_inst_p);
    }
}

void
RULE_CTRL_UT_Proc_Validate_Matching_PCL(
    CPSS_INTERFACE_INFO_STC   *interfaceInfoPtr,
    const RULE_CTRL_PCL_CFG_T *pcl_cfg_p)
{
    GT_STATUS                       rc;

    CPSS_PCL_DIRECTION_ENT          direction;
    CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum;

    CPSS_DXCH_PCL_LOOKUP_CFG_STC    lookupCfg;

    direction = (RULE_TYPE_INBOUND == pcl_cfg_p->interface.direction) ? CPSS_PCL_DIRECTION_INGRESS_E :
                                                    CPSS_PCL_DIRECTION_EGRESS_E;

    lookupNum = (DEVRM_PCL_LOOKUP_0_0 == pcl_cfg_p->lookup_num ||
                 DEVRM_PCL_LOOKUP_0_1 == pcl_cfg_p->lookup_num) ? CPSS_PCL_LOOKUP_0_E :
                (DEVRM_PCL_LOOKUP_1   == pcl_cfg_p->lookup_num) ? CPSS_PCL_LOOKUP_1_E : 0xCCCCCCCC;

    rc = cpssDxChPclCfgTblGet(interfaceInfoPtr->devNum, interfaceInfoPtr, direction, lookupNum, &lookupCfg);
    assert(GT_OK == rc);

    //assert(GT_TRUE == lookupCfg.enableLookup);

    if (DEVRM_PCL_LOOKUP_0_0 == pcl_cfg_p->lookup_num
#if (0 == DEVRM_RESERVED_RUEL_FOR_L3_ROUTING)
        || DEVRM_PCL_LOOKUP_1   == pcl_cfg_p->lookup_num
#endif
        )
    {
        /* FIXME: Before dynamic bind pcl, per-port will bind after global, so this check will pass
         *        but in dynamic bind pcl, per-port and global doesn't has const sequence to bind,
         *        so this check will fail, patch to look global mask
         */
        assert((lookupCfg.pclId & 0x00000380 /* pcl_cfg_p->pcl_id_mask */) ==
               (pcl_cfg_p->pcl_id & 0x00000380/* pcl_cfg_p->pcl_id_mask*/));
    }
    else if (DEVRM_PCL_LOOKUP_0_1 == pcl_cfg_p->lookup_num)
    {
        assert(GT_TRUE == lookupCfg.dualLookup);
        assert((lookupCfg.pclIdL01 & 0x00000380 /* pcl_cfg_p->pcl_id_mask */) ==
               (pcl_cfg_p->pcl_id & 0x00000380/*pcl_cfg_p->pcl_id_mask */));
    }
}

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Global_PCL(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    const RULE_CTRL_PCL_CFG_T *pcl_cfg_p)
{
    GT_U8                           devNum = 0;

    CPSS_INTERFACE_INFO_STC         interfaceInfo;

    UI32_T unit = 1;
    UI32_T port;
    UI32_T trunk_id;
    UI32_T module_id, device_id, phy_port;

    BOOL_T b_result;

    assert(NULL != interface_p);
    assert(RULE_TYPE_INTERFACE_ALL_UNIT == interface_p->type ||
           RULE_TYPE_INTERFACE_UNIT == interface_p->type);
    assert(NULL != pcl_cfg_p);

    for (port = 1; port <= SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT_ON_BOARD; ++ port)
    {
        b_result = DEV_SWDRV_Logical2PhyDevicePortID(unit, port, &module_id, &device_id, &phy_port);
        assert(TRUE == b_result);

        memset(&interfaceInfo, 0, sizeof(interfaceInfo));

        interfaceInfo.type = CPSS_INTERFACE_PORT_E;
        interfaceInfo.devPort.devNum  = device_id;
        interfaceInfo.devPort.portNum = phy_port;
        interfaceInfo.devNum = device_id;

        RULE_CTRL_UT_Proc_Validate_Matching_PCL(&interfaceInfo, pcl_cfg_p);
    }

    for (trunk_id = 1; trunk_id <= SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM; ++ trunk_id)
    {
        memset(&interfaceInfo, 0, sizeof(interfaceInfo));

        interfaceInfo.type = CPSS_INTERFACE_TRUNK_E;
        interfaceInfo.devPort.devNum  = devNum;
        interfaceInfo.trunkId = (GT_U16)DEV_SWDRV_CONVER_TRUNKID_A2C(interfaceInfo.devNum, trunk_id);
        interfaceInfo.devNum = devNum;

        RULE_CTRL_UT_Proc_Validate_Matching_PCL(&interfaceInfo, pcl_cfg_p);
    }
}

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Craft_Port_PCL(
    const RULE_CTRL_PCL_CFG_T *pcl_cfg_p)
{
    CPSS_INTERFACE_INFO_STC interfaceInfo;

    UI8_T device_id, phy_port;

    assert(NULL != pcl_cfg_p);

    STKTPLG_BOARD_GetCraftPortInfo(&device_id, &phy_port);

    memset(&interfaceInfo, 0, sizeof(interfaceInfo));

    interfaceInfo.type = CPSS_INTERFACE_PORT_E;
    interfaceInfo.devPort.devNum  = device_id;
    interfaceInfo.devPort.portNum = phy_port;
    interfaceInfo.devNum = device_id;

    RULE_CTRL_UT_Proc_Validate_Matching_PCL(&interfaceInfo, pcl_cfg_p);
}

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_CPU_Port_PCL(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    const RULE_CTRL_PCL_CFG_T *pcl_cfg_p)
{
    enum
    {
        MY_UNIT = 1,
        PHY_CPU_PORT = 63
    };

    UI32_T unit;

    assert(NULL != interface_p);
    assert(RULE_TYPE_INTERFACE_CPU_PORT == interface_p->type);
    assert(NULL != pcl_cfg_p);

    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        if (MY_UNIT == unit)
        {
            UI32_T num_of_device;
            UI32_T device_id;

            CPSS_INTERFACE_INFO_STC interfaceInfo;

            num_of_device = DEVRM_PMGR_GetNumberOfChips();

            for (device_id = 0; device_id < num_of_device; ++ device_id)
            {
                memset(&interfaceInfo, 0, sizeof(interfaceInfo));

                interfaceInfo.type = CPSS_INTERFACE_PORT_E;
                interfaceInfo.devPort.devNum  = device_id;
                interfaceInfo.devPort.portNum = PHY_CPU_PORT;
                interfaceInfo.devNum = device_id;

                RULE_CTRL_UT_Proc_Validate_Matching_PCL(&interfaceInfo, pcl_cfg_p);
            }
        }
    }
}

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_User_Port_PCL(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    const RULE_CTRL_PCL_CFG_T *pcl_cfg_p)
{
    CPSS_INTERFACE_INFO_STC interfaceInfo;

    UI32_T module_id, device_id, phy_port;

    BOOL_T b_result;

    assert(NULL != interface_p);
    assert(RULE_TYPE_INTERFACE_UPORT == interface_p->type);
    assert(NULL != pcl_cfg_p);

    b_result = DEV_SWDRV_Logical2PhyDevicePortID(interface_p->uport.unit,
                                                 interface_p->uport.port,
                                                 &module_id, &device_id, &phy_port);
    assert(TRUE == b_result);

    memset(&interfaceInfo, 0, sizeof(interfaceInfo));

    interfaceInfo.type = CPSS_INTERFACE_PORT_E;
    interfaceInfo.devPort.devNum  = device_id;
    interfaceInfo.devPort.portNum = phy_port;
    interfaceInfo.devNum = device_id;

    RULE_CTRL_UT_Proc_Validate_Matching_PCL(&interfaceInfo, pcl_cfg_p);
}

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Trunk_Port_PCL(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    const RULE_CTRL_PCL_CFG_T *pcl_cfg_p)
{
    enum
    {
        MY_UNIT = 1
    };

    UI32_T unit;

    assert(NULL != interface_p);
    assert(RULE_TYPE_INTERFACE_TRUNK == interface_p->type);
    assert(NULL != pcl_cfg_p);

    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        if (MY_UNIT == unit)
        {
            UI32_T num_of_device;
            UI32_T device_id;

            CPSS_INTERFACE_INFO_STC interfaceInfo;

            num_of_device = DEVRM_PMGR_GetNumberOfChips();

            for (device_id = 0; device_id < num_of_device; ++ device_id)
            {
                memset(&interfaceInfo, 0, sizeof(interfaceInfo));

                interfaceInfo.type = CPSS_INTERFACE_TRUNK_E;
                interfaceInfo.devPort.devNum  = device_id;
                interfaceInfo.trunkId = (GT_U16)DEV_SWDRV_CONVER_TRUNKID_A2C(interfaceInfo.devNum, interface_p->trunk_id);
                interfaceInfo.devNum = device_id;

                RULE_CTRL_UT_Proc_Validate_Matching_PCL(&interfaceInfo, pcl_cfg_p);
            }
        }
    }
}

typedef struct
{
    struct
    {
        union
        {
            RULE_TYPE_INTERFACE_INFO_PTR_T interface_p;
            void *ptr_param;
        };
    } arg[10];
} RULE_CTRL_UT_VALIDATE_PARAM_T, *RULE_CTRL_UT_VALIDATE_PARAM_PTR_T;

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance(
    RULE_TYPE_INSTANCE_PTR_T in,
    void *cookie)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_INTERFACE_INFO_PTR_T interface_p;

    RULE_CTRL_UT_VALIDATE_PARAM_PTR_T param_p;

    BOOL_T b_result;

    assert(NULL != in);
    assert(NULL != cookie);

    param_p = cookie;

    interface_p = param_p->arg[0].interface_p;

    if (RULE_CTRL_IS_CLASS_INSTANCE_TYPE(in->type))
    {
        RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

        class_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T) in;

        if (RULE_TYPE_INST_ACL == in->type)
        {
            RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

            if_entry_p = RULE_CTRL_Priv_GetIfEntry(interface_p);
            assert(NULL != if_entry_p);

            if (0 == memcmp(&if_entry_p->class_inst_ptr,
                            &class_inst_p->super.links.parent,
                            sizeof(if_entry_p->class_inst_ptr)))
            {
                RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_ACL(interface_p,
                                                                         (RULE_TYPE_CLASS_INSTANCE_PTR_T)in);
            }
        }

        if (RULE_TYPE_INST_POLICY_MAP == in->type)
        {
            RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Policy_Map(interface_p,
                                                                            (RULE_TYPE_CLASS_INSTANCE_PTR_T)in);
        }
    }
    else if (RULE_CTRL_IS_RULE_INSTANCE_TYPE(in->type))
    {
        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_TYPE_CLASS_INSTANCE_PTR_T parent_of_rule_inst_p;
        RULE_CTRL_PCL_CFG_T pcl_cfg;

        rule_inst_p = (RULE_TYPE_RULE_INSTANCE_PTR_T) in;

        assert(RULE_TYPE_NIL != rule_inst_p->super.links.parent.type);
        parent_of_rule_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_IN_Ptr2Instance(rule_inst_p->super.links.parent);
        assert(NULL != parent_of_rule_inst_p);

        assert(RULE_TYPE_PACKET_NIL != parent_of_rule_inst_p->mvl_pkt_type);

        result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                             parent_of_rule_inst_p->mvl_pkt_type,
                                                             &pcl_cfg);
        assert(RULE_TYPE_OK == result);

        assert(rule_inst_p->dev_rule_info.pcl_id == pcl_cfg.pcl_id);

        //
        // Check PCL ID. Each rule should have match PCL ID field.
        //
        if (TRUE == rule_inst_p->active)
        {
            DEVRM_PCE_T  *pce;

            CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
            CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
            CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
            CPSS_DXCH_PCL_ACTION_STC action;

            b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                    rule_inst_p->dev_rule_info.rule_id,
                                    &pce);
            assert(TRUE == b_result);
            assert(NULL != pce);

            result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                    pce,
                                                    &ruleFormat, &mask_u, &pattern_u, &action);
            assert(RULE_TYPE_OK == result);

            if (RULE_TYPE_INBOUND == pcl_cfg.interface.direction)
            {
                assert(pcl_cfg.pcl_id == pattern_u.ruleExtNotIpv6.common.pclId);
                assert(pcl_cfg.pcl_id_mask == mask_u.ruleExtNotIpv6.common.pclId);
            }
            else
            {
                assert(pcl_cfg.pcl_id == pattern_u.ruleEgrExtNotIpv6.common.pclId);
                assert(pcl_cfg.pcl_id_mask == mask_u.ruleEgrExtNotIpv6.common.pclId);
            }

            switch (interface_p->type)
            {
                case RULE_TYPE_INTERFACE_ALL_UNIT:
                case RULE_TYPE_INTERFACE_UNIT:
                    RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Global_PCL(interface_p,
                                                                                    &pcl_cfg);
                    break;

                case RULE_TYPE_INTERFACE_CRAFT_PORT:
                    RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Craft_Port_PCL(&pcl_cfg);
                    break;

                case RULE_TYPE_INTERFACE_CPU_PORT:
                    RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_CPU_Port_PCL(interface_p,
                                                                                      &pcl_cfg);
                    break;

                case RULE_TYPE_INTERFACE_UPORT:
                    RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_User_Port_PCL(interface_p,
                                                                                       &pcl_cfg);
                    break;

                case RULE_TYPE_INTERFACE_TRUNK:
                    RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance_Trunk_Port_PCL(interface_p,
                                                                                        &pcl_cfg);
                    break;

                default:
                    assert(0);
                    break;
            }
        }
    }
    else
    {
        assert(0);
    }
}

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_L4_OM_Consistency(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    const RULE_TYPE_CLASS_INSTANCE_OBJECT_T *if_class_obj_p)
{

    if (RULE_TYPE_INTERFACE_UPORT == interface_p->type ||
        RULE_TYPE_INTERFACE_TRUNK == interface_p->type ||
        RULE_TYPE_INTERFACE_CPU_PORT == interface_p->type ||
        RULE_TYPE_INTERFACE_ALL_UNIT == interface_p->type)
    {
        RULE_TYPE_RETURN_TYPE_T result;
        UI32_T ifindex;

        RULE_TYPE_PortEntry_T *port_entry_p;

        result = RULE_CTRL_Interface_To_Ifindex(interface_p, &ifindex);
        assert(RULE_TYPE_OK == result);

        if (FALSE == RULE_OM_LocalIsValidIfindex(ifindex, interface_p->direction))
        {
            return;
        }

        port_entry_p = RULE_OM_LocalGetPortEntryByIfIndex(ifindex, interface_p->direction);
        assert(NULL != port_entry_p);

        //
        // policy-map should have bound on interface
        //
        if (0 != port_entry_p->policy_map_index &&
            RULE_OM_IS_ENTRY_ACTIVE(port_entry_p->policy_map_row_status))
        {
            RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;

            RULE_CTRL_INSTANCE_TYPE_ID_T param;
            memset(&param, 0, sizeof(param));

            param.type = RULE_TYPE_INST_POLICY_MAP;
            param.id = port_entry_p->policy_map_index;

            policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj_p->inst,
                                                                                               RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                               &param);
            assert(NULL != policy_map_inst_p);
        }

        if (0 != port_entry_p->bind_acl[RULE_TYPE_MAC_ACL].acl_index &&
            RULE_OM_IS_ENTRY_ACTIVE(port_entry_p->bind_acl[RULE_TYPE_MAC_ACL].row_status))
        {
            RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;
            UI32_T acl_index = port_entry_p->bind_acl[RULE_TYPE_MAC_ACL].acl_index;

#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
            {
                RULE_TYPE_Acl_T *acl_entry_p;

                acl_entry_p = RULE_OM_LocalGetAclByIndex(acl_index);
                assert(NULL != acl_entry_p);

                if (TRUE == acl_entry_p->flag_aggregate_done)
                {
                    acl_index = acl_entry_p->aggregate_acl_index;
                }
            }
#endif // SYS_CPNT_ACL_AUTO_COMPRESS_ACE

            acl_inst_p = RULE_CTRL_Priv_GetAclInstanceById(interface_p, acl_index);
            assert(NULL != acl_inst_p);
        }

        if (0 != port_entry_p->bind_acl[RULE_TYPE_IP_ACL].acl_index &&
            RULE_OM_IS_ENTRY_ACTIVE(port_entry_p->bind_acl[RULE_TYPE_IP_ACL].row_status))
        {
            RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;

            UI32_T acl_index = port_entry_p->bind_acl[RULE_TYPE_IP_ACL].acl_index;

#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
            {
                RULE_TYPE_Acl_T *acl_entry_p;

                acl_entry_p = RULE_OM_LocalGetAclByIndex(acl_index);
                assert(NULL != acl_entry_p);

                if (TRUE == acl_entry_p->flag_aggregate_done)
                {
                    acl_index = acl_entry_p->aggregate_acl_index;
                }
            }
#endif // SYS_CPNT_ACL_AUTO_COMPRESS_ACE

            acl_inst_p = RULE_CTRL_Priv_GetAclInstanceById(interface_p, acl_index);
            assert(NULL != acl_inst_p);
        }

        if (0 != port_entry_p->bind_acl[RULE_TYPE_IPV6_ACL].acl_index &&
            RULE_OM_IS_ENTRY_ACTIVE(port_entry_p->bind_acl[RULE_TYPE_IPV6_ACL].row_status))
        {
            RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;

            UI32_T acl_index = port_entry_p->bind_acl[RULE_TYPE_IPV6_ACL].acl_index;

#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
            {
                RULE_TYPE_Acl_T *acl_entry_p;

                acl_entry_p = RULE_OM_LocalGetAclByIndex(acl_index);
                assert(NULL != acl_entry_p);

                if (TRUE == acl_entry_p->flag_aggregate_done)
                {
                    acl_index = acl_entry_p->aggregate_acl_index;
                }
            }
#endif // SYS_CPNT_ACL_AUTO_COMPRESS_ACE

            acl_inst_p = RULE_CTRL_Priv_GetAclInstanceById(interface_p, acl_index);
            assert(NULL != acl_inst_p);
        }
    }
}

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p)
{
    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

    RULE_CTRL_UT_VALIDATE_PARAM_T param;

    assert(NULL != interface_p);

    if_entry_p = RULE_CTRL_Priv_GetIfEntry(interface_p);
    assert(NULL != if_entry_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                              &if_class_obj);

    param.arg[0].interface_p = interface_p;

    RULE_CTRL_IN_Priv_Walk((RULE_TYPE_INSTANCE_PTR_T)if_class_obj.inst,
                           RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_Instance,
                           &param);

    RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If_L4_OM_Consistency(interface_p, &if_class_obj);
}

UI32_T
RULE_CTRL_UT_Proc_Get_Total_Number_Of_Acl_Qos_Rule(
    RULE_CTRL_UT_RULE_STAT *rs)
{
    RULE_TYPE_RULE_INSTANCE_T *rule_in;
    UI32_T i;

    UI32_T total_number = 0;

    assert(NULL != rs);

    for (i = 0; i <_countof(shmem_data_p->_rule_inst_pool_buf); ++i)
    {
        rule_in = &shmem_data_p->_rule_inst_pool_buf[i];

        if (RULE_TYPE_NIL == rule_in->super.type)
        {
            continue;
        }

        total_number += 1;
        rs->total_number += 1;

        if (TRUE == rule_in->active)
        {
            rs->active_number += 1;
        }
        else
        {
            rs->unactive_number += 1;
        }
    }

    return total_number;
}

UI32_T
RULE_CTRL_UT_Proc_Get_Total_Number_Of_Dflt_Rule(
    RULE_CTRL_UT_RULE_STAT *rs)
{
    UI32_T total_number = 0;

    assert(NULL != rs);

    total_number += RULE_CTRL_UT_Proc_Get_Total_Number_Of_Acl_Qos_Rule(rs);

    return total_number;
}

UI32_T
RULE_CTRL_UT_Proc_Count_Of_Ace(
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T mf_ace_inst_iter)
{
    int *ace_table = calloc(RULE_TYPE_MAX_NBRS_OF_ACE_OF_SYSTEM, sizeof(*ace_table));
    UI32_T count = 0;

    assert(NULL != ace_table);

    for (mf_ace_inst_iter.first(&mf_ace_inst_iter);
         NULL != mf_ace_inst_iter.get_instance(&mf_ace_inst_iter);
         mf_ace_inst_iter.next(&mf_ace_inst_iter))
    {
        RULE_TYPE_RULE_INSTANCE_T   *ace_inst_p;

        ace_inst_p = (RULE_TYPE_RULE_INSTANCE_T *) mf_ace_inst_iter.get_instance(&mf_ace_inst_iter);

        assert(ace_inst_p->ace_id < RULE_TYPE_MAX_NBRS_OF_ACE_OF_SYSTEM);

        if (0 == ace_table[ace_inst_p->ace_id - 1])
        {
            ++ count;
        }

        ++ ace_table[ace_inst_p->ace_id - 1];
    }

    free(ace_table);
    ace_table = NULL;

    return count;
}

RULE_TYPE_RULE_INSTANCE_PTR_T
RULE_CTRL_UT_Proc_Get_Rule_Instance(
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T mf_ace_inst_iter,
    UI32_T ace_index,
    UI32_T unit,
    UI32_T device_id)
{
    for (mf_ace_inst_iter.first(&mf_ace_inst_iter);
         NULL != mf_ace_inst_iter.get_instance(&mf_ace_inst_iter);
         mf_ace_inst_iter.next(&mf_ace_inst_iter))
    {
        RULE_TYPE_RULE_INSTANCE_T  *ace_inst_p;

        ace_inst_p = (RULE_TYPE_RULE_INSTANCE_T *) mf_ace_inst_iter.get_instance(&mf_ace_inst_iter);

        if (ace_inst_p->ace_id == ace_index &&
            ace_inst_p->dev_rule_info.unit == unit &&
            ace_inst_p->dev_rule_info.device == device_id)
        {
            return ace_inst_p;
        }
    }

    return NULL;
}

void
RULE_CTRL_UT_Proc_Validate_QoS_Class_Instance_ACL(
    UI32_T ifindex,
    const RULE_TYPE_PolicyElement_T *policy_element_p,
    RULE_TYPE_ClassType_T class_type,
    UI32_T acl_index,
    const RULE_TYPE_CLASS_INSTANCE_T *acl_inst)
{
    enum
    {
        MAX_UNIT = 1,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T i;

    UI32_T unit;

    UI32_T ace_count;
    UI32_T ace_index;

    RULE_TYPE_AclType_T ace_type;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T           acl_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T ace_inst_iter;

    RULE_TYPE_Acl_T         acl_entry;
    RULE_TYPE_Ace_Entry_T   ace_entry;

    BOOL_T b_result;

    assert(NULL != policy_element_p);
    assert(NULL != acl_inst);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(acl_inst, &acl_inst_obj);
    acl_inst_obj.get_element_iterator(&acl_inst_obj, &ace_inst_iter);

    assert(RULE_TYPE_CLASS_ACL == class_type);
    assert(RULE_TYPE_INST_ACL == acl_inst->super.type);
    assert(acl_index == acl_inst->id);

    result = RULE_OM_GetAclByIndex(acl_index, &acl_entry);
    assert(RULE_TYPE_OK == result);

#if (SYS_CPNT_DIFFSERV_USE_DENY_ACE_IN_ACL == TRUE)
    ace_count = acl_entry.ace_count;
#else
    ace_count = 0;

    for (ace_index = 0, i = 0;
         RULE_TYPE_OK == RULE_OM_GetNextAceByAcl(acl_index, &ace_type, &ace_index, &ace_entry);
         ++i)
    {
        if (RULE_TYPE_ACE_PERMIT == ace_entry.access)
        {
            ace_count ++;
        }
    }

    assert(acl_entry.ace_count == i);
#endif // SYS_CPNT_DIFFSERV_USE_DENY_ACE_IN_ACL

    assert(ace_count == RULE_CTRL_UT_Proc_Count_Of_Ace(ace_inst_iter));

    for (unit = 1; unit <= MAX_UNIT; ++ unit)
    {
        UI32_T num_of_device = DEVRM_PMGR_GetNumberOfChips();
        UI32_T device_id;

        for (device_id = 0; device_id < num_of_device; ++ device_id)
        {
            RULE_TYPE_RULE_INSTANCE_T *prev_ace_inst_ptr;

            prev_ace_inst_ptr = NULL;

            for (ace_index = 0, i = 0;
                 RULE_TYPE_OK == RULE_OM_GetNextAceByAcl(acl_index, &ace_type, &ace_index, &ace_entry);
                 ++i)
            {
                RULE_TYPE_RULE_INSTANCE_T   *ace_inst_p;

                DEVRM_PCE_T                 *pce;

#if (SYS_CPNT_DIFFSERV_USE_DENY_ACE_IN_ACL == TRUE)
                // Nothing to do
#else
                if (RULE_TYPE_ACE_PERMIT != ace_entry.access)
                {
                    continue;
                }
#endif // SYS_CPNT_DIFFSERV_USE_DENY_ACE_IN_ACL

                ace_inst_p = RULE_CTRL_UT_Proc_Get_Rule_Instance(ace_inst_iter,
                                                                 ace_index,
                                                                 unit,
                                                                 device_id);

                //
                // The uport rule not exist on all unit and device
                // Skip it if rule instance was not found
                // But it must have least one in device. How to check it ?
                //
                if (NULL == ace_inst_p && RULE_TYPE_IS_UPORT(ifindex))
                {
                    continue;
                }

                assert(NULL != ace_inst_p);
                assert(unit == ace_inst_p->dev_rule_info.unit);
                assert(device_id == ace_inst_p->dev_rule_info.device);

                //
                // Check the rule order in ACL and rule group is consistent
                //

                assert(ace_index == ace_inst_p->ace_id);

                //
                // Check wether PCE is exist or not
                //
                b_result = DEVRM_GetPce(ace_inst_p->dev_rule_info.device,
                                        ace_inst_p->dev_rule_info.rule_id,
                                        &pce);

                assert(TRUE == b_result);

                assert(policy_element_p->meter_index == ace_inst_p->meter_id);

                //
                // Check all ACE in ACL must be sort by priority
                //
                if (NULL != prev_ace_inst_ptr)
                {
                    DEVRM_PCE_T *prev_pce;

                    b_result = DEVRM_GetPce(prev_ace_inst_ptr->dev_rule_info.device,
                                            prev_ace_inst_ptr->dev_rule_info.rule_id,
                                            &prev_pce);
                    assert(TRUE == b_result);

                    assert(prev_pce->hw_idx < pce->hw_idx);
                }

                prev_ace_inst_ptr = ace_inst_p;
            }
        }
    }
}

void
RULE_CTRL_UT_Proc_Validate_QoS_Class_Instance_MF(
    UI32_T ifindex,
    const RULE_TYPE_PolicyElement_T *policy_element_p,
    RULE_TYPE_ClassType_T class_type,
    UI32_T ace_index,
    const RULE_TYPE_CLASS_INSTANCE_T *mf_ace_inst)
{
    RULE_TYPE_Ace_Entry_T   ace_entry;

    RULE_TYPE_RETURN_TYPE_T result;
    BOOL_T                  b_result;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T           mf_ace_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T mf_ace_inst_iter;

    assert(NULL != policy_element_p);
    assert(NULL != mf_ace_inst);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(mf_ace_inst, &mf_ace_inst_obj);
    mf_ace_inst_obj.get_element_iterator(&mf_ace_inst_obj, &mf_ace_inst_iter);

    assert(RULE_TYPE_CLASS_MF == class_type);
    assert(RULE_TYPE_INST_MF_ACE == mf_ace_inst->super.type);
    assert(ace_index == mf_ace_inst->id);

    result = RULE_OM_GetAceByIndex(ace_index, &ace_entry);
    assert(RULE_TYPE_OK == result);

    assert(1 == RULE_CTRL_UT_Proc_Count_Of_Ace(mf_ace_inst_iter));

    for (mf_ace_inst_iter.first(&mf_ace_inst_iter);
         NULL != mf_ace_inst_iter.get_instance(&mf_ace_inst_iter);
         mf_ace_inst_iter.next(&mf_ace_inst_iter))
    {
        RULE_TYPE_RULE_INSTANCE_T   *ace_inst_p;
        DEVRM_PCE_T                 *pce;

        ace_inst_p = (RULE_TYPE_RULE_INSTANCE_T *) mf_ace_inst_iter.get_instance(&mf_ace_inst_iter);

        //
        // Check wether ACE index is consistent
        //
        assert(ace_index == ace_inst_p->ace_id);

        //
        // Check wether PCE is exist or not
        //
        b_result = DEVRM_GetPce(ace_inst_p->dev_rule_info.device,
                                ace_inst_p->dev_rule_info.rule_id,
                                &pce);
        assert(TRUE == b_result);

        assert(policy_element_p->meter_index == ace_inst_p->meter_id);
    }

}

void RULE_CTRL_UT_Proc_Validate_ACL_Action(
    RULE_TYPE_RULE_INSTANCE_T *rule_inst_p)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_AceAction_T access;
    RULE_TYPE_Ace_Entry_T ace_entry;

    DEVRM_PCE_T *pce;

    CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT mask;
    CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern;
    CPSS_DXCH_PCL_ACTION_STC action;

    BOOL_T b_result;

    assert(NULL != rule_inst_p);

    result = RULE_OM_GetAceByIndex(rule_inst_p->ace_id, &ace_entry);
    assert(RULE_TYPE_OK == result);

    access = ace_entry.access;

    b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                            rule_inst_p->dev_rule_info.rule_id,
                            &pce);
    assert(TRUE == b_result);
    assert(NULL != pce);

    result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                            pce,
                                            &ruleFormat, &mask, &pattern, &action);
    assert(RULE_TYPE_OK == result);

    switch (access)
    {
        case RULE_TYPE_ACE_PERMIT:
            assert(CPSS_PACKET_CMD_FORWARD_E == action.pktCmd);
            break;

        case RULE_TYPE_ACE_DENY:
            assert(CPSS_PACKET_CMD_DROP_HARD_E == action.pktCmd);
            break;

        default:
            assert(FALSE);
    }
}

void
RULE_CTRL_UT_Proc_Validate_ACLs()
{
    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T ifindex;

    //
    // Scan ACL by uport/direction/acl_type
    //

    ifindex = 0;
    while (RULE_TYPE_OK == RULE_CTRL_UT_Proc_Get_Next_Ifindex(&ifindex))
    {
        RULE_TYPE_INTERFACE_INFO_T interface;
//        RULE_TYPE_InOutDirection_T direction;

        result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
        assert(RULE_TYPE_OK == result);

        for (interface.direction = RULE_TYPE_INBOUND; interface.direction <= RULE_TYPE_OUTBOUND; ++ interface.direction)
        {

            RULE_TYPE_AclType_T acl_type_ary[] = {
                RULE_TYPE_MAC_ACL,
                RULE_TYPE_IP_ACL,
                RULE_TYPE_IPV6_ACL
            };

            RULE_TYPE_AclType_T acl_type_idx;

            for (acl_type_idx = 0; acl_type_idx < _countof(acl_type_ary); ++acl_type_idx)
            {
                UI32_T                      acl_type = acl_type_ary[acl_type_idx];
                UI32_T                      acl_index;
//                UI32_T                      result;

                RULE_TYPE_COUNTER_ENABLE_T  counter_enable;

                UI8_T                       time_range_name[SYS_ADPT_TIME_RANGE_MAX_NAME_LENGTH+1];

                BOOL_T                      b_result;

                //
                // FIXME: NOT support craft port now
                //
                if (RULE_TYPE_IS_CRAFT_PORT(ifindex))
                {
                    continue;
                }

                result = RULE_OM_GetPortAclIndex(ifindex, acl_type,
                                                 interface.direction==RULE_TYPE_INBOUND?TRUE:FALSE,
                                                 &acl_index,
                                                 time_range_name,
                                                 &counter_enable);
                if (RULE_TYPE_OK == result)
                {
                    UI32_T                      ace_index;
                    UI32_T                      i;

                    RULE_TYPE_AclType_T         ace_type;

                    RULE_TYPE_Acl_T             acl_entry;
                    RULE_TYPE_Ace_Entry_T       ace_entry;

                    RULE_TYPE_CLASS_INSTANCE_T  *acl_inst_p;
                    RULE_TYPE_RULE_INSTANCE_T   *rule_inst_ptr;

                    RULE_TYPE_CLASS_INSTANCE_OBJECT_T acl_inst_obj;
                    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T ace_inst_iter;

                    result = RULE_OM_GetAclByIndex(acl_index, &acl_entry);
                    assert(RULE_TYPE_OK == result);

#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
                    if (TRUE == acl_entry.flag_aggregate_done &&
                        0 != acl_entry.aggregate_acl_index)
                    {
                        acl_index = acl_entry.aggregate_acl_index;

                        result = RULE_OM_GetAclByIndex(acl_index, &acl_entry);
                        assert(RULE_TYPE_OK == result);
                    }
#endif // SYS_CPNT_ACL_AUTO_COMPRESS_ACE

                    acl_inst_p = RULE_CTRL_Priv_GetAclInstanceById(&interface, acl_index);

                    assert(NULL != acl_inst_p);

                    assert(acl_inst_p->super.type == RULE_TYPE_INST_ACL);
                    assert(acl_inst_p->id == acl_index);

                    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(acl_inst_p,
                                                                   &acl_inst_obj);
                    acl_inst_obj.get_element_iterator(&acl_inst_obj, &ace_inst_iter);

                    assert(ace_inst_iter.count(&ace_inst_iter) == acl_entry.ace_count);

                    for (ace_index = 0, i = 0;
                         RULE_TYPE_OK == RULE_OM_GetNextAceByAcl(acl_index, &ace_type, &ace_index, &ace_entry);
                         ++i, ace_inst_iter.next(&ace_inst_iter))
                    {
                        UI32_T                  remapped_pkt_type;
                        RULE_TYPE_DEFAULT_ACE_T type;

                        DEVRM_PCE_T *pce;

                        UI32_T vir_group_id;

                        rule_inst_ptr = (RULE_TYPE_RULE_INSTANCE_T *) ace_inst_iter.get_instance(&ace_inst_iter);

                        assert(NULL != rule_inst_ptr);
                        assert(RULE_TYPE_INST_RULE == rule_inst_ptr->super.type);

                        //
                        // Check the rule order in ACL and rule group is consistent
                        //

                        assert(ace_index == rule_inst_ptr->ace_id);

                        //
                        // Ignore if rule is not active
                        //
                        if (rule_inst_ptr->active == FALSE)
                        {
                            continue;
                        }

                        //
                        // Check the virtual group is correct
                        //

                        if (i == acl_entry.ace_count-1 &&
                            TRUE == RULE_OM_IsMatchAnyAnyAce(ace_index))
                        {
                            if (RULE_TYPE_INBOUND == interface.direction)
                            {
                                type = RULE_TYPE_DFLT_ACE_ACL_MATCH_ANY_ANY;
                                remapped_pkt_type = RULE_TYPE_PACKET_ACL_MATCH_ANY_ANY;
                            }
                            else
                            {
                                type = RULE_TYPE_DFLT_ACE_EGRESS_ACL_MATCH_ANY_ANY;
                                remapped_pkt_type = RULE_TYPE_PACKET_EGRESS_ACL_MATCH_ANY_ANY;
                            }
                        }
                        else
                        {
                            if (RULE_TYPE_INBOUND == interface.direction)
                            {
                                type = RULE_TYPE_DFLT_ACE_ACL;
                                remapped_pkt_type = RULE_TYPE_PACKET_ACL;
                            }
                            else
                            {
                                type = RULE_TYPE_DFLT_ACE_EGRESS_ACL;
                                remapped_pkt_type = RULE_TYPE_PACKET_EGRESS_ACL;
                            }
                        }

                        vir_group_id = RULE_CTRL_UT_Proc_Convert_Dflt_Rule_Type_To_Vgid(remapped_pkt_type, type);

                        b_result = DEVRM_GetPce(rule_inst_ptr->dev_rule_info.device,
                                                rule_inst_ptr->dev_rule_info.rule_id,
                                                &pce);
                        assert(TRUE == b_result);

                        assert(vir_group_id == (UI32_T)pce->vir_group_id);

                        //
                        // Check all ACE in ACL must be sort by priority
                        //
                        if (TRUE == ace_inst_iter.has_prev(&ace_inst_iter))
                        {
                            RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T rule_iter_tmp = ace_inst_iter;

                            RULE_TYPE_RULE_INSTANCE_T *prev_rule_inst_ptr;
                            DEVRM_PCE_T *prev_pce;

                            prev_rule_inst_ptr = (RULE_TYPE_RULE_INSTANCE_T *) rule_iter_tmp.prev(&rule_iter_tmp);
                            assert(NULL != prev_rule_inst_ptr);

                            if (TRUE == prev_rule_inst_ptr->active)
                            {
                                b_result = DEVRM_GetPce(prev_rule_inst_ptr->dev_rule_info.device,
                                                        prev_rule_inst_ptr->dev_rule_info.rule_id,
                                                        &prev_pce);
                                assert(TRUE == b_result);

                                assert(prev_pce->hw_idx < pce->hw_idx);
                            }

                        }

                        RULE_CTRL_UT_Proc_Validate_ACL_Action(rule_inst_ptr);
                    }

                    assert(acl_entry.ace_count == i);

                } // ui32_result == OK

            } // acl_type_idx

        } // direction

    } // ifindex
}

typedef struct
{
    RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;
    RULE_TYPE_RULE_INSTANCE_PTR_T prev_rule_inst_p[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK][SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
} RULE_CTRL_UT_VALIDATE_PRIORITY_ACL_T, *RULE_CTRL_UT_VALIDATE_PRIORITY_ACL_PTR_T;

UI32_T
RULE_CTRL_UT_Proc_Get_Priority_Of_ACE_In_ACL(
    UI32_T acl_index,
    UI32_T ace_index)
{
    RULE_TYPE_Acl_T *acl_entry_p;

    UI32_T _ace_index;
    RULE_TYPE_Ace_Entry_T *ace_entry_p;

    UI32_T priority;

    acl_entry_p = RULE_OM_LocalGetAclByIndex(acl_index);
    assert(NULL != acl_entry_p);

    for (priority = 0, _ace_index = 0;
         RULE_TYPE_OK == RULE_OM_LocalGetNextAceByAcl(acl_entry_p, &_ace_index, &ace_entry_p);
         ++ priority)
    {
        if (ace_index == _ace_index)
        {
            return priority;
        }
    }

    assert(0);
    return 0xffffffff;
}

void
RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_ACLs_If_Instance_Each_Rule(
    RULE_TYPE_INSTANCE_PTR_T in,
    void *cookie)
{
    if (TRUE == RULE_CTRL_IS_RULE_INSTANCE_TYPE(in->type))
    {
        RULE_CTRL_UT_VALIDATE_PRIORITY_ACL_PTR_T param_p;
        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;

        param_p = (RULE_CTRL_UT_VALIDATE_PRIORITY_ACL_PTR_T)cookie;

        rule_inst_p = (RULE_TYPE_RULE_INSTANCE_PTR_T)in;

        //
        // Skip non-active rule
        //
        if (TRUE != rule_inst_p->active)
        {
            return;
        }

        if (NULL != param_p->prev_rule_inst_p[rule_inst_p->dev_rule_info.unit - 1][rule_inst_p->dev_rule_info.device])
        {
            RULE_TYPE_CLASS_INSTANCE_PTR_T prev_ace_inst_p;
            RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p;

            RULE_TYPE_CLASS_INSTANCE_PTR_T prev_acl_inst_p;
            RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;

            RULE_TYPE_RULE_INSTANCE_PTR_T prev_rule_inst_p;

            UI32_T prev_ace_priority;
            UI32_T ace_priority;

            DEVRM_PCE_T *prev_pce;
            DEVRM_PCE_T *pce;

            BOOL_T b_result;

            prev_rule_inst_p = param_p->prev_rule_inst_p[rule_inst_p->dev_rule_info.unit-1][rule_inst_p->dev_rule_info.device];

            prev_ace_inst_p = RULE_CTRL_IN_Ptr2Instance(prev_rule_inst_p->super.links.parent);
            assert(NULL != prev_ace_inst_p);

            ace_inst_p = RULE_CTRL_IN_Ptr2Instance(rule_inst_p->super.links.parent);
            assert(NULL != ace_inst_p);

            prev_acl_inst_p = RULE_CTRL_IN_Ptr2Instance(prev_ace_inst_p->super.links.parent);
            assert(NULL != prev_acl_inst_p);

            acl_inst_p = RULE_CTRL_IN_Ptr2Instance(ace_inst_p->super.links.parent);
            assert(NULL != acl_inst_p);

            assert(acl_inst_p == prev_acl_inst_p);
            assert(prev_acl_inst_p == param_p->acl_inst_p);

            prev_ace_priority = RULE_CTRL_UT_Proc_Get_Priority_Of_ACE_In_ACL(prev_acl_inst_p->id,
                                                                             prev_ace_inst_p->id);
            ace_priority = RULE_CTRL_UT_Proc_Get_Priority_Of_ACE_In_ACL(acl_inst_p->id,
                                                                        ace_inst_p->id);
            assert(prev_ace_priority != ace_priority);

            b_result = DEVRM_GetPce(prev_rule_inst_p->dev_rule_info.device,
                                    prev_rule_inst_p->dev_rule_info.rule_id,
                                    &prev_pce);
            assert(TRUE == b_result);

            b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                    rule_inst_p->dev_rule_info.rule_id,
                                    &pce);
            assert(TRUE == b_result);

            if (prev_ace_priority < ace_priority)
            {
                assert(prev_pce->hw_idx < pce->hw_idx);
            }
            else
            {
                assert(pce->hw_idx < prev_pce->hw_idx);
            }

//            printf("unit[%hu].device[%hu].rule[%lu] vs unit[%hu].device[%hu].rule[%lu]\r\n",
//                   prev_rule_inst_p->dev_rule_info.unit,
//                   prev_rule_inst_p->dev_rule_info.device,
//                   prev_rule_inst_p->dev_rule_info.rule_id,
//                   rule_inst_p->dev_rule_info.unit,
//                   rule_inst_p->dev_rule_info.device,
//                   rule_inst_p->dev_rule_info.rule_id);
        }

        param_p->prev_rule_inst_p[rule_inst_p->dev_rule_info.unit - 1][rule_inst_p->dev_rule_info.device] = rule_inst_p;
    }
}

void
RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_ACLs_If_Instance(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p)
{
    RULE_CTRL_UT_VALIDATE_PRIORITY_ACL_T param;

    assert(NULL != interface_p);
    assert(NULL != acl_inst_p);

    memset(&param, 0, sizeof(param));

    param.acl_inst_p = acl_inst_p;

    RULE_CTRL_IN_Priv_Walk((RULE_TYPE_INSTANCE_PTR_T)acl_inst_p,
                           RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_ACLs_If_Instance_Each_Rule,
                           &param);
}

typedef struct
{
    RULE_TYPE_RULE_INSTANCE_PTR_T prev_rule_inst_p[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK][SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
} RULE_CTRL_UT_VALIDATE_PRIORITY_CLASS_MAP_T, *RULE_CTRL_UT_VALIDATE_PRIORITY_CLASS_MAP_PTR_T;

UI32_T
RULE_CTRL_UT_Proc_Get_Priority_Of_Element_In_Class_Map(
    UI32_T class_map_index,
    RULE_TYPE_ClassType_T class_type,
    UI32_T mf_ace_index)
{
    RULE_TYPE_ClassMap_T *class_map_p;
    UI32_T cx;
    UI32_T priority;

    class_map_p = RULE_OM_LocalGetClassMapByIndex(class_map_index);
    assert(NULL != class_map_p);

    for (priority = 0, cx = 0; cx < class_map_p->class_element_count; ++ cx, ++ priority)
    {
        if (class_type == class_map_p->class_type[cx] &&
            mf_ace_index == class_map_p->class_index_list[cx])
        {
            return priority;
        }
    }

    assert(0);
    return 0xffffffff;
}

void
RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_Policy_Maps_If_Instance_Class_Map_Each_Rule(
    RULE_TYPE_INSTANCE_PTR_T in,
    void *cookie)
{
    if (TRUE == RULE_CTRL_IS_RULE_INSTANCE_TYPE(in->type))
    {
        RULE_CTRL_UT_VALIDATE_PRIORITY_CLASS_MAP_PTR_T param_p;
        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;

        param_p = (RULE_CTRL_UT_VALIDATE_PRIORITY_CLASS_MAP_PTR_T)cookie;

        rule_inst_p = (RULE_TYPE_RULE_INSTANCE_PTR_T)in;

        assert(TRUE == rule_inst_p->active);

        if (NULL != param_p->prev_rule_inst_p[rule_inst_p->dev_rule_info.unit - 1][rule_inst_p->dev_rule_info.device])
        {
            RULE_TYPE_CLASS_INSTANCE_PTR_T prev_ace_inst_p;
            RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p;

            RULE_TYPE_RULE_INSTANCE_PTR_T prev_rule_inst_p;

            UI32_T prev_ace_priority = 0;
            UI32_T ace_priority = 0;

            DEVRM_PCE_T *prev_pce;
            DEVRM_PCE_T *pce;

            BOOL_T b_result;

            prev_rule_inst_p = param_p->prev_rule_inst_p[rule_inst_p->dev_rule_info.unit-1][rule_inst_p->dev_rule_info.device];

            prev_ace_inst_p = RULE_CTRL_IN_Ptr2Instance(prev_rule_inst_p->super.links.parent);
            assert(NULL != prev_ace_inst_p);

            ace_inst_p = RULE_CTRL_IN_Ptr2Instance(rule_inst_p->super.links.parent);
            assert(NULL != ace_inst_p);

            //
            // MF vs MF
            //
            if (RULE_TYPE_INST_MF_ACE == prev_ace_inst_p->super.type &&
                RULE_TYPE_INST_MF_ACE == ace_inst_p->super.type)
            {
                RULE_TYPE_CLASS_INSTANCE_PTR_T prev_class_map_inst_p;
                RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p;

                prev_class_map_inst_p = RULE_CTRL_IN_Ptr2Instance(prev_ace_inst_p->super.links.parent);
                assert(NULL != prev_class_map_inst_p);

                class_map_inst_p = RULE_CTRL_IN_Ptr2Instance(ace_inst_p->super.links.parent);
                assert(NULL != class_map_inst_p);

                assert(prev_class_map_inst_p == class_map_inst_p);

                prev_ace_priority = RULE_CTRL_UT_Proc_Get_Priority_Of_Element_In_Class_Map(prev_class_map_inst_p->id,
                                                                                           RULE_TYPE_CLASS_MF,
                                                                                           prev_ace_inst_p->id);
                ace_priority = RULE_CTRL_UT_Proc_Get_Priority_Of_Element_In_Class_Map(class_map_inst_p->id,
                                                                                      RULE_TYPE_CLASS_MF,
                                                                                      ace_inst_p->id);
            }

            if (RULE_TYPE_INST_MF_ACE == prev_ace_inst_p->super.type &&
                RULE_TYPE_INST_ACE == ace_inst_p->super.type)
            {
                RULE_TYPE_CLASS_INSTANCE_PTR_T prev_class_map_inst_p;
                RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p;
                RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;

                prev_class_map_inst_p = RULE_CTRL_IN_Ptr2Instance(prev_ace_inst_p->super.links.parent);
                assert(NULL != prev_class_map_inst_p);

                acl_inst_p = RULE_CTRL_IN_Ptr2Instance(ace_inst_p->super.links.parent);
                assert(NULL != acl_inst_p);

                class_map_inst_p = RULE_CTRL_IN_Ptr2Instance(acl_inst_p->super.links.parent);
                assert(NULL != class_map_inst_p);

                assert(prev_class_map_inst_p == class_map_inst_p);

                prev_ace_priority = RULE_CTRL_UT_Proc_Get_Priority_Of_Element_In_Class_Map(prev_class_map_inst_p->id,
                                                                                           RULE_TYPE_CLASS_MF,
                                                                                           prev_ace_inst_p->id);
                ace_priority = RULE_CTRL_UT_Proc_Get_Priority_Of_Element_In_Class_Map(class_map_inst_p->id,
                                                                                      RULE_TYPE_CLASS_ACL,
                                                                                      acl_inst_p->id);
            }

            if (RULE_TYPE_INST_ACE == prev_ace_inst_p->super.type &&
                RULE_TYPE_INST_MF_ACE == ace_inst_p->super.type)
            {
                RULE_TYPE_CLASS_INSTANCE_PTR_T prev_class_map_inst_p;
                RULE_TYPE_CLASS_INSTANCE_PTR_T prev_acl_inst_p;
                RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p;

                prev_acl_inst_p = RULE_CTRL_IN_Ptr2Instance(prev_ace_inst_p->super.links.parent);
                assert(NULL != prev_acl_inst_p);

                prev_class_map_inst_p = RULE_CTRL_IN_Ptr2Instance(prev_acl_inst_p->super.links.parent);
                assert(NULL != prev_class_map_inst_p);

                class_map_inst_p = RULE_CTRL_IN_Ptr2Instance(ace_inst_p->super.links.parent);
                assert(NULL != class_map_inst_p);

                assert(prev_class_map_inst_p == class_map_inst_p);

                prev_ace_priority = RULE_CTRL_UT_Proc_Get_Priority_Of_Element_In_Class_Map(prev_class_map_inst_p->id,
                                                                                           RULE_TYPE_CLASS_ACL,
                                                                                           prev_acl_inst_p->id);
                ace_priority = RULE_CTRL_UT_Proc_Get_Priority_Of_Element_In_Class_Map(class_map_inst_p->id,
                                                                                      RULE_TYPE_CLASS_MF,
                                                                                      ace_inst_p->id);
            }

            //
            // ACE vs ACE
            //
            if (RULE_TYPE_INST_ACE == prev_ace_inst_p->super.type &&
                RULE_TYPE_INST_ACE == ace_inst_p->super.type)
            {
                RULE_TYPE_CLASS_INSTANCE_PTR_T prev_acl_inst_p;
                RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;

                prev_acl_inst_p = RULE_CTRL_IN_Ptr2Instance(prev_ace_inst_p->super.links.parent);
                assert(NULL != prev_acl_inst_p);

                acl_inst_p = RULE_CTRL_IN_Ptr2Instance(ace_inst_p->super.links.parent);
                assert(NULL != acl_inst_p);

                if (prev_acl_inst_p == acl_inst_p)
                {
                    prev_ace_priority = RULE_CTRL_UT_Proc_Get_Priority_Of_ACE_In_ACL(prev_acl_inst_p->id,
                                                                                     prev_ace_inst_p->id);
                    ace_priority = RULE_CTRL_UT_Proc_Get_Priority_Of_ACE_In_ACL(acl_inst_p->id,
                                                                                ace_inst_p->id);
                }
                else
                {
                    RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p;

                    //
                    // If the two ACE are come from different ACL, then check
                    // the ACL priority in the class-map as well
                    //

                    class_map_inst_p = RULE_CTRL_IN_Ptr2Instance(prev_acl_inst_p->super.links.parent);
                    assert(NULL != class_map_inst_p);

                    assert(RULE_CTRL_IN_Ptr2Instance(acl_inst_p->super.links.parent) == class_map_inst_p);

                    prev_ace_priority = RULE_CTRL_UT_Proc_Get_Priority_Of_Element_In_Class_Map(class_map_inst_p->id,
                                                                                               RULE_TYPE_CLASS_ACL,
                                                                                               prev_acl_inst_p->id);

                    ace_priority = RULE_CTRL_UT_Proc_Get_Priority_Of_Element_In_Class_Map(class_map_inst_p->id,
                                                                                          RULE_TYPE_CLASS_ACL,
                                                                                          acl_inst_p->id);
                }
            }

            assert(prev_ace_priority != ace_priority);

            b_result = DEVRM_GetPce(prev_rule_inst_p->dev_rule_info.device,
                                    prev_rule_inst_p->dev_rule_info.rule_id,
                                    &prev_pce);
            assert(TRUE == b_result);

            b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                    rule_inst_p->dev_rule_info.rule_id,
                                    &pce);
            assert(TRUE == b_result);

            if (TRUE == rule_ctrl_ut_option.debug)
            {
                printf("unit[%hu].device[%hu].rule[%lu] vs unit[%hu].device[%hu].rule[%lu]\r\n",
                       prev_rule_inst_p->dev_rule_info.unit,
                       prev_rule_inst_p->dev_rule_info.device,
                       prev_rule_inst_p->dev_rule_info.rule_id,
                       rule_inst_p->dev_rule_info.unit,
                       rule_inst_p->dev_rule_info.device,
                       rule_inst_p->dev_rule_info.rule_id);
            }

            if (prev_ace_priority < ace_priority)
            {
                assert(prev_pce->hw_idx < pce->hw_idx);
            }
            else
            {
                assert(pce->hw_idx < prev_pce->hw_idx);
            }
        }

        param_p->prev_rule_inst_p[rule_inst_p->dev_rule_info.unit - 1][rule_inst_p->dev_rule_info.device] = rule_inst_p;
    }
}

void
RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_Policy_Maps_If_Instance_Class_Map(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p)
{
    RULE_CTRL_UT_VALIDATE_PRIORITY_CLASS_MAP_T param;

    assert(NULL != interface_p);
    assert(NULL != class_map_inst_p);

    memset(&param, 0, sizeof(param));

    RULE_CTRL_IN_Priv_Walk((RULE_TYPE_INSTANCE_PTR_T)class_map_inst_p,
                           RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_Policy_Maps_If_Instance_Class_Map_Each_Rule,
                           &param);
}

typedef struct
{
    RULE_TYPE_CLASS_INSTANCE_PTR_T win_class_map_inst_p;
    RULE_TYPE_CLASS_INSTANCE_PTR_T lost_class_map_inst_p;
    RULE_TYPE_RULE_INSTANCE_PTR_T win_rule_inst_p;
} RULE_CTRL_UT_VALIDATE_PRIORITY_BETWEEN_TWO_CLASS_MAP_T, *RULE_CTRL_UT_VALIDATE_PRIORITY_BETWEEN_TWO_CLASS_MAP_PTR_T;

void
RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_Policy_Maps_If_Instance_Two_Class_Maps_Loop2(
    RULE_TYPE_INSTANCE_PTR_T in,
    void *cookie)
{
    if (TRUE == RULE_CTRL_IS_RULE_INSTANCE_TYPE(in->type))
    {
        RULE_CTRL_UT_VALIDATE_PRIORITY_BETWEEN_TWO_CLASS_MAP_PTR_T param_p;
        RULE_TYPE_RULE_INSTANCE_PTR_T lost_rule_inst_p;

        param_p = (RULE_CTRL_UT_VALIDATE_PRIORITY_BETWEEN_TWO_CLASS_MAP_PTR_T)cookie;
        lost_rule_inst_p = (RULE_TYPE_RULE_INSTANCE_PTR_T)in;

        if (param_p->win_rule_inst_p->dev_rule_info.unit == lost_rule_inst_p->dev_rule_info.unit &&
            param_p->win_rule_inst_p->dev_rule_info.device == lost_rule_inst_p->dev_rule_info.device)
        {
            DEVRM_PCE_T *win_pce;
            DEVRM_PCE_T *lost_pce;

            BOOL_T b_result;

            b_result = DEVRM_GetPce(param_p->win_rule_inst_p->dev_rule_info.device,
                                    param_p->win_rule_inst_p->dev_rule_info.rule_id,
                                    &win_pce);
            assert(TRUE == b_result);

            b_result = DEVRM_GetPce(lost_rule_inst_p->dev_rule_info.device,
                                    lost_rule_inst_p->dev_rule_info.rule_id,
                                    &lost_pce);
            assert(TRUE == b_result);

//            printf("class_map[%hu].unit[%hu].device[%hu].rule[%lu] vs class_map[%hu].unit[%hu].device[%hu].rule[%lu]\r\n",
//                   param_p->win_class_map_inst_p->id,
//                   param_p->win_rule_inst_p->dev_rule_info.unit,
//                   param_p->win_rule_inst_p->dev_rule_info.device,
//                   param_p->win_rule_inst_p->dev_rule_info.rule_id,
//                   param_p->lost_class_map_inst_p->id,
//                   lost_rule_inst_p->dev_rule_info.unit,
//                   lost_rule_inst_p->dev_rule_info.device,
//                   lost_rule_inst_p->dev_rule_info.rule_id);

            assert(win_pce->hw_idx < lost_pce->hw_idx);
        }
    }
}

void
RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_Policy_Maps_If_Instance_Two_Class_Maps_Loop1(
    RULE_TYPE_INSTANCE_PTR_T in,
    void *cookie)
{
    if (TRUE == RULE_CTRL_IS_RULE_INSTANCE_TYPE(in->type))
    {
        RULE_CTRL_UT_VALIDATE_PRIORITY_BETWEEN_TWO_CLASS_MAP_PTR_T param_p;

        param_p = (RULE_CTRL_UT_VALIDATE_PRIORITY_BETWEEN_TWO_CLASS_MAP_PTR_T)cookie;
        param_p->win_rule_inst_p = (RULE_TYPE_RULE_INSTANCE_PTR_T)in;

        RULE_CTRL_IN_Priv_Walk((RULE_TYPE_INSTANCE_PTR_T)param_p->lost_class_map_inst_p,
                               RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_Policy_Maps_If_Instance_Two_Class_Maps_Loop2,
                               param_p);
    }
}

void
RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_Policy_Maps_If_Instance_Two_Class_Maps(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T win_class_map_inst_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T lost_class_map_inst_p)
{
    RULE_CTRL_UT_VALIDATE_PRIORITY_BETWEEN_TWO_CLASS_MAP_T param;

    assert(NULL != interface_p);
    assert(NULL != win_class_map_inst_p);
    assert(NULL != lost_class_map_inst_p);

    memset(&param, 0, sizeof(param));

    param.win_class_map_inst_p = win_class_map_inst_p;
    param.lost_class_map_inst_p = lost_class_map_inst_p;

    RULE_CTRL_IN_Priv_Walk((RULE_TYPE_INSTANCE_PTR_T)win_class_map_inst_p,
                           RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_Policy_Maps_If_Instance_Two_Class_Maps_Loop1,
                           &param);
}

UI32_T
RULE_CTRL_UT_Proc_Get_Priority_Of_Class_Map_In_Policy_Map(
    UI32_T policy_map_index,
    UI32_T class_map_index)
{
    RULE_TYPE_PolicyMap_T *policy_map_p;
    UI32_T px;
    UI32_T priority;

    policy_map_p = RULE_OM_LocalGetPolicyMapByIndex(policy_map_index);
    assert(NULL != policy_map_p);

    for (priority = 0, px = 0; px < policy_map_p->element_count; ++ px, ++ priority)
    {
        UI32_T policy_element_index = policy_map_p->policy_map_element_index_list[px];
        RULE_TYPE_PolicyElement_T *policy_element_p = RULE_OM_LocalGetPolicyMapElementByIndex(policy_element_index);

        if (policy_element_p->class_map_index == class_map_index)
        {
            return priority;
        }
    }

    assert(0);
    return 0xffffffff;
}

void
RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_Policy_Maps_If_Instance(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T policy_map_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T class_map_inst_iter;

    RULE_TYPE_PolicyMap_T policy_map;

    assert(NULL != interface_p);
    assert(NULL != policy_map_inst_p);

    result = RULE_OM_GetPolicyMapByIndex(policy_map_inst_p->id, &policy_map);
    assert(RULE_TYPE_OK == result);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(policy_map_inst_p, &policy_map_inst_obj);
    policy_map_inst_obj.get_element_iterator(&policy_map_inst_obj, &class_map_inst_iter);

    {
        RULE_TYPE_CLASS_INSTANCE_PTR_T prev_class_map_inst_p = NULL;

        for (class_map_inst_iter.first(&class_map_inst_iter);
             NULL != class_map_inst_iter.get_instance(&class_map_inst_iter);
             class_map_inst_iter.next(&class_map_inst_iter))
        {
            RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p;

            class_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)class_map_inst_iter.get_instance(&class_map_inst_iter);

            RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_Policy_Maps_If_Instance_Class_Map(interface_p,
                                                                                          class_map_inst_p);

            if (NULL != prev_class_map_inst_p)
            {
                UI32_T prev_class_map_inst_priority;
                UI32_T class_map_inst_priority;

                RULE_TYPE_CLASS_INSTANCE_PTR_T win_p;
                RULE_TYPE_CLASS_INSTANCE_PTR_T lost_p;

                prev_class_map_inst_priority = RULE_CTRL_UT_Proc_Get_Priority_Of_Class_Map_In_Policy_Map(policy_map_inst_p->id,
                                                                                                         prev_class_map_inst_p->id);
                class_map_inst_priority = RULE_CTRL_UT_Proc_Get_Priority_Of_Class_Map_In_Policy_Map(policy_map_inst_p->id,
                                                                                                    class_map_inst_p->id);
                assert(prev_class_map_inst_priority != class_map_inst_priority);

                if (prev_class_map_inst_priority < class_map_inst_priority)
                {
                    win_p = prev_class_map_inst_p;
                    lost_p = class_map_inst_p;
                }
                else
                {
                    win_p = class_map_inst_p;
                    lost_p = prev_class_map_inst_p;
                }

                RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_Policy_Maps_If_Instance_Two_Class_Maps(interface_p,
                                                                                                   win_p,
                                                                                                   lost_p);
            }

            prev_class_map_inst_p = class_map_inst_p;
        }
    }
}

void
RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_ACLs_If(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p)
{
    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

    RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;

    RULE_CTRL_INSTANCE_TYPE_ID_T param;

    if_entry_p = RULE_CTRL_Priv_GetIfEntry(interface_p);
    assert(NULL != if_entry_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                              &if_class_obj);

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_ACL;

    acl_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                RULE_CTRL_Priv_IsClassInstanceMatchType,
                                                                                &param);
    while (NULL != acl_inst_p)
    {
        RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_ACLs_If_Instance(interface_p, acl_inst_p);

        acl_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetNextSiblingIf((RULE_TYPE_INSTANCE_PTR_T)acl_inst_p,
                                                                                     RULE_CTRL_Priv_IsClassInstanceMatchType,
                                                                                     &param);
    }
}

void
RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_Policy_Maps_If(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p)
{
    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;

    RULE_CTRL_INSTANCE_TYPE_ID_T param;

    if_entry_p = RULE_CTRL_Priv_GetIfEntry(interface_p);
    assert(NULL != if_entry_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                              &if_class_obj);

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_POLICY_MAP;

    policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                       RULE_CTRL_Priv_IsClassInstanceMatchType,
                                                                                       &param);
    while (NULL != policy_map_inst_p)
    {
        RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_Policy_Maps_If_Instance(interface_p, policy_map_inst_p);

        policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetNextSiblingIf((RULE_TYPE_INSTANCE_PTR_T)policy_map_inst_p,
                                                                                           RULE_CTRL_Priv_IsClassInstanceMatchType,
                                                                                           &param);
    }
}

void
RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_Policy_Maps_And_ACLs()
{
    UI32_T i;

    for (i = 0; i < _countof(shmem_data_p->if_table); ++ i)
    {
        RULE_TYPE_INTERFACE_INFO_T interface;

        RULE_CTRL_Priv_IfEntry_Index_To_Interface(i, &interface);

        RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_ACLs_If(&interface);
        RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_Policy_Maps_If(&interface);
    }
}

UI32_T
RULE_CTRL_UT_Proc_Get_Total_Number_Of_Rule(
    RULE_CTRL_UT_RULE_STAT *rs)
{
    UI32_T dflt_rule_number;

    assert(NULL != rs);

    memset(rs, 0, sizeof(*rs));

    dflt_rule_number = RULE_CTRL_UT_Proc_Get_Total_Number_Of_Dflt_Rule(rs);

    assert(rs->total_number == rs->active_number + rs->unactive_number);

    return dflt_rule_number;
}

UI32_T
RULE_CTRL_UT_Proc_Get_Total_Number_Of_Rule_On_Devrm()
{
    DEVRM_PCE_T *pce = NULL;

    UI32_T  pce_number;

    UI32_T device_id;
    UI32_T num_of_device;

    pce_number = 0;

    num_of_device = DEVRM_GetNumberOfChips();

    for (device_id = 0; device_id < num_of_device; ++ device_id)
    {
        while (DEVRM_GetNextPce(device_id, &pce))
        {
            ++pce_number;
        }
    }

    return pce_number;
}

void
RULE_CTRL_UT_Proc_Validate_Number_Of_Rule()
{
    UI32_T rule_number;
    UI32_T pce_number;

    RULE_CTRL_UT_RULE_STAT rule_state;

    rule_number = RULE_CTRL_UT_Proc_Get_Total_Number_Of_Rule(&rule_state);
    pce_number = RULE_CTRL_UT_Proc_Get_Total_Number_Of_Rule_On_Devrm();

    assert(rule_state.active_number == pce_number);
    assert(rule_state.unactive_number + pce_number == rule_number);

    //
    // Check stack_free_nbr_pce and stack_PCE_bitmap
    //
    {
        UI32_T device_id;

        UI32_T rule_used_cnt = 0;

        for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT; ++ device_id)
        {
            UI32_T unit = 1;
            UI32_T i;
            UI32_T total_pce_number = RULE_CTRL_MAX_NBR_OF_PCE_PER_UNIT;
            UI32_T rule_size = 2;

            UI32_T rule_used_cnt_per_device = 0;

            for (i = 0; i < RULE_CTRL_MAX_NBR_OF_PCE_PER_UNIT; ++i)
            {
                if ( RULE_CTRL_IS_BIT_ON(shmem_data_p->stack_PCE_bitmap[unit-1][device_id], i) )
                {
                    rule_used_cnt_per_device ++;
                    rule_used_cnt ++;
                }
            }

            //
            // suppose rule_size == 2
            //
            assert(total_pce_number ==
                   (rule_used_cnt_per_device * rule_size + shmem_data_p->stack_free_nbr_pce[unit-1][device_id]) );
        }

        assert(rule_used_cnt == rule_state.total_number);
    }

}

void
RULE_CTRL_UT_Proc_Validate_Leaks_Instance_Make_ACE(
    RULE_TYPE_RULE_INSTANCE_T *ace_inst,
    RULE_TYPE_CLASS_INSTANCE_T *dup_class_inst_pool_buf,
    RULE_TYPE_RULE_INSTANCE_T *dup_rule_inst_pool_buf)
{
    UI32_T                                  rule_ary_index;
    RULE_TYPE_RULE_INSTANCE_T               *dup_rule_inst;

    RULE_TYPE_Ace_Entry_T                   ace_entry;
    UI32_T                                  ui32_result;

    assert(NULL != ace_inst);
    assert(NULL != dup_class_inst_pool_buf);
    assert(NULL != dup_rule_inst_pool_buf);

    assert(RULE_TYPE_INST_RULE == ace_inst->super.type);

    ui32_result = RULE_OM_GetAceByIndex(ace_inst->id, &ace_entry);
    assert(RULE_TYPE_OK == ui32_result);

    rule_ary_index = RULE_CTRL_IN_IndexOfRuleInstance(ace_inst);
    dup_rule_inst = &dup_rule_inst_pool_buf[ rule_ary_index ];

    assert(0 == memcmp(dup_rule_inst, ace_inst, sizeof(*dup_rule_inst)));
    memset(dup_rule_inst, 0, sizeof(*dup_rule_inst));
}

void
RULE_CTRL_UT_Proc_Validate_Leaks_Instance_Make_MF_ACE(
    RULE_TYPE_CLASS_INSTANCE_T *mf_ace_inst,
    RULE_TYPE_CLASS_INSTANCE_T *dup_class_inst_pool_buf,
    RULE_TYPE_RULE_INSTANCE_T *dup_rule_inst_pool_buf)
{
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T           mf_ace_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T ace_inst_iter;

    UI32_T                                      class_ary_index;
    RULE_TYPE_CLASS_INSTANCE_T                  *dup_class_inst;

    assert(NULL != mf_ace_inst);
    assert(NULL != dup_class_inst_pool_buf);
    assert(NULL != dup_rule_inst_pool_buf);

    assert(RULE_TYPE_INST_MF_ACE == mf_ace_inst->super.type);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(mf_ace_inst, &mf_ace_inst_obj);
    mf_ace_inst_obj.get_element_iterator(&mf_ace_inst_obj, &ace_inst_iter);

    for (ace_inst_iter.first(&ace_inst_iter);
         NULL != ace_inst_iter.get_instance(&ace_inst_iter);
         ace_inst_iter.next(&ace_inst_iter))
    {
        RULE_TYPE_RULE_INSTANCE_T   *ace_inst;

        ace_inst = (RULE_TYPE_RULE_INSTANCE_T *) ace_inst_iter.get_instance(&ace_inst_iter);

        assert(NULL != ace_inst);

        RULE_CTRL_UT_Proc_Validate_Leaks_Instance_Make_ACE(ace_inst,
                                                           dup_class_inst_pool_buf,
                                                           dup_rule_inst_pool_buf);
    }

    class_ary_index = RULE_CTRL_IN_IndexOfClassInstance(mf_ace_inst);
    dup_class_inst = &dup_class_inst_pool_buf[ class_ary_index ];

    assert(0 == memcmp(dup_class_inst, mf_ace_inst, sizeof(*dup_class_inst)));
    memset(dup_class_inst, 0, sizeof(*dup_class_inst));
}

void
RULE_CTRL_UT_Proc_Validate_Leaks_Instance_Make_QoS_ACL(
    UI32_T acl_index,
    RULE_TYPE_CLASS_INSTANCE_T *acl_inst,
    RULE_TYPE_CLASS_INSTANCE_T *dup_class_inst_pool_buf,
    RULE_TYPE_RULE_INSTANCE_T *dup_rule_inst_pool_buf)
{
    RULE_TYPE_Acl_T                             acl_entry;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T           acl_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T ace_inst_iter;

    UI32_T                                      class_ary_index;
    RULE_TYPE_CLASS_INSTANCE_T                  *dup_class_inst;

    UI32_T                                      ui32_result;

    assert(0 != acl_index);
    assert(NULL != acl_inst);
    assert(NULL != dup_class_inst_pool_buf);
    assert(NULL != dup_rule_inst_pool_buf);

    assert(RULE_TYPE_INST_ACL == acl_inst->super.type);
    assert(acl_inst->id == acl_index);

    ui32_result = RULE_OM_GetAclByIndex(acl_inst->id, &acl_entry);
    assert(RULE_TYPE_OK == ui32_result);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(acl_inst, &acl_inst_obj);
    acl_inst_obj.get_element_iterator(&acl_inst_obj, &ace_inst_iter);

    for (ace_inst_iter.first(&ace_inst_iter);
         NULL != ace_inst_iter.get_instance(&ace_inst_iter);
         ace_inst_iter.next(&ace_inst_iter))
    {
        RULE_TYPE_RULE_INSTANCE_T   *ace_inst;

        ace_inst = (RULE_TYPE_RULE_INSTANCE_T *) ace_inst_iter.get_instance(&ace_inst_iter);

        assert(NULL != ace_inst);

        RULE_CTRL_UT_Proc_Validate_Leaks_Instance_Make_ACE(ace_inst,
                                                           dup_class_inst_pool_buf,
                                                           dup_rule_inst_pool_buf);
    }

    class_ary_index = RULE_CTRL_IN_IndexOfClassInstance(acl_inst);
    dup_class_inst = &dup_class_inst_pool_buf[ class_ary_index ];

    assert(0 == memcmp(dup_class_inst, acl_inst, sizeof(*dup_class_inst)));
    memset(dup_class_inst, 0, sizeof(*dup_class_inst));
}

void
RULE_CTRL_UT_Proc_Validate_Leaks_Instance_CPU_Interface_Make_ACE(
    const RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p,
    RULE_TYPE_CLASS_INSTANCE_T *dup_class_inst_pool_buf,
    RULE_TYPE_RULE_INSTANCE_T *dup_rule_inst_pool_buf)
{
    UI32_T                                  rule_ary_index;
    RULE_TYPE_RULE_INSTANCE_T               *dup_rule_inst;

    assert(NULL != rule_inst_p);
    assert(NULL != dup_class_inst_pool_buf);
    assert(NULL != dup_rule_inst_pool_buf);

    assert(RULE_TYPE_INST_RULE == rule_inst_p->super.type);

    rule_ary_index = RULE_CTRL_IN_IndexOfRuleInstance(rule_inst_p);
    dup_rule_inst = &dup_rule_inst_pool_buf[ rule_ary_index ];

    assert(0 == memcmp(dup_rule_inst, rule_inst_p, sizeof(*dup_rule_inst)));
    memset(dup_rule_inst, 0, sizeof(*dup_rule_inst));
}

void
RULE_CTRL_UT_Proc_Validate_Leaks_Instance_CPU_Interface_Make_ACL(
    const RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    RULE_TYPE_CLASS_INSTANCE_T *dup_class_inst_pool_buf,
    RULE_TYPE_RULE_INSTANCE_T *dup_rule_inst_pool_buf)
{
    UI32_T class_ary_index;
    RULE_TYPE_CLASS_INSTANCE_T *dup_class_inst;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T class_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T inst_iter;

    assert(NULL != class_inst_p);
    assert(NULL != dup_class_inst_pool_buf);
    assert(NULL != dup_rule_inst_pool_buf);

    assert(RULE_CTRL_IS_CLASS_INSTANCE_TYPE(class_inst_p->super.type) ||
           RULE_CTRL_IS_RULE_INSTANCE_TYPE(class_inst_p->super.type));

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_inst_p,
                                                   &class_inst_obj);

    class_inst_obj.get_element_iterator(&class_inst_obj, &inst_iter);

    for (inst_iter.first(&inst_iter);
         NULL != inst_iter.get_instance(&inst_iter);
         inst_iter.next(&inst_iter))
    {
        RULE_TYPE_INSTANCE_PTR_T inst_p;

        inst_p = inst_iter.get_instance(&inst_iter);

        if (RULE_CTRL_IS_CLASS_INSTANCE_TYPE(inst_p->type))
        {
            RULE_CTRL_UT_Proc_Validate_Leaks_Instance_CPU_Interface_Make_ACL((RULE_TYPE_CLASS_INSTANCE_PTR_T)inst_p,
                                                                             dup_class_inst_pool_buf,
                                                                             dup_rule_inst_pool_buf);
        }
        else if (RULE_CTRL_IS_RULE_INSTANCE_TYPE(inst_p->type))
        {
            RULE_CTRL_UT_Proc_Validate_Leaks_Instance_CPU_Interface_Make_ACE(
                                                                             (RULE_TYPE_RULE_INSTANCE_PTR_T)inst_p,
                                                                             dup_class_inst_pool_buf,
                                                                             dup_rule_inst_pool_buf);
        }
        else
        {
            assert(0);
        }
    }

    class_ary_index = RULE_CTRL_IN_IndexOfClassInstance(class_inst_p);
    dup_class_inst = &dup_class_inst_pool_buf[ class_ary_index ];

    assert(0 == memcmp(dup_class_inst, class_inst_p, sizeof(*dup_class_inst)));
    memset(dup_class_inst, 0, sizeof(*dup_class_inst));
}

void
RULE_CTRL_UT_Proc_Validate_Leaks_Instance_CPU_Interface(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p,
    RULE_TYPE_CLASS_INSTANCE_T *dup_class_inst_pool_buf,
    RULE_TYPE_RULE_INSTANCE_T *dup_rule_inst_pool_buf)
{
    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T agg_class_inst_iter;

    if_entry_p = RULE_CTRL_Priv_GetIfEntry(interface_p);
    assert(NULL != if_entry_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                              &if_class_obj);

    if_class_obj.get_element_iterator(&if_class_obj, &agg_class_inst_iter);
    for (agg_class_inst_iter.first(&agg_class_inst_iter);
         NULL != agg_class_inst_iter.get_instance(&agg_class_inst_iter);
         agg_class_inst_iter.next(&agg_class_inst_iter))
    {
        RULE_TYPE_CLASS_INSTANCE_PTR_T agg_class_inst_p;
        RULE_TYPE_CLASS_INSTANCE_OBJECT_T agg_class_inst_obj;

        agg_class_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)agg_class_inst_iter.get_instance(&agg_class_inst_iter);

        RULE_CTRL_IN_Priv_ConstructClassInstanceObject(agg_class_inst_p,
                                                       &agg_class_inst_obj);

        RULE_CTRL_UT_Proc_Validate_Leaks_Instance_CPU_Interface_Make_ACL(agg_class_inst_p,
                                                        dup_class_inst_pool_buf,
                                                        dup_rule_inst_pool_buf);
    }

    //
    // Validate class instance of if entry
    //
    {
        UI32_T class_ary_index;
        RULE_TYPE_CLASS_INSTANCE_T *dup_class_inst;

        class_ary_index = RULE_CTRL_IN_IndexOfClassInstance(if_class_obj.inst);
        dup_class_inst = &dup_class_inst_pool_buf[class_ary_index];

        assert(0 == memcmp(dup_class_inst, if_class_obj.inst, sizeof(*dup_class_inst)));
        memset(dup_class_inst, 0, sizeof(*dup_class_inst));
    }
}

void
RULE_CTRL_UT_Proc_Validate_Leaks_Instance()
{
    RULE_TYPE_RETURN_TYPE_T result;
    UI32_T i;

    RULE_TYPE_CLASS_INSTANCE_T *dup_class_inst_pool_buf = malloc(sizeof(shmem_data_p->_class_inst_pool_buf));
    RULE_TYPE_RULE_INSTANCE_T  *dup_rule_inst_pool_buf  = malloc(sizeof(shmem_data_p->_rule_inst_pool_buf));

    RULE_TYPE_Acl_T dup_acl_table[RULE_TYPE_MAX_NBRS_OF_ACL];

    assert(NULL != dup_class_inst_pool_buf);
    assert(NULL != dup_rule_inst_pool_buf);

    memcpy(dup_class_inst_pool_buf, shmem_data_p->_class_inst_pool_buf,
                                    sizeof(shmem_data_p->_class_inst_pool_buf));

    memcpy(dup_rule_inst_pool_buf, shmem_data_p->_rule_inst_pool_buf,
                                     sizeof(shmem_data_p->_rule_inst_pool_buf));

    memset(dup_acl_table, 0, sizeof(dup_acl_table));

    //
    // FIXME: NOT START FROM LPORT, LOSS GLOBAL
    //
    {
        RULE_TYPE_INTERFACE_INFO_T interface;

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_UNIT;

        for (interface.direction = RULE_TYPE_INBOUND;
             interface.direction <= RULE_TYPE_OUTBOUND;
             ++ interface.direction)
        {
            RULE_CTRL_UT_Proc_Validate_Leaks_Instance_CPU_Interface(&interface,
                                                                    dup_class_inst_pool_buf,
                                                                    dup_rule_inst_pool_buf);
        }
    }

    {
        UI32_T ifindex;
        ifindex = 0;
        while (RULE_TYPE_OK == RULE_CTRL_UT_Proc_Get_Next_Ifindex(&ifindex))
        {
            RULE_TYPE_RETURN_TYPE_T result;

            RULE_TYPE_INTERFACE_INFO_T interface;

            memset(&interface, 0, sizeof(interface));

            result = RULE_CTRL_UT_Proc_Ifindex_To_Interface(ifindex, &interface);
            assert(RULE_TYPE_OK == result);

            for (interface.direction = RULE_TYPE_INBOUND;
                 interface.direction <= RULE_TYPE_OUTBOUND;
                 ++ interface.direction)
            {
                RULE_CTRL_UT_Proc_Validate_Leaks_Instance_CPU_Interface(&interface,
                                                                        dup_class_inst_pool_buf,
                                                                        dup_rule_inst_pool_buf);
            }
        }
    }

    for (i = 0; i < _countof(shmem_data_p->if_table); ++ i)
    {
        RULE_TYPE_INTERFACE_INFO_T interface;

        result = RULE_CTRL_Priv_IfEntry_Index_To_Interface(i, &interface);
        assert(RULE_TYPE_OK == result);

        {
            RULE_TYPE_AclType_T acl_type_ary[] =
            {
                RULE_TYPE_MAC_ACL,
                RULE_TYPE_IP_ACL,
                RULE_TYPE_IPV6_ACL
            };

            RULE_TYPE_AclType_T acl_type_idx;

            UI32_T ifindex;

            //
            // NOT support craft port now
            //
            if (RULE_TYPE_INTERFACE_CRAFT_PORT == interface.type)
            {
                continue;
            }

            result = RULE_CTRL_Interface_To_Ifindex(&interface, &ifindex);
            assert(RULE_TYPE_OK == result);

            //
            // ACL
            //
            for (acl_type_idx = 0; acl_type_idx < _countof(acl_type_ary); ++acl_type_idx)
            {
                UI32_T                      acl_type = acl_type_ary[acl_type_idx];
                UI32_T                      acl_index;

                RULE_TYPE_COUNTER_ENABLE_T  counter_enable;

                UI8_T                       time_range_name[SYS_ADPT_TIME_RANGE_MAX_NAME_LENGTH+1];

                result = RULE_OM_GetPortAclIndex(ifindex, acl_type,
                                                 interface.direction == RULE_TYPE_INBOUND ? TRUE : FALSE,
                                                 &acl_index,
                                                 time_range_name,
                                                 &counter_enable);
                if (RULE_TYPE_OK == result)
                {
                    RULE_TYPE_Acl_T acl_entry;
                    RULE_TYPE_PortEntry_T port_entry;

                    RULE_TYPE_CLASS_INSTANCE_T  *acl_inst;

                    result = RULE_OM_Get_PortEntryEx(ifindex,
                                                     interface.direction,
                                                     &port_entry);
                    assert(RULE_TYPE_OK == result);

                    result = RULE_OM_GetAclByIndex(acl_index, &acl_entry);
                    assert(RULE_TYPE_OK == result);

                    if (RULE_TYPE_INBOUND == interface.direction)
                    {
                        RULE_CTRL_SET_BIT_ON(dup_acl_table[acl_index-1].filtering_in_port_list, RULE_TYPE_IFINDEX_TO_PORT_LIST_INDEX(ifindex));
                    }
                    else
                    {
                        RULE_CTRL_SET_BIT_ON(dup_acl_table[acl_index-1].filtering_out_port_list, RULE_TYPE_IFINDEX_TO_PORT_LIST_INDEX(ifindex));
                    }

#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
                    if (TRUE == acl_entry.flag_aggregate_done &&
                        0 != acl_entry.aggregate_acl_index)
                    {
                        acl_index = acl_entry.aggregate_acl_index;

                        result = RULE_OM_GetAclByIndex(acl_index, &acl_entry);
                        assert(RULE_TYPE_OK == result);
                    }
#endif // SYS_CPNT_ACL_AUTO_COMPRESS_ACE

                    acl_inst = RULE_CTRL_Priv_GetAclInstanceById(&interface, acl_index);

                    assert(NULL != acl_inst);

                    if (RULE_TYPE_INBOUND == interface.direction)
                    {
                        RULE_CTRL_SET_BIT_ON(dup_acl_table[acl_index-1].filtering_in_port_list, RULE_TYPE_IFINDEX_TO_PORT_LIST_INDEX(ifindex));
                    }
                    else
                    {
                        RULE_CTRL_SET_BIT_ON(dup_acl_table[acl_index-1].filtering_out_port_list, RULE_TYPE_IFINDEX_TO_PORT_LIST_INDEX(ifindex));
                    }

                }
            }

        } // for (direction
    } // for (ifindex

    //
    // ACL group and MF group
    //
    {
        UI32_T i;

        for (i = 0; i < _countof(shmem_data_p->_class_inst_pool_buf); ++i)
        {
            RULE_TYPE_CLASS_INSTANCE_T *class_inst = &dup_class_inst_pool_buf[i];
            assert(RULE_TYPE_NIL == class_inst->super.type);
        }

        for (i = 0; i < _countof(shmem_data_p->_rule_inst_pool_buf); ++i)
        {
            RULE_TYPE_RULE_INSTANCE_T *rule_inst = &dup_rule_inst_pool_buf[i];
            assert(RULE_TYPE_NIL == rule_inst->super.type);
        }
    }

    //
    // ACL table
    //
    {
        UI32_T acl_index;

        for (acl_index = 1; acl_index <= _countof(dup_acl_table); ++acl_index)
        {
            RULE_TYPE_Acl_T acl;
            int    int_result;

            result = RULE_OM_GetAclByIndex(acl_index, &acl);
            if (RULE_TYPE_OK != result)
            {
                memset(&acl, 0, sizeof(acl));
            }

            int_result = memcmp(acl.filtering_in_port_list,
                                dup_acl_table[acl_index-1].filtering_in_port_list,
                                sizeof(acl.filtering_in_port_list));

            assert(0 == int_result);

            int_result = memcmp(acl.filtering_out_port_list,
                                dup_acl_table[acl_index-1].filtering_out_port_list,
                                sizeof(acl.filtering_out_port_list));

            assert(0 == int_result);

        }
    }

    free(dup_class_inst_pool_buf);
    free(dup_rule_inst_pool_buf);
}

void
RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule()
{
    {
        UI32_T i;

        for (i = 0; i < _countof(shmem_data_p->_rule_inst_pool_buf); ++ i)
        {
            RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_1_p;
            RULE_TYPE_CLASS_INSTANCE_PTR_T parent_of_rule_inst_1_p;
            DEVRM_PCE_T *pce1;
            DEVRM_PCL_T *pcl1;

            UI32_T j;

            BOOL_T b_result;

            rule_inst_1_p = &shmem_data_p->_rule_inst_pool_buf[i];

            if (RULE_TYPE_NIL == rule_inst_1_p->super.type)
            {
                continue;
            }

            if (TRUE != rule_inst_1_p->active)
            {
                continue;
            }

            parent_of_rule_inst_1_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_IN_Ptr2Instance(rule_inst_1_p->super.links.parent);
            assert(NULL != parent_of_rule_inst_1_p);
            assert(TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(parent_of_rule_inst_1_p->super.type));
            assert(RULE_TYPE_INST_ACE == parent_of_rule_inst_1_p->super.type ||
                   RULE_TYPE_INST_MF_ACE == parent_of_rule_inst_1_p->super.type);
            assert(RULE_TYPE_PACKET_NIL != parent_of_rule_inst_1_p->mvl_pkt_type);

            b_result = DEVRM_GetPce(rule_inst_1_p->dev_rule_info.device,
                                    rule_inst_1_p->dev_rule_info.rule_id,
                                    &pce1);
            assert(TRUE == b_result);

            pcl1 = DEVRM_GetPcl(rule_inst_1_p->dev_rule_info.device,
                                rule_inst_1_p->dev_rule_info.pcl_id);
            assert(NULL != pcl1);

            for (j = i + 1; j < _countof(shmem_data_p->_rule_inst_pool_buf); ++ j)
            {
                RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_2_p;
                RULE_TYPE_CLASS_INSTANCE_PTR_T parent_of_rule_inst_2_p;
                DEVRM_PCE_T *pce2;
                DEVRM_PCL_T *pcl2;

                rule_inst_2_p = &shmem_data_p->_rule_inst_pool_buf[j];

                if (RULE_TYPE_NIL == rule_inst_2_p->super.type)
                {
                    continue;
                }

                if (TRUE != rule_inst_2_p->active)
                {
                    continue;
                }

                if (rule_inst_2_p->dev_rule_info.unit != rule_inst_1_p->dev_rule_info.unit)
                {
                    continue;
                }

                if (rule_inst_2_p->dev_rule_info.device != rule_inst_1_p->dev_rule_info.device)
                {
                    continue;
                }

                //
                // Check interface of rule
                //
                if (((rule_inst_1_p->dev_rule_info.pcl_id & rule_inst_1_p->dev_rule_info.pcl_id_mask) !=
                     (rule_inst_2_p->dev_rule_info.pcl_id & rule_inst_2_p->dev_rule_info.pcl_id_mask)) &&

                    //
                    // Global rule vs eth/trunk rule
                    //
                    ((rule_inst_1_p->dev_rule_info.pcl_id & rule_inst_2_p->dev_rule_info.pcl_id_mask) !=
                     (rule_inst_2_p->dev_rule_info.pcl_id & rule_inst_2_p->dev_rule_info.pcl_id_mask)) &&
                    ((rule_inst_1_p->dev_rule_info.pcl_id & rule_inst_1_p->dev_rule_info.pcl_id_mask) !=
                     (rule_inst_2_p->dev_rule_info.pcl_id & rule_inst_1_p->dev_rule_info.pcl_id_mask)))
                {
                    continue;
                }

                parent_of_rule_inst_2_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_IN_Ptr2Instance(rule_inst_2_p->super.links.parent);
                assert(NULL != parent_of_rule_inst_2_p);
                assert(TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(parent_of_rule_inst_2_p->super.type));
                assert(RULE_TYPE_INST_ACE == parent_of_rule_inst_2_p->super.type ||
                       RULE_TYPE_INST_MF_ACE == parent_of_rule_inst_2_p->super.type);
                assert(RULE_TYPE_PACKET_NIL != parent_of_rule_inst_2_p->mvl_pkt_type);

//                printf("%s (%d): pkt_type = %s vs %s\r\n",
//                       __FUNCTION__,
//                       __LINE__,
//                       RULE_CTRL_REMAPPED_PACKET_TYPE_STR(parent_of_rule_inst_1_p->mvl_pkt_type),
//                       RULE_CTRL_REMAPPED_PACKET_TYPE_STR(parent_of_rule_inst_2_p->mvl_pkt_type));

                b_result = DEVRM_GetPce(rule_inst_2_p->dev_rule_info.device,
                                        rule_inst_2_p->dev_rule_info.rule_id,
                                        &pce2);
                assert(TRUE == b_result);

                pcl2 = DEVRM_GetPcl(rule_inst_2_p->dev_rule_info.device,
                                    rule_inst_2_p->dev_rule_info.pcl_id);
                assert(NULL != pcl2);

                //
                // Skip if the rule doesn't bind on the same interface
                //
                if (pcl1->direction != pcl2->direction ||
                    pcl1->lookup_num != pcl2->lookup_num)
                {
                    continue;
                }

                if (parent_of_rule_inst_1_p->mvl_pkt_type < parent_of_rule_inst_2_p->mvl_pkt_type)
                {
                    //
                    // smaller hw_idx is more priority
                    //
                    assert(pce1->hw_idx < pce2->hw_idx);
                }
                else if (parent_of_rule_inst_1_p->mvl_pkt_type < parent_of_rule_inst_2_p->mvl_pkt_type)
                {
                    assert(pce1->hw_idx > pce2->hw_idx);
                }
            }

        }
    }

    RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule_Policy_Maps_And_ACLs();
}

void
RULE_CTRL_UT_Proc_Validate_State_Of_Rule()
{
    UI32_T i;

    for (i = 0; i < _countof(shmem_data_p->if_table); ++ i)
    {
        RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

        RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

        RULE_TYPE_INTERFACE_INFO_T interface;

        if_entry_p = &shmem_data_p->if_table[i];

        RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                  &if_class_obj);

        RULE_CTRL_Priv_IfEntry_Index_To_Interface(i, &interface);

        RULE_CTRL_UT_Proc_Validate_State_Of_Rule_If(&interface);
    }
}

void
RULE_CTRL_UT_Proc_Validate_Leaks()
{
    RULE_CTRL_UT_Proc_Validate_Leaks_Instance();
}

void
RULE_CTRL_UT_Proc_Validate_Rule()
{
    RULE_CTRL_UT_Proc_Validate_Number_Of_Rule();
    RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule();
    RULE_CTRL_UT_Proc_Validate_State_Of_Rule();
    RULE_CTRL_UT_Proc_Validate_Leaks();

    DEVRM_UT_Proc_Validate_PCE_Status_Complete();

    RULE_OM_UT_Proc_Validate_Rule();
}

/*------------------------------------------------------------------------------
 * Test Functions
 *------------------------------------------------------------------------------
 */

#include "time_range_mgr.h"
int
RULE_CTRL_UT_Setup()
{
    _cpssInit();
    DEVRM_Initial();

    RULE_OM_InitiateSystemResources();
    RULE_CTRL_InitiateSystemResources();

    RULE_CTRL_EnterTransitionMode();
    RULE_CTRL_EnterMasterMode();

#if (SYS_CPNT_TIME_BASED_ACL == TRUE)
    SYS_TIME_AttachSystemResources();

    SYS_TIME_InitiateSystemResources();
    SYS_TIME_EnterMasterMode();

    TIME_RANGE_OM_InitiateSystemResources();
    TIME_RANGE_OM_Initiate_System_Resources();
#endif // SYS_CPNT_TIME_BASED_ACL


#if (SYS_CPNT_STACKING == TRUE)
    L_MM_Init();
    ISC_Init();
#endif /* SYS_CPNT_STACKING */
    return 0;
}

int
RULE_CTRL_UT_Teardown()
{
    DEVRM_FreeSystemResource();
    return 0;
}

int
RULE_CTRL_UT_Teardown_With_Validating_Rule()
{
    RULE_CTRL_UT_Proc_Validate_Rule();

    return RULE_CTRL_UT_Teardown();
}

/*------------------------------------------------------------------------------
 * Core Functions Test
 *------------------------------------------------------------------------------
 */

int
RULE_CTRL_UT_SelfTest_Create_Acl_And_Add_Ace()
{
    enum
    {
        MAX_ACE_IN_ACL = 5,
    };

    const char *acl_name = "a1";

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_AclType_T acl_type = RULE_TYPE_IP_STD_ACL;
    UI32_T acl_index;

    RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace(acl_name,
                                             acl_type,
                                             MAX_ACE_IN_ACL,
                                             RULE_CTRL_UT_COMPRESS_DISABLE,
                                             &acl_index);

#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
    result = RULE_OM_RebuildAggregateAcl(acl_index);
    assert(RULE_TYPE_OK == result);

    acl_index = RULE_OM_LocalGetAclByIndex(acl_index)->aggregate_acl_index;
#endif // SYS_CPNT_ACL_AUTO_COMPRESS_ACE

    assert(MAX_ACE_IN_ACL == RULE_OM_LocalGetAclByIndex(acl_index)->ace_count);

    return 0;
}

int
RULE_CTRL_UT_Remapped_Packet_Type()
{
    UI32_T i;
    RULE_TYPE_INTERFACE_TYPE_E interface_type;

    RULE_TYPE_RETURN_TYPE_T result;

    typedef struct
    {
        UI32_T if_type;
    } REMAP_ACE_TYPE_ENTRY_T;

    REMAP_ACE_TYPE_ENTRY_T packet_to_ace_tbl[] =
    {
#define PACKET_TYPE(pktType, ifType, remapAceType, quota)  {ifType},

        RULE_CONFIG_PACKET_TYPE_TABLE

#undef PACKET_TYPE
    };

    for (i = 0; i < RULE_TYPE_PACKET_MAX_TYPE; ++i)
    {
        result = RULE_CTRL_Priv_ConvertPacketTypeToAceType(i, &interface_type);
        assert(RULE_TYPE_OK == result);

        assert(interface_type == packet_to_ace_tbl[i].if_type);

    }

    assert(0 != i);

    return 0;
}

int
RULE_CTRL_UT_Get_Next_Ifindex()
{
    struct
    {
        UI32_T total_nbr_of_user_port;
        UI32_T total_nbr_of_trunk_port;
        UI32_T total_nbr_of_cpu_port;
        UI32_T total_nbr_of_craft_port;
        UI32_T total_nbr_of_port;
    } stat;

    RULE_TYPE_RETURN_TYPE_T result;
    UI32_T ifindex;

    memset(&stat, 0, sizeof(stat));

    for (ifindex = 0; RULE_TYPE_OK == RULE_CTRL_UT_Proc_Get_Next_Ifindex(&ifindex);)
    {
        RULE_TYPE_INTERFACE_INFO_T interface;

        memset(&interface, 0, sizeof(interface));

        result = RULE_CTRL_UT_Proc_Ifindex_To_Interface(ifindex, &interface);
        assert(RULE_TYPE_OK == result);

        if (RULE_TYPE_INTERFACE_UPORT == interface.type)
        {
            stat.total_nbr_of_user_port ++;
        }
        else if (RULE_TYPE_INTERFACE_TRUNK == interface.type)
        {
            stat.total_nbr_of_trunk_port ++;
        }
        else if (RULE_TYPE_INTERFACE_CPU_PORT == interface.type)
        {
            stat.total_nbr_of_cpu_port ++;
        }
        else if (RULE_TYPE_INTERFACE_CRAFT_PORT == interface.type)
        {
            stat.total_nbr_of_craft_port ++;
        }

        stat.total_nbr_of_port ++;
    }

    assert(0 != ifindex);

    assert(stat.total_nbr_of_user_port == RULE_CTRL_TOTAL_NBR_OF_UPORT);
    assert(stat.total_nbr_of_trunk_port == RULE_CTRL_TOTAL_NBR_OF_TRUNK_PORT);
    assert(stat.total_nbr_of_cpu_port == RULE_CTRL_TOTAL_NBR_OF_CPU_PORT);
    assert(stat.total_nbr_of_craft_port == RULE_CTRL_TOTAL_NBR_OF_CRAFT_PORT);

    //
    // No global (unit) here
    //
    assert(stat.total_nbr_of_port == (RULE_CTRL_TOTAL_NBR_OF_UPORT +
                                      RULE_CTRL_TOTAL_NBR_OF_TRUNK_PORT +
                                      RULE_CTRL_TOTAL_NBR_OF_CPU_PORT +
                                      RULE_CTRL_TOTAL_NBR_OF_CRAFT_PORT));

    return 0;
}

int
RULE_CTRL_UT_Convert_Between_Ifindex_Interface()
{
    RULE_TYPE_RETURN_TYPE_T result;
    UI32_T ifindex;

    for (ifindex = 0; RULE_TYPE_OK == RULE_CTRL_UT_Proc_Get_Next_Ifindex(&ifindex);)
    {
        RULE_TYPE_INTERFACE_INFO_T interface;

        memset(&interface, 0, sizeof(interface));

        result = RULE_CTRL_UT_Proc_Ifindex_To_Interface(ifindex, &interface);
        assert(RULE_TYPE_OK == result);

        {
            UI32_T temp_ifindex;

            result = RULE_CTRL_UT_Proc_Interface_To_Ifindex(&interface, &temp_ifindex);
            assert(RULE_TYPE_OK == result);
            assert(ifindex == temp_ifindex);
        }
    }

    assert(0 != ifindex);

    return 0;
}

int
RULE_CTRL_UT_Rule_Count()
{
    if (0)
    {
#define PACKET_TYPE(pktType, ifType, remapAceType, quota)  (ifType == RULE_TYPE_INTERFACE_ALL_UNIT ? remapAceType##_RULE_CNT : 0) +

    UI32_T total_rule_cnt = RULE_CONFIG_PACKET_TYPE_TABLE 0;

#undef PACKET_TYPE

        UI32_T rule_cnt = RULE_CTRL_GLOBAL_RULE_CNT;

        //
        // FIXME: Because ALL_PORT_ACL, this check will fail
        //
        assert(rule_cnt == total_rule_cnt);
    }

    {
#define PACKET_TYPE(pktType, ifType, remapAceType, quota)  (ifType == RULE_TYPE_INTERFACE_CRAFT_PORT ? remapAceType##_RULE_CNT : 0) +

    UI32_T total_rule_cnt =
        RULE_CONFIG_PACKET_TYPE_TABLE 0;

#undef PACKET_TYPE

        UI32_T rule_cnt = RULE_CTRL_CRAFT_PORT_RULE_CNT;

        assert(rule_cnt == total_rule_cnt);
    }

    {
#define PACKET_TYPE(pktType, ifType, remapAceType, quota)  (ifType == RULE_TYPE_INTERFACE_UPORT ? remapAceType##_RULE_CNT : 0) +

        //UI32_T total_rule_cnt = RULE_CONFIG_PACKET_TYPE_TABLE 0;

#undef PACKET_TYPE

        //UI32_T rule_cnt = RULE_CTRL_NORMAL_PORT_RULE_CNT;

        printf("%s, %d: check here !!\r\n", __FUNCTION__, __LINE__);
    }

    return 0;
}

int
RULE_CTRL_UT_Static_Constant_Value()
{
    assert(RULE_TYPE_PacketType_MAX == _countof(rule_ctrl_packet_type_str));
    assert(RULE_TYPE_PACKET_MAX_TYPE == _countof(rule_ctrl_remapped_pkt_type_str));

    assert(0 == strcmp(RULE_CTRL_PACKET_TYPE_STR(RULE_TYPE_PacketType_MAX), "(invalid)"));
    assert(0 == strcmp(RULE_CTRL_REMAPPED_PACKET_TYPE_STR(RULE_TYPE_PACKET_MAX_TYPE), "(invalid)"));

    assert(0 == strcmp("RULE_TYPE_PacketType_PTP_EVENT_ETH", RULE_CTRL_PACKET_TYPE_STR(RULE_TYPE_PacketType_PTP_EVENT_ETH)));
    assert(0 == strcmp("RULE_TYPE_PacketType_MLD_Query", RULE_CTRL_PACKET_TYPE_STR(RULE_TYPE_PacketType_MLD_Query)));
    assert(0 == strcmp("RULE_TYPE_PacketType_MLD_Report", RULE_CTRL_PACKET_TYPE_STR(RULE_TYPE_PacketType_MLD_Report)));
    assert(0 == strcmp("RULE_TYPE_PacketType_MLD_Done", RULE_CTRL_PACKET_TYPE_STR(RULE_TYPE_PacketType_MLD_Done)));
    assert(0 == strcmp("RULE_TYPE_PacketType_MLDV2_Reports", RULE_CTRL_PACKET_TYPE_STR(RULE_TYPE_PacketType_MLDV2_Reports)));
    assert(0 == strcmp("RULE_TYPE_PacketType_DHCP6_CLIENT", RULE_CTRL_PACKET_TYPE_STR(RULE_TYPE_PacketType_DHCP6_CLIENT)));
    assert(0 == strcmp("RULE_TYPE_PacketType_DHCP6_SERVER", RULE_CTRL_PACKET_TYPE_STR(RULE_TYPE_PacketType_DHCP6_SERVER)));
    assert(0 == strcmp("RULE_TYPE_PacketType_PIM6", RULE_CTRL_PACKET_TYPE_STR(RULE_TYPE_PacketType_PIM6)));


    assert(0 == strcmp(RULE_CTRL_REMAPPED_PACKET_TYPE_STR(RULE_TYPE_PACKET_MY_MAC_CRAFT_PORT), "RULE_TYPE_PACKET_MY_MAC_CRAFT_PORT"));

    return 0;
}

int
RULE_CTRL_UT_Get_PCL_Config()
{
#define RULE_CTRL_MAX_PCL_ID 0x000003ff

    typedef struct
    {
        BOOL_T *pcl_id_ary;
    } pcl_cfg_table_t;

    RULE_TYPE_RETURN_TYPE_T res;

    UI32_T lookup_num;
    UI32_T unit;
    UI32_T port;
    UI32_T trunk_id;
    UI32_T device_id;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_CTRL_PCL_CFG_T pcl_cfg;

    pcl_cfg_table_t pcl_cfg_table[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                 [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];

    //
    // Allocate pcl_id_array for each unit / device
    //
    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT; ++ device_id)
        {
            pcl_cfg_table_t *tbl = &pcl_cfg_table[unit-1][device_id];

            assert(sizeof(*tbl->pcl_id_ary) == sizeof(BOOL_T));
            tbl->pcl_id_ary = calloc(RULE_CTRL_MAX_PCL_ID+1, sizeof(*tbl->pcl_id_ary));

            assert(NULL != tbl->pcl_id_ary);
        }
    }

    //
    // UPort
    //
    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        for (port = 1; port <= SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT_ON_BOARD; ++ port)
        {
            UI32_T chip_port = ((port-1) % SYS_ADPT_MAX_NBR_OF_SWITCH_PORT_PER_CHIP)+1;

            interface.type = RULE_TYPE_INTERFACE_UPORT;
            interface.uport.unit = unit;
            interface.uport.port = port;
            interface.direction  = RULE_TYPE_INBOUND;

            lookup_num = 0;

            res = RULE_CTRL_Priv_GetPclConfig(&interface, lookup_num, &pcl_cfg);
            assert(RULE_TYPE_OK == res);

            assert(pcl_cfg.pcl_id == 0x00000080 + chip_port);
            assert(pcl_cfg.pcl_id_mask == 0x000003ff);

            /* PCL ID should be unique for each device
             */
            {
                pcl_cfg_table_t *tbl = NULL;
                device_id = RULE_CTRL_UT_Proc_UPort_To_Device_Id(interface.uport.unit,
                                                                 interface.uport.port);

                tbl = &pcl_cfg_table[unit-1][device_id];
                assert(FALSE == tbl->pcl_id_ary[ pcl_cfg.pcl_id ]);

                tbl->pcl_id_ary[ pcl_cfg.pcl_id ] = TRUE;
            }
        }
    }

    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        for (port = 1; port <= SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT_ON_BOARD; ++ port)
        {
            UI32_T chip_port = ((port-1) % SYS_ADPT_MAX_NBR_OF_SWITCH_PORT_PER_CHIP)+1;

            interface.type = RULE_TYPE_INTERFACE_UPORT;
            interface.uport.unit = unit;
            interface.uport.port = port;
            interface.direction  = RULE_TYPE_INBOUND;

            lookup_num = 1;

            res = RULE_CTRL_Priv_GetPclConfig(&interface, lookup_num, &pcl_cfg);
            assert(RULE_TYPE_OK == res);

            assert(pcl_cfg.pcl_id == 0x00000100 + chip_port);
            assert(pcl_cfg.pcl_id_mask == 0x000003ff);

            /* PCL ID should be unique for each device
             */
            {
                pcl_cfg_table_t *tbl = NULL;
                device_id = RULE_CTRL_UT_Proc_UPort_To_Device_Id(interface.uport.unit,
                                                                 interface.uport.port);

                tbl = &pcl_cfg_table[unit-1][device_id];
                assert(FALSE == tbl->pcl_id_ary[ pcl_cfg.pcl_id ]);

                tbl->pcl_id_ary[ pcl_cfg.pcl_id ] = TRUE;
            }
        }
    }

    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        for (port = 1; port <= SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT_ON_BOARD; ++ port)
        {
            UI32_T chip_port = ((port-1) % SYS_ADPT_MAX_NBR_OF_SWITCH_PORT_PER_CHIP)+1;

            interface.type = RULE_TYPE_INTERFACE_UPORT;
            interface.uport.unit = unit;
            interface.uport.port = port;
            interface.direction  = RULE_TYPE_INBOUND;

            lookup_num = 2;

            res = RULE_CTRL_Priv_GetPclConfig(&interface, lookup_num, &pcl_cfg);
            assert(RULE_TYPE_OK == res);

            assert(pcl_cfg.pcl_id == 0x00000180 + chip_port);
            assert(pcl_cfg.pcl_id_mask == 0x000003ff);

            /* PCL ID should be unique for each device
             */
            {
                pcl_cfg_table_t *tbl = NULL;
                device_id = RULE_CTRL_UT_Proc_UPort_To_Device_Id(interface.uport.unit,
                                                                 interface.uport.port);

                tbl = &pcl_cfg_table[unit-1][device_id];
                assert(FALSE == tbl->pcl_id_ary[ pcl_cfg.pcl_id ]);

                tbl->pcl_id_ary[ pcl_cfg.pcl_id ] = TRUE;
            }
        }
    }

    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        for (port = 1; port <= SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT_ON_BOARD; ++ port)
        {
            UI32_T chip_port = ((port-1) % SYS_ADPT_MAX_NBR_OF_SWITCH_PORT_PER_CHIP)+1;

            interface.type = RULE_TYPE_INTERFACE_UPORT;
            interface.uport.unit = unit;
            interface.uport.port = port;
            interface.direction  = RULE_TYPE_OUTBOUND;

            lookup_num = 0;

            res = RULE_CTRL_Priv_GetPclConfig(&interface, lookup_num, &pcl_cfg);
            assert(RULE_TYPE_OK == res);

            assert(pcl_cfg.pcl_id == 0x00000200 + chip_port);
            assert(pcl_cfg.pcl_id_mask == 0x000003ff);

            /* PCL ID should be unique for each device
             */
            {
                pcl_cfg_table_t *tbl = NULL;
                device_id = RULE_CTRL_UT_Proc_UPort_To_Device_Id(interface.uport.unit,
                                                                 interface.uport.port);

                tbl = &pcl_cfg_table[unit-1][device_id];
                assert(FALSE == tbl->pcl_id_ary[ pcl_cfg.pcl_id ]);

                tbl->pcl_id_ary[ pcl_cfg.pcl_id ] = TRUE;
            }
        }
    }

    //
    // Trunk Port
    //
    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        for (trunk_id = 1; trunk_id <= SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM; ++ trunk_id)
        {
            interface.type = RULE_TYPE_INTERFACE_TRUNK;
            interface.trunk_id = trunk_id;
            interface.direction  = RULE_TYPE_INBOUND;

            lookup_num = 0;

            res = RULE_CTRL_Priv_GetPclConfig(&interface, lookup_num, &pcl_cfg);
            assert(RULE_TYPE_OK == res);

            assert(pcl_cfg.pcl_id == 0x000000C0 + trunk_id);
            assert(pcl_cfg.pcl_id_mask == 0x000003ff);

            /* PCL ID should be unique for each device
             */
            for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_DRIVER_UNIT_PER_STACK; ++ device_id)
            {
                pcl_cfg_table_t *tbl = &pcl_cfg_table[unit-1][device_id];
                assert(FALSE == tbl->pcl_id_ary[ pcl_cfg.pcl_id ]);

                tbl->pcl_id_ary[ pcl_cfg.pcl_id ] = TRUE;
            }
        }
    }

    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        for (trunk_id = 1; trunk_id <= SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM; ++ trunk_id)
        {
            interface.type = RULE_TYPE_INTERFACE_TRUNK;
            interface.trunk_id = trunk_id;
            interface.direction  = RULE_TYPE_INBOUND;

            lookup_num = 1;

            res = RULE_CTRL_Priv_GetPclConfig(&interface, lookup_num, &pcl_cfg);
            assert(RULE_TYPE_OK == res);

            assert(pcl_cfg.pcl_id == 0x00000140 + trunk_id);
            assert(pcl_cfg.pcl_id_mask == 0x000003ff);

            /* PCL ID should be unique for each device
             */
            for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_DRIVER_UNIT_PER_STACK; ++ device_id)
            {
                pcl_cfg_table_t *tbl = &pcl_cfg_table[unit-1][device_id];
                assert(FALSE == tbl->pcl_id_ary[ pcl_cfg.pcl_id ]);

                tbl->pcl_id_ary[ pcl_cfg.pcl_id ] = TRUE;
            }
        }
    }

    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        for (trunk_id = 1; trunk_id <= SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM; ++ trunk_id)
        {
            interface.type = RULE_TYPE_INTERFACE_TRUNK;
            interface.trunk_id = trunk_id;
            interface.direction  = RULE_TYPE_INBOUND;

            lookup_num = 2;

            res = RULE_CTRL_Priv_GetPclConfig(&interface, lookup_num, &pcl_cfg);
            assert(RULE_TYPE_OK == res);

            assert(pcl_cfg.pcl_id == 0x000001C0 + trunk_id);
            assert(pcl_cfg.pcl_id_mask == 0x000003ff);

            /* PCL ID should be unique for each device
             */
            for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_DRIVER_UNIT_PER_STACK; ++ device_id)
            {
                pcl_cfg_table_t *tbl = &pcl_cfg_table[unit-1][device_id];
                assert(FALSE == tbl->pcl_id_ary[ pcl_cfg.pcl_id ]);

                tbl->pcl_id_ary[ pcl_cfg.pcl_id ] = TRUE;
            }
        }
    }

    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        for (trunk_id = 1; trunk_id <= SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM; ++ trunk_id)
        {
            interface.type = RULE_TYPE_INTERFACE_TRUNK;
            interface.trunk_id = trunk_id;
            interface.direction  = RULE_TYPE_OUTBOUND;

            lookup_num = 0;

            res = RULE_CTRL_Priv_GetPclConfig(&interface, lookup_num, &pcl_cfg);
            assert(RULE_TYPE_OK == res);

            assert(pcl_cfg.pcl_id == 0x00000240 + trunk_id);
            assert(pcl_cfg.pcl_id_mask == 0x000003ff);

            /* PCL ID should be unique for each device
             */
            for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_DRIVER_UNIT_PER_STACK; ++ device_id)
            {
                pcl_cfg_table_t *tbl = &pcl_cfg_table[unit-1][device_id];
                assert(FALSE == tbl->pcl_id_ary[ pcl_cfg.pcl_id ]);

                tbl->pcl_id_ary[ pcl_cfg.pcl_id ] = TRUE;
            }
        }
    }

    //
    // All Front Port
    //
    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        interface.type = RULE_TYPE_INTERFACE_UNIT;
        interface.unit = unit;
        interface.direction  = RULE_TYPE_INBOUND;

        lookup_num = 0;

        res = RULE_CTRL_Priv_GetPclConfig(&interface, lookup_num, &pcl_cfg);
        assert(RULE_TYPE_OK == res);

        assert(pcl_cfg.pcl_id == 0x00000080);
        assert(pcl_cfg.pcl_id_mask == 0x00000380);

        /* PCL ID should be unique for each device
         */
        for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_DRIVER_UNIT_PER_STACK; ++ device_id)
        {
            pcl_cfg_table_t *tbl = &pcl_cfg_table[unit-1][device_id];
            assert(FALSE == tbl->pcl_id_ary[ pcl_cfg.pcl_id ]);

            tbl->pcl_id_ary[ pcl_cfg.pcl_id ] = TRUE;
        }
    }

    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        interface.type = RULE_TYPE_INTERFACE_UNIT;
        interface.unit = unit;
        interface.direction  = RULE_TYPE_INBOUND;

        lookup_num = 1;

        res = RULE_CTRL_Priv_GetPclConfig(&interface, lookup_num, &pcl_cfg);
        assert(RULE_TYPE_OK == res);

        assert(pcl_cfg.pcl_id == 0x00000100);
        assert(pcl_cfg.pcl_id_mask == 0x00000380);

        /* PCL ID should be unique for each device
         */
        for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_DRIVER_UNIT_PER_STACK; ++ device_id)
        {
            pcl_cfg_table_t *tbl = &pcl_cfg_table[unit-1][device_id];
            assert(FALSE == tbl->pcl_id_ary[ pcl_cfg.pcl_id ]);

            tbl->pcl_id_ary[ pcl_cfg.pcl_id ] = TRUE;
        }
    }

    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        interface.type = RULE_TYPE_INTERFACE_UNIT;
        interface.unit = unit;
        interface.direction  = RULE_TYPE_INBOUND;

        lookup_num = 2;

        res = RULE_CTRL_Priv_GetPclConfig(&interface, lookup_num, &pcl_cfg);
        assert(RULE_TYPE_OK == res);

        assert(pcl_cfg.pcl_id == 0x00000180);
        assert(pcl_cfg.pcl_id_mask == 0x00000380);

        /* PCL ID should be unique for each device
         */
        for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_DRIVER_UNIT_PER_STACK; ++ device_id)
        {
            pcl_cfg_table_t *tbl = &pcl_cfg_table[unit-1][device_id];
            assert(FALSE == tbl->pcl_id_ary[ pcl_cfg.pcl_id ]);

            tbl->pcl_id_ary[ pcl_cfg.pcl_id ] = TRUE;
        }
    }

    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        interface.type = RULE_TYPE_INTERFACE_UNIT;
        interface.unit = unit;
        interface.direction  = RULE_TYPE_OUTBOUND;

        lookup_num = 0;

        res = RULE_CTRL_Priv_GetPclConfig(&interface, lookup_num, &pcl_cfg);
        assert(RULE_TYPE_OK == res);

        assert(pcl_cfg.pcl_id == 0x00000200);
        assert(pcl_cfg.pcl_id_mask == 0x00000380);

        /* PCL ID should be unique for each device
         */
        for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_DRIVER_UNIT_PER_STACK; ++ device_id)
        {
            pcl_cfg_table_t *tbl = &pcl_cfg_table[unit-1][device_id];
            assert(FALSE == tbl->pcl_id_ary[ pcl_cfg.pcl_id ]);

            tbl->pcl_id_ary[ pcl_cfg.pcl_id ] = TRUE;
        }
    }

    //
    // Craft Port
    //
    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        interface.type = RULE_TYPE_INTERFACE_CRAFT_PORT;
        interface.unit = unit;
        interface.direction  = RULE_TYPE_INBOUND;

        lookup_num = 0;

        res = RULE_CTRL_Priv_GetPclConfig(&interface, lookup_num, &pcl_cfg);
        assert(RULE_TYPE_OK == res);

        assert(pcl_cfg.pcl_id == 0x00000381);
        assert(pcl_cfg.pcl_id_mask == 0x000003ff);

        /* PCL ID should be unique for each device
         */
        for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_DRIVER_UNIT_PER_STACK; ++ device_id)
        {
            pcl_cfg_table_t *tbl = &pcl_cfg_table[unit-1][device_id];
            assert(FALSE == tbl->pcl_id_ary[ pcl_cfg.pcl_id ]);

            tbl->pcl_id_ary[ pcl_cfg.pcl_id ] = TRUE;
        }
    }

    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        interface.type = RULE_TYPE_INTERFACE_CRAFT_PORT;
        interface.unit = unit;
        interface.direction  = RULE_TYPE_INBOUND;

        lookup_num = 1;

        res = RULE_CTRL_Priv_GetPclConfig(&interface, lookup_num, &pcl_cfg);
        assert(RULE_TYPE_OK == res);

        assert(pcl_cfg.pcl_id == 0x00000382);
        assert(pcl_cfg.pcl_id_mask == 0x000003ff);

        /* PCL ID should be unique for each device
         */
        for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_DRIVER_UNIT_PER_STACK; ++ device_id)
        {
            pcl_cfg_table_t *tbl = &pcl_cfg_table[unit-1][device_id];
            assert(FALSE == tbl->pcl_id_ary[ pcl_cfg.pcl_id ]);

            tbl->pcl_id_ary[ pcl_cfg.pcl_id ] = TRUE;
        }
    }

    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        interface.type = RULE_TYPE_INTERFACE_CRAFT_PORT;
        interface.unit = unit;
        interface.direction  = RULE_TYPE_INBOUND;

        lookup_num = 2;

        res = RULE_CTRL_Priv_GetPclConfig(&interface, lookup_num, &pcl_cfg);
        assert(RULE_TYPE_OK == res);

        assert(pcl_cfg.pcl_id == 0x00000383);
        assert(pcl_cfg.pcl_id_mask == 0x000003ff);

        /* PCL ID should be unique for each device
         */
        for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_DRIVER_UNIT_PER_STACK; ++ device_id)
        {
            pcl_cfg_table_t *tbl = &pcl_cfg_table[unit-1][device_id];
            assert(FALSE == tbl->pcl_id_ary[ pcl_cfg.pcl_id ]);

            tbl->pcl_id_ary[ pcl_cfg.pcl_id ] = TRUE;
        }
    }

    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        interface.type = RULE_TYPE_INTERFACE_CRAFT_PORT;
        interface.unit = unit;
        interface.direction  = RULE_TYPE_OUTBOUND;

        lookup_num = 0;

        res = RULE_CTRL_Priv_GetPclConfig(&interface, lookup_num, &pcl_cfg);
        assert(RULE_TYPE_OK == res);

        assert(pcl_cfg.pcl_id == 0x00000384);
        assert(pcl_cfg.pcl_id_mask == 0x000003ff);

        /* PCL ID should be unique for each device
         */
        for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_DRIVER_UNIT_PER_STACK; ++ device_id)
        {
            pcl_cfg_table_t *tbl = &pcl_cfg_table[unit-1][device_id];
            assert(FALSE == tbl->pcl_id_ary[ pcl_cfg.pcl_id ]);

            tbl->pcl_id_ary[ pcl_cfg.pcl_id ] = TRUE;
        }
    }

    //
    // CPU Port
    //
    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        interface.type = RULE_TYPE_INTERFACE_CPU_PORT;
        interface.unit = unit;
        interface.direction  = RULE_TYPE_INBOUND;

        lookup_num = 0;

        res = RULE_CTRL_Priv_GetPclConfig(&interface, lookup_num, &pcl_cfg);
        assert(RULE_TYPE_OK == res);

        assert(pcl_cfg.pcl_id == 0x00000385);
        assert(pcl_cfg.pcl_id_mask == 0x000003ff);

        /* PCL ID should be unique for each device
         */
        for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_DRIVER_UNIT_PER_STACK; ++ device_id)
        {
            pcl_cfg_table_t *tbl = &pcl_cfg_table[unit-1][device_id];
            assert(FALSE == tbl->pcl_id_ary[ pcl_cfg.pcl_id ]);

            tbl->pcl_id_ary[ pcl_cfg.pcl_id ] = TRUE;
        }
    }

    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        interface.type = RULE_TYPE_INTERFACE_CPU_PORT;
        interface.unit = unit;
        interface.direction  = RULE_TYPE_INBOUND;

        lookup_num = 1;

        res = RULE_CTRL_Priv_GetPclConfig(&interface, lookup_num, &pcl_cfg);
        assert(RULE_TYPE_OK == res);

        assert(pcl_cfg.pcl_id == 0x00000386);
        assert(pcl_cfg.pcl_id_mask == 0x000003ff);

        /* PCL ID should be unique for each device
         */
        for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_DRIVER_UNIT_PER_STACK; ++ device_id)
        {
            pcl_cfg_table_t *tbl = &pcl_cfg_table[unit-1][device_id];
            assert(FALSE == tbl->pcl_id_ary[ pcl_cfg.pcl_id ]);

            tbl->pcl_id_ary[ pcl_cfg.pcl_id ] = TRUE;
        }
    }

    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        interface.type = RULE_TYPE_INTERFACE_CPU_PORT;
        interface.unit = unit;
        interface.direction  = RULE_TYPE_INBOUND;

        lookup_num = 2;

        res = RULE_CTRL_Priv_GetPclConfig(&interface, lookup_num, &pcl_cfg);
        assert(RULE_TYPE_OK == res);

        assert(pcl_cfg.pcl_id == 0x00000387);
        assert(pcl_cfg.pcl_id_mask == 0x000003ff);

        /* PCL ID should be unique for each device
         */
        for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_DRIVER_UNIT_PER_STACK; ++ device_id)
        {
            pcl_cfg_table_t *tbl = &pcl_cfg_table[unit-1][device_id];
            assert(FALSE == tbl->pcl_id_ary[ pcl_cfg.pcl_id ]);

            tbl->pcl_id_ary[ pcl_cfg.pcl_id ] = TRUE;
        }
    }

    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        interface.type = RULE_TYPE_INTERFACE_CPU_PORT;
        interface.unit = unit;
        interface.direction  = RULE_TYPE_OUTBOUND;

        lookup_num = 0;

        res = RULE_CTRL_Priv_GetPclConfig(&interface, lookup_num, &pcl_cfg);
        assert(RULE_TYPE_OK == res);

        assert(pcl_cfg.pcl_id == 0x00000388);
        assert(pcl_cfg.pcl_id_mask == 0x000003ff);

        /* PCL ID should be unique for each device
         */
        for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_DRIVER_UNIT_PER_STACK; ++ device_id)
        {
            pcl_cfg_table_t *tbl = &pcl_cfg_table[unit-1][device_id];
            assert(FALSE == tbl->pcl_id_ary[ pcl_cfg.pcl_id ]);

            tbl->pcl_id_ary[ pcl_cfg.pcl_id ] = TRUE;
        }
    }

    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
    {
        for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT; ++ device_id)
        {
            pcl_cfg_table_t *tbl = &pcl_cfg_table[unit-1][device_id];

            free(tbl->pcl_id_ary);
            tbl->pcl_id_ary = NULL;
        }
    }

    return 0;

#undef RULE_CTRL_MAX_PCL_ID
}

int
RULE_CTRL_UT_Is_Match_Any_Any_Ace()
{
    RULE_TYPE_RETURN_TYPE_T result;

    const char *acl_name = "a1";
    RULE_TYPE_AclType_T acl_type = RULE_TYPE_IP_STD_ACL;
    UI32_T  acl_index;

    RULE_TYPE_INTERFACE_INFO_T interface;

    UI32_T  remapped_pkt_type;

    UI32_T  ace_index;
    RULE_TYPE_AclType_T   ace_type;
    RULE_TYPE_Ace_Entry_T ace_entry;

    BOOL_T  b_result;

    RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace_Without_Match_Any_Ace(acl_name, acl_type, 5, RULE_CTRL_UT_COMPRESS_DEFAULT, &acl_index);

    memset(&interface, 0, sizeof(interface));

    ace_index = 0;
    while (RULE_TYPE_OK == RULE_OM_GetNextAceByAcl(acl_index, &ace_type, &ace_index, &ace_entry))
    {
        b_result = RULE_CTRL_Priv_IsMatchAnyAnyAce(acl_index, ace_index);
        assert(FALSE == b_result);

        interface.type = RULE_TYPE_INTERFACE_UPORT;
        interface.direction = RULE_TYPE_INBOUND;
        result = RULE_CTRL_Priv_GetPacketTypeOfAcl(&interface, acl_index, ace_index,
                                                   &remapped_pkt_type);
        assert(RULE_TYPE_OK == result);
        assert(RULE_TYPE_PACKET_ACL == remapped_pkt_type);

        interface.type = RULE_TYPE_INTERFACE_UPORT;
        interface.direction = RULE_TYPE_OUTBOUND;
        result = RULE_CTRL_Priv_GetPacketTypeOfAcl(&interface, acl_index, ace_index,
                                                   &remapped_pkt_type);
        assert(RULE_TYPE_OK == result);
        assert(RULE_TYPE_PACKET_EGRESS_ACL == remapped_pkt_type);
    }

    ace_entry.ace_type = RULE_TYPE_IP_STD_ACL;
    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    {
        RULE_TYPE_Ace_Entry_T tmp_ace_entry;

        result = RULE_OM_GetLastAceByAcl(acl_index, &ace_type, &ace_index, &tmp_ace_entry);
        assert(RULE_TYPE_OK == result);

        assert(0 == memcmp(&ace_entry.u.ip, &tmp_ace_entry.u.ip, sizeof(ace_entry.u.ip)));
    }

    b_result = RULE_CTRL_Priv_IsMatchAnyAnyAce(acl_index, ace_index);
    assert(TRUE == b_result);

    interface.type = RULE_TYPE_INTERFACE_UPORT;
    interface.direction = RULE_TYPE_INBOUND;

    result = RULE_CTRL_Priv_GetPacketTypeOfAcl(&interface, acl_index, ace_index,
                                               &remapped_pkt_type);
    assert(RULE_TYPE_OK == result);
    assert(RULE_TYPE_PACKET_ACL_MATCH_ANY_ANY == remapped_pkt_type);

    interface.type = RULE_TYPE_INTERFACE_UPORT;
    interface.direction = RULE_TYPE_OUTBOUND;

    result = RULE_CTRL_Priv_GetPacketTypeOfAcl(&interface, acl_index, ace_index,
                                               &remapped_pkt_type);
    assert(RULE_TYPE_OK == result);
    assert(RULE_TYPE_PACKET_EGRESS_ACL_MATCH_ANY_ANY == remapped_pkt_type);

    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// CPU interface rule
//
////////////////////////////////////////////////////////////////////////////////

void
RULE_CTRL_UT_Proc_Validate_My_Mac_Craft_Port_Rule(
    BOOL_T enable_flag,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p)
{
    enum
    {
        UNIT = 1,
    };

    UI8_T damac[SYS_ADPT_MAC_ADDR_LEN];
    UI8_T damask[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    STKTPLG_POM_GetLocalUnitBaseMac(damac);

    if (TRUE == enable_flag)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Dest_Mac_Address(&rule_entry_p->rule_pattern, damac, damask);

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;

                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 == pce->policer_idx);

                result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                     remapped_pkt_type,
                                                                     &pcl_cfg);
                assert(RULE_TYPE_OK == result);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                b_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce);
                assert(TRUE == b_result);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    assert(0 == memcmp(pattern->macDa.arEther, damac, sizeof(damac)));
                    assert(0 == memcmp(mask->macDa.arEther, damask, sizeof(damask)));

                    assert(pattern->common.isL2Valid == 1);
                    assert(mask->common.isL2Valid == 1);
                }

                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);

                assert(CPSS_PACKET_CMD_TRAP_TO_CPU_E == action.pktCmd);
                assert(CPSS_NET_FIRST_USER_DEFINED_E == action.mirror.cpuCode);

                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
            }
        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

void
RULE_CTRL_UT_Proc_Set_My_Mac_Craft_Port_Rule(
    BOOL_T enable_flag)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_MY_MAC_CRAFT_PORT;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    RULE_TYPE_PacketType_T packet_type = RULE_TYPE_Packettype_MY_MAC_CRAFT_PORT;

    BOOL_T b_result;

    b_result = RULE_CTRL_TrapPacket2Cpu(enable_flag, packet_type, NULL);
    assert(TRUE == b_result);

    memset(&interface, 0, sizeof(interface));
    interface.type = RULE_TYPE_INTERFACE_CRAFT_PORT;
    interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);

    if (TRUE == enable_flag)
    {
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);
    }
    else
    {
        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_My_Mac_Craft_Port_Rule(enable_flag,
                                                      &interface,
                                                      remapped_pkt_type,
                                                      class_inst_p);
}

int
RULE_CTRL_UT_Set_Global_My_Mac_Craft_Port_Rule()
{
#if (SYS_CPNT_CRAFT_PORT == TRUE) && (SYS_CPNT_CRAFT_PORT_MODE == SYS_CPNT_CRAFT_PORT_MODE_FRONT_PORT_CRAFT_PORT)
    enum
    {
        MAX_RETRY = 2,
    };

    UI32_T retry;
    BOOL_T enable_flag;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        enable_flag = TRUE;

        RULE_CTRL_UT_Proc_Set_My_Mac_Craft_Port_Rule(enable_flag);

        enable_flag = FALSE;

        RULE_CTRL_UT_Proc_Set_My_Mac_Craft_Port_Rule(enable_flag);

        enable_flag = TRUE;

        RULE_CTRL_UT_Proc_Set_My_Mac_Craft_Port_Rule(enable_flag);
    }

    enable_flag = TRUE;

    RULE_CTRL_UT_Proc_Set_My_Mac_Craft_Port_Rule(enable_flag);
#endif /* SYS_CPNT_CRAFT_PORT */

    return 0;

}

void
RULE_CTRL_UT_Proc_Validate_My_Mac_Arp_Rule(
    BOOL_T enable_flag,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p)
{
    enum
    {
        UNIT = 1,
    };

    UI16_T ether_type       = 0x806;
    UI16_T ether_type_mask  = 0xffff;

    UI8_T damac[SYS_ADPT_MAC_ADDR_LEN];
    UI8_T damask[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    STKTPLG_POM_GetLocalUnitBaseMac(damac);

    if (TRUE == enable_flag)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Dest_Mac_Address(&rule_entry_p->rule_pattern, damac, damask);
            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ether_Type(&rule_entry_p->rule_pattern, ether_type, ether_type_mask);

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;

                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 == pce->policer_idx);

                result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                     remapped_pkt_type,
                                                                     &pcl_cfg);
                assert(RULE_TYPE_OK == result);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                b_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce);
                assert(TRUE == b_result);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    assert(0 == memcmp(pattern->macDa.arEther, damac, sizeof(damac)));
                    assert(0 == memcmp(mask->macDa.arEther, damask, sizeof(damask)));

                    assert(pattern->etherType == L_STDLIB_Hton16(ether_type));
                    assert(mask->etherType == L_STDLIB_Hton16(ether_type_mask));

                    assert(pattern->common.isL2Valid == 1);
                    assert(mask->common.isL2Valid == 1);
                }

                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);

                assert(CPSS_PACKET_CMD_TRAP_TO_CPU_E == action.pktCmd);
                assert(CPSS_NET_FIRST_USER_DEFINED_E == action.mirror.cpuCode);

                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
            }
        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

void
RULE_CTRL_UT_Proc_Set_My_Mac_Arp_Rule(
    BOOL_T enable_flag)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_MY_MAC_ARP;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    RULE_TYPE_PacketType_T packet_type = RULE_TYPE_PacketType_MY_MAC_ARP;

    BOOL_T b_result;

    b_result = RULE_CTRL_TrapPacket2Cpu(enable_flag, packet_type, NULL);
    assert(TRUE == b_result);

    memset(&interface, 0, sizeof(interface));
    interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
    interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);

    if (TRUE == enable_flag)
    {
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);
    }
    else
    {
        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_My_Mac_Arp_Rule(enable_flag,
                                               &interface,
                                               remapped_pkt_type,
                                               class_inst_p);
}

int
RULE_CTRL_UT_Set_Global_My_Mac_Arp_Rule()
{
#if (SYS_CPNT_ROUTING == TRUE)
    enum
    {
        MAX_RETRY = 2,
    };

    UI32_T retry;
    BOOL_T enable_flag;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        enable_flag = TRUE;

        RULE_CTRL_UT_Proc_Set_My_Mac_Arp_Rule(enable_flag);

        enable_flag = FALSE;

        RULE_CTRL_UT_Proc_Set_My_Mac_Arp_Rule(enable_flag);

        enable_flag = TRUE;

        RULE_CTRL_UT_Proc_Set_My_Mac_Arp_Rule(enable_flag);
    }

    enable_flag = TRUE;

    RULE_CTRL_UT_Proc_Set_My_Mac_Arp_Rule(enable_flag);
#endif // SYS_CPNT_ROUTING

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_Rip_Rule(
    BOOL_T enable_flag,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p)
{
    enum
    {
        UNIT = 1,
        RULE_CTRL_PORT_RIP = 520,
    };

    UI16_T l4_dst_port_data = RULE_CTRL_PORT_RIP;
    UI16_T l4_dst_port_mask = 0xffff;

    if (TRUE == enable_flag)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_L4_Dest_Port(&rule_entry_p->rule_pattern, l4_dst_port_data, l4_dst_port_mask);

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;

                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 == pce->policer_idx);

                result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                     remapped_pkt_type,
                                                                     &pcl_cfg);
                assert(RULE_TYPE_OK == result);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                b_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce);
                assert(TRUE == b_result);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    UI16_T tmp_data = L_STDLIB_Hton16(l4_dst_port_data);
                    UI16_T tmp_mask = L_STDLIB_Hton16(l4_dst_port_mask);

                    assert(pattern->common.isIp == 1);
                    assert(mask->common.isIp == 0xFF);
                    assert(pattern->commonExt.l4Byte2 == ((unsigned char *)&tmp_data)[0]);
                    assert(pattern->commonExt.l4Byte3 == ((unsigned char *)&tmp_data)[1]);
                    assert(mask->commonExt.l4Byte2 == ((unsigned char *)&tmp_mask)[0]);
                    assert(mask->commonExt.l4Byte3 == ((unsigned char *)&tmp_mask)[1]);

                    assert(pattern->commonExt.isL4Valid == 1);
                    assert(mask->commonExt.isL4Valid == 0xFF);
                }

                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);

                assert(CPSS_PACKET_CMD_MIRROR_TO_CPU_E == action.pktCmd);
                assert(CPSS_NET_FIRST_USER_DEFINED_E == action.mirror.cpuCode);

                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
            }
        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

void
RULE_CTRL_UT_Proc_Set_Rip_Rule(
    BOOL_T enable_flag)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_RIP;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    RULE_TYPE_PacketType_T packet_type = RULE_TYPE_PacketType_RIP;

    BOOL_T b_result;

    b_result = RULE_CTRL_TrapPacket2Cpu(enable_flag, packet_type, NULL);
    assert(TRUE == b_result);

    memset(&interface, 0, sizeof(interface));
    interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
    interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);

    if (TRUE == enable_flag)
    {
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);
    }
    else
    {
        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rip_Rule(enable_flag,
                                        &interface,
                                        remapped_pkt_type,
                                        class_inst_p);
}

int
RULE_CTRL_UT_Set_Global_Rip_Rule()
{
#if (SYS_CPNT_RIP == TRUE)
    enum
    {
        MAX_RETRY = 2,
    };

    UI32_T retry;
    BOOL_T enable_flag;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        enable_flag = TRUE;

        RULE_CTRL_UT_Proc_Set_Rip_Rule(enable_flag);

        enable_flag = FALSE;

        RULE_CTRL_UT_Proc_Set_Rip_Rule(enable_flag);

        enable_flag = TRUE;

        RULE_CTRL_UT_Proc_Set_Rip_Rule(enable_flag);
    }

    enable_flag = TRUE;

    RULE_CTRL_UT_Proc_Set_Rip_Rule(enable_flag);

#endif /* (SYS_CPNT_RIP == TRUE) */
    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_Igmp_Rule(
    BOOL_T enable_flag,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    BOOL_T flood,
    BOOL_T to_cpu)
{
    enum
    {
        UNIT = 1,
        RULE_CTRL_PROTOCOL_IGMP = 2
    };

    UI8_T protocol = RULE_CTRL_PROTOCOL_IGMP;

    if (TRUE == enable_flag)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Protocol(&rule_entry_p->rule_pattern, protocol, 0xff);

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;

                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 == pce->policer_idx);

                result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                     remapped_pkt_type,
                                                                     &pcl_cfg);
                assert(RULE_TYPE_OK == result);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                b_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce);
                assert(TRUE == b_result);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    assert(pattern->common.isIp == 1);
                    assert(mask->common.isIp == 0xFF);

                    assert(pattern->commonExt.ipProtocol == protocol);
                    assert(mask->commonExt.ipProtocol == 0xFF);
                }

                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);

                if (flood == TRUE && to_cpu == TRUE)
                {
                    assert(CPSS_PACKET_CMD_MIRROR_TO_CPU_E == action.pktCmd);
                    assert(CPSS_NET_FIRST_USER_DEFINED_E == action.mirror.cpuCode);
                }
                else if (flood == FALSE && to_cpu == TRUE)
                {
                    assert(CPSS_PACKET_CMD_TRAP_TO_CPU_E == action.pktCmd);
                    assert(CPSS_NET_FIRST_USER_DEFINED_E == action.mirror.cpuCode);
                }
                else if (flood == FALSE && to_cpu == FALSE)
                {
                    assert(CPSS_PACKET_CMD_DROP_HARD_E == action.pktCmd);
                }
                else
                {
                    assert(0);
                }

                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
            }
        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

void
RULE_CTRL_UT_Proc_Set_Igmp_Rule(
    BOOL_T enable_flag,
    BOOL_T flood,
    BOOL_T to_cpu)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_IGMP;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    RULE_TYPE_PacketType_T packet_type = RULE_TYPE_PacketType_IGMP;
    RULE_TYPE_CpuRuleInfo_T rule_info;

    BOOL_T b_result;

    rule_info.common.flood = flood;
    rule_info.common.to_cpu = to_cpu;

    b_result = RULE_CTRL_TrapPacket2Cpu(enable_flag, packet_type, &rule_info);
    assert(TRUE == b_result);

    memset(&interface, 0, sizeof(interface));
    interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
    interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);

    if (TRUE == enable_flag)
    {
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);
    }
    else
    {
        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Igmp_Rule(enable_flag,
                                         &interface,
                                         remapped_pkt_type,
                                         class_inst_p,
                                         flood,
                                         to_cpu);
}

int
RULE_CTRL_UT_Set_Global_Igmp_Rule()
{
    enum
    {
        MAX_RETRY = 2,
    };

    UI32_T retry;
    BOOL_T enable_flag;
    BOOL_T flood;
    BOOL_T to_cpu;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        enable_flag = TRUE;
        flood = FALSE;
        to_cpu = TRUE;

        RULE_CTRL_UT_Proc_Set_Igmp_Rule(enable_flag, flood, to_cpu);

        enable_flag = TRUE;
        flood = TRUE;
        to_cpu = TRUE;

        RULE_CTRL_UT_Proc_Set_Igmp_Rule(enable_flag, flood, to_cpu);

        enable_flag = TRUE;
        flood = FALSE;
        to_cpu = FALSE;

        RULE_CTRL_UT_Proc_Set_Igmp_Rule(enable_flag, flood, to_cpu);

        enable_flag = FALSE;
        flood = TRUE;
        to_cpu = FALSE;

        RULE_CTRL_UT_Proc_Set_Igmp_Rule(enable_flag, flood, to_cpu); // delete

        enable_flag = TRUE;
        flood = FALSE;
        to_cpu = TRUE;

        RULE_CTRL_UT_Proc_Set_Igmp_Rule(enable_flag, flood, to_cpu);
    }

    enable_flag = TRUE;
    flood = FALSE;
    to_cpu = TRUE;

    RULE_CTRL_UT_Proc_Set_Igmp_Rule(enable_flag, flood, to_cpu);

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_DhcpSnp_Rule(
    BOOL_T enable_flag,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    BOOL_T flood,
    BOOL_T to_cpu)
{
    enum
    {
        UNIT = 1,
        RULE_CTRL_PORT_DHCP_SERVER = 67,
        RULE_CTRL_PORT_DHCP_CLIENT = 68,
        RULE_CTRL_PORT_DHCP6_SERVER = 547,
        RULE_CTRL_PORT_DHCP6_CLIENT = 546,
    };

    UI16_T l4_dst_port_data;
    UI16_T l4_dst_port_mask;
    UI32_T cpu_code;
    UI8_T protocol = RULE_TYPE_ACL_UDP_PROTOCOL;

    switch (remapped_pkt_type)
    {
        case RULE_TYPE_PACKET_DHCP_CLIENT:
            l4_dst_port_data = RULE_CTRL_PORT_DHCP_SERVER;
            l4_dst_port_mask = 0xffff;
            cpu_code = SWDRV_PKTTYPE_DHCP_CLIENT;
            break;

        case RULE_TYPE_PACKET_DHCP_SERVER:
            l4_dst_port_data = RULE_CTRL_PORT_DHCP_CLIENT;
            l4_dst_port_mask = 0xffff;
            cpu_code = SWDRV_PKTTYPE_DHCP_SERVER;
            break;

        case RULE_TYPE_PACKET_DHCP6_CLIENT:
            l4_dst_port_data = RULE_CTRL_PORT_DHCP6_SERVER;
            l4_dst_port_mask = 0xffff;
            cpu_code = SWDRV_PKTTYPE_DHCP6_CLIENT;
            break;

        case RULE_TYPE_PACKET_DHCP6_SERVER:
            l4_dst_port_data = RULE_CTRL_PORT_DHCP6_CLIENT;
            l4_dst_port_mask = 0xffff;
            cpu_code = SWDRV_PKTTYPE_DHCP6_SERVER;
            break;

        default:
            assert(0);
    }

    if (TRUE == enable_flag)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            if (RULE_TYPE_PACKET_DHCP_CLIENT == remapped_pkt_type ||
                RULE_TYPE_PACKET_DHCP_SERVER == remapped_pkt_type)
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip(&rule_entry_p->rule_pattern);
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_IpFragment(&rule_entry_p->rule_pattern, 0, 0Xff);
            }
            else
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6(&rule_entry_p->rule_pattern);
            }

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_L4_Dest_Port(&rule_entry_p->rule_pattern, l4_dst_port_data, l4_dst_port_mask);
            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Protocol(&rule_entry_p->rule_pattern, protocol, 0xff);

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;

                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 == pce->policer_idx);

                result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                     remapped_pkt_type,
                                                                     &pcl_cfg);
                assert(RULE_TYPE_OK == result);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                b_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce);
                assert(TRUE == b_result);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                if (RULE_TYPE_PACKET_DHCP_CLIENT == remapped_pkt_type ||
                    RULE_TYPE_PACKET_DHCP_SERVER == remapped_pkt_type)
                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    UI16_T tmp_data = L_STDLIB_Hton16(l4_dst_port_data);
                    UI16_T tmp_mask = L_STDLIB_Hton16(l4_dst_port_mask);

                    assert(pattern->common.isIp == 1);
                    assert(mask->common.isIp == 0xFF);
                    assert(pattern->commonExt.l4Byte2 == ((unsigned char *)&tmp_data)[0]);
                    assert(pattern->commonExt.l4Byte3 == ((unsigned char *)&tmp_data)[1]);
                    assert(mask->commonExt.l4Byte2 == ((unsigned char *)&tmp_mask)[0]);
                    assert(mask->commonExt.l4Byte3 == ((unsigned char *)&tmp_mask)[1]);

                    assert(pattern->commonExt.ipProtocol == protocol);
                    assert(mask->commonExt.ipProtocol == 0xFF);

                    assert(pattern->commonExt.isL4Valid == 1);
                    assert(mask->commonExt.isL4Valid == 0xFF);

                    assert(pattern->ipv4Fragmented == 0);
                    assert(mask->ipv4Fragmented == 0xFF);
                }
                else
                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_IPV6_L2_STC *mask = &mask_u.ruleExtIpv6L2;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_IPV6_L2_STC *pattern = &pattern_u.ruleExtIpv6L2;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    UI16_T tmp_data = L_STDLIB_Hton16(l4_dst_port_data);
                    UI16_T tmp_mask = L_STDLIB_Hton16(l4_dst_port_mask);

                    assert(pattern->commonExt.isIpv6 == 1);
                    assert(mask->commonExt.isIpv6 == 0xFF);
                    assert(pattern->commonExt.l4Byte2 == ((unsigned char *)&tmp_data)[0]);
                    assert(pattern->commonExt.l4Byte3 == ((unsigned char *)&tmp_data)[1]);
                    assert(mask->commonExt.l4Byte2 == ((unsigned char *)&tmp_mask)[0]);
                    assert(mask->commonExt.l4Byte3 == ((unsigned char *)&tmp_mask)[1]);

                    assert(pattern->commonExt.ipProtocol == protocol);
                    assert(mask->commonExt.ipProtocol == 0xFF);
                }

                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);

                if (flood == TRUE && to_cpu == TRUE)
                {
                    assert(CPSS_PACKET_CMD_MIRROR_TO_CPU_E == action.pktCmd);
                    assert(CPSS_NET_FIRST_USER_DEFINED_E + cpu_code  == action.mirror.cpuCode);
                }
                else if (flood == FALSE && to_cpu == TRUE)
                {
                    assert(CPSS_PACKET_CMD_TRAP_TO_CPU_E == action.pktCmd);
                    assert(CPSS_NET_FIRST_USER_DEFINED_E + cpu_code  == action.mirror.cpuCode);
                }
                else if (flood == FALSE && to_cpu == FALSE)
                {
                    assert(CPSS_PACKET_CMD_DROP_HARD_E == action.pktCmd);
                }
                else
                {
                    assert(0);
                }

                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
            }
        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

void
RULE_CTRL_UT_Proc_Set_DhcpSnp_Rule(
    RULE_TYPE_PacketType_T packet_type,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    BOOL_T enable_flag,
    BOOL_T flood,
    BOOL_T to_cpu)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    RULE_TYPE_CpuRuleInfo_T rule_info;

    BOOL_T b_result;

    rule_info.common.flood = flood;
    rule_info.common.to_cpu = to_cpu;

    b_result = RULE_CTRL_TrapPacket2Cpu(enable_flag, packet_type, &rule_info);
    assert(TRUE == b_result);

    memset(&interface, 0, sizeof(interface));
    interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
    interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);

    if (TRUE == enable_flag)
    {
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);
    }
    else
    {
        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_DhcpSnp_Rule(enable_flag,
                                            &interface,
                                            remapped_pkt_type,
                                            class_inst_p,
                                            flood,
                                            to_cpu);
}

int
RULE_CTRL_UT_Set_Global_DhcpSnp_Rule()
{
    enum
    {
        MAX_RETRY = 2,
    };

    UI32_T retry;
    BOOL_T enable_flag;
    BOOL_T flood;
    BOOL_T to_cpu;

    UI32_T i;

    struct ABC
    {
        RULE_TYPE_PacketType_T packet_type;
        RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type;
    } dhcp_snp_rule[] =
    {
#if (SYS_CPNT_DHCPSNP == TRUE)
        {RULE_TYPE_PacketType_DHCP_CLIENT, RULE_TYPE_PACKET_DHCP_CLIENT},
        {RULE_TYPE_PacketType_DHCP_SERVER, RULE_TYPE_PACKET_DHCP_SERVER},
#endif // SYS_CPNT_DHCPSNP

#if (SYS_CPNT_DHCPV6SNP == TRUE)
        {RULE_TYPE_PacketType_DHCP6_CLIENT, RULE_TYPE_PACKET_DHCP6_CLIENT},
        {RULE_TYPE_PacketType_DHCP6_SERVER, RULE_TYPE_PACKET_DHCP6_SERVER}
#endif // SYS_CPNT_DHCPV6SNP
    };

    for (i = 0; i < _countof(dhcp_snp_rule); ++ i)
    {
        RULE_TYPE_PacketType_T packet_type = dhcp_snp_rule[i].packet_type;
        RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = dhcp_snp_rule[i].remapped_pkt_type;

        for (retry = 1; retry <= MAX_RETRY; ++ retry)
        {
            enable_flag = TRUE;
            flood = FALSE;
            to_cpu = TRUE;

            RULE_CTRL_UT_Proc_Set_DhcpSnp_Rule(packet_type, remapped_pkt_type, enable_flag, flood, to_cpu);

            enable_flag = TRUE;
            flood = TRUE;
            to_cpu = TRUE;

            RULE_CTRL_UT_Proc_Set_DhcpSnp_Rule(packet_type, remapped_pkt_type, enable_flag, flood, to_cpu);

            enable_flag = TRUE;
            flood = FALSE;
            to_cpu = FALSE;

            RULE_CTRL_UT_Proc_Set_DhcpSnp_Rule(packet_type, remapped_pkt_type, enable_flag, flood, to_cpu);

            enable_flag = FALSE;
            flood = TRUE;
            to_cpu = FALSE;

            RULE_CTRL_UT_Proc_Set_DhcpSnp_Rule(packet_type, remapped_pkt_type, enable_flag, flood, to_cpu); // delete

            enable_flag = TRUE;
            flood = FALSE;
            to_cpu = TRUE;

            RULE_CTRL_UT_Proc_Set_DhcpSnp_Rule(packet_type, remapped_pkt_type, enable_flag, flood, to_cpu);
        }

        enable_flag = TRUE;
        flood = FALSE;
        to_cpu = TRUE;

        RULE_CTRL_UT_Proc_Set_DhcpSnp_Rule(packet_type, remapped_pkt_type, enable_flag, flood, to_cpu);
    }

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_Pvst_Rule(
    BOOL_T enable_flag,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    BOOL_T flood,
    BOOL_T to_cpu)
{
    enum
    {
        UNIT = 1
    };

    UI8_T damac[] = {0x01, 0x00, 0x0c, 0xcc, 0xcc, 0xcd};
    UI8_T damask[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    if (TRUE == enable_flag)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Dest_Mac_Address(&rule_entry_p->rule_pattern, damac, damask);

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;

                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 == pce->policer_idx);

                result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                     remapped_pkt_type,
                                                                     &pcl_cfg);
                assert(RULE_TYPE_OK == result);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                b_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce);
                assert(TRUE == b_result);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    assert(0 == memcmp(pattern->macDa.arEther, damac, sizeof(damac)));
                    assert(0 == memcmp(mask->macDa.arEther, damask, sizeof(damask)));
                }

                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);

                if (flood == TRUE && to_cpu == TRUE)
                {
                    assert(CPSS_PACKET_CMD_MIRROR_TO_CPU_E == action.pktCmd);
                    assert(CPSS_NET_FIRST_USER_DEFINED_E == action.mirror.cpuCode);
                }
                else if (flood == FALSE && to_cpu == TRUE)
                {
                    assert(CPSS_PACKET_CMD_TRAP_TO_CPU_E == action.pktCmd);
                    assert(CPSS_NET_FIRST_USER_DEFINED_E == action.mirror.cpuCode);
                }
                else if (flood == FALSE && to_cpu == FALSE)
                {
                    assert(CPSS_PACKET_CMD_DROP_HARD_E == action.pktCmd);
                }
                else
                {
                    assert(0);
                }

                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
            }
        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

void
RULE_CTRL_UT_Proc_Set_Pvst_Rule(
    BOOL_T enable_flag,
    BOOL_T flood,
    BOOL_T to_cpu)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_PVST;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    RULE_TYPE_PacketType_T packet_type = RULE_TYPE_PacketType_PVST;
    RULE_TYPE_CpuRuleInfo_T rule_info;

    BOOL_T b_result;

    rule_info.common.flood = flood;
    rule_info.common.to_cpu = to_cpu;

    b_result = RULE_CTRL_TrapPacket2Cpu(enable_flag, packet_type, &rule_info);
    assert(TRUE == b_result);

    memset(&interface, 0, sizeof(interface));
    interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
    interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);

    if (TRUE == enable_flag)
    {
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);
    }
    else
    {
        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Pvst_Rule(enable_flag,
                                         &interface,
                                         remapped_pkt_type,
                                         class_inst_p,
                                         flood,
                                         to_cpu);
}

int
RULE_CTRL_UT_Set_Global_Pvst_Rule()
{
#if (SYS_CPNT_QINQ_L2PT_PVST == TRUE)
    enum
    {
        MAX_RETRY = 2,
    };

    UI32_T retry;
    BOOL_T enable_flag;
    BOOL_T flood;
    BOOL_T to_cpu;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        enable_flag = TRUE;
        flood = FALSE;
        to_cpu = TRUE;

        RULE_CTRL_UT_Proc_Set_Pvst_Rule(enable_flag, flood, to_cpu);

        enable_flag = TRUE;
        flood = TRUE;
        to_cpu = TRUE;

        RULE_CTRL_UT_Proc_Set_Pvst_Rule(enable_flag, flood, to_cpu);

        enable_flag = TRUE;
        flood = FALSE;
        to_cpu = FALSE;

        RULE_CTRL_UT_Proc_Set_Pvst_Rule(enable_flag, flood, to_cpu);

        enable_flag = FALSE;
        flood = TRUE;
        to_cpu = FALSE;

        RULE_CTRL_UT_Proc_Set_Pvst_Rule(enable_flag, flood, to_cpu); // delete

        enable_flag = TRUE;
        flood = FALSE;
        to_cpu = TRUE;

        RULE_CTRL_UT_Proc_Set_Pvst_Rule(enable_flag, flood, to_cpu);
    }

    enable_flag = TRUE;
    flood = FALSE;
    to_cpu = TRUE;

    RULE_CTRL_UT_Proc_Set_Pvst_Rule(enable_flag, flood, to_cpu);
#else
    assert(0);
#endif

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_Cdp_Rule(
    BOOL_T enable_flag,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    BOOL_T flood,
    BOOL_T to_cpu)
{
    enum
    {
        UNIT = 1
    };

    UI8_T damac[] = {0x01, 0x00, 0x0c, 0xcc, 0xcc, 0xcc};
    UI8_T damask[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    if (TRUE == enable_flag)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Dest_Mac_Address(&rule_entry_p->rule_pattern, damac, damask);

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;

                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 == pce->policer_idx);

                result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                     remapped_pkt_type,
                                                                     &pcl_cfg);
                assert(RULE_TYPE_OK == result);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                b_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce);
                assert(TRUE == b_result);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    assert(0 == memcmp(pattern->macDa.arEther, damac, sizeof(damac)));
                    assert(0 == memcmp(mask->macDa.arEther, damask, sizeof(damask)));
                }

                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);

                if (flood == TRUE && to_cpu == TRUE)
                {
                    assert(CPSS_PACKET_CMD_MIRROR_TO_CPU_E == action.pktCmd);
                    assert(CPSS_NET_FIRST_USER_DEFINED_E == action.mirror.cpuCode);
                }
                else if (flood == FALSE && to_cpu == TRUE)
                {
                    assert(CPSS_PACKET_CMD_TRAP_TO_CPU_E == action.pktCmd);
                    assert(CPSS_NET_FIRST_USER_DEFINED_E == action.mirror.cpuCode);
                }
                else if (flood == FALSE && to_cpu == FALSE)
                {
                    assert(CPSS_PACKET_CMD_DROP_HARD_E == action.pktCmd);
                }
                else
                {
                    assert(0);
                }

                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);

            }
        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

void
RULE_CTRL_UT_Proc_Set_Cdp_Rule(
    BOOL_T enable_flag,
    BOOL_T flood,
    BOOL_T to_cpu)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_CDP;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    RULE_TYPE_PacketType_T packet_type = RULE_TYPE_PacketType_CDP;
    RULE_TYPE_CpuRuleInfo_T rule_info;

    BOOL_T b_result;

    rule_info.common.flood = flood;
    rule_info.common.to_cpu = to_cpu;

    b_result = RULE_CTRL_TrapPacket2Cpu(enable_flag, packet_type, &rule_info);
    assert(TRUE == b_result);

    memset(&interface, 0, sizeof(interface));
    interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
    interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);

    if (TRUE == enable_flag)
    {
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);
    }
    else
    {
        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Cdp_Rule(enable_flag,
                                        &interface,
                                        remapped_pkt_type,
                                        class_inst_p,
                                        flood,
                                        to_cpu);
}

int
RULE_CTRL_UT_Set_Global_Cdp_Rule()
{
#if (SYS_CPNT_QINQ_L2PT_CDP == TRUE) || (SYS_CPNT_QINQ_L2PT_VTP == TRUE)
    enum
    {
        MAX_RETRY = 2,
    };

    UI32_T retry;
    BOOL_T enable;
    BOOL_T flood;
    BOOL_T to_cpu;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        enable = TRUE;
        flood = FALSE;
        to_cpu = TRUE;

        RULE_CTRL_UT_Proc_Set_Cdp_Rule(enable, flood, to_cpu);

        enable = TRUE;
        flood = TRUE;
        to_cpu = TRUE;

        RULE_CTRL_UT_Proc_Set_Cdp_Rule(enable, flood, to_cpu);

        enable = TRUE;
        flood = FALSE;
        to_cpu = FALSE;

        RULE_CTRL_UT_Proc_Set_Cdp_Rule(enable, flood, to_cpu);

        enable = FALSE;
        flood = TRUE;
        to_cpu = FALSE;
        RULE_CTRL_UT_Proc_Set_Cdp_Rule(enable, flood, to_cpu);  // delete

        enable = TRUE;
        flood = FALSE;
        to_cpu = TRUE;
        RULE_CTRL_UT_Proc_Set_Cdp_Rule(enable, flood, to_cpu);
    }

    enable = TRUE;
    flood = FALSE;
    to_cpu = TRUE;
    RULE_CTRL_UT_Proc_Set_Cdp_Rule(enable, flood, to_cpu);
#else
    assert(0);
#endif // SYS_CPNT_QINQ_L2PT_CDP || SYS_CPNT_QINQ_L2PT_VTP

    return 0;
}

int
RULE_CTRL_UT_Set_Global_Pvst_Cdp_Mixed_Rule()
{
#if (SYS_CPNT_QINQ_L2PT_PVST == TRUE) && ((SYS_CPNT_QINQ_L2PT_CDP == TRUE) || \
    (SYS_CPNT_QINQ_L2PT_VTP == TRUE))

    enum
    {
        MAX_RETRY = 2,
    };

    UI32_T retry;
    BOOL_T enable;
    BOOL_T flood;
    BOOL_T to_cpu;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        enable = TRUE;
        flood = FALSE;
        to_cpu = TRUE;
        RULE_CTRL_UT_Proc_Set_Pvst_Rule(enable, flood, to_cpu);
        RULE_CTRL_UT_Proc_Set_Cdp_Rule(enable, flood, to_cpu);

        enable = TRUE;
        flood = TRUE;
        to_cpu = TRUE;
        RULE_CTRL_UT_Proc_Set_Pvst_Rule(enable, flood, to_cpu);
        RULE_CTRL_UT_Proc_Set_Cdp_Rule(enable, flood, to_cpu);

        enable = TRUE;
        flood = FALSE;
        to_cpu = FALSE;
        RULE_CTRL_UT_Proc_Set_Pvst_Rule(enable, flood, to_cpu);
        RULE_CTRL_UT_Proc_Set_Cdp_Rule(enable, flood, to_cpu);

        enable = FALSE;
        flood = TRUE;
        to_cpu = FALSE;
        RULE_CTRL_UT_Proc_Set_Pvst_Rule(enable, flood, to_cpu);   // delete
        RULE_CTRL_UT_Proc_Set_Cdp_Rule(enable, flood, to_cpu);    // delete
    }

    enable = TRUE;
    flood = FALSE;
    to_cpu = TRUE;
    RULE_CTRL_UT_Proc_Set_Pvst_Rule(enable, flood, to_cpu);
    RULE_CTRL_UT_Proc_Set_Cdp_Rule(enable, flood, to_cpu);

#else
    assert(0);
#endif

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_Dos_Echo_Chargen_Rule(
    BOOL_T enable_flag,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    UI32_T rate)
{
    enum
    {
        UNIT = 1
    };

    UI16_T l4_dst_port_data;
    UI16_T l4_dst_port_mask;

    assert(RULE_TYPE_PACKET_DOS_CHARGEN == remapped_pkt_type ||
           RULE_TYPE_PACKET_DOS_ECHO == remapped_pkt_type);

    if (RULE_TYPE_PACKET_DOS_CHARGEN == remapped_pkt_type)
    {
        l4_dst_port_data = 19;
        l4_dst_port_mask = 0xffff;
    }
    else if (RULE_TYPE_PACKET_DOS_ECHO == remapped_pkt_type)
    {
        l4_dst_port_data = 7;
        l4_dst_port_mask = 0xffff;
    }
    else
    {
        assert(0);
    }

    if (TRUE == enable_flag)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_L4_Dest_Port(&rule_entry_p->rule_pattern, l4_dst_port_data, l4_dst_port_mask);

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;

                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;
                CPSS_DXCH3_POLICER_METERING_ENTRY_STC meter;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 != pce->policer_idx);

                result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                     remapped_pkt_type,
                                                                     &pcl_cfg);
                assert(RULE_TYPE_OK == result);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                b_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce);
                assert(TRUE == b_result);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    if (RULE_TYPE_PACKET_DOS_CHARGEN == remapped_pkt_type ||
                        RULE_TYPE_PACKET_DOS_ECHO == remapped_pkt_type)
                    {
                        UI16_T tmp_data = L_STDLIB_Hton16(l4_dst_port_data);
                        UI16_T tmp_mask = L_STDLIB_Hton16(l4_dst_port_mask);

                        assert(pattern->common.isIp == 1);
                        assert(mask->common.isIp == 0xFF);
                        assert(pattern->commonExt.l4Byte2 == ((unsigned char *)&tmp_data)[0]);
                        assert(pattern->commonExt.l4Byte3 == ((unsigned char *)&tmp_data)[1]);
                        assert(mask->commonExt.l4Byte2 == ((unsigned char *)&tmp_mask)[0]);
                        assert(mask->commonExt.l4Byte3 == ((unsigned char *)&tmp_mask)[1]);
                        assert(pattern->commonExt.isL4Valid == 1);
                        assert(mask->commonExt.isL4Valid == 0xFF);
                    }
                    else
                    {
                        // TODO: Add others DOS cases here
                        assert(0);
                    }
                }

                assert(CPSS_PACKET_CMD_FORWARD_E == action.pktCmd);
                assert(-1 != pce->policer_idx && (UI32_T)pce->policer_idx == action.policer.policerId);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Meter(rule_inst_p->dev_rule_info.device,
                                                         pce,
                                                         &meter);
                assert(RULE_TYPE_OK == result);
                assert(CPSS_POLICER_COLOR_BLIND_E == meter.meterColorMode);
                assert(rate == meter.tokenBucketParams.srTcmParams.cir);

                assert(CPSS_DXCH3_POLICER_NON_CONFORM_CMD_DROP_E == meter.redPcktCmd);
                assert(CPSS_DXCH3_POLICER_NON_CONFORM_CMD_NO_CHANGE_E == meter.yellowPcktCmd);

                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
            }
        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

int
RULE_CTRL_UT_Set_Global_Dos_Echo_Chargen_Rule()
{
#if (SYS_CPNT_DOS_ECHO_CHARGEN == TRUE)
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T swdrv_type = SWDRV_DOS_RATELIMIT_ECHO_CHARGEN;

    UI32_T rate_ar[] = {200, 300, 200, 0, 200, 300, 0, 200};

    UI32_T i;

    BOOL_T enable_flag;
    BOOL_T b_result;

    for (i = 0; i < _countof(rate_ar); ++i)
    {
        UI32_T rate = rate_ar[i];

        b_result = RULE_CTRL_SetDosProtectionRateLimit(swdrv_type, rate);
        assert(TRUE == b_result);

//        RULE_CTRL_DumpGlobalAce_BackDoor();

        //
        // Echo
        //
        remapped_pkt_type = RULE_TYPE_PACKET_DOS_ECHO;

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        enable_flag = (0 < rate) ? TRUE : FALSE;

        if (TRUE == enable_flag)
        {
            assert(RULE_TYPE_OK == result);
            assert(NULL != class_inst_p);
        }
        else
        {
            assert(RULE_TYPE_OK != result);
            assert(NULL == class_inst_p);
        }

        RULE_CTRL_UT_Proc_Validate_Dos_Echo_Chargen_Rule(enable_flag,
                                                         &interface,
                                                         remapped_pkt_type,
                                                         class_inst_p,
                                                         rate);

        //
        // Chargen
        //
        remapped_pkt_type = RULE_TYPE_PACKET_DOS_CHARGEN;

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        enable_flag = (0 < rate) ? TRUE : FALSE;

        if (TRUE == enable_flag)
        {
            assert(RULE_TYPE_OK == result);
            assert(NULL != class_inst_p);
        }
        else
        {
            assert(RULE_TYPE_OK != result);
            assert(NULL == class_inst_p);
        }

        RULE_CTRL_UT_Proc_Validate_Dos_Echo_Chargen_Rule(enable_flag,
                                                         &interface,
                                                         remapped_pkt_type,
                                                         class_inst_p,
                                                         rate);
    }

#endif // SYS_CPNT_DOS_ECHO_CHARGEN
    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_Dos_Rule(
    BOOL_T enable_flag,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    UI32_T rate)
{
#define RULE_CTRL_PROTOCOL_TCP           6
#define RULE_CTRL_PROTOCOL_UDP           17

#define RULE_CTRL_TCP_FLAG_SYN           BIT_1
#define RULE_CTRL_TCP_FLAG_URG           BIT_5

#define RULE_CTRL_PORT_NBSS              139

    enum
    {
        UNIT = 1
    };

    assert(remapped_pkt_type == RULE_TYPE_PACKET_DOS_TCP_FLOODING ||
           remapped_pkt_type == RULE_TYPE_PACKET_DOS_UDP_FLOODING ||
           remapped_pkt_type == RULE_TYPE_PACKET_DOS_WIN_NUKE);

    if (TRUE == enable_flag)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            if (RULE_TYPE_PACKET_DOS_TCP_FLOODING == remapped_pkt_type)
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip(&rule_entry_p->rule_pattern);
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Tcp_Control_Flags(&rule_entry_p->rule_pattern,
                                                                          RULE_CTRL_TCP_FLAG_SYN, RULE_CTRL_TCP_FLAG_SYN);
            }
            else if (RULE_TYPE_PACKET_DOS_UDP_FLOODING == remapped_pkt_type)
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip(&rule_entry_p->rule_pattern);
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Udp(&rule_entry_p->rule_pattern);
            }
            else if (RULE_TYPE_PACKET_DOS_WIN_NUKE == remapped_pkt_type)
            {
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip(&rule_entry_p->rule_pattern);
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_L4_Dest_Port(&rule_entry_p->rule_pattern, RULE_CTRL_PORT_NBSS, 0xffff);
                RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Tcp_Control_Flags(&rule_entry_p->rule_pattern,
                                                                          RULE_CTRL_TCP_FLAG_URG, RULE_CTRL_TCP_FLAG_URG);
            }
            else
            {
                assert(0);
            }

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;

                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;
                CPSS_DXCH3_POLICER_METERING_ENTRY_STC meter;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 != pce->policer_idx);

                result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                     remapped_pkt_type,
                                                                     &pcl_cfg);
                assert(RULE_TYPE_OK == result);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                b_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce);
                assert(TRUE == b_result);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);


                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    if (RULE_TYPE_PACKET_DOS_TCP_FLOODING == remapped_pkt_type)
                    {
                        assert(pattern->commonExt.ipProtocol == RULE_CTRL_PROTOCOL_TCP);
                        assert(mask->commonExt.ipProtocol == 0xff);

                        assert(RULE_CTRL_TCP_FLAG_SYN == pattern->commonExt.l4Byte13);
                        assert(RULE_CTRL_TCP_FLAG_SYN == mask->commonExt.l4Byte13);

                        assert(pattern->commonExt.isL4Valid == 1);
                        assert(mask->commonExt.isL4Valid == 0xFF);
                    }
                    else if (RULE_TYPE_PACKET_DOS_UDP_FLOODING == remapped_pkt_type)
                    {
                        assert(pattern->commonExt.ipProtocol == RULE_CTRL_PROTOCOL_UDP);
                        assert(mask->commonExt.ipProtocol == 0xff);
                    }
                    else if (RULE_TYPE_PACKET_DOS_WIN_NUKE == remapped_pkt_type)
                    {
                        UI16_T tmp_data = L_STDLIB_Hton16(RULE_CTRL_PORT_NBSS);
                        UI16_T tmp_mask = L_STDLIB_Hton16(0xffff);

                        assert(pattern->commonExt.ipProtocol == RULE_CTRL_PROTOCOL_TCP);
                        assert(mask->commonExt.ipProtocol == 0xff);

                        assert(pattern->commonExt.l4Byte2 == ((unsigned char *)&tmp_data)[0]);
                        assert(pattern->commonExt.l4Byte3 == ((unsigned char *)&tmp_data)[1]);
                        assert(mask->commonExt.l4Byte2 == ((unsigned char *)&tmp_mask)[0]);
                        assert(mask->commonExt.l4Byte3 == ((unsigned char *)&tmp_mask)[1]);
                    }

                    assert(pattern->common.isIp == 1);
                    assert(mask->common.isIp == 0xFF);
                }

                assert(CPSS_PACKET_CMD_FORWARD_E == action.pktCmd);
                assert(-1 != pce->policer_idx && (UI32_T)pce->policer_idx == action.policer.policerId);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Meter(rule_inst_p->dev_rule_info.device,
                                                         pce,
                                                         &meter);
                assert(RULE_TYPE_OK == result);
                assert(CPSS_POLICER_COLOR_BLIND_E == meter.meterColorMode);
                assert(rate == meter.tokenBucketParams.srTcmParams.cir);

                assert(CPSS_DXCH3_POLICER_NON_CONFORM_CMD_DROP_E == meter.redPcktCmd);
                assert(CPSS_DXCH3_POLICER_NON_CONFORM_CMD_NO_CHANGE_E == meter.yellowPcktCmd);

                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
            }
        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();

#undef RULE_CTRL_PROTOCOL_TCP
#undef RULE_CTRL_PROTOCOL_UDP

#undef RULE_CTRL_TCP_FLAG_SYN
#undef RULE_CTRL_TCP_FLAG_URG

#undef RULE_CTRL_PORT_NBSS
}

void
RULE_CTRL_UT_Proc_Set_Dos_Tcp_Flooding_Rule(
    UI32_T rate)
{
#if (SYS_CPNT_DOS_TCP_FLOODING == TRUE)
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_DOS_TCP_FLOODING;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T swdrv_type = SWDRV_DOS_RATELIMIT_TCP_FLOODING;

    BOOL_T enable_flag;
    BOOL_T b_result;

    b_result = RULE_CTRL_SetDosProtectionRateLimit(swdrv_type, rate);
    assert(TRUE == b_result);

    memset(&interface, 0, sizeof(interface));
    interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
    interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);

    enable_flag = (0 < rate) ? TRUE : FALSE;

    if (TRUE == enable_flag)
    {
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);
    }
    else
    {
        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Dos_Rule(enable_flag,
                                        &interface,
                                        remapped_pkt_type,
                                        class_inst_p,
                                        rate);
#else
    assert(0);
#endif
}

void
RULE_CTRL_UT_Proc_Set_Dos_Udp_Flooding_Rule(
    UI32_T rate)
{
#if (SYS_CPNT_DOS_UDP_FLOODING == TRUE)
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_DOS_UDP_FLOODING;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T swdrv_type = SWDRV_DOS_RATELIMIT_UDP_FLOODING;

    BOOL_T enable_flag;
    BOOL_T b_result;

    b_result = RULE_CTRL_SetDosProtectionRateLimit(swdrv_type, rate);
    assert(TRUE == b_result);

    memset(&interface, 0, sizeof(interface));
    interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
    interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);

    enable_flag = (0 < rate) ? TRUE : FALSE;

    if (TRUE == enable_flag)
    {
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);
    }
    else
    {
        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Dos_Rule(enable_flag,
                                        &interface,
                                        remapped_pkt_type,
                                        class_inst_p,
                                        rate);
#else
    assert(0);
#endif
}

int
RULE_CTRL_UT_Set_Global_Dos_Tcp_Udp_Flooding_Mixed_Rule()
{
#if (SYS_CPNT_DOS == TRUE)
    UI32_T rate;

    rate = 100;
    RULE_CTRL_UT_Proc_Set_Dos_Tcp_Flooding_Rule(rate);

    rate = 0;
    RULE_CTRL_UT_Proc_Set_Dos_Tcp_Flooding_Rule(rate);

    rate = 100;
    RULE_CTRL_UT_Proc_Set_Dos_Tcp_Flooding_Rule(rate);

    rate = 200;
    RULE_CTRL_UT_Proc_Set_Dos_Tcp_Flooding_Rule(rate);

    rate = 500;
    RULE_CTRL_UT_Proc_Set_Dos_Udp_Flooding_Rule(rate);

    rate = 0;
    RULE_CTRL_UT_Proc_Set_Dos_Tcp_Flooding_Rule(rate);

    rate = 100;
    RULE_CTRL_UT_Proc_Set_Dos_Tcp_Flooding_Rule(rate);

#else
    assert(0);
#endif
    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_Mvr_Receiver_Vlan_Rule(
    BOOL_T is_enable,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    UI16_T src_vid,
    UI32_T src_mip,
    UI16_T dst_vid)
{
    enum
    {
        UNIT = 1
    };

    if (TRUE == is_enable)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Vlan(&rule_entry_p->rule_pattern, src_vid, 0xffff);
            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Dest_Address(&rule_entry_p->rule_pattern, src_mip, 0xffffffff);

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;
                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 == pce->policer_idx);

                result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                     remapped_pkt_type,
                                                                     &pcl_cfg);
                assert(RULE_TYPE_OK == result);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                b_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce);
                assert(TRUE == b_result);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    assert(L_STDLIB_Hton16(src_vid & 0x0fff) == pattern->common.vid);
                    assert(L_STDLIB_Hton16(0xffffffff & 0x0fff) == mask->common.vid);

                    assert(L_STDLIB_Hton16(0x0800) == pattern->etherType);
                    assert(L_STDLIB_Hton16(0xffff) == mask->etherType);

                    assert(L_STDLIB_Hton32(src_mip) == pattern->dip.u32Ip);
                    assert(L_STDLIB_Hton32(0xffffffff) == mask->dip.u32Ip);
                }

                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);
                assert(CPSS_PACKET_CMD_FORWARD_E == action.pktCmd);

                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E == action.vlan.modifyVlan);
                assert(dst_vid == action.vlan.vlanId);
                assert(GT_FALSE == action.vlan.nestedVlan);

                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
            }
        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

void
RULE_CTRL_UT_Proc_Set_Mvr_Receiver_Vlan_Rule(
    BOOL_T is_enable,
    UI16_T src_vid,
    UI32_T src_mip,
    UI16_T dst_vid)
{
    BOOL_T b_result;

    if (TRUE == is_enable)
    {
        b_result = RULE_CTRL_SetMvrRecVlanEntry(src_vid, src_mip, dst_vid);
        assert(TRUE == b_result);
    }
    else
    {
        b_result = RULE_CTRL_DeleteMvrRecVlanEntry(src_vid, src_mip);
        assert(TRUE == b_result);
    }
}

int
RULE_CTRL_UT_Set_Global_Mvr_Receiver_Vlan_Rule()
{
    enum
    {
        MAX_RETRY = 2,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_MVR_REC_VLAN;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;

    UI16_T src_vid;
    UI32_T src_mip;

    UI16_T dst_vid;

    UI32_T i;

    BOOL_T is_enable;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        //
        // Create rule
        //

        is_enable = TRUE;

        src_vid = 100;
        src_mip = 0x01020304;
        dst_vid = 200;

        RULE_CTRL_UT_Proc_Set_Mvr_Receiver_Vlan_Rule(is_enable, src_vid, src_mip, dst_vid);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Mvr_Receiver_Vlan_Rule(is_enable,
                                                          &interface,
                                                          remapped_pkt_type,
                                                          class_inst_p,
                                                          src_vid,
                                                          src_mip,
                                                          dst_vid);

        //
        // Update rule
        //

        is_enable = TRUE;

        dst_vid = 300;

        RULE_CTRL_UT_Proc_Set_Mvr_Receiver_Vlan_Rule(is_enable, src_vid, src_mip, dst_vid);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Mvr_Receiver_Vlan_Rule(is_enable,
                                                          &interface,
                                                          remapped_pkt_type,
                                                          class_inst_p,
                                                          src_vid,
                                                          src_mip,
                                                          dst_vid);

        //
        // Remove rule
        //

        is_enable = FALSE;
        RULE_CTRL_UT_Proc_Set_Mvr_Receiver_Vlan_Rule(is_enable, src_vid, src_mip, dst_vid);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Mvr_Receiver_Vlan_Rule(is_enable,
                                                          &interface,
                                                          remapped_pkt_type,
                                                          class_inst_p,
                                                          src_vid,
                                                          src_mip,
                                                          dst_vid);

        //
        // capacity test
        //

        class_inst_p = NULL;

        for (i = 0; i < SYS_ADPT_MVR_MAX_NBR_OF_RECEIVER_GROUPS; ++ i)
        {
            is_enable = TRUE;

            src_vid = 1000 + i;
            src_mip = 10 + i;
            dst_vid = 200;

            RULE_CTRL_UT_Proc_Set_Mvr_Receiver_Vlan_Rule(is_enable, src_vid, src_mip, dst_vid);

            // RULE_CTRL_DumpGlobalAce_BackDoor();

            result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                      remapped_pkt_type,
                                                                      RULE_TYPE_INST_CPU_IF,
                                                                      remapped_pkt_type,
                                                                      &class_inst_p);

            assert(RULE_TYPE_OK == result);
            assert(NULL != class_inst_p);

            RULE_CTRL_UT_Proc_Validate_Mvr_Receiver_Vlan_Rule(is_enable,
                                                              &interface,
                                                              remapped_pkt_type,
                                                              class_inst_p,
                                                              src_vid,
                                                              src_mip,
                                                              dst_vid);
        }

        {
            BOOL_T b_result;

            src_vid = 1000 + i;
            src_mip = 10 + i;
            dst_vid = 200;

            b_result = RULE_CTRL_SetMvrRecVlanEntry(src_vid, src_mip, dst_vid);
            assert(TRUE != b_result);
        }

        //
        // Update rule
        // Note: The rule will be reorder
        //

        class_inst_p = NULL;

        for (i = 0; i < SYS_ADPT_MVR_MAX_NBR_OF_RECEIVER_GROUPS; ++ i)
        {
            is_enable = TRUE;

            src_vid = 1000 + i;
            src_mip = 10 + i;
            dst_vid = 500;

            RULE_CTRL_UT_Proc_Set_Mvr_Receiver_Vlan_Rule(is_enable, src_vid, src_mip, dst_vid);

            // RULE_CTRL_DumpGlobalAce_BackDoor();
        }

        class_inst_p = NULL;

        for (i = 0; i < SYS_ADPT_MVR_MAX_NBR_OF_RECEIVER_GROUPS; ++ i)
        {
            is_enable = TRUE;

            src_vid = 1000 + i;
            src_mip = 10 + i;
            dst_vid = 500;

            result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                      remapped_pkt_type,
                                                                      RULE_TYPE_INST_CPU_IF,
                                                                      remapped_pkt_type,
                                                                      &class_inst_p);

            assert(RULE_TYPE_OK == result);
            assert(NULL != class_inst_p);

            RULE_CTRL_UT_Proc_Validate_Mvr_Receiver_Vlan_Rule(is_enable,
                                                              &interface,
                                                              remapped_pkt_type,
                                                              class_inst_p,
                                                              src_vid,
                                                              src_mip,
                                                              dst_vid);
        }

        //
        // Remove all
        //
        for (i = 0; i < SYS_ADPT_MVR_MAX_NBR_OF_RECEIVER_GROUPS; ++ i)
        {
            is_enable = FALSE;

            src_vid = 1000 + i;
            src_mip = 10 + i;
            dst_vid = 200;

            RULE_CTRL_UT_Proc_Set_Mvr_Receiver_Vlan_Rule(is_enable, src_vid, src_mip, dst_vid);

            // RULE_CTRL_DumpGlobalAce_BackDoor();

            RULE_CTRL_UT_Proc_Validate_Rule();
        }
    }

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_Mac_Vlan_Rule(
    BOOL_T is_enable,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    UI8_T mac_addr[SYS_ADPT_MAC_ADDR_LEN],
    UI8_T mask_addr[SYS_ADPT_MAC_ADDR_LEN],
    UI16_T vid,
    UI8_T priority)
{
    enum
    {
        UNIT = 1
    };

    if (TRUE == is_enable)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Source_Mac_Address(&rule_entry_p->rule_pattern, mac_addr, mask_addr);

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;
                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 == pce->policer_idx);

                result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                     remapped_pkt_type,
                                                                     &pcl_cfg);
                assert(RULE_TYPE_OK == result);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                b_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce);
                assert(TRUE == b_result);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    assert(0 == memcmp(pattern->macSa.arEther, mac_addr, sizeof(pattern->macSa.arEther)));
                    assert(0 == memcmp(mask->macSa.arEther, mask_addr, sizeof(mask->macSa.arEther)));

                    assert(1 == pattern->common.isL2Valid);
                    assert(1 == mask->common.isL2Valid);
                }

                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);

                assert(CPSS_PACKET_CMD_FORWARD_E == action.pktCmd);

                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_UNTAGGED_E == action.vlan.modifyVlan);
                assert(vid == action.vlan.vlanId);
                assert(GT_FALSE == action.vlan.nestedVlan);

#if (SYS_CPNT_MAC_VLAN_WITH_PRIORITY == TRUE)
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E == action.qos.modifyUp);
                assert(DEV_SWDRVL4_UpToQosProfieIdx(priority) == action.qos.qos.ingress.profileIndex);
                assert(GT_TRUE == action.qos.qos.ingress.profileAssignIndex);
#else
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
#endif // SYS_CPNT_MAC_VLAN_WITH_PRIORITY
            }
        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

void
RULE_CTRL_UT_Proc_Set_Mac_Vlan_Rule(
    BOOL_T is_enable,
    UI8_T mac_addr[SYS_ADPT_MAC_ADDR_LEN],
    UI8_T mask_addr[SYS_ADPT_MAC_ADDR_LEN],
    UI16_T vid,
    UI8_T priority)
{
    BOOL_T b_result;

    if (TRUE == is_enable)
    {
        b_result = RULE_CTRL_SetMacVlanEntry(mac_addr, mask_addr, vid, priority);
        assert(TRUE == b_result);
    }
    else
    {
        b_result = RULE_CTRL_DeleteMacVlanEntry(mac_addr, mask_addr);
        assert(TRUE == b_result);
    }
}

int
RULE_CTRL_UT_Set_Global_Mac_Vlan_Rule()
{
    enum
    {
        MAX_RETRY = 2,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_MAC_BASED_VLAN;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;

    UI8_T  mac[SYS_ADPT_MAC_ADDR_LEN];
    UI8_T  mask[SYS_ADPT_MAC_ADDR_LEN];

    UI16_T vid;
    UI8_T  priority;

    UI32_T i;

    BOOL_T is_enable;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        //
        // Create rule
        //

        is_enable = TRUE;

        memset(mac, 0, sizeof(mac));
        mac[4] = 0xff;
        mac[5] = 1;

        memset(mask, 0xff, sizeof(mask));

        vid = 1000;
        priority = 6;

        RULE_CTRL_UT_Proc_Set_Mac_Vlan_Rule(is_enable, mac, mask, vid, priority);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Mac_Vlan_Rule(is_enable,
                                                          &interface,
                                                          remapped_pkt_type,
                                                          class_inst_p,
                                                          mac, mask,
                                                          vid, priority);

        //
        // Update rule
        //

        is_enable = TRUE;

        vid = 1001;
        priority = 2;

        RULE_CTRL_UT_Proc_Set_Mac_Vlan_Rule(is_enable, mac, mask, vid, priority);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Mac_Vlan_Rule(is_enable,
                                                 &interface,
                                                 remapped_pkt_type,
                                                 class_inst_p,
                                                 mac, mask,
                                                 vid, priority);

        //
        // Remove rule
        //

        is_enable = FALSE;
        RULE_CTRL_UT_Proc_Set_Mac_Vlan_Rule(is_enable, mac, mask, vid, priority);

        //RULE_CTRL_DumpGlobalAce_BackDoor();

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Mac_Vlan_Rule(is_enable,
                                                 &interface,
                                                 remapped_pkt_type,
                                                 class_inst_p,
                                                 mac, mask,
                                                 vid, priority);

        //
        // capacity test
        //
        class_inst_p = NULL;

        for (i = 0; i < SYS_ADPT_MAX_NBR_OF_MAC_VLAN_ENTRY; ++ i)
        {
            is_enable = TRUE;

            memset(mac, 0, sizeof(mac));
            mac[4] = 0xff;
            mac[5] = i;

            memset(mask, 0xff, sizeof(mask));

            vid = 1000 + i;
            priority = 6;

            RULE_CTRL_UT_Proc_Set_Mac_Vlan_Rule(is_enable, mac, mask, vid, priority);

            // RULE_CTRL_DumpGlobalAce_BackDoor();

            result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                      remapped_pkt_type,
                                                                      RULE_TYPE_INST_CPU_IF,
                                                                      remapped_pkt_type,
                                                                      &class_inst_p);

            assert(RULE_TYPE_OK == result);
            assert(NULL != class_inst_p);

            RULE_CTRL_UT_Proc_Validate_Mac_Vlan_Rule(is_enable,
                                                     &interface,
                                                     remapped_pkt_type,
                                                     class_inst_p,
                                                     mac, mask,
                                                     vid, priority);
        }

        {
            BOOL_T b_result;

            memset(mac, 0, sizeof(mac));
            mac[4] = 0xff;
            mac[5] = i;

            memset(mask, 0xff, sizeof(mask));

            vid = 1000 + i;
            priority = 6;

            b_result = RULE_CTRL_SetMacVlanEntry(mac, mask, vid, priority);
            assert(TRUE != b_result);
        }

        //
        // Update rule
        // Note: The rule will be reorder
        //

        for (i = 0; i < SYS_ADPT_MAX_NBR_OF_MAC_VLAN_ENTRY; ++ i)
        {
            is_enable = TRUE;

            memset(mac, 0, sizeof(mac));
            mac[4] = 0xff;
            mac[5] = i;

            memset(mask, 0xff, sizeof(mask));

            vid = 2000 + i;
            priority = 4;

            RULE_CTRL_UT_Proc_Set_Mac_Vlan_Rule(is_enable, mac, mask, vid, priority);

            // RULE_CTRL_DumpGlobalAce_BackDoor();
        }

        class_inst_p = NULL;

        for (i = 0; i < SYS_ADPT_MAX_NBR_OF_MAC_VLAN_ENTRY; ++ i)
        {
            is_enable = TRUE;

            memset(mac, 0, sizeof(mac));
            mac[4] = 0xff;
            mac[5] = i;

            memset(mask, 0xff, sizeof(mask));

            vid = 2000 + i;
            priority = 4;

            result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                      remapped_pkt_type,
                                                                      RULE_TYPE_INST_CPU_IF,
                                                                      remapped_pkt_type,
                                                                      &class_inst_p);

            assert(RULE_TYPE_OK == result);
            assert(NULL != class_inst_p);

            RULE_CTRL_UT_Proc_Validate_Mac_Vlan_Rule(is_enable,
                                                     &interface,
                                                     remapped_pkt_type,
                                                     class_inst_p,
                                                     mac, mask,
                                                     vid, priority);
        }

        //
        // Remove all
        //
        for (i = 0; i < SYS_ADPT_MAX_NBR_OF_MAC_VLAN_ENTRY; ++ i)
        {
            is_enable = FALSE;

            memset(mac, 0, sizeof(mac));
            mac[4] = 0xff;
            mac[5] = i;

            memset(mask, 0xff, sizeof(mask));

            vid = 2000 + i;
            priority = 4;

            RULE_CTRL_UT_Proc_Set_Mac_Vlan_Rule(is_enable, mac, mask, vid, priority);

            // RULE_CTRL_DumpGlobalAce_BackDoor();

            RULE_CTRL_UT_Proc_Validate_Rule();
        }
    }

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_Mac_Mirror_Rule(
    BOOL_T is_enable,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    UI8_T mac_addr[SYS_ADPT_MAC_ADDR_LEN])
{
    enum
    {
        UNIT = 1
    };

    UI8_T mask_addr[] = {0xff, 0xff,0xff, 0xff, 0xff,0xff};

    if (TRUE == is_enable)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Source_Mac_Address(&rule_entry_p->rule_pattern, mac_addr, mask_addr);

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;
                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 == pce->policer_idx);

                result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                     remapped_pkt_type,
                                                                     &pcl_cfg);
                assert(RULE_TYPE_OK == result);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                b_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce);
                assert(TRUE == b_result);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    assert(0 == memcmp(pattern->macSa.arEther, mac_addr,
                                       sizeof(pattern->macSa.arEther)));
                    assert(0 == memcmp(mask->macSa.arEther, mask_addr,
                                       sizeof(mask->macSa.arEther)));

                    assert(1 == pattern->common.isL2Valid);
                    assert(1 == mask->common.isL2Valid);
                }

                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);

                assert(CPSS_PACKET_CMD_FORWARD_E == action.pktCmd);

                assert(GT_TRUE == action.mirror.mirrorToRxAnalyzerPort);
                assert(CPSS_NET_INGRESS_MIRRORED_TO_ANLYZER_E == action.mirror.cpuCode);

                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
            }
        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

void
RULE_CTRL_UT_Proc_Set_Mac_Mirror_Rule(
    BOOL_T is_enable,
    UI8_T mac_addr[SYS_ADPT_MAC_ADDR_LEN])
{
    BOOL_T b_result;

    if (TRUE == is_enable)
    {
        b_result = RULE_CTRL_SetMacMirrorEntry(mac_addr);
        assert(TRUE == b_result);
    }
    else
    {
        b_result = RULE_CTRL_DeleteMacMirrorEntry(mac_addr);
        assert(TRUE == b_result);
    }
}

int
RULE_CTRL_UT_Set_Global_Mac_Mirror_Rule()
{
    enum
    {
        MAX_RETRY = 2,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_MAC_BASED_MIRROR;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;

    UI8_T  mac[SYS_ADPT_MAC_ADDR_LEN];

    UI32_T i;

    BOOL_T is_enable;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        //
        // Create rule
        //

        is_enable = TRUE;

        memset(mac, 0, sizeof(mac));
        mac[4] = 0xff;
        mac[5] = 1;

        RULE_CTRL_UT_Proc_Set_Mac_Mirror_Rule(is_enable, mac);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Mac_Mirror_Rule(is_enable,
                                                   &interface,
                                                   remapped_pkt_type,
                                                   class_inst_p,
                                                   mac);

        //
        // Remove rule
        //

        is_enable = FALSE;
        RULE_CTRL_UT_Proc_Set_Mac_Mirror_Rule(is_enable, mac);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Mac_Mirror_Rule(is_enable,
                                                   &interface,
                                                   remapped_pkt_type,
                                                   class_inst_p,
                                                   mac);

        //
        // capacity test
        //
        class_inst_p = NULL;

        for (i = 0; i < SYS_ADPT_MAX_NBR_OF_MAC_BASED_MIRROR_ENTRY; ++ i)
        {
            is_enable = TRUE;

            memset(mac, 0, sizeof(mac));
            mac[4] = 0xff;
            mac[5] = i;

            RULE_CTRL_UT_Proc_Set_Mac_Mirror_Rule(is_enable, mac);

            // RULE_CTRL_DumpGlobalAce_BackDoor();

            result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                      remapped_pkt_type,
                                                                      RULE_TYPE_INST_CPU_IF,
                                                                      remapped_pkt_type,
                                                                      &class_inst_p);

            assert(RULE_TYPE_OK == result);
            assert(NULL != class_inst_p);

            RULE_CTRL_UT_Proc_Validate_Mac_Mirror_Rule(is_enable,
                                                       &interface,
                                                       remapped_pkt_type,
                                                       class_inst_p,
                                                       mac);
        }

        {
            BOOL_T b_result;

            memset(mac, 0, sizeof(mac));
            mac[4] = 0xff;
            mac[5] = i;

            b_result = RULE_CTRL_SetMacMirrorEntry(mac);
            assert(TRUE != b_result);
        }

        //
        // Remove all
        //
        for (i = 0; i < SYS_ADPT_MAX_NBR_OF_MAC_BASED_MIRROR_ENTRY; ++ i)
        {
            is_enable = FALSE;

            memset(mac, 0, sizeof(mac));
            mac[4] = 0xff;
            mac[5] = i;

            RULE_CTRL_UT_Proc_Set_Mac_Mirror_Rule(is_enable, mac);

            // RULE_CTRL_DumpGlobalAce_BackDoor();

            RULE_CTRL_UT_Proc_Validate_Rule();
        }
    }

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_Global_Ip_Subnet_Vlan_Rule(
    BOOL_T is_enable,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    UI32_T ip_addr,
    UI32_T mask_addr,
    UI16_T vid,
    UI8_T priority)
{
    enum
    {
        UNIT = 1
    };

    if (TRUE == is_enable)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Source_Address(&rule_entry_p->rule_pattern, ip_addr, mask_addr);

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;
                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 == pce->policer_idx);

                result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                     remapped_pkt_type,
                                                                     &pcl_cfg);
                assert(RULE_TYPE_OK == result);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                b_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce);
                assert(TRUE == b_result);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    assert(pattern->sip.u32Ip == L_STDLIB_Hton32(ip_addr));
                    assert(mask->sip.u32Ip == L_STDLIB_Hton32(mask_addr));

                    assert(1 == pattern->common.isIp);
                    assert(0xff == mask->common.isIp);
                }

                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);

                assert(CPSS_PACKET_CMD_FORWARD_E == action.pktCmd);

                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_UNTAGGED_E == action.vlan.modifyVlan);
                assert(vid == action.vlan.vlanId);
                assert(GT_FALSE == action.vlan.nestedVlan);

#if (SYS_CPNT_IP_SUBNET_VLAN_WITH_PRIORITY == TRUE)
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E == action.qos.modifyUp);
                assert(DEV_SWDRVL4_UpToQosProfieIdx(priority) == action.qos.qos.ingress.profileIndex);
                assert(GT_TRUE == action.qos.qos.ingress.profileAssignIndex);
#else
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
#endif // SYS_CPNT_MAC_VLAN_WITH_PRIORITY
            }
        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

void
RULE_CTRL_UT_Proc_Set_Global_Ip_Subnet_Vlan_Rule(
    BOOL_T is_enable,
    UI32_T ip_addr,
    UI32_T mask_addr,
    UI16_T vid,
    UI8_T priority)
{
    BOOL_T b_result;

    if (TRUE == is_enable)
    {
        b_result = RULE_CTRL_SetIpSubnetVlanEntry(ip_addr, mask_addr, vid, priority);
        assert(TRUE == b_result);
    }
    else
    {
        b_result = RULE_CTRL_DeleteIpSubnetVlanEntry(ip_addr, mask_addr);
        assert(TRUE == b_result);
    }
}

int
RULE_CTRL_UT_Set_Global_Ip_Subnet_Vlan_Rule()
{
#if (SYS_CPNT_IP_SUBNET_VLAN_BIND_PORT == FALSE)
    enum
    {
        MAX_RETRY = 2,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_IP_SUBNET_BASED_VLAN;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;

    UI32_T ip_addr;
    UI32_T mask_addr;

    UI16_T vid;
    UI8_T  priority;

    UI32_T i;

    BOOL_T is_enable;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        //
        // Create rule
        //

        is_enable = TRUE;

        ip_addr   = 0x01020304;
        mask_addr = 0xffffffff;

        vid = 1000;
        priority = 6;

        RULE_CTRL_UT_Proc_Set_Global_Ip_Subnet_Vlan_Rule(is_enable, ip_addr,
                                                         mask_addr, vid, priority);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Global_Ip_Subnet_Vlan_Rule(is_enable,
                                                              &interface,
                                                              remapped_pkt_type,
                                                              class_inst_p,
                                                              ip_addr, mask_addr,
                                                              vid, priority);

        //
        // Update rule
        //

        is_enable = TRUE;

        vid = 1001;
        priority = 2;

        RULE_CTRL_UT_Proc_Set_Global_Ip_Subnet_Vlan_Rule(is_enable, ip_addr,
                                                         mask_addr, vid, priority);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Global_Ip_Subnet_Vlan_Rule(is_enable,
                                                              &interface,
                                                              remapped_pkt_type,
                                                              class_inst_p,
                                                              ip_addr, mask_addr,
                                                              vid, priority);

        //
        // Remove rule
        //

        is_enable = FALSE;
        RULE_CTRL_UT_Proc_Set_Global_Ip_Subnet_Vlan_Rule(is_enable, ip_addr,
                                                         mask_addr, vid, priority);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Global_Ip_Subnet_Vlan_Rule(is_enable,
                                                              &interface,
                                                              remapped_pkt_type,
                                                              class_inst_p,
                                                              ip_addr, mask_addr,
                                                              vid, priority);

        //
        // capacity test
        //

        class_inst_p = NULL;

        for (i = 0; i < SYS_ADPT_MAX_NBR_OF_IP_SUBNET_VLAN_ENTRY; ++ i)
        {
            is_enable = TRUE;

            ip_addr   = 0x01020300 + i;
            mask_addr = 0xffffffff;

            vid = 1000 + i;
            priority = 6;

            RULE_CTRL_UT_Proc_Set_Global_Ip_Subnet_Vlan_Rule(is_enable, ip_addr,
                                                             mask_addr, vid, priority);

            // RULE_CTRL_DumpGlobalAce_BackDoor();

            result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                      remapped_pkt_type,
                                                                      RULE_TYPE_INST_CPU_IF,
                                                                      remapped_pkt_type,
                                                                      &class_inst_p);

            assert(RULE_TYPE_OK == result);
            assert(NULL != class_inst_p);

            RULE_CTRL_UT_Proc_Validate_Global_Ip_Subnet_Vlan_Rule(is_enable,
                                                                  &interface,
                                                                  remapped_pkt_type,
                                                                  class_inst_p,
                                                                  ip_addr, mask_addr,
                                                                  vid, priority);
        }

        {
            BOOL_T b_result;

            ip_addr   = 0x01020300 + i;
            mask_addr = 0xffffffff;

            vid = 1000 + i;
            priority = 6;

            b_result = RULE_CTRL_SetIpSubnetVlanEntry(ip_addr, mask_addr, vid, priority);
            assert(TRUE != b_result);
        }

        //
        // Update rule
        // Note: The rule will be reorder
        //

        for (i = 0; i < SYS_ADPT_MAX_NBR_OF_IP_SUBNET_VLAN_ENTRY; ++ i)
        {
            is_enable = TRUE;

            ip_addr   = 0x01020300 + i;
            mask_addr = 0xffffffff;

            vid = 2000 + i;
            priority = 4;

            RULE_CTRL_UT_Proc_Set_Global_Ip_Subnet_Vlan_Rule(is_enable, ip_addr,
                                                             mask_addr, vid, priority);

            // RULE_CTRL_DumpGlobalAce_BackDoor();
        }

        class_inst_p = NULL;

        for (i = 0; i < SYS_ADPT_MAX_NBR_OF_IP_SUBNET_VLAN_ENTRY; ++ i)
        {
            is_enable = TRUE;

            ip_addr   = 0x01020300 + i;
            mask_addr = 0xffffffff;

            vid = 2000 + i;
            priority = 4;

            result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                      remapped_pkt_type,
                                                                      RULE_TYPE_INST_CPU_IF,
                                                                      remapped_pkt_type,
                                                                      &class_inst_p);

            assert(RULE_TYPE_OK == result);
            assert(NULL != class_inst_p);

            RULE_CTRL_UT_Proc_Validate_Global_Ip_Subnet_Vlan_Rule(is_enable,
                                                                  &interface,
                                                                  remapped_pkt_type,
                                                                  class_inst_p,
                                                                  ip_addr, mask_addr,
                                                                  vid, priority);
        }

        //
        // Remove all
        //
        for (i = 0; i < SYS_ADPT_MAX_NBR_OF_IP_SUBNET_VLAN_ENTRY; ++ i)
        {
            is_enable = FALSE;

            ip_addr   = 0x01020300 + i;
            mask_addr = 0xffffffff;

            vid = 2000 + i;
            priority = 4;

            RULE_CTRL_UT_Proc_Set_Global_Ip_Subnet_Vlan_Rule(is_enable, ip_addr,
                                                             mask_addr, vid, priority);

            // RULE_CTRL_DumpGlobalAce_BackDoor();

            RULE_CTRL_UT_Proc_Validate_Rule();
        }
    }

#endif // SYS_CPNT_IP_SUBNET_VLAN_BIND_PORT

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_Igmp_Rule_2(
    BOOL_T is_enable,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p)
{
    enum
    {
        UNIT = 1
    };

    UI8_T  ar_ip_addr[]  =  {224,   0,   0, 0};
    UI8_T  ar_mask_addr[] = {255, 255, 255, 0};

    UI32_T *ip_addr_p = (UI32_T *)&ar_ip_addr;
    UI32_T *mask_addr_p = (UI32_T *)&ar_mask_addr;

    UI8_T  protocol = 2;
    UI8_T  protocol_mask = 0xff;

    if (TRUE == is_enable)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Dest_Address(&rule_entry_p->rule_pattern, *ip_addr_p, *mask_addr_p);
            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Protocol(&rule_entry_p->rule_pattern, protocol, 0xff);

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;
                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 == pce->policer_idx);

                result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                     remapped_pkt_type,
                                                                     &pcl_cfg);
                assert(RULE_TYPE_OK == result);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                b_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce);
                assert(TRUE == b_result);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    // ???: Endian wrong ?
                    printf("%s(%d): Endian wrong here ??\r\n", __FUNCTION__, __LINE__);
                    assert(pattern->dip.u32Ip == L_STDLIB_Hton32(*ip_addr_p));
                    assert(mask->dip.u32Ip == L_STDLIB_Hton32(*mask_addr_p));

                    //assert(pattern->dip.u32Ip == * (UI32_T *) ar_ip_addr);
                    //assert(mask->dip.u32Ip == * (UI32_T *) ar_mask_addr);

                    assert(pattern->commonExt.ipProtocol == protocol);
                    assert(mask->commonExt.ipProtocol == protocol_mask);

                    assert(1 == pattern->common.isIp);
                    assert(0xff == mask->common.isIp);
                }

                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);
                assert(CPSS_PACKET_CMD_TRAP_TO_CPU_E == action.pktCmd);

                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
            }
        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

int
RULE_CTRL_UT_Set_Global_Igmp_Rule_2()
{
    enum
    {
        MAX_RETRY = 2,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_IGMP;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;

    BOOL_T is_enable;
    BOOL_T b_result;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        //
        // Create rule
        //

        is_enable = TRUE;

        b_result = RULE_CTRL_SetIgmpEntry(is_enable);
        assert(TRUE == b_result);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Igmp_Rule_2(is_enable,
                                               &interface,
                                               remapped_pkt_type,
                                               class_inst_p);

        //
        // Update rule
        //

        is_enable = TRUE;

        b_result = RULE_CTRL_SetIgmpEntry(is_enable);
        assert(TRUE == b_result);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Igmp_Rule_2(is_enable,
                                               &interface,
                                               remapped_pkt_type,
                                               class_inst_p);

        //
        // Remove rule
        //

        is_enable = FALSE;

        b_result = RULE_CTRL_SetIgmpEntry(is_enable);
        assert(TRUE == b_result);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Igmp_Rule_2(is_enable,
                                               &interface,
                                               remapped_pkt_type,
                                               class_inst_p);

        //
        // Remove rule (non exist)
        //

        is_enable = FALSE;

        b_result = RULE_CTRL_SetIgmpEntry(is_enable);
        assert(TRUE == b_result);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Igmp_Rule_2(is_enable,
                                               &interface,
                                               remapped_pkt_type,
                                               class_inst_p);
    }

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_L2pt_Tunnel_Pdu_Rule(
    BOOL_T is_enable,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    UI8_T mac_addr[SYS_ADPT_MAC_ADDR_LEN])
{
    enum
    {
        UNIT = 1
    };

    UI8_T mask_addr[] = {0xff, 0xff,0xff, 0xff, 0xff,0xff};

    if (TRUE == is_enable)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Dest_Mac_Address(&rule_entry_p->rule_pattern, mac_addr, mask_addr);

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;
                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 == pce->policer_idx);

                result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                     remapped_pkt_type,
                                                                     &pcl_cfg);
                assert(RULE_TYPE_OK == result);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                b_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce);
                assert(TRUE == b_result);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    assert(0 == memcmp(pattern->macDa.arEther, mac_addr,
                                       sizeof(pattern->macDa.arEther)));
                    assert(0 == memcmp(mask->macDa.arEther, mask_addr,
                                       sizeof(mask->macDa.arEther)));

                    assert(1 == pattern->common.isL2Valid);
                    assert(1 == mask->common.isL2Valid);
                }

                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);
                assert(CPSS_PACKET_CMD_TRAP_TO_CPU_E == action.pktCmd);
                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);

            }
        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

int
RULE_CTRL_UT_Set_Global_L2pt_Tunnel_Pdu_Rule()
{
#if (SYS_CPNT_QINQ_L2PT == TRUE && SYS_CPNT_QINQ_L2PT_DA_REMARK == TRUE)

    enum
    {
        MAX_RETRY = 2,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_L2PT;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;

    UI8_T  mac_addr[SYS_ADPT_MAC_ADDR_LEN];

    BOOL_T is_enable;
    BOOL_T b_result;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        //
        // Create rule
        //

        is_enable = TRUE;

        memset(mac_addr, 0, sizeof(mac_addr));
        mac_addr[4] = 0xff;
        mac_addr[5] = 0x01;

        b_result = RULE_CTRL_SetL2PTTunnelPduToCpu(mac_addr, is_enable);
        assert(TRUE == b_result);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_L2pt_Tunnel_Pdu_Rule(is_enable,
                                                        &interface,
                                                        remapped_pkt_type,
                                                        class_inst_p,
                                                        mac_addr);

        //
        // Update rule
        //

        is_enable = TRUE;

        b_result = RULE_CTRL_SetL2PTTunnelPduToCpu(mac_addr, is_enable);
        assert(TRUE == b_result);

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_L2pt_Tunnel_Pdu_Rule(is_enable,
                                                        &interface,
                                                        remapped_pkt_type,
                                                        class_inst_p,
                                                        mac_addr);

        //
        // Remove rule
        //

        is_enable = FALSE;

        b_result = RULE_CTRL_SetL2PTTunnelPduToCpu(mac_addr, is_enable);
        assert(TRUE == b_result);

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);

        RULE_CTRL_UT_Proc_Validate_L2pt_Tunnel_Pdu_Rule(is_enable,
                                                        &interface,
                                                        remapped_pkt_type,
                                                        class_inst_p,
                                                        mac_addr);

        //
        // capacity test
        //

        class_inst_p = NULL;

        {
            is_enable = TRUE;

            memset(mac_addr, 0, sizeof(mac_addr));
            mac_addr[4] = 0xff;
            mac_addr[5] = 1;

            b_result = RULE_CTRL_SetL2PTTunnelPduToCpu(mac_addr, is_enable);
            assert(TRUE == b_result);

            result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                      remapped_pkt_type,
                                                                      RULE_TYPE_INST_CPU_IF,
                                                                      remapped_pkt_type,
                                                                      &class_inst_p);

            assert(RULE_TYPE_OK == result);
            assert(NULL != class_inst_p);

            RULE_CTRL_UT_Proc_Validate_L2pt_Tunnel_Pdu_Rule(is_enable,
                                                            &interface,
                                                            remapped_pkt_type,
                                                            class_inst_p,
                                                            mac_addr);
        }

        //
        // Update rule
        // Note: The rule will be reorder
        //

        {
            is_enable = TRUE;

            memset(mac_addr, 0, sizeof(mac_addr));
            mac_addr[4] = 0xff;
            mac_addr[5] = 1;

            b_result = RULE_CTRL_SetL2PTTunnelPduToCpu(mac_addr, is_enable);
            assert(TRUE == b_result);
        }

        class_inst_p = NULL;

        {
            is_enable = TRUE;

            memset(mac_addr, 0, sizeof(mac_addr));
            mac_addr[4] = 0xff;
            mac_addr[5] = 1;

            result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                      remapped_pkt_type,
                                                                      RULE_TYPE_INST_CPU_IF,
                                                                      remapped_pkt_type,
                                                                      &class_inst_p);

            assert(RULE_TYPE_OK == result);
            assert(NULL != class_inst_p);

            RULE_CTRL_UT_Proc_Validate_L2pt_Tunnel_Pdu_Rule(is_enable,
                                                            &interface,
                                                            remapped_pkt_type,
                                                            class_inst_p,
                                                            mac_addr);
        }

        //
        // Remove all
        //
        {
            is_enable = FALSE;

            memset(mac_addr, 0, sizeof(mac_addr));
            mac_addr[4] = 0xff;
            mac_addr[5] = 1;

            b_result = RULE_CTRL_SetL2PTTunnelPduToCpu(mac_addr, is_enable);
            assert(TRUE == b_result);

            RULE_CTRL_UT_Proc_Validate_Rule();
        }
    }

#endif // #if (SYS_CPNT_QINQ_L2PT == TRUE && SYS_CPNT_QINQ_L2PT_DA_REMARK == TRUE)

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_Pppoe_Rule(
    BOOL_T is_enable,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p)
{
    enum
    {
        UNIT = 1
    };

    UI16_T ether_type       = 0x8863;
    UI16_T ether_type_mask  = 0xffff;

    if (TRUE == is_enable)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ether_Type(&rule_entry_p->rule_pattern, ether_type, ether_type_mask);

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;
                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 == pce->policer_idx);

                result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                     remapped_pkt_type,
                                                                     &pcl_cfg);
                assert(RULE_TYPE_OK == result);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                b_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce);
                assert(TRUE == b_result);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    assert(pattern->etherType == L_STDLIB_Hton16(ether_type));
                    assert(mask->etherType == L_STDLIB_Hton16(ether_type_mask));

                    assert(pattern->common.isL2Valid == 1);
                    assert(mask->common.isL2Valid == 1);
                }

                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);
                assert(CPSS_PACKET_CMD_TRAP_TO_CPU_E == action.pktCmd);
                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
            }
        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

int
RULE_CTRL_UT_Set_Global_Pppoe_Rule()
{
#if (SYS_CPNT_PPPOE_IA == TRUE)
    enum
    {
        MAX_RETRY = 2,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_PPPOED;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;

    BOOL_T is_enable;
    BOOL_T b_result;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        //
        // Create rule
        //

        is_enable = TRUE;

        b_result = RULE_CTRL_SetPPPoEDPktToCpuPerSystem(is_enable);
        assert(TRUE == b_result);

        //  RULE_CTRL_DumpGlobalAce_BackDoor();

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Pppoe_Rule(is_enable,
                                                          &interface,
                                                          remapped_pkt_type,
                                                          class_inst_p);

        //
        // Update rule
        //

        is_enable = TRUE;

        b_result = RULE_CTRL_SetPPPoEDPktToCpuPerSystem(is_enable);
        assert(TRUE == b_result);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Pppoe_Rule(is_enable,
                                              &interface,
                                              remapped_pkt_type,
                                              class_inst_p);

        //
        // Remove rule
        //

        is_enable = FALSE;

        b_result = RULE_CTRL_SetPPPoEDPktToCpuPerSystem(is_enable);
        assert(TRUE == b_result);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Pppoe_Rule(is_enable,
                                              &interface,
                                              remapped_pkt_type,
                                              class_inst_p);

        //
        // Remove rule (non exist)
        //

        is_enable = FALSE;

        b_result = RULE_CTRL_SetPPPoEDPktToCpuPerSystem(is_enable);
        assert(TRUE == b_result);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Pppoe_Rule(is_enable,
                                              &interface,
                                              remapped_pkt_type,
                                              class_inst_p);
    }

#endif // SYS_CPNT_PPPOE_IA

    return 0;
}


/* FIXME: Modified all rule validate function to this interface
 *   (Maybe need to define better struct of RULE_CTRL_UT_VALIDATE_RULE_PATTERN_T)
 */
void
RULE_CTRL_UT_Proc_Validate_DropArpPacke_Rule(
    BOOL_T is_enable,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    const RULE_CTRL_UT_VALIDATE_RULE_PATTERN_T *pattern_p)
{
    enum
    {
        UNIT = 1
    };

    UI16_T ether_type       = RULE_TYPE_ETHERTYPE_ARP;
    UI16_T ether_type_mask  = 0xffff;

    if (TRUE == is_enable)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ether_Type(&rule_entry_p->rule_pattern, ether_type, ether_type_mask);

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;
                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 == pce->policer_idx);

                result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                     remapped_pkt_type,
                                                                     &pcl_cfg);
                assert(RULE_TYPE_OK == result);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                b_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce);
                assert(TRUE == b_result);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    assert(pattern->etherType == L_STDLIB_Hton16(ether_type));
                    assert(mask->etherType == L_STDLIB_Hton16(ether_type_mask));

                    assert(0 == memcmp(pattern->macSa.arEther, pattern_p->src_mac, sizeof(pattern->macSa.arEther)));
                    assert(0 == memcmp(mask->macSa.arEther, pattern_p->src_mac_mask, sizeof(mask->macSa.arEther)));

                    assert(pattern->sip.u32Ip == L_STDLIB_Hton32(pattern_p->src_ip));
                    assert(mask->sip.u32Ip == L_STDLIB_Hton32(pattern_p->src_ip_mask));
                }

                assert(CPSS_PACKET_CMD_DROP_HARD_E == action.pktCmd);

            }
        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }
    
    RULE_CTRL_UT_Proc_Validate_Rule();
}

int
RULE_CTRL_UT_Set_Global_DropArpPacket()
{
#if (SYS_CPNT_DAI_ARP_ACL == TRUE)
    enum
    {
        MAX_RETRY = 2,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_DAI_ARP_DROP;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry, rule_num;

    BOOL_T is_enable;
    BOOL_T b_result;

    const UI32_T sip = 0xC0A80001; /* 192.168.0.1 */
    const UI32_T sip_mask = 0xffffffff;
    const UI8_T  sa_mask[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        RULE_CTRL_UT_VALIDATE_RULE_PATTERN_T pattern;
        UI8_T  cur_sa[6];
        UI32_T cur_sip;

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;
        class_inst_p = NULL;

        /* ========================
         * = Create Rule
         * ========================
         */
        for (rule_num = 0; rule_num < SYS_ADPT_ARP_INSPECTION_MAX_NBR_OF_DENY_RULE; ++rule_num)
        {
            memset(cur_sa, 0, sizeof(cur_sa));
            cur_sa[5] = rule_num + 1;
            cur_sip = sip + rule_num;

            is_enable = TRUE;

            result = RULE_CTRL_DAI_DropArpPacket(is_enable, cur_sa, cur_sip);
            assert(RULE_TYPE_OK == result);

            //  RULE_CTRL_DumpGlobalAce_BackDoor();


            result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                      remapped_pkt_type,
                                                                      RULE_TYPE_INST_CPU_IF,
                                                                      remapped_pkt_type,
                                                                      &class_inst_p);

            assert(RULE_TYPE_OK == result);
            assert(NULL != class_inst_p);

            memset(&pattern, 0, sizeof(pattern));
            memcpy(pattern.src_mac, cur_sa, sizeof(pattern.src_mac));
            memcpy(pattern.src_mac_mask, sa_mask, sizeof(pattern.src_mac_mask));
            pattern.src_ip = cur_sip;
            pattern.src_ip_mask = sip_mask;

            RULE_CTRL_UT_Proc_Validate_DropArpPacke_Rule(is_enable,
                                                         &interface,
                                                         remapped_pkt_type,
                                                         class_inst_p,
                                                         &pattern);
        }
        // RULE_CTRL_DumpGlobalAce_BackDoor();

        /* ========================
         * = Create rules exceed SYS_ADPT_ARP_INSPECTION_MAX_NBR_OF_DENY_RULE rules
         * ========================
         */
        {
            cur_sip = sip + rule_num;
            cur_sa[5] = rule_num + 1;

            result = RULE_CTRL_DAI_DropArpPacket(TRUE, cur_sa, cur_sip);
            assert(RULE_TYPE_OK != result);
        }

        /* ========================
         * = Remove all rules
         * ========================
         */
        {
            for (rule_num = 0; rule_num < SYS_ADPT_ARP_INSPECTION_MAX_NBR_OF_DENY_RULE; ++rule_num)
            {
                memset(cur_sa, 0, sizeof(cur_sa));
                cur_sa[5] = rule_num + 1;
                cur_sip = sip + rule_num;

                is_enable = FALSE;

                result = RULE_CTRL_DAI_DropArpPacket(is_enable, cur_sa, cur_sip);
                assert(RULE_TYPE_OK == result);

                // RULE_CTRL_DumpGlobalAce_BackDoor();
            }

            memset(&interface, 0, sizeof(interface));
            interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
            interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

            class_inst_p = NULL;
            result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                      remapped_pkt_type,
                                                                      RULE_TYPE_INST_CPU_IF,
                                                                      remapped_pkt_type,
                                                                      &class_inst_p);

            assert(RULE_TYPE_OK != result);

            memset(&pattern, 0, sizeof(pattern));
            RULE_CTRL_UT_Proc_Validate_DropArpPacke_Rule(is_enable,
                                                         &interface,
                                                         remapped_pkt_type,
                                                         class_inst_p,
                                                         &pattern);

        }
        //RULE_CTRL_DumpGlobalAce_BackDoor();

        /* ========================
         * = Remove not existed rule
         * ========================
         */

        is_enable = FALSE;
        cur_sa[5] = 0xff;

        b_result =  RULE_CTRL_DAI_DropArpPacket(is_enable, cur_sa, cur_sip);
        assert(TRUE == b_result);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);

        memset(&pattern, 0, sizeof(pattern));
        RULE_CTRL_UT_Proc_Validate_DropArpPacke_Rule(is_enable,
                                                     &interface,
                                                     remapped_pkt_type,
                                                     class_inst_p,
                                                     &pattern);
    }
    
#endif /* SYS_CPNT_DAI_ARP_ACL*/
    
    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_Vlan_Translation_Rule(
    BOOL_T enable_flag,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    UI32_T old_vid,
    UI32_T new_vid)
{
    RULE_TYPE_RETURN_TYPE_T result;

    BOOL_T b_result;

    if (TRUE == enable_flag)
    {
        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        if (interface_p->type == RULE_TYPE_INTERFACE_TRUNK)
        {
            UI32_T unit;

            STKTPLG_OM_GetMyUnitID(&unit);
            assert(RULE_CTRL_GetNumberOfChips(unit) == RULE_CTRL_UT_Proc_Count_Of_Rule_Instance(class_inst_p));
        }
        else
        {
            assert(1 == RULE_CTRL_UT_Proc_Count_Of_Rule_Instance(class_inst_p));
        }

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        assert(0 != rule_inst_p->dev_rule_info.rule_id);
        assert(TRUE == rule_inst_p->active);

        rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
        assert(NULL != rule_entry_p);

        RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Vlan(&rule_entry_p->rule_pattern, old_vid, 0xfff);


        {
            DEVRM_PCE_T *pce;
            DEVRM_PCL_T *pcl;

            RULE_CTRL_PCL_CFG_T pcl_cfg;

            CPSS_DXCH_POLICER_STAGE_TYPE_ENT policer_stage;

            result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                 remapped_pkt_type,
                                                                 &pcl_cfg);
            assert(RULE_TYPE_OK == result);

            b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                    rule_inst_p->dev_rule_info.rule_id,
                                    &pce);
            assert(TRUE == b_result);
            assert(NULL != pce);
            assert(-1 == pce->policer_idx);

            pcl = DEVRM_GetPcl(rule_inst_p->dev_rule_info.device, pce->pcl_id);
            assert(NULL != pcl);

            DEVRM_GetPolicerStageFromPce(rule_inst_p->dev_rule_info.device,
                                         pce,
                                         &policer_stage);

            if (RULE_TYPE_INBOUND == interface_p->direction)
            {
                assert(CPSS_DXCH_POLICER_STAGE_INGRESS_0_E == policer_stage);
            }
            else
            {
                assert(CPSS_DXCH_POLICER_STAGE_EGRESS_E == policer_stage);
            }

            {
                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT  ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT       pattern_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT       mask_u;
                CPSS_DXCH_PCL_ACTION_STC            action;

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(RULE_TYPE_OK == result);

                if (RULE_TYPE_INBOUND == interface_p->direction)
                {
                    assert(pce->pcl_id == pattern_u.ruleExtNotIpv6.common.pclId);

                    assert(pcl_cfg.pcl_id == pattern_u.ruleExtNotIpv6.common.pclId);
                    assert(pcl_cfg.pcl_id_mask == mask_u.ruleExtNotIpv6.common.pclId);

                    assert(L_STDLIB_Hton16(old_vid) == pattern_u.ruleExtNotIpv6.common.vid);
                    assert(L_STDLIB_Hton16(0x0fff) == mask_u.ruleExtNotIpv6.common.vid);
                }
                else
                {
                    assert(pce->pcl_id == pattern_u.ruleEgrExtNotIpv6.common.pclId);

                    assert(pcl_cfg.pcl_id == pattern_u.ruleEgrExtNotIpv6.common.pclId);
                    assert(pcl_cfg.pcl_id_mask == mask_u.ruleEgrExtNotIpv6.common.pclId);

                    assert(L_STDLIB_Hton16(old_vid) == pattern_u.ruleEgrExtNotIpv6.common.vid);
                    assert(L_STDLIB_Hton16(0x0fff) == mask_u.ruleEgrExtNotIpv6.common.vid);
                }

                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);
                assert(CPSS_PACKET_CMD_FORWARD_E == action.pktCmd);
                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_TAGGED_E == action.vlan.modifyVlan);
                assert(new_vid == action.vlan.vlanId);
                assert(GT_FALSE == action.vlan.nestedVlan);
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
            }

        }

    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

int
RULE_CTRL_UT_Set_Dflt_Vlan_Translation_Rule()
{
#if (SYS_CPNT_VLAN_XLATE == TRUE && SYS_CPNT_VLAN_XLATE_BY_RULE == TRUE)
    enum
    {
        MAX_UNIT = 1,
        MAX_PORT = 2,
        MAX_DIRECTION = RULE_TYPE_OUTBOUND,
    };

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T old_vid; // key
    UI32_T new_vid;
    UI32_T i;
    UI32_T cnt;

    BOOL_T enable_flag;

    memset(&interface, 0, sizeof(interface));
    interface.type = RULE_TYPE_INTERFACE_UPORT;

    for (interface.uport.unit = 1; interface.uport.unit <= MAX_UNIT;
                                                        ++ interface.uport.unit)
    {
        for (interface.uport.port = 1; interface.uport.port <= MAX_PORT;
                                                        ++ interface.uport.port)
        {
            for (interface.direction = RULE_TYPE_INBOUND; interface.direction <= MAX_DIRECTION;
                                                         ++ interface.direction)
            {
                //
                // Add
                //
                old_vid = 1;
                new_vid = 2;
                result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
                assert(RULE_TYPE_OK == result);

                remapped_pkt_type = (RULE_TYPE_INBOUND == interface.direction) ?
                RULE_TYPE_PACKET_VLAN_TRANSLATION :
                RULE_TYPE_PACKET_EGRESS_VLAN_TRANSLATION;

                class_inst_p = NULL;
                result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                          remapped_pkt_type,
                                                                          RULE_TYPE_INST_CPU_IF,
                                                                          remapped_pkt_type,
                                                                          &class_inst_p);
                assert(RULE_TYPE_OK == result);
                assert(NULL != class_inst_p);

                enable_flag = (0 != new_vid) ? TRUE : FALSE;

                RULE_CTRL_UT_Proc_Validate_Vlan_Translation_Rule(enable_flag,
                                                                 &interface,
                                                                 remapped_pkt_type,
                                                                 class_inst_p,
                                                                 old_vid, new_vid);
                //
                // Remove
                //

                old_vid = 1;
                new_vid = 0;
                result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
                assert(RULE_TYPE_OK == result);

                remapped_pkt_type = (RULE_TYPE_INBOUND == interface.direction) ?
                RULE_TYPE_PACKET_VLAN_TRANSLATION :
                RULE_TYPE_PACKET_EGRESS_VLAN_TRANSLATION;

                class_inst_p = NULL;
                result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                          remapped_pkt_type,
                                                                          RULE_TYPE_INST_CPU_IF,
                                                                          remapped_pkt_type,
                                                                          &class_inst_p);
                assert(RULE_TYPE_OK != result);
                assert(NULL == class_inst_p);

                enable_flag = (0 != new_vid) ? TRUE : FALSE;

                RULE_CTRL_UT_Proc_Validate_Vlan_Translation_Rule(enable_flag,
                                                                 &interface,
                                                                 remapped_pkt_type,
                                                                 class_inst_p,
                                                                 old_vid, new_vid);

                //
                // Add
                //
                old_vid = 1;
                new_vid = 2;
                result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
                assert(RULE_TYPE_OK == result);

                remapped_pkt_type = (RULE_TYPE_INBOUND == interface.direction) ?
                RULE_TYPE_PACKET_VLAN_TRANSLATION :
                RULE_TYPE_PACKET_EGRESS_VLAN_TRANSLATION;

                class_inst_p = NULL;
                result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                          remapped_pkt_type,
                                                                          RULE_TYPE_INST_CPU_IF,
                                                                          remapped_pkt_type,
                                                                          &class_inst_p);
                assert(RULE_TYPE_OK == result);
                assert(NULL != class_inst_p);

                enable_flag = (0 != new_vid) ? TRUE : FALSE;

                RULE_CTRL_UT_Proc_Validate_Vlan_Translation_Rule(enable_flag,
                                                                 &interface,
                                                                 remapped_pkt_type,
                                                                 class_inst_p,
                                                                 old_vid, new_vid);

                //
                // Update
                //
                old_vid = 1;
                new_vid = 3;
                result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
                assert(RULE_TYPE_OK == result);

                remapped_pkt_type = (RULE_TYPE_INBOUND == interface.direction) ?
                RULE_TYPE_PACKET_VLAN_TRANSLATION :
                RULE_TYPE_PACKET_EGRESS_VLAN_TRANSLATION;

                class_inst_p = NULL;
                result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                          remapped_pkt_type,
                                                                          RULE_TYPE_INST_CPU_IF,
                                                                          remapped_pkt_type,
                                                                          &class_inst_p);
                assert(RULE_TYPE_OK == result);
                assert(NULL != class_inst_p);

                enable_flag = (0 != new_vid) ? TRUE : FALSE;

                RULE_CTRL_UT_Proc_Validate_Vlan_Translation_Rule(enable_flag,
                                                                 &interface,
                                                                 remapped_pkt_type,
                                                                 class_inst_p,
                                                                 old_vid, new_vid);

                //
                // Replace continuously
                //
                i = 10;
                cnt = SYS_ADPT_MAX_NBR_OF_VLAN_XLATE_PER_PORT;
                while (cnt-- > 0)
                {
                    new_vid = i++;
                    result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
                    assert(RULE_TYPE_OK == result);

                    remapped_pkt_type = (RULE_TYPE_INBOUND == interface.direction) ?
                                             RULE_TYPE_PACKET_VLAN_TRANSLATION :
                                       RULE_TYPE_PACKET_EGRESS_VLAN_TRANSLATION;

                    class_inst_p = NULL;
                    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                              remapped_pkt_type,
                                                                              RULE_TYPE_INST_CPU_IF,
                                                                              remapped_pkt_type,
                                                                              &class_inst_p);
                    assert(RULE_TYPE_OK == result);
                    assert(NULL != class_inst_p);

                    enable_flag = (0 != new_vid) ? TRUE : FALSE;

                    RULE_CTRL_UT_Proc_Validate_Vlan_Translation_Rule(enable_flag,
                                                                     &interface,
                                                                     remapped_pkt_type,
                                                                     class_inst_p,
                                                                     old_vid, new_vid);
                }

                old_vid = 1;
                new_vid = 0;
                result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
                assert(RULE_TYPE_OK == result);

                //
                // Capacity test
                //
                i = 2;
                cnt = SYS_ADPT_MAX_NBR_OF_VLAN_XLATE_PER_PORT;
                class_inst_p = NULL;

                while (cnt -- > 0)
                {
                    old_vid = i;
                    new_vid = (i++) + 10;
                    result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
                    assert(RULE_TYPE_OK == result);

                    remapped_pkt_type = (RULE_TYPE_INBOUND == interface.direction) ?
                                             RULE_TYPE_PACKET_VLAN_TRANSLATION :
                                       RULE_TYPE_PACKET_EGRESS_VLAN_TRANSLATION;

                    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                              remapped_pkt_type,
                                                                              RULE_TYPE_INST_CPU_IF,
                                                                              remapped_pkt_type,
                                                                              &class_inst_p);
                    assert(RULE_TYPE_OK == result);
                    assert(NULL != class_inst_p);

                    enable_flag = (0 != new_vid) ? TRUE : FALSE;

                    RULE_CTRL_UT_Proc_Validate_Vlan_Translation_Rule(enable_flag,
                                                                     &interface,
                                                                     remapped_pkt_type,
                                                                     class_inst_p,
                                                                     old_vid, new_vid);
                }

                old_vid = i;
                new_vid = (i++) + 10;
                result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
                assert(RULE_TYPE_OK != result);

                //
                // Remove all
                //
                for (; i > 0; )
                {
                    old_vid = --i;
                    new_vid = 0;

                    result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
                    assert(RULE_TYPE_OK == result);
                }

                //
                // and re-test again
                //
                i = 100;
                cnt = SYS_ADPT_MAX_NBR_OF_VLAN_XLATE_PER_PORT;
                class_inst_p = NULL;

                for (i = 0; i < cnt; i ++)
                {
                    old_vid = i;
                    new_vid = i + 10;
                    result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
                    assert(RULE_TYPE_OK == result);

                    remapped_pkt_type = (RULE_TYPE_INBOUND == interface.direction) ?
                                             RULE_TYPE_PACKET_VLAN_TRANSLATION :
                                       RULE_TYPE_PACKET_EGRESS_VLAN_TRANSLATION;

                    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                              remapped_pkt_type,
                                                                              RULE_TYPE_INST_CPU_IF,
                                                                              remapped_pkt_type,
                                                                              &class_inst_p);
                    assert(RULE_TYPE_OK == result);
                    assert(NULL != class_inst_p);

                    enable_flag = (0 != new_vid) ? TRUE : FALSE;

                    RULE_CTRL_UT_Proc_Validate_Vlan_Translation_Rule(enable_flag,
                                                                     &interface,
                                                                     remapped_pkt_type,
                                                                     class_inst_p,
                                                                     old_vid, new_vid);
                }

                old_vid = i;
                new_vid = (i++) + 10;
                result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
                assert(RULE_TYPE_OK != result);
            }
        }
    }

#else
    assert(0);
#endif
    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_Rate_Limit_Rule(
    BOOL_T enable_flag,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    UI32_T rate)
{
    RULE_TYPE_RETURN_TYPE_T result;

    BOOL_T b_result;

    if (TRUE == enable_flag)
    {
        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        assert(1 == RULE_CTRL_UT_Proc_Count_Of_Rule_Instance(class_inst_p));

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        assert(0 != rule_inst_p->dev_rule_info.rule_id);
        assert(TRUE == rule_inst_p->active);

        rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
        assert(NULL != rule_entry_p);

        assert(0 == rule_entry_p->rule_pattern.entry_qualify);

        {
            DEVRM_PCE_T *pce;
            CPSS_DXCH_POLICER_STAGE_TYPE_ENT policer_stage;

            b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                    rule_inst_p->dev_rule_info.rule_id,
                                    &pce);

            assert(TRUE == b_result);
            assert(NULL != pce);
            assert(-1 != pce->policer_idx);

            DEVRM_GetPolicerStageFromPce(rule_inst_p->dev_rule_info.device,
                                         pce,
                                         &policer_stage);

            assert(CPSS_DXCH_POLICER_STAGE_INGRESS_0_E == policer_stage);

            //
            // Validates the rule should be bound at 0-1 ingress PCL
            //
            {
                GT_U8 devNum = 0;
                CPSS_PCL_DIRECTION_ENT          direction;
                CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum;

                CPSS_INTERFACE_INFO_STC         interfaceInfo;
                CPSS_DXCH_PCL_LOOKUP_CFG_STC    lookupCfg;

                GT_STATUS rc;

                UI32_T phy_port;

                {
                    UI32_T module_id;
                    UI32_T device_id;

                    assert(RULE_TYPE_INTERFACE_UPORT == interface_p->type);

                    b_result = DEV_SWDRV_Logical2PhyDevicePortID(interface_p->uport.unit,
                                                                 interface_p->uport.port,
                                                                 &module_id, &device_id, &phy_port);
                    assert(TRUE == b_result);

                    assert(device_id == rule_inst_p->dev_rule_info.device);
                }

                direction = CPSS_PCL_DIRECTION_INGRESS_E;
                lookupNum = CPSS_PCL_LOOKUP_0_E;

                interfaceInfo.type = CPSS_INTERFACE_PORT_E;
                interfaceInfo.devPort.devNum = rule_inst_p->dev_rule_info.device;
                interfaceInfo.devPort.portNum = phy_port;
                interfaceInfo.devNum = rule_inst_p->dev_rule_info.device;

                rc = cpssDxChPclCfgTblGet(devNum,
                                          &interfaceInfo,
                                          direction,
                                          lookupNum,
                                          &lookupCfg);
                assert(GT_OK == rc);
                assert(GT_TRUE == lookupCfg.enableLookup);
                assert(GT_TRUE == lookupCfg.dualLookup);
                assert(pce->pcl_id == lookupCfg.pclIdL01);
            }

            //
            // Validates the content of rule and action
            //
            {
                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT      ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT           pattern_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT           mask_u;
                CPSS_DXCH_PCL_ACTION_STC                action;
                CPSS_DXCH3_POLICER_METERING_ENTRY_STC   meter;

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(RULE_TYPE_OK == result);

                assert(pce->pcl_id == pattern_u.ruleExtNotIpv6.common.pclId);

                assert(CPSS_PACKET_CMD_FORWARD_E == action.pktCmd);
                assert(-1 != pce->policer_idx && (UI32_T)pce->policer_idx == action.policer.policerId);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Meter(rule_inst_p->dev_rule_info.device,
                                                         pce,
                                                         &meter);
                assert(RULE_TYPE_OK == result);
                assert(CPSS_POLICER_COLOR_BLIND_E == meter.meterColorMode);
                assert(rate == meter.tokenBucketParams.srTcmParams.cir);

                assert(CPSS_DXCH3_POLICER_NON_CONFORM_CMD_DROP_E == meter.redPcktCmd);
                assert(CPSS_DXCH3_POLICER_NON_CONFORM_CMD_NO_CHANGE_E == meter.yellowPcktCmd);

                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
            }
        }
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

void
RULE_CTRL_UT_Proc_Set_Rate_Limit_Rule(
    BOOL_T enable_flag,
    UI32_T unit,
    UI32_T port,
    UI32_T k_bps)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_RATE_LIMIT;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    BOOL_T b_result;

    if (TRUE == enable_flag)
    {
        b_result = RULE_CTRL_SetRateLimit(unit, port, 0, k_bps);
        assert(TRUE == b_result);
    }
    else
    {
        b_result = RULE_CTRL_DeleteRateLimit(unit, port, 0);
        assert(TRUE == b_result);
    }

    memset(&interface, 0, sizeof(interface));
    interface.type = RULE_TYPE_INTERFACE_UPORT;
    interface.uport.unit = unit;
    interface.uport.port = port;
    interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);

    if (TRUE == enable_flag)
    {
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);
    }
    else
    {
        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rate_Limit_Rule(enable_flag,
                                               &interface,
                                               remapped_pkt_type,
                                               class_inst_p,
                                               k_bps);
}

int
RULE_CTRL_UT_Set_Dflt_Rate_Limit_Rule()
{
#if ((SYS_CPNT_INGRESS_RATE_LIMIT_VIA_FILTER_ENGINE == TRUE) && (SYS_CPNT_QOS_V2 == TRUE))
    enum
    {
        MAX_UNIT = 1,
        MAX_PORT = 2,
        MAX_DIRECTION = RULE_TYPE_INBOUND,
    };

    BOOL_T enable_flag;
    UI32_T unit;
    UI32_T port;
    UI32_T k_bps;

    for (unit = 1; unit <= MAX_UNIT; ++ unit)
    {
        for (port = 1; port <= MAX_PORT; ++ port)
        {
            enable_flag = TRUE;
            k_bps = 100;
            RULE_CTRL_UT_Proc_Set_Rate_Limit_Rule(enable_flag, unit, port, k_bps);

            enable_flag = TRUE;
            k_bps = 200;
            RULE_CTRL_UT_Proc_Set_Rate_Limit_Rule(enable_flag, unit, port, k_bps);

            enable_flag = TRUE;
            k_bps = 100;
            RULE_CTRL_UT_Proc_Set_Rate_Limit_Rule(enable_flag, unit, port, k_bps);

            enable_flag = FALSE;
            k_bps = 0;
            RULE_CTRL_UT_Proc_Set_Rate_Limit_Rule(enable_flag, unit, port, k_bps);

            enable_flag = TRUE;
            k_bps = 100;
            RULE_CTRL_UT_Proc_Set_Rate_Limit_Rule(enable_flag, unit, port, k_bps);
        }
    }

#else
    assert(0);
#endif
    return 0;
}

void
RULE_CTRL_UT_Validate_Service_QinQ_Rule(
    BOOL_T is_enable,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    UI32_T inner_vid,
    UI32_T inner_priority,
    UI32_T outer_vid,
    UI32_T outer_priority)
{
    if (TRUE == is_enable)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        assert(1 == RULE_CTRL_UT_Proc_Count_Of_Rule_Instance(class_inst_p));

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        assert(0 != rule_inst_p->dev_rule_info.rule_id);
        assert(TRUE == rule_inst_p->active);

        rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
        assert(NULL != rule_entry_p);

        if (0xffff != inner_vid)
        {
            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Vlan(&rule_entry_p->rule_pattern, inner_vid, 0xfff);
        }

        if (0xffff != inner_priority)
        {
            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Cos(&rule_entry_p->rule_pattern, inner_priority, 7);
        }

        {
            DEVRM_PCE_T *pce;
            RULE_CTRL_PCL_CFG_T pcl_cfg;

            BOOL_T b_result;

            CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
            CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
            CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
            CPSS_DXCH_PCL_ACTION_STC action;
            UI32_T ui32_result;

            b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                    rule_inst_p->dev_rule_info.rule_id,
                                    &pce);
            assert(TRUE == b_result);
            assert(NULL != pce);
            assert(-1 == pce->policer_idx);

            RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                        remapped_pkt_type,
                                                        &pcl_cfg);
            assert(pce->pcl_id == pcl_cfg.pcl_id);

            assert(TRUE == RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce));

            ui32_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                         pce,
                                                         &ruleFormat, &mask_u, &pattern_u, &action);
            assert(ui32_result == RULE_TYPE_OK);

            {
                CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                assert(pattern->common.pclId == pcl_cfg.pcl_id);
                assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                if (0xffff != inner_vid)
                {
                    assert(pattern->common.vid == L_STDLIB_Hton16(inner_vid & 0x0fff));
                    assert(mask->common.vid == L_STDLIB_Hton16(0xffffffff & 0x0fff));
                }
            }

            assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);
            assert(CPSS_PACKET_CMD_FORWARD_E == action.pktCmd);

            assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_ALL_E == action.vlan.modifyVlan);
            assert(outer_vid == action.vlan.vlanId);

            assert(GT_TRUE == action.vlan.nestedVlan);

            if (0xffff != outer_priority)
            {
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E == action.qos.modifyUp);
                assert(DEV_SWDRVL4_UpToQosProfieIdx(outer_priority) == action.qos.qos.ingress.profileIndex);
                assert(GT_TRUE == action.qos.qos.ingress.profileAssignIndex);
            }
            else
            {
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
            }

        }
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

int
RULE_CTRL_UT_Set_Dflt_Service_QinQ_Rule()
{
#if (SYS_CPNT_QINQ == TRUE && SYS_CPNT_SWCTRL_QINQ_SERVICE == TRUE)
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_UP_VID;

    int    retry_count = 1;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    BOOL_T is_enable;

    BOOL_T b_result;

    UI32_T i;

    UI32_T unit;
    UI32_T port;

    UI32_T inner_vid;
    UI32_T inner_priority;

    UI32_T outer_vid;
    UI32_T outer_priority;

    ////////////////////////////////////////////////////////////////////////////

    //
    // Create rule
    //
    is_enable = TRUE;

    unit = 1;
    port = 2;

    inner_vid = 1000;
    inner_priority = 2;

    outer_vid = 2000;
    outer_priority = 6;

    b_result = RULE_CTRL_Service_QinQ(unit, port, inner_vid, inner_priority, outer_vid, outer_priority, is_enable);

    assert(TRUE == b_result);

    // RULE_CTRL_DumpDfltAceByPort_BackDoor(unit, port);

    interface.type = RULE_TYPE_INTERFACE_UPORT;
    interface.uport.unit = unit;
    interface.uport.port = port;
    interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);
    assert(RULE_TYPE_OK == result);
    assert(NULL != class_inst_p);

    RULE_CTRL_UT_Validate_Service_QinQ_Rule(is_enable,
                                            &interface,
                                            remapped_pkt_type,
                                            class_inst_p,
                                            inner_vid, inner_priority,
                                            outer_vid, outer_priority);

    ////////////////////////////////////////////////////////////////////////////

    //
    // Update rule (Not create entry)
    //

    for (i = 0; i < SYS_ADPT_MAX_NBR_OF_QINQ_SERVICE_SUBSCRIPTION_PER_PORT + 1; ++i)
    {
        is_enable = TRUE;

        outer_vid = 2000 + i;
        outer_priority = (i % 8);

        b_result = RULE_CTRL_Service_QinQ(unit, port, inner_vid, inner_priority,
                                          outer_vid, outer_priority, is_enable);
        assert(TRUE == b_result);

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Validate_Service_QinQ_Rule(is_enable,
                                                &interface,
                                                remapped_pkt_type,
                                                class_inst_p,
                                                inner_vid, inner_priority,
                                                outer_vid, outer_priority);
    }

    ////////////////////////////////////////////////////////////////////////////

    //
    // Update rule (Not create entry)
    //

    for (i = 0; i < SYS_ADPT_MAX_NBR_OF_QINQ_SERVICE_SUBSCRIPTION_PER_PORT + 1; ++i)
    {
        is_enable = TRUE;

        outer_vid = 0xffff;
        outer_priority = (i % 8);

        b_result = RULE_CTRL_Service_QinQ(unit, port, inner_vid, inner_priority,
                                          outer_vid, outer_priority, is_enable);
        assert(TRUE == b_result);

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Validate_Service_QinQ_Rule(is_enable,
                                                &interface,
                                                remapped_pkt_type,
                                                class_inst_p,
                                                inner_vid, inner_priority,
                                                outer_vid, outer_priority);
    }

    ////////////////////////////////////////////////////////////////////////////

    //
    // Update rule (Not create entry)
    //

    for (i = 0; i < SYS_ADPT_MAX_NBR_OF_QINQ_SERVICE_SUBSCRIPTION_PER_PORT + 1; ++i)
    {
        is_enable = TRUE;

        outer_vid = 2000 + i;
        outer_priority = 0xffff;

        b_result = RULE_CTRL_Service_QinQ(unit, port, inner_vid, inner_priority,
                                          outer_vid, outer_priority, is_enable);
        assert(TRUE == b_result);

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Validate_Service_QinQ_Rule(is_enable,
                                                &interface,
                                                remapped_pkt_type,
                                                class_inst_p,
                                                inner_vid, inner_priority,
                                                outer_vid, outer_priority);
    }

    ////////////////////////////////////////////////////////////////////////////

    //
    // Remove rule
    //

    is_enable = FALSE;

    b_result = RULE_CTRL_Service_QinQ(unit, port, inner_vid, inner_priority,
                                      outer_vid, outer_priority, is_enable);
    assert(TRUE == b_result);

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);
    assert(RULE_TYPE_OK != result);
    assert(NULL == class_inst_p);

    RULE_CTRL_UT_Proc_Validate_Rule();

    ////////////////////////////////////////////////////////////////////////////

    //
    // Remove rule second (nothing to do)
    //

    is_enable = FALSE;

    b_result = RULE_CTRL_Service_QinQ(unit, port, inner_vid, inner_priority,
                                      outer_vid, outer_priority, is_enable);
    assert(TRUE == b_result);

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);
    assert(RULE_TYPE_OK != result);
    assert(NULL == class_inst_p);

    RULE_CTRL_UT_Proc_Validate_Rule();

retry_again:
    ////////////////////////////////////////////////////////////////////////////

    //
    // Capacity test
    //

    class_inst_p = NULL;

    for (i = 0; i < SYS_ADPT_MAX_NBR_OF_QINQ_SERVICE_SUBSCRIPTION_PER_PORT; ++i)
    {
        is_enable = TRUE;

        unit = 1;
        port = 2;

        inner_vid = 1000 + i;
        inner_priority = 2;

        outer_vid = 2000;
        outer_priority = 6;

        b_result = RULE_CTRL_Service_QinQ(unit, port, inner_vid, inner_priority,
                                          outer_vid, outer_priority, is_enable);
        assert(TRUE == b_result);

        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Validate_Service_QinQ_Rule(is_enable,
                                                &interface,
                                                remapped_pkt_type,
                                                class_inst_p,
                                                inner_vid, inner_priority,
                                                outer_vid, outer_priority);
    }

    is_enable = TRUE;

    unit = 1;
    port = 2;

    inner_vid = 1000 + i;
    inner_priority = 2;

    outer_vid = 2000;
    outer_priority = 6;

    b_result = RULE_CTRL_Service_QinQ(unit, port, inner_vid, inner_priority,
                                      outer_vid, outer_priority, is_enable);
    assert(TRUE != b_result);

    RULE_CTRL_UT_Proc_Validate_Rule();

    ////////////////////////////////////////////////////////////////////////////

    //
    // Update rule
    //

    for (i = 0; i < SYS_ADPT_MAX_NBR_OF_QINQ_SERVICE_SUBSCRIPTION_PER_PORT; ++i)
    {
        is_enable = TRUE;

        unit = 1;
        port = 2;

        inner_vid = 1000 + i;
        inner_priority = 2;

        outer_vid = 3000;
        outer_priority = 5;

        b_result = RULE_CTRL_Service_QinQ(unit, port, inner_vid, inner_priority,
                                          outer_vid, outer_priority, is_enable);
        assert(TRUE == b_result);
    }

    class_inst_p = NULL;
    for (i = 0; i < SYS_ADPT_MAX_NBR_OF_QINQ_SERVICE_SUBSCRIPTION_PER_PORT; ++i)
    {
        unit = 1;
        port = 2;

        inner_vid = 1000 + i;
        inner_priority = 2;

        outer_vid = 3000;
        outer_priority = 5;

        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Validate_Service_QinQ_Rule(is_enable,
                                                &interface,
                                                remapped_pkt_type,
                                                class_inst_p,
                                                inner_vid, inner_priority,
                                                outer_vid, outer_priority);
    }

    ////////////////////////////////////////////////////////////////////////////

    //
    // Update rule
    //

    for (i = 0; i < SYS_ADPT_MAX_NBR_OF_QINQ_SERVICE_SUBSCRIPTION_PER_PORT; ++i)
    {
        is_enable = TRUE;

        unit = 1;
        port = 2;

        inner_vid = 1000 + i;
        inner_priority = 2;

        outer_vid = 0xffff;
        outer_priority = 5;

        b_result = RULE_CTRL_Service_QinQ(unit, port, inner_vid, inner_priority,
                                          outer_vid, outer_priority, is_enable);
        assert(TRUE == b_result);
    }

    class_inst_p = NULL;
    for (i = 0; i < SYS_ADPT_MAX_NBR_OF_QINQ_SERVICE_SUBSCRIPTION_PER_PORT; ++i)
    {
        unit = 1;
        port = 2;

        inner_vid = 1000 + i;
        inner_priority = 2;

        outer_vid = 0xffff;
        outer_priority = 5;

        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Validate_Service_QinQ_Rule(is_enable,
                                                &interface,
                                                remapped_pkt_type,
                                                class_inst_p,
                                                inner_vid, inner_priority,
                                                outer_vid, outer_priority);
    }

    ////////////////////////////////////////////////////////////////////////////

    //
    // Update rule
    //

    for (i = 0; i < SYS_ADPT_MAX_NBR_OF_QINQ_SERVICE_SUBSCRIPTION_PER_PORT; ++i)
    {
        is_enable = TRUE;

        unit = 1;
        port = 2;

        inner_vid = 1000 + i;
        inner_priority = 2;

        outer_vid = 3000;
        outer_priority = 0xffff;

        b_result = RULE_CTRL_Service_QinQ(unit, port, inner_vid, inner_priority,
                                          outer_vid, outer_priority, is_enable);
        assert(TRUE == b_result);
    }

    class_inst_p = NULL;
    for (i = 0; i < SYS_ADPT_MAX_NBR_OF_QINQ_SERVICE_SUBSCRIPTION_PER_PORT; ++i)
    {
        unit = 1;
        port = 2;

        inner_vid = 1000 + i;
        inner_priority = 2;

        outer_vid = 3000;
        outer_priority = 0xffff;

        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Validate_Service_QinQ_Rule(is_enable,
                                                &interface,
                                                remapped_pkt_type,
                                                class_inst_p,
                                                inner_vid, inner_priority,
                                                outer_vid, outer_priority);
    }

    ////////////////////////////////////////////////////////////////////////////

    //
    // Remove all
    //

    for (i = 0; i < SYS_ADPT_MAX_NBR_OF_QINQ_SERVICE_SUBSCRIPTION_PER_PORT; ++i)
    {
        is_enable = FALSE;

        unit = 1;
        port = 2;

        inner_vid = 1000 + i;
        inner_priority = 2;

        outer_vid = 3000;
        outer_priority = 5;

        b_result = RULE_CTRL_Service_QinQ(unit, port, inner_vid, inner_priority,
                                          outer_vid, outer_priority, is_enable);
        assert(TRUE == b_result);

        RULE_CTRL_UT_Proc_Validate_Rule();
    }

    if (retry_count-- > 0)
    {
        goto retry_again;
    }

#endif // SYS_CPNT_QINQ && SYS_CPNT_SWCTRL_QINQ_SERVICE

    return 0;
}

void
RULE_CTRL_UT_Validate_Ip_Subnet_VLAN_Per_Port_Rule(
    BOOL_T is_enable,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    UI32_T ip_addr,
    UI32_T mask_addr,
    UI16_T vid,
    UI8_T priority)
{
    if (TRUE == is_enable)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        assert(1 == RULE_CTRL_UT_Proc_Count_Of_Rule_Instance(class_inst_p));

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        assert(0 != rule_inst_p->dev_rule_info.rule_id);
        assert(TRUE == rule_inst_p->active);

        rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
        assert(NULL != rule_entry_p);

        RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Source_Address(&rule_entry_p->rule_pattern, ip_addr, mask_addr);

        {
            DEVRM_PCE_T *pce;
            RULE_CTRL_PCL_CFG_T pcl_cfg;

            BOOL_T b_result;

            CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
            CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
            CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
            CPSS_DXCH_PCL_ACTION_STC action;
            UI32_T ui32_result;

            b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                    rule_inst_p->dev_rule_info.rule_id,
                                    &pce);
            assert(TRUE == b_result);
            assert(NULL != pce);
            assert(-1 == pce->policer_idx);

            RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                        remapped_pkt_type,
                                                        &pcl_cfg);
            assert(pce->pcl_id == pcl_cfg.pcl_id);

            assert(TRUE == RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce));

            ui32_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                         pce,
                                                         &ruleFormat, &mask_u, &pattern_u, &action);
            assert(ui32_result == RULE_TYPE_OK);

            {
                CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                assert(pattern->common.pclId == pcl_cfg.pcl_id);
                assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                assert(pattern->sip.u32Ip == L_STDLIB_Hton32(ip_addr));
                assert(mask->sip.u32Ip == L_STDLIB_Hton32(mask_addr));

                assert(1 == pattern->common.isIp);
                assert(0xff == mask->common.isIp);
            }

            assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);

            assert(CPSS_PACKET_CMD_FORWARD_E == action.pktCmd);

            assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_FOR_UNTAGGED_E == action.vlan.modifyVlan);
            assert(vid == action.vlan.vlanId);
            assert(GT_FALSE == action.vlan.nestedVlan);

#if (SYS_CPNT_IP_SUBNET_VLAN_WITH_PRIORITY == TRUE)
            assert(CPSS_PACKET_ATTRIBUTE_MODIFY_ENABLE_E == action.qos.modifyUp);
            assert(DEV_SWDRVL4_UpToQosProfieIdx(priority) == action.qos.qos.ingress.profileIndex);
            assert(GT_TRUE == action.qos.qos.ingress.profileAssignIndex);
#else
            assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
#endif // SYS_CPNT_MAC_VLAN_WITH_PRIORITY

        }
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

int
RULE_CTRL_UT_Set_Dflt_Ip_Subnet_VLAN_Per_Port_Rule()
{
#if (SYS_CPNT_IP_SUBNET_VLAN_BIND_PORT == TRUE)
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_IP_SUBNET_BASED_VLAN_PER_PORT;

    int    retry_count = 1;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    BOOL_T is_enable;

    BOOL_T b_result;

    UI32_T i;

    UI32_T unit;
    UI32_T port;

    UI32_T ip_addr;
    UI32_T mask_addr;

    UI16_T vid;
    UI8_T priority;

    ////////////////////////////////////////////////////////////////////////////

    //
    // Create rule
    //
    is_enable = TRUE;

    unit = 1;
    port = 2;

    ip_addr   = 0x01020304;
    mask_addr = 0xffffffff;

    vid = 1001;
    priority = 7;

    b_result = RULE_CTRL_SetIpSubnetVlanEntryPerPort(unit, port, ip_addr, mask_addr, vid, priority);

    assert(TRUE == b_result);

    // RULE_CTRL_DumpDfltAceByPort_BackDoor(unit, port);

    interface.type = RULE_TYPE_INTERFACE_UPORT;
    interface.uport.unit = unit;
    interface.uport.port = port;
    interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);
    assert(RULE_TYPE_OK == result);
    assert(NULL != class_inst_p);

    RULE_CTRL_UT_Validate_Ip_Subnet_VLAN_Per_Port_Rule(is_enable,
                                                       &interface,
                                                       remapped_pkt_type,
                                                       class_inst_p,
                                                       ip_addr, mask_addr,
                                                       vid, priority);

    ////////////////////////////////////////////////////////////////////////////

    //
    // Update rule (Not create entry)
    //

    for (i = 0; i < SYS_ADPT_MAX_NBR_OF_IP_SUBNET_VLAN_ENTRY + 1; ++i)
    {
        is_enable = TRUE;

        vid = 1001 + i;
        priority = (i % 8);

        b_result = RULE_CTRL_SetIpSubnetVlanEntryPerPort(unit, port, ip_addr, mask_addr, vid, priority);
        assert(TRUE == b_result);

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Validate_Ip_Subnet_VLAN_Per_Port_Rule(is_enable,
                                                           &interface,
                                                           remapped_pkt_type,
                                                           class_inst_p,
                                                           ip_addr, mask_addr,
                                                           vid, priority);
    }

    ////////////////////////////////////////////////////////////////////////////

    //
    // Remove rule
    //

    is_enable = FALSE;

    b_result = RULE_CTRL_DeleteIpSubnetVlanEntryPerPort(unit, port, ip_addr, mask_addr);
    assert(TRUE == b_result);

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);
    assert(RULE_TYPE_OK != result);
    assert(NULL == class_inst_p);

    RULE_CTRL_UT_Proc_Validate_Rule();

    ////////////////////////////////////////////////////////////////////////////

    //
    // Remove rule second (nothing to do)
    //

    is_enable = FALSE;

    b_result = RULE_CTRL_DeleteIpSubnetVlanEntryPerPort(unit, port, ip_addr, mask_addr);
    assert(TRUE == b_result);

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);
    assert(RULE_TYPE_OK != result);
    assert(NULL == class_inst_p);

    RULE_CTRL_UT_Proc_Validate_Rule();

retry_again:
    ////////////////////////////////////////////////////////////////////////////

    //
    // Capacity test
    //

    class_inst_p = NULL;

    for (i = 0; i < SYS_ADPT_MAX_NBR_OF_IP_SUBNET_VLAN_ENTRY; ++i)
    {
        is_enable = TRUE;

        unit = 1;
        port = 2;

        ip_addr   = 0x01020300 + i;
        mask_addr = 0xffffffff;

        vid = 1000 + i;
        priority = 6;

        b_result = RULE_CTRL_SetIpSubnetVlanEntryPerPort(unit, port, ip_addr, mask_addr, vid, priority);
        assert(TRUE == b_result);

        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Validate_Ip_Subnet_VLAN_Per_Port_Rule(is_enable,
                                                           &interface,
                                                           remapped_pkt_type,
                                                           class_inst_p,
                                                           ip_addr, mask_addr,
                                                           vid, priority);
    }

    is_enable = TRUE;

    unit = 1;
    port = 2;

    ip_addr   = 0x01020300 + i;
    mask_addr = 0xffffffff;

    vid = 1000 + i;
    priority = 6;

    b_result = RULE_CTRL_SetIpSubnetVlanEntryPerPort(unit, port, ip_addr, mask_addr, vid, priority);
    assert(TRUE != b_result);

    RULE_CTRL_UT_Proc_Validate_Rule();

    ////////////////////////////////////////////////////////////////////////////

    //
    // Update rule
    //

    for (i = 0; i < SYS_ADPT_MAX_NBR_OF_IP_SUBNET_VLAN_ENTRY; ++i)
    {
        is_enable = TRUE;

        ip_addr   = 0x01020300 + i;
        mask_addr = 0xffffffff;

        vid = 2000 + i;
        priority = 4;

        b_result = RULE_CTRL_SetIpSubnetVlanEntryPerPort(unit, port, ip_addr, mask_addr, vid, priority);
        assert(TRUE == b_result);
    }

    class_inst_p = NULL;
    for (i = 0; i < SYS_ADPT_MAX_NBR_OF_IP_SUBNET_VLAN_ENTRY; ++i)
    {
        unit = 1;
        port = 2;

        ip_addr   = 0x01020300 + i;
        mask_addr = 0xffffffff;

        vid = 2000 + i;
        priority = 4;

        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Validate_Ip_Subnet_VLAN_Per_Port_Rule(is_enable,
                                                           &interface,
                                                           remapped_pkt_type,
                                                           class_inst_p,
                                                           ip_addr, mask_addr,
                                                           vid, priority);
    }

    ////////////////////////////////////////////////////////////////////////////

    //
    // Remove all
    //

    for (i = 0; i < SYS_ADPT_MAX_NBR_OF_IP_SUBNET_VLAN_ENTRY; ++i)
    {
        is_enable = FALSE;

        unit = 1;
        port = 2;

        ip_addr   = 0x01020300 + i;
        mask_addr = 0xffffffff;

        vid = 2000 + i;
        priority = 4;

        b_result = RULE_CTRL_DeleteIpSubnetVlanEntryPerPort(unit, port, ip_addr, mask_addr);
        assert(TRUE == b_result);

        RULE_CTRL_UT_Proc_Validate_Rule();
    }

    if (retry_count-- > 0)
    {
        goto retry_again;
    }

#endif // SYS_CPNT_IP_SUBNET_VLAN_BIND_PORT

    return 0;
}

int
RULE_CTRL_UT_Set_All_Global_And_Dflt_Rule()
{
    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T unit = 1;
    UI32_T port = 3;

    RULE_TYPE_CpuRuleInfo_T info;

    BOOL_T is_enable;
    BOOL_T b_result;

    is_enable = TRUE;

again:

    info.common.flood = FALSE;
    info.common.to_cpu = TRUE;

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_EAPS, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_DOT1X, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_ARP_REPLY, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_ARP_REQUEST, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_RIP, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_OSPF, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_OSPF6, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_DVMRP, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_PIM, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_VRRP, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_UNKNOWN_IPMC, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_IP_BCAST, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_L2_SLF, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_CFM, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_RAPS, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_L2PT, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_CDP, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_PVST, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_PTP_EVENT_ETH, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_ALL_HOST, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_ALL_ROUTER, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_MY_MAC_MY_IP, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_IP_OPTION, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_SLF, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_IGMP, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_HBT, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_BPDU, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_L2CP, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_MY_MAC_ARP, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_Packettype_MY_MAC_CRAFT_PORT, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_PTP_EVENT_UDP, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_PTP_GENERAL_UDP, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_IPV6_ALL_NODES, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_IPV6_ALL_ROUTERS, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_UNKNOWN_IPV6MC, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_MLD_Query, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_MLD_Report, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_MLD_Done, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_MLDV2_Reports, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_DHCP6_CLIENT, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_DHCP6_SERVER, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_LinkLocal, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_PIM6, &info);
    assert(TRUE == b_result);

    ////////////////////////////////////////////////////////////////////////////

#if (SYS_CPNT_DHCPSNP == TRUE)
    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_DHCP_CLIENT, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_DHCP_SERVER, &info);
    assert(TRUE == b_result);
#endif /* SYS_CPNT_DHCPSNP */

#if (SYS_CPNT_DHCPV6SNP == TRUE)
    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_DHCP6_CLIENT, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_DHCP6_SERVER, &info);
    assert(TRUE == b_result);
#endif /* SYS_CPNT_DHCPV6SNP */

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_ORG_SPECIFIC, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_ORG_SPECIFIC2, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_CDP, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_PVST, &info);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_IGMP, &info);
    assert(TRUE == b_result);

#if (SYS_CPNT_IP_SUBNET_VLAN_BIND_PORT == TRUE)
    if (is_enable == TRUE)
    {
        b_result = RULE_CTRL_SetIpSubnetVlanEntryPerPort(unit, port,
                                                         0x01020304,    // IP address
                                                         0xffffffff,    // mask address
                                                         1001,          // vlan ID
                                                         5);            // priority
        assert(TRUE == b_result);
    }
    else
    {

        b_result =  RULE_CTRL_DeleteIpSubnetVlanEntryPerPort(unit, port,
                                                             0x01020304,     // IP address
                                                             0xffffffff);    // mask address
        assert(TRUE == b_result);
    }
#endif // SYS_CPNT_IP_SUBNET_VLAN_BIND_PORT

    b_result = RULE_CTRL_SetMulticastEntry(unit, port,
                                           1002,                    // vlan ID
                                           is_enable);
    assert(TRUE == b_result);

#if (SYS_CPNT_QINQ == TRUE)
#if (SYS_CPNT_SWCTRL_QINQ_SERVICE == TRUE)
    b_result = RULE_CTRL_Service_QinQ(unit, port, 1000, 2, 2000, 4, is_enable);
    assert(TRUE == b_result);
#endif /*end of #if (SYS_CPNT_SWCTRL_QINQ_SERVICE == TRUE)*/

#if (SYS_CPNT_QINQ_L2PT == TRUE)
#if (SYS_CPNT_QINQ_L2PT_DA_REMARK == TRUE)
    {
        UI8_T tunnel_da[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06};

        b_result = RULE_CTRL_SetL2PTTunnelPduToCpu(tunnel_da, is_enable);
        assert(TRUE == b_result);
    }
#endif /* (SYS_CPNT_QINQ_L2PT_DA_REMARK == TRUE) */

#if (SYS_CPNT_QINQ_L2PT_CUSTOM_PDU == TRUE)
    {
        UI8_T dst_mac[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06};

        b_result = RULE_CTRL_SetCustomPduTrapStatusForL2PT(unit, port,
                                                           1,       // id
                                                           dst_mac,
                                                           0x0102,  // ethertype
                                                           0,       // pdu_len
                                                           NULL,    // pdu_data
                                                           NULL,    // pdu_mask
                                                           is_enable);
        assert(TRUE == b_result);
    }
#endif /* (SYS_CPNT_QINQ_L2PT_CUSTOM_PDU == TRUE) */
#endif /* (SYS_CPNT_QINQ_L2PT == TRUE) */
#endif /*end of #if (SYS_CPNT_QINQ == TRUE)*/

#if (SYS_CPNT_PPPOE_IA == TRUE)
    b_result = RULE_CTRL_SetPPPoEDPktToCpuPerSystem(is_enable);
#endif // #if (SYS_CPNT_PPPOE_IA == TRUE)

#if (SYS_CPNT_ERPS == TRUE)
    {
        UI8_T dst_mac[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06};

        b_result = RULE_CTRL_LocalSetRapsPktToCpuPerSystem(0x0102,  // eth_type
                                                           dst_mac,
                                                           is_enable);

        //
        // Set by RULE_CTRL_TrapPacket2Cpu(... RULE_TYPE_PacketType_RAPS ?
        //
        if (TRUE == is_enable && TRUE != b_result)
        {
            b_result = RULE_CTRL_TrapPacket2Cpu(FALSE, RULE_TYPE_PacketType_RAPS, &info);
            assert(TRUE == b_result);

            b_result = RULE_CTRL_LocalSetRapsPktToCpuPerSystem(0x0102,  // eth_type
                                                               dst_mac,
                                                               TRUE);
            assert(TRUE == b_result);

            b_result = RULE_CTRL_LocalSetRapsPktToCpuPerSystem(0x0102,  // eth_type
                                                               dst_mac,
                                                               FALSE);
            assert(TRUE == b_result);

            b_result = RULE_CTRL_TrapPacket2Cpu(TRUE, RULE_TYPE_PacketType_RAPS, &info);
            assert(TRUE == b_result);
        }
    }
#endif // #if (SYS_CPNT_ERPS == TRUE)

#if (SYS_CPNT_IP_MULTICAST_DATA_DROP == TRUE) || (SYS_CPNT_MVR == TRUE)
    b_result = RULE_CTRL_IGMPSNP_DenyMulticastData(is_enable, unit, port);
    assert(TRUE == b_result);
#endif // #if (SYS_CPNT_IP_MULTICAST_DATA_DROP == TRUE) || (SYS_CPNT_MVR == TRUE)

#if (SYS_CPNT_IPV6_MULTICAST_DATA_DROP == TRUE) || (SYS_CPNT_MVR6 == TRUE)
    b_result = RULE_CTRL_IPV6_DenyMulticastData(is_enable, unit, port);
    assert(TRUE == b_result);
#endif // #if (SYS_CPNT_IPV6_MULTICAST_DATA_DROP == TRUE) || (SYS_CPNT_MVR6 == TRUE)

    b_result = RULE_CTRL_SetCdpPktToCpu(is_enable);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_SetPvstPktToCpu(is_enable);
    assert(TRUE == b_result);

#if (SYS_CPNT_DOS_SMURF == TRUE)
    b_result = RULE_CTRL_SetDosProtectionFilter(SWDRV_DOS_FILTER_SMURF, is_enable);
    assert(TRUE == b_result);
#endif // SYS_CPNT_DOS_SMURF

#if (SYS_CPNT_DOS_ECHO_CHARGEN == TRUE)
    b_result = RULE_CTRL_SetDosProtectionRateLimit(SWDRV_DOS_RATELIMIT_ECHO_CHARGEN, is_enable ? 4000 : 0);
    assert(TRUE == b_result);
#endif // SYS_CPNT_DOS_ECHO_CHARGEN

#if (SYS_CPNT_DOS_TCP_FLOODING == TRUE)
    b_result = RULE_CTRL_SetDosProtectionRateLimit(SWDRV_DOS_RATELIMIT_TCP_FLOODING, is_enable ? 4000 : 0);
    assert(TRUE == b_result);
#endif // SYS_CPNT_DOS_TCP_FLOODING

#if (SYS_CPNT_DOS_UDP_FLOODING == TRUE)
    b_result = RULE_CTRL_SetDosProtectionRateLimit(SWDRV_DOS_RATELIMIT_UDP_FLOODING, is_enable ? 4000 : 0);
    assert(TRUE == b_result);
#endif // SYS_CPNT_DOS_UDP_FLOODING

#if (SYS_CPNT_DOS_WIN_NUKE == TRUE)
    b_result = RULE_CTRL_SetDosProtectionRateLimit(SWDRV_DOS_RATELIMIT_WIN_NUKE, is_enable ? 4000 : 0);
    assert(TRUE == b_result);
#endif // SYS_CPNT_DOS_WIN_NUKE

#if (SYS_CPNT_VLAN_XLATE == TRUE && SYS_CPNT_VLAN_XLATE_BY_RULE == TRUE)
    {
        RULE_TYPE_INTERFACE_INFO_T interface = {0};

        interface.type = RULE_TYPE_INTERFACE_UPORT;
        interface.uport.unit = unit;
        interface.uport.port = port;
        result = RULE_CTRL_SetPortVlanXlate(&interface,
                                            1000,   // old_vid
                                            2000);  // new_vid
        assert(RULE_TYPE_OK == result);
    }
#endif // #if (SYS_CPNT_VLAN_XLATE == TRUE && SYS_CPNT_VLAN_XLATE_BY_RULE == TRUE)

#if (SYS_CPNT_ND_BY_RULE == TRUE)
    b_result = RULE_CTRL_IP6_SetNdRsPacketToCpu(is_enable);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_IP6_SetNdRaPacketToCpu(is_enable);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_IP6_SetNdNsPacketToCpu(is_enable);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_IP6_SetNdNaPacketToCpu(is_enable);
    assert(TRUE == b_result);

    b_result = RULE_CTRL_IP6_SetNdRedirectPacketToCpu(is_enable);
    assert(TRUE == b_result);
#endif // #if (SYS_CPNT_ND_BY_RULE == TRUE)

#if (SYS_CPNT_WEBAUTH == TRUE)
    {
        RULE_CTRL_UnitPort_T unit_port;
        RULE_CTRL_UnitPortSip_T unit_port_sip;

        memset(&unit_port, 0, sizeof(unit_port));
        memset(&unit_port_sip, 0, sizeof(unit_port_sip));

        unit_port.unit = unit;
        unit_port.port = port;

        unit_port_sip.unit = unit;
        unit_port_sip.port = port;
        unit_port_sip.sip  = 0x01020304;

        b_result = RULE_CTRL_Service(is_enable, RULE_CTRL_WEBAUTH_REDIR_HTTP, &unit_port);
        assert(TRUE == b_result);

        b_result = RULE_CTRL_Service(is_enable, RULE_CTRL_WEBAUTH_PERMIT_DHCPC, &unit_port);
        assert(TRUE == b_result);

        b_result = RULE_CTRL_Service(is_enable, RULE_CTRL_WEBAUTH_PERMIT_DNS, &unit_port);
        assert(TRUE == b_result);

        b_result = RULE_CTRL_Service(is_enable, RULE_CTRL_WEBAUTH_DENY_IP, &unit_port);
        assert(TRUE == b_result);

        b_result = RULE_CTRL_Service(is_enable, RULE_CTRL_WEBAUTH_PERMIT_SIP, &unit_port_sip);
        assert(TRUE == b_result);
    }
#endif //#if (SYS_CPNT_WEBAUTH == TRUE)

#if (SYS_CPNT_IP_SOURCE_GUARD == TRUE)
    {
        RULE_CTRL_UnitPortVidSip_T unit_port_vid_sip;
        RULE_CTRL_UnitPortSaVidSip_T unit_port_sa_vid_sip;
        RULE_CTRL_UnitPort_T unit_port;

        memset(&unit_port_vid_sip, 0, sizeof(unit_port_vid_sip));

        unit_port_vid_sip.unit = unit;
        unit_port_vid_sip.port = port;
        unit_port_vid_sip.sip  = 0x01020304;
        unit_port_vid_sip.vid  = 1000;

        b_result = RULE_CTRL_Service(is_enable, RULE_CTRL_IP_SOURCE_GUARD_PERMIT_VID_SIP, &unit_port_vid_sip);
        assert(TRUE == b_result);

        memset(&unit_port_sa_vid_sip, 0, sizeof(unit_port_sa_vid_sip));

        unit_port_sa_vid_sip.unit = unit;
        unit_port_sa_vid_sip.port = port;
        unit_port_sa_vid_sip.sa[4] = 0xff;
        unit_port_sa_vid_sip.sa[5] = 0x01;
        unit_port_sa_vid_sip.sip  = 0x01020304;

        b_result = RULE_CTRL_Service(is_enable, RULE_CTRL_IP_SOURCE_GUARD_PERMIT_SA_VID_SIP, &unit_port_sa_vid_sip);
        assert(TRUE == b_result);

        memset(&unit_port, 0, sizeof(unit_port));

        unit_port.unit = unit;
        unit_port.port = port;

        b_result = RULE_CTRL_Service(is_enable, RULE_CTRL_IP_SOURCE_GUARD_DENY_IP, &unit_port);
        assert(TRUE == b_result);
    }
#endif // #if (SYS_CPNT_IP_SOURCE_GUARD == TRUE)

#if (SYS_CPNT_IPV6_SOURCE_GUARD == TRUE)
    {
        RULE_CTRL_UnitPortVidSip6_T unit_port_vid_sip6;
        RULE_CTRL_UnitPort_T unit_port;

        memset(&unit_port_vid_sip6, 0, sizeof(unit_port_vid_sip6));

        unit_port_vid_sip6.unit = unit;
        unit_port_vid_sip6.port = port;
        unit_port_vid_sip6.sip6[0] = 0x20;
        unit_port_vid_sip6.sip6[15] = 0x01;
        unit_port_vid_sip6.vid = 1000;

        b_result = RULE_CTRL_Service(is_enable, RULE_CTRL_IPV6_SOURCE_GUARD_PERMIT_VID_SIP6, &unit_port_vid_sip6);
        assert(TRUE == b_result);

        memset(&unit_port, 0, sizeof(unit_port));

        unit_port.unit = unit;
        unit_port.port = port;

        b_result = RULE_CTRL_Service(is_enable, RULE_CTRL_IPV6_SOURCE_GUARD_DENY_IP6, &unit_port);
        assert(TRUE == b_result);
    }
#endif // #if (SYS_CPNT_IPV6_SOURCE_GUARD == TRUE)

#if (SYS_CPNT_EFM_OAM_REMOTE_LB_ACTIVELY == TRUE)
    b_result = RULE_CTRL_OAM_CO_TrapOamLoopbackToCPU(is_enable, unit, port);
    assert(TRUE == b_result);
#endif // #if (SYS_CPNT_EFM_OAM_REMOTE_LB_ACTIVELY == TRUE)

#if (SYS_CPNT_APP_FILTER_CDP == TRUE)
    result = RULE_CTRL_AF_DenyCdpPacket(is_enable, unit, port);
    assert(RULE_TYPE_OK == result);
#endif // SYS_CPNT_APP_FILTER_CDP

#if (SYS_CPNT_APP_FILTER_PVST == TRUE)
    result = RULE_CTRL_AF_DenyPvstPacket(is_enable, unit, port);
    assert(RULE_TYPE_OK == result);
#endif // SYS_CPNT_APP_FILTER_PVST

    RULE_CTRL_DumpGlobalAce_BackDoor();
    RULE_CTRL_DumpDfltAceByPort_BackDoor(unit, port);

    if (TRUE == is_enable)
    {
        is_enable = FALSE;
        goto again;
    }

    return 0;
}

int
RULE_CTRL_UT_Get_Utilization()
{
    RULE_TYPE_RETURN_TYPE_T result;
    RULE_CTRL_UTILIZATION_T snapshot;

    UI32_T unit = 1;
    UI32_T port = 3;

    RULE_TYPE_CpuRuleInfo_T info;

    BOOL_T is_enable;
    BOOL_T b_result;

    is_enable = TRUE;

    info.common.flood = FALSE;
    info.common.to_cpu = TRUE;

    RULE_CTRL_Priv_GetUtilization(&snapshot);

    ////////////////////////////////////////////////////////////////////////
#if (SYS_CPNT_RIP == TRUE)
    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_RIP, &info);
    assert(TRUE == b_result);

    {
        UI32_T unit;
        UI32_T device;
        RULE_CONFIG_MVL_PACKET_TYPE_T mvl_pkt_type = RULE_TYPE_PACKET_RIP;

        RULE_CTRL_UTILIZATION_T tmp_rule_util;

        RULE_CTRL_Priv_GetUtilization(&tmp_rule_util);

        for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
        {
            if (!STKTPLG_OM_UnitExist(unit))
            {
                continue;
            }

            for (device = 0; device < SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT; ++ device)
            {
                snapshot.unit[unit-1].device[device].each_type[mvl_pkt_type] += 1;
                snapshot.unit[unit-1].device[device].total += 1;
                snapshot.unit[unit-1].total += 1;
            }
        }

        snapshot.each_type[mvl_pkt_type] = DEVRM_PMGR_GetNumberOfChips();
        snapshot.total = snapshot.total + tmp_rule_util.each_type[mvl_pkt_type];

        assert(memcmp(&snapshot, &tmp_rule_util, sizeof(snapshot)) == 0);

        RULE_CTRL_Priv_GetUtilization(&snapshot);
    }
#endif /* (SYS_CPNT_RIP == TRUE) */

#if (SYS_CPNT_DHCPSNP == TRUE)

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_DHCP_CLIENT, &info);
    assert(TRUE == b_result);

    {
        UI32_T unit;
        UI32_T device;
        RULE_CONFIG_MVL_PACKET_TYPE_T mvl_pkt_type = RULE_TYPE_PACKET_DHCP_CLIENT;

        RULE_CTRL_UTILIZATION_T tmp_rule_util;

        RULE_CTRL_Priv_GetUtilization(&tmp_rule_util);

        for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
        {
            if (!STKTPLG_OM_UnitExist(unit))
            {
                continue;
            }

            for (device = 0; device < SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT; ++ device)
            {
                snapshot.unit[unit-1].device[device].each_type[mvl_pkt_type] += 1;
                snapshot.unit[unit-1].device[device].total += 1;
                snapshot.unit[unit-1].total += 1;
            }
        }

        snapshot.each_type[mvl_pkt_type] = DEVRM_PMGR_GetNumberOfChips();
        snapshot.total = snapshot.total + tmp_rule_util.each_type[mvl_pkt_type];

        assert(memcmp(&snapshot, &tmp_rule_util, sizeof(snapshot)) == 0);

        RULE_CTRL_Priv_GetUtilization(&snapshot);
    }

    ////////////////////////////////////////////////////////////////////////

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_DHCP_SERVER, &info);
    assert(TRUE == b_result);

    {
        UI32_T unit;
        UI32_T device;
        RULE_CONFIG_MVL_PACKET_TYPE_T mvl_pkt_type = RULE_TYPE_PACKET_DHCP_SERVER;

        RULE_CTRL_UTILIZATION_T tmp_rule_util;

        RULE_CTRL_Priv_GetUtilization(&tmp_rule_util);

        for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
        {
            if (!STKTPLG_OM_UnitExist(unit))
            {
                continue;
            }

            for (device = 0; device < SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT; ++ device)
            {
                snapshot.unit[unit-1].device[device].each_type[mvl_pkt_type] += 1;
                snapshot.unit[unit-1].device[device].total += 1;
                snapshot.unit[unit-1].total += 1;
            }
        }

        snapshot.each_type[mvl_pkt_type] = DEVRM_PMGR_GetNumberOfChips();
        snapshot.total = snapshot.total + tmp_rule_util.each_type[mvl_pkt_type];

        assert(memcmp(&snapshot, &tmp_rule_util, sizeof(snapshot)) == 0);

        RULE_CTRL_Priv_GetUtilization(&snapshot);
    }
#endif /* SYS_CPNT_DHCPSNP */


#if (SYS_CPNT_EFM_OAM_REMOTE_LB_ACTIVELY == TRUE)
    b_result = RULE_CTRL_OAM_CO_TrapOamLoopbackToCPU(is_enable, unit, port);
    assert(TRUE == b_result);

    {
        UI32_T device = RULE_CTRL_UT_Proc_UPort_To_Device_Id(unit, port);
        RULE_CONFIG_MVL_PACKET_TYPE_T mvl_pkt_type = RULE_TYPE_PACKET_OAM_LBK;

        RULE_CTRL_UTILIZATION_T tmp_rule_util;

        RULE_CTRL_Priv_GetUtilization(&tmp_rule_util);

        snapshot.unit[unit-1].device[device].each_type[mvl_pkt_type] += 1;
        snapshot.unit[unit-1].device[device].total += 1;
        snapshot.unit[unit-1].total += 1;

        snapshot.each_type[mvl_pkt_type] = 1;
        snapshot.total = snapshot.total + tmp_rule_util.each_type[mvl_pkt_type];

        assert(memcmp(&snapshot, &tmp_rule_util, sizeof(snapshot)) == 0);

        RULE_CTRL_Priv_GetUtilization(&snapshot);
    }
#endif // #if (SYS_CPNT_EFM_OAM_REMOTE_LB_ACTIVELY == TRUE)

#if (SYS_CPNT_APP_FILTER_CDP == TRUE)
    result = RULE_CTRL_AF_DenyCdpPacket(is_enable, unit, port);
    assert(RULE_TYPE_OK == result);

    {
        UI32_T device = RULE_CTRL_UT_Proc_UPort_To_Device_Id(unit, port);
        RULE_CONFIG_MVL_PACKET_TYPE_T mvl_pkt_type = RULE_TYPE_PACKET_AF_DENY_CDP;

        RULE_CTRL_UTILIZATION_T tmp_rule_util;

        RULE_CTRL_Priv_GetUtilization(&tmp_rule_util);

        snapshot.unit[unit-1].device[device].each_type[mvl_pkt_type] += 1;
        snapshot.unit[unit-1].device[device].total += 1;
        snapshot.unit[unit-1].total += 1;

        snapshot.each_type[mvl_pkt_type] = 1;
        snapshot.total = snapshot.total + tmp_rule_util.each_type[mvl_pkt_type];

        assert(memcmp(&snapshot, &tmp_rule_util, sizeof(snapshot)) == 0);

        RULE_CTRL_Priv_GetUtilization(&snapshot);
    }
#endif // SYS_CPNT_APP_FILTER_CDP

#if (SYS_CPNT_APP_FILTER_PVST == TRUE)
    result = RULE_CTRL_AF_DenyPvstPacket(is_enable, unit, port);
    assert(RULE_TYPE_OK == result);

    {
        UI32_T device = RULE_CTRL_UT_Proc_UPort_To_Device_Id(unit, port);
        RULE_CONFIG_MVL_PACKET_TYPE_T mvl_pkt_type = RULE_TYPE_PACKET_AF_DENY_PVST;

        RULE_CTRL_UTILIZATION_T tmp_rule_util;

        RULE_CTRL_Priv_GetUtilization(&tmp_rule_util);

        snapshot.unit[unit-1].device[device].each_type[mvl_pkt_type] += 1;
        snapshot.unit[unit-1].device[device].total += 1;
        snapshot.unit[unit-1].total += 1;

        snapshot.each_type[mvl_pkt_type] = 1;
        snapshot.total = snapshot.total + tmp_rule_util.each_type[mvl_pkt_type];

        assert(memcmp(&snapshot, &tmp_rule_util, sizeof(snapshot)) == 0);

        RULE_CTRL_Priv_GetUtilization(&snapshot);
    }
#endif // SYS_CPNT_APP_FILTER_PVST

    return 0;
}

int
RULE_CTRL_UT_Get_TCAM_Utilization()
{
    RULE_TYPE_RETURN_TYPE_T result;
    RULE_TYPE_TCAMUtilization_T snapshot;

    UI32_T unit = 1;
    UI32_T port = 3;

    RULE_TYPE_CpuRuleInfo_T info;

    BOOL_T is_enable;
    BOOL_T b_result;

    is_enable = TRUE;

    info.common.flood = FALSE;
    info.common.to_cpu = TRUE;

    b_result = RULE_CTRL_GetTCAMUtilization(&snapshot);
    assert(TRUE == b_result);

    ////////////////////////////////////////////////////////////////////////

#if (SYS_CPNT_RIP == TRUE)
    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_RIP, &info);
    assert(TRUE == b_result);

    {
        UI32_T unit;
        UI32_T device;

        RULE_TYPE_TCAMUtilization_T tmp_rule_util;
        RULE_TYPE_TCAMUtilization_T *tcam_util_p = &snapshot;

        b_result = RULE_CTRL_GetTCAMUtilization(&tmp_rule_util);
        assert(TRUE == b_result);

        for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
        {
            RULE_TYPE_TCAM_UNIT_UTIL_T *tcam_unit_p = &tcam_util_p->unit[unit-1];

            if (TRUE != STKTPLG_OM_UnitExist(unit))
            {
                continue;
            }

            for (device = 0; device < SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT; ++ device)
            {
                RULE_TYPE_TCAM_DEVICE_UTIL_T *tcam_device_p = &tcam_unit_p->device[device];

                tcam_device_p->pce_free -= (1 * 2);
                tcam_device_p->pce_used += (1 * 2);
                tcam_device_p->pce_used_by_system += (1 * 2);

                tcam_device_p->pce_utility_rate = (tcam_device_p->pce_used * 100) / (float)tcam_device_p->pce_total;

                assert(memcmp(tcam_device_p, &tmp_rule_util.unit[unit-1].device[device], sizeof(*tcam_device_p)) == 0);
            }
        }

        b_result = RULE_CTRL_GetTCAMUtilization(&snapshot);
        assert(TRUE == b_result);
    }
#endif /* (SYS_CPNT_RIP == TRUE) */

#if (SYS_CPNT_DHCPSNP == TRUE)

    b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_DHCP_CLIENT, &info);
    assert(TRUE == b_result);

    {
        UI32_T unit;
        UI32_T device;

        RULE_TYPE_TCAMUtilization_T tmp_rule_util;
        RULE_TYPE_TCAMUtilization_T *tcam_util_p = &snapshot;

        b_result = RULE_CTRL_GetTCAMUtilization(&tmp_rule_util);
        assert(TRUE == b_result);

        for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
        {
            RULE_TYPE_TCAM_UNIT_UTIL_T *tcam_unit_p = &tcam_util_p->unit[unit-1];

            if (TRUE != STKTPLG_OM_UnitExist(unit))
            {
                continue;
            }

            for (device = 0; device < SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT; ++ device)
            {
                RULE_TYPE_TCAM_DEVICE_UTIL_T *tcam_device_p = &tcam_unit_p->device[device];

                tcam_device_p->pce_free -= (1 * 2);
                tcam_device_p->pce_used += (1 * 2);
                tcam_device_p->pce_used_by_system += (1 * 2);

                tcam_device_p->pce_utility_rate = (tcam_device_p->pce_used * 100) / (float)tcam_device_p->pce_total;

                assert(memcmp(tcam_device_p, &tmp_rule_util.unit[unit-1].device[device], sizeof(*tcam_device_p)) == 0);
            }
        }

        b_result = RULE_CTRL_GetTCAMUtilization(&snapshot);
        assert(TRUE == b_result);
    }
#endif /* SYS_CPNT_DHCPSNP */

#if (SYS_CPNT_EFM_OAM_REMOTE_LB_ACTIVELY == TRUE)
    b_result = RULE_CTRL_OAM_CO_TrapOamLoopbackToCPU(is_enable, unit, port);
    assert(TRUE == b_result);

    {
        UI32_T device = RULE_CTRL_UT_Proc_UPort_To_Device_Id(unit, port);

        RULE_TYPE_TCAMUtilization_T tmp_rule_util;
        RULE_TYPE_TCAMUtilization_T *tcam_util_p = &snapshot;

        b_result = RULE_CTRL_GetTCAMUtilization(&tmp_rule_util);
        assert(TRUE == b_result);

        {
            RULE_TYPE_TCAM_UNIT_UTIL_T *tcam_unit_p = &tcam_util_p->unit[unit-1];

            RULE_TYPE_TCAM_DEVICE_UTIL_T *tcam_device_p = &tcam_unit_p->device[device];

            tcam_device_p->pce_free -= (1 * 2);
            tcam_device_p->pce_used += (1 * 2);
            tcam_device_p->pce_used_by_user += (1 * 2);

            tcam_device_p->pce_utility_rate = (tcam_device_p->pce_used * 100) / (float)tcam_device_p->pce_total;

            assert(memcmp(tcam_device_p, &tmp_rule_util.unit[unit-1].device[device], sizeof(*tcam_device_p)) == 0);
        }

        b_result = RULE_CTRL_GetTCAMUtilization(&snapshot);
        assert(TRUE == b_result);
    }
#endif // #if (SYS_CPNT_EFM_OAM_REMOTE_LB_ACTIVELY == TRUE)

#if (SYS_CPNT_IP_SOURCE_GUARD == TRUE)
    {
        RULE_CTRL_UnitPortVidSip_T unit_port_vid_sip;

        memset(&unit_port_vid_sip, 0, sizeof(unit_port_vid_sip));

        unit_port_vid_sip.unit = unit;
        unit_port_vid_sip.port = port;
        unit_port_vid_sip.sip  = 0x01020304;
        unit_port_vid_sip.vid  = 1000;

        b_result = RULE_CTRL_Service(is_enable, RULE_CTRL_IP_SOURCE_GUARD_PERMIT_VID_SIP, &unit_port_vid_sip);
        assert(TRUE == b_result);

        {
            UI32_T device = RULE_CTRL_UT_Proc_UPort_To_Device_Id(unit, port);

            RULE_TYPE_TCAMUtilization_T tmp_rule_util;
            RULE_TYPE_TCAMUtilization_T *tcam_util_p = &snapshot;

            b_result = RULE_CTRL_GetTCAMUtilization(&tmp_rule_util);
            assert(TRUE == b_result);

            {
                RULE_TYPE_TCAM_UNIT_UTIL_T *tcam_unit_p = &tcam_util_p->unit[unit-1];

                RULE_TYPE_TCAM_DEVICE_UTIL_T *tcam_device_p = &tcam_unit_p->device[device];

                tcam_device_p->pce_free -= (1 * 2);
                tcam_device_p->pce_used += (1 * 2);
                tcam_device_p->pce_used_by_user += (1 * 2);

                tcam_device_p->pce_utility_rate = (tcam_device_p->pce_used * 100) / (float)tcam_device_p->pce_total;

                assert(memcmp(tcam_device_p, &tmp_rule_util.unit[unit-1].device[device], sizeof(*tcam_device_p)) == 0);
            }

            b_result = RULE_CTRL_GetTCAMUtilization(&snapshot);
            assert(TRUE == b_result);
        }
    }
#endif // #if (SYS_CPNT_IP_SOURCE_GUARD == TRUE)
    {
        enum
        {
            MAX_ACE = 1,
        };

        const char *acl_name = "a1";
        UI32_T acl_index;

        RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace(acl_name, RULE_TYPE_MAC_ACL,
                                                 MAX_ACE, RULE_CTRL_UT_COMPRESS_DISABLE,
                                                 &acl_index);
        {
            UI32_T ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);
            BOOL_T is_add = TRUE;
            RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;

            result = RULE_CTRL_SetAcl(ifindex,
                                      RULE_TYPE_INBOUND,
                                      acl_index,
                                      is_add,
                                      RULE_TYPE_UNDEF_TIME_RANGE,
                                      counter_enable);
            assert(RULE_TYPE_OK == result);

            result = RULE_OM_SetAcl(ifindex,
                                    RULE_TYPE_INBOUND,
                                    acl_index,
                                    RULE_TYPE_UNDEF_TIME_RANGE,
                                    (UI8_T *)"",
                                    counter_enable);
            assert(RULE_TYPE_OK == result);

            {
                UI32_T device = RULE_CTRL_UT_Proc_UPort_To_Device_Id(unit, port);

                RULE_TYPE_TCAMUtilization_T tmp_rule_util;
                RULE_TYPE_TCAMUtilization_T *tcam_util_p = &snapshot;

                b_result = RULE_CTRL_GetTCAMUtilization(&tmp_rule_util);
                assert(TRUE == b_result);

                {
                    RULE_TYPE_TCAM_UNIT_UTIL_T *tcam_unit_p = &tcam_util_p->unit[unit-1];

                    RULE_TYPE_TCAM_DEVICE_UTIL_T *tcam_device_p = &tcam_unit_p->device[device];

                    tcam_device_p->pce_free -= (MAX_ACE * 2);
                    tcam_device_p->pce_used += (MAX_ACE * 2);
                    tcam_device_p->pce_used_by_user += (MAX_ACE * 2);

                    tcam_device_p->pce_utility_rate = (tcam_device_p->pce_used * 100) / (float)tcam_device_p->pce_total;

                    assert(memcmp(tcam_device_p, &tmp_rule_util.unit[unit-1].device[device], sizeof(*tcam_device_p)) == 0);
                }

                b_result = RULE_CTRL_GetTCAMUtilization(&snapshot);
                assert(TRUE == b_result);
            }
        }

//
//        FIXME: There have one priority bug,
//        RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule
//        RULE_TYPE_PACKET_IP_SG_PERMIT_HOST_STRICT vs RULE_TYPE_PACKET_ALL_PORTS_ACL_MATCH_ANY_ANY
//        Assertion failed: (pce1->hw_idx < pce2->hw_idx), function
//
#if (SYS_CPNT_QOS_V2_ALL_PORTS == TRUE)
        if (0)
        {
            UI32_T ifindex = RULE_TYPE_ALL_PORTS_1_IF_INDEX_NUMBER;
            BOOL_T is_add = TRUE;
            RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;

            result = RULE_CTRL_SetAcl(ifindex,
                                      RULE_TYPE_INBOUND,
                                      acl_index,
                                      is_add,
                                      RULE_TYPE_UNDEF_TIME_RANGE,
                                      counter_enable);
            assert(RULE_TYPE_OK == result);

            result = RULE_OM_SetAcl(ifindex,
                                    RULE_TYPE_INBOUND,
                                    acl_index,
                                    RULE_TYPE_UNDEF_TIME_RANGE,
                                    (UI8_T *)"",
                                    counter_enable);
            assert(RULE_TYPE_OK == result);

            {
                UI32_T unit;
                UI32_T device;

                RULE_TYPE_TCAMUtilization_T tmp_rule_util;
                RULE_TYPE_TCAMUtilization_T *tcam_util_p = &snapshot;

                b_result = RULE_CTRL_GetTCAMUtilization(&tmp_rule_util);
                assert(TRUE == b_result);

                for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
                {
                    RULE_TYPE_TCAM_UNIT_UTIL_T *tcam_unit_p = &tcam_util_p->unit[unit-1];

                    if (TRUE != STKTPLG_OM_UnitExist(unit))
                    {
                        continue;
                    }

                    for (device = 0; device < SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT; ++ device)
                    {
                        RULE_TYPE_TCAM_DEVICE_UTIL_T *tcam_device_p = &tcam_unit_p->device[device];

                        tcam_device_p->pce_free -= (MAX_ACE * 2);
                        tcam_device_p->pce_used += (MAX_ACE * 2);
                        tcam_device_p->pce_used_by_user += (MAX_ACE * 2);

                        tcam_device_p->pce_utility_rate = (tcam_device_p->pce_used * 100) / (float)tcam_device_p->pce_total;

                        assert(memcmp(tcam_device_p, &tmp_rule_util.unit[unit-1].device[device], sizeof(*tcam_device_p)) == 0);
                    }
                }

                b_result = RULE_CTRL_GetTCAMUtilization(&snapshot);
                assert(TRUE == b_result);
            }

        }
#endif // SYS_CPNT_QOS_V2_ALL_PORTS
    }

    return 0;
}

int
RULE_CTRL_UT_Get_TCAM_Entry()
{
#define SET_TCAM_ENTRY_INDEX(entry, unit, device, pool) \
    {                                                   \
        entry.unit = unit;                              \
        entry.device_id = device;                       \
        entry.pool_id = pool;                           \
    }

    typedef struct
    {
        UI32_T remapped_pkt_type;
        RULE_TYPE_INTERFACE_TYPE_E if_type;
        UI32_T min;
        UI32_T max;
    } PACKET_TYPE_ENTRY_T;

    PACKET_TYPE_ENTRY_T remapped_pkt_type_tbl[] =
    {
#define PACKET_TYPE(pktType, ifType, remapAceType, quota) {pktType, ifType, quota},

        RULE_CONFIG_PACKET_TYPE_TABLE

#undef PACKET_TYPE
    };

    RULE_TYPE_RETURN_TYPE_T result;
    RULE_TYPE_TCAM_ENTRY_T  snapshot_entry;
    RULE_TYPE_TCAM_ENTRY_T  tmp_tcam_entry;

    typedef struct
    {
        RULE_TYPE_PacketType_T pkt_type;

    } INPUT_T;

    INPUT_T input[] =
    {
#if (SYS_CPNT_RIP == TRUE)
        {RULE_TYPE_PacketType_RIP},
#endif /* SYS_CPNT_RIP */
#if (SYS_CPNT_DHCPSNP == TRUE)
        {RULE_TYPE_PacketType_DHCP_CLIENT},
#endif /* SYS_CPNT_DHCPSNP */


        {RULE_TYPE_PacketType_MAX}
    };

    const UI32_T unit = 1;
    const UI32_T device_id = 0;
    const UI32_T pool_id = 0;
    const UI32_T rule_size = 2;

    UI32_T i, pkt_type_cnt;
    UI32_T port;

    RULE_TYPE_CpuRuleInfo_T info;

    BOOL_T is_enable;
    BOOL_T b_result;

    is_enable = TRUE;
    info.common.flood = FALSE;
    info.common.to_cpu = TRUE;

    SET_TCAM_ENTRY_INDEX(snapshot_entry, unit, device_id, pool_id);
    result = RULE_CTRL_GetTcamEntry(&snapshot_entry);
    assert(RULE_TYPE_OK == result);

    /* check default reserved rule
     */
    {
        UI32_T reserved_rule = 0;

        for (pkt_type_cnt = 0; pkt_type_cnt < _countof(remapped_pkt_type_tbl); ++pkt_type_cnt)
        {
            if (remapped_pkt_type_tbl[pkt_type_cnt].min != 0)
            {
                reserved_rule += remapped_pkt_type_tbl[pkt_type_cnt].min * rule_size;
            }
        }

        assert(snapshot_entry.used == reserved_rule);
    }

    ////////////////////////////////////////////////////////////////////////////
    for (i = 0; i < _countof(input); ++i)
    {
        UI32_T remapped_pkt_type;

        RULE_CTRL_RemapPacketType(input[i].pkt_type, &remapped_pkt_type);
        if (remapped_pkt_type == RULE_TYPE_PACKET_MAX_TYPE)
        {
            break;
        }

        b_result = RULE_CTRL_TrapPacket2Cpu(is_enable, input[i].pkt_type, &info);
        assert(TRUE == b_result);

        SET_TCAM_ENTRY_INDEX(tmp_tcam_entry, unit, device_id, pool_id);

        result = RULE_CTRL_GetTcamEntry(&tmp_tcam_entry);
        assert(RULE_TYPE_OK == result);

        for (pkt_type_cnt = 0; pkt_type_cnt < _countof(remapped_pkt_type_tbl); ++pkt_type_cnt)
        {
            if (remapped_pkt_type_tbl[pkt_type_cnt].remapped_pkt_type == remapped_pkt_type)
            {
                if (remapped_pkt_type_tbl[pkt_type_cnt].min == 0)
                {
                    snapshot_entry.free -= 1 * rule_size;
                    snapshot_entry.used += 1 * rule_size;
                }

                assert(0 == memcmp(&snapshot_entry, &tmp_tcam_entry, sizeof(snapshot_entry)));

                break;
            }
        }

        assert(pkt_type_cnt != _countof(remapped_pkt_type_tbl));
    }

    ////////////////////////////////////////////////////////////////////////////
#if (SYS_CPNT_EFM_OAM_REMOTE_LB_ACTIVELY == TRUE)
    {
        UI32_T device;
        UI32_T remapped_pkt_type = RULE_TYPE_PACKET_OAM_LBK;

        port = 3;
        device = RULE_CTRL_UT_Proc_UPort_To_Device_Id(unit, port);

        SET_TCAM_ENTRY_INDEX(snapshot_entry, unit, device, pool_id);
        result = RULE_CTRL_GetTcamEntry(&snapshot_entry);
        assert(RULE_TYPE_OK == result);

        b_result = RULE_CTRL_OAM_CO_TrapOamLoopbackToCPU(is_enable, unit, port);
        assert(TRUE == b_result);

        SET_TCAM_ENTRY_INDEX(tmp_tcam_entry, unit, device, pool_id);
        result = RULE_CTRL_GetTcamEntry(&tmp_tcam_entry);
        assert(RULE_TYPE_OK == result);

        for (pkt_type_cnt = 0; pkt_type_cnt < _countof(remapped_pkt_type_tbl); ++pkt_type_cnt)
        {
            if (remapped_pkt_type_tbl[pkt_type_cnt].remapped_pkt_type == remapped_pkt_type)
            {
                if (remapped_pkt_type_tbl[pkt_type_cnt].min == 0)
                {
                    snapshot_entry.free -= 1 * rule_size;
                    snapshot_entry.used += 1 * rule_size;
                }

                assert(0 == memcmp(&snapshot_entry, &tmp_tcam_entry, sizeof(snapshot_entry)));

                break;
            }
        }

        assert(pkt_type_cnt != _countof(remapped_pkt_type_tbl));
    }
#endif // #if (SYS_CPNT_EFM_OAM_REMOTE_LB_ACTIVELY == TRUE)

    ////////////////////////////////////////////////////////////////////////////
#if (SYS_CPNT_IP_SOURCE_GUARD == TRUE)
    {
        RULE_CTRL_UnitPortVidSip_T unit_port_vid_sip;

        UI32_T remapped_pkt_type;
        UI32_T device;

        port = 3;
        remapped_pkt_type = RULE_TYPE_PACKET_SA_SIP_VID;

    #if (SYS_CPNT_IPSG_STRICT_MODE == TRUE)
        remapped_pkt_type = RULE_TYPE_PACKET_IP_SG_PERMIT_HOST_STRICT;
    #endif /* SYS_CPNT_IPSG_STRICT_MODE */

        memset(&unit_port_vid_sip, 0, sizeof(unit_port_vid_sip));

        unit_port_vid_sip.unit = unit;
        unit_port_vid_sip.port = port;
        unit_port_vid_sip.sip  = 0x01020304;
        unit_port_vid_sip.vid  = 1000;

        port = 3;
        device = RULE_CTRL_UT_Proc_UPort_To_Device_Id(unit, port);

        SET_TCAM_ENTRY_INDEX(snapshot_entry, unit, device, pool_id);
        result = RULE_CTRL_GetTcamEntry(&snapshot_entry);
        assert(RULE_TYPE_OK == result);

        b_result = RULE_CTRL_Service(is_enable, RULE_CTRL_IP_SOURCE_GUARD_PERMIT_VID_SIP, &unit_port_vid_sip);
        assert(TRUE == b_result);

        SET_TCAM_ENTRY_INDEX(tmp_tcam_entry, unit, device, pool_id);
        result = RULE_CTRL_GetTcamEntry(&tmp_tcam_entry);
        assert(RULE_TYPE_OK == result);

        for (pkt_type_cnt = 0; pkt_type_cnt < _countof(remapped_pkt_type_tbl); ++pkt_type_cnt)
        {
            if (remapped_pkt_type_tbl[pkt_type_cnt].remapped_pkt_type == remapped_pkt_type)
            {
                if (remapped_pkt_type_tbl[pkt_type_cnt].min == 0)
                {
                    snapshot_entry.free -= 1 * rule_size;
                    snapshot_entry.used += 1 * rule_size;
                }

                assert(0 == memcmp(&snapshot_entry, &tmp_tcam_entry, sizeof(snapshot_entry)));

                break;
            }
        }

        assert(pkt_type_cnt != _countof(remapped_pkt_type_tbl));
    }
#endif // #if (SYS_CPNT_IP_SOURCE_GUARD == TRUE)

    {
        enum
        {
            MAX_ACE = 5,
        };

        const char *acl_name = "a1";
        UI32_T remapped_pkt_type = RULE_TYPE_PACKET_ACL;
        UI32_T acl_index;
        UI32_T device;

        port = 5;
        device = RULE_CTRL_UT_Proc_UPort_To_Device_Id(unit, port);

        SET_TCAM_ENTRY_INDEX(snapshot_entry, unit, device, pool_id);
        result = RULE_CTRL_GetTcamEntry(&snapshot_entry);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace(acl_name, RULE_TYPE_MAC_ACL,
                                                 MAX_ACE, RULE_CTRL_UT_COMPRESS_DISABLE,
                                                 &acl_index);

        {
            UI32_T ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);
            BOOL_T is_add = TRUE;
            UI16_T time_range_index = RULE_TYPE_UNDEF_TIME_RANGE;
            RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;

            result = RULE_CTRL_SetAcl(ifindex,
                                      RULE_TYPE_INBOUND,
                                      acl_index,
                                      is_add,
                                      time_range_index,
                                      counter_enable);
            assert(RULE_TYPE_OK == result);

            result = RULE_OM_SetAcl(ifindex,
                                    RULE_TYPE_INBOUND,
                                    acl_index,
                                    RULE_TYPE_UNDEF_TIME_RANGE,
                                    (UI8_T *)"",
                                    counter_enable);

            assert(RULE_TYPE_OK == result);

            SET_TCAM_ENTRY_INDEX(tmp_tcam_entry, unit, device, pool_id);
            result = RULE_CTRL_GetTcamEntry(&tmp_tcam_entry);
            assert(RULE_TYPE_OK == result);

            for (pkt_type_cnt = 0; pkt_type_cnt < _countof(remapped_pkt_type_tbl); ++pkt_type_cnt)
            {
                if (remapped_pkt_type_tbl[pkt_type_cnt].remapped_pkt_type == remapped_pkt_type)
                {
                    if (remapped_pkt_type_tbl[pkt_type_cnt].min == 0)
                    {
                        snapshot_entry.free -= MAX_ACE * rule_size;
                        snapshot_entry.used += MAX_ACE * rule_size;
                    }

                    assert(0 == memcmp(&snapshot_entry, &tmp_tcam_entry, sizeof(snapshot_entry)));

                    break;
                }
            }

            assert(pkt_type_cnt != _countof(remapped_pkt_type_tbl));

            /* Unbind ACL
             */

            result = RULE_CTRL_SetAcl(ifindex,
                                      RULE_TYPE_INBOUND,
                                      acl_index,
                                      FALSE,
                                      time_range_index,
                                      counter_enable);
            assert(RULE_TYPE_OK == result);

            result = RULE_OM_ResetAcl(ifindex, RULE_TYPE_INBOUND, acl_index);
            assert(RULE_TYPE_OK == result);

            SET_TCAM_ENTRY_INDEX(tmp_tcam_entry, unit, device, pool_id);
            result = RULE_CTRL_GetTcamEntry(&tmp_tcam_entry);
            assert(RULE_TYPE_OK == result);

            for (pkt_type_cnt = 0; pkt_type_cnt < _countof(remapped_pkt_type_tbl); ++pkt_type_cnt)
            {
                if (remapped_pkt_type_tbl[pkt_type_cnt].remapped_pkt_type == remapped_pkt_type)
                {
                    if (remapped_pkt_type_tbl[pkt_type_cnt].min == 0)
                    {
                        snapshot_entry.free += MAX_ACE * rule_size;
                        snapshot_entry.used -= MAX_ACE * rule_size;
                    }

                    assert(0 == memcmp(&snapshot_entry, &tmp_tcam_entry, sizeof(snapshot_entry)));

                    break;
                }
            }

            assert(pkt_type_cnt != _countof(remapped_pkt_type_tbl));
        }
    }

    return 0;

#undef SET_TCAM_ENTRY_INDEX
}

int
RULE_CTRL_UT_GetNextTcamEntry()
{
#define SET_TCAM_ENTRY_INDEX(_entry, _unit, _device, _pool) \
    {                                                       \
        _entry.unit = _unit;                                \
        _entry.device_id = _device;                         \
        _entry.pool_id = _pool;                             \
    }

    typedef struct
    {
        UI32_T remapped_pkt_type;
        RULE_TYPE_INTERFACE_TYPE_E if_type;
        UI32_T min;
        UI32_T max;
    } PACKET_TYPE_ENTRY_T;

    typedef struct
    {
        UI32_T unit;
        UI32_T device;
        UI32_T pool_id;

        UI32_T next_unit;
        UI32_T next_device;
        UI32_T next_pool_id;
    } INPUT_T;

    INPUT_T input[] =
    {
        {0, 0, 0,    1, 0, 0},
        {1, 0, 0,    1, 1, 0},
        {1, 0, 1,    1, 1, 0},
        {1, RULE_TYPE_UNDEF_DEVICE_ID, 0,   1, 0, 0},
        {1, 0, RULE_TYPE_UNDEF_POOL_ID,     1, 0, 0},
    };

    UI32_T i;

    for (i = 0; i < _countof(input); ++i)
    {
        INPUT_T *in_p = &input[i];
        RULE_TYPE_TCAM_ENTRY_T tcam_entry;
        RULE_TYPE_RETURN_TYPE_T result;

        SET_TCAM_ENTRY_INDEX(tcam_entry, in_p->unit, in_p->device, in_p->pool_id);
        result = RULE_CTRL_GetNextTcamEntry(&tcam_entry);
        assert(RULE_TYPE_OK == result);

        assert(in_p->next_unit == tcam_entry.unit);
        assert(in_p->next_device == tcam_entry.device_id);
        assert(in_p->next_pool_id == tcam_entry.pool_id);
    }

    return 0;

#undef SET_TCAM_ENTRY_INDEX
}

int
RULE_CTRL_UT_Apply_ACL()
{
    enum
    {
        MAX_ACE  = 5,

        MIN_DIRECTION = RULE_TYPE_INBOUND,

#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION = RULE_TYPE_OUTBOUND,
#else
        MAX_DIRECTION = RULE_TYPE_INBOUND,
#endif
    };

    struct
    {
        RULE_TYPE_AclType_T acl_type;
    } acls[] =
    {
        {
            RULE_TYPE_MAC_ACL
        },
        {
            RULE_TYPE_IP_STD_ACL
        },
        {
            RULE_TYPE_IP_EXT_ACL
        },
        {
            RULE_TYPE_IPV6_STD_ACL
        },
        {
            RULE_TYPE_IPV6_EXT_ACL
        },
    };

    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T i, j;

    UI32_T port_list[] =
    {
        1,
        2,
        3,
        SYS_ADPT_MAX_NBR_OF_SWITCH_PORT_PER_CHIP + 1,
        SYS_ADPT_MAX_NBR_OF_SWITCH_PORT_PER_CHIP + 2,
        SYS_ADPT_MAX_NBR_OF_SWITCH_PORT_PER_CHIP + 3,
    };

    for (i = 0; i < _countof(acls); ++ i)
    {
        char acl_name[30];
        UI32_T acl_index;

        snprintf(acl_name, sizeof(acl_name), "%lu", i);
        acl_name[sizeof(acl_name)-1] = '\0';

        RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace(acl_name, acls[i].acl_type,
                                                 MAX_ACE, RULE_CTRL_UT_COMPRESS_DEFAULT,
                                                 &acl_index);

        for (j = 0; j < _countof(port_list); ++ j)
        {
            UI32_T ifindex = port_list[j];

            RULE_TYPE_INTERFACE_INFO_T interface;

            RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);

            for (interface.direction = MIN_DIRECTION; interface.direction <= MAX_DIRECTION; ++ interface.direction)
            {
                BOOL_T is_add = TRUE;
                RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;

                result = RULE_CTRL_SetAcl(ifindex,
                                          interface.direction,
                                          acl_index,
                                          is_add,
                                          RULE_TYPE_UNDEF_TIME_RANGE,
                                          counter_enable);
                assert(RULE_TYPE_OK == result);

                result = RULE_OM_SetAcl(ifindex,
                                        interface.direction,
                                        acl_index,
                                        RULE_TYPE_UNDEF_TIME_RANGE,
                                        (UI8_T *)"",
                                        counter_enable);
                assert(RULE_TYPE_OK == result);

                RULE_CTRL_UT_Proc_Validate_Rule();
            }
        }

        for (j = 0; j < _countof(port_list); ++ j)
        {
            UI32_T ifindex = port_list[j];

            RULE_TYPE_INTERFACE_INFO_T interface;

            RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);

            for (interface.direction = MIN_DIRECTION; interface.direction <= MAX_DIRECTION; ++ interface.direction)
            {
                BOOL_T is_add = FALSE;
                UI16_T time_range_index = RULE_TYPE_UNDEF_TIME_RANGE;
                RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;

                result = RULE_CTRL_SetAcl(ifindex,
                                          interface.direction,
                                          acl_index,
                                          is_add,
                                          time_range_index,
                                          counter_enable);
                assert(RULE_TYPE_OK == result);

                result = RULE_OM_ResetAcl(ifindex, interface.direction, acl_index);
                assert(RULE_TYPE_OK == result);

                RULE_CTRL_UT_Proc_Validate_Rule();
            }
        }

        RULE_OM_DelAcl(acl_index);
    }

    return 0;
}

int
RULE_CTRL_UT_Apply_ACL_With_Counter_Enabled()
{
    enum
    {
        MAX_ACE  = 5,

        MIN_DIRECTION = RULE_TYPE_INBOUND,

#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION = RULE_TYPE_OUTBOUND,
#else
        MAX_DIRECTION = RULE_TYPE_INBOUND,
#endif
    };

    struct
    {
        RULE_TYPE_AclType_T acl_type;
    } acls[] =
    {
        {
            RULE_TYPE_MAC_ACL
        },
#if (PLATFORM_MAX_NBR_OF_ACL_PER_PORT > 1)
        {
            RULE_TYPE_IP_EXT_ACL
        },
        {
            RULE_TYPE_IPV6_EXT_ACL
        },
#endif // PLATFORM_MAX_NBR_OF_ACL_PER_PORT > 1
    };

    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T i, j;

    UI32_T port_list[] =
    {
        1,
        2,
        3,
        SYS_ADPT_MAX_NBR_OF_SWITCH_PORT_PER_CHIP + 1,
        SYS_ADPT_MAX_NBR_OF_SWITCH_PORT_PER_CHIP + 2,
        SYS_ADPT_MAX_NBR_OF_SWITCH_PORT_PER_CHIP + 3,
    };

    for (i = 0; i < _countof(acls); ++ i)
    {
        char acl_name[30];
        UI32_T acl_index;

        snprintf(acl_name, sizeof(acl_name), "%lu", i);
        acl_name[sizeof(acl_name)-1] = '\0';

        RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace(acl_name, acls[i].acl_type,
                                                 MAX_ACE, RULE_CTRL_UT_COMPRESS_DEFAULT,
                                                 &acl_index);

        for (j = 0; j < _countof(port_list); ++ j)
        {
            UI32_T ifindex = port_list[j];

            RULE_TYPE_INTERFACE_INFO_T interface;

            RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);

            for (interface.direction = MIN_DIRECTION; interface.direction <= MAX_DIRECTION; ++ interface.direction)
            {
                BOOL_T is_add = TRUE;
                RULE_TYPE_COUNTER_ENABLE_T counter_enable = TRUE;

                result = RULE_CTRL_SetAcl(ifindex,
                                          interface.direction,
                                          acl_index,
                                          is_add,
                                          RULE_TYPE_UNDEF_TIME_RANGE,
                                          counter_enable);
                assert(RULE_TYPE_OK == result);


                result = RULE_OM_SetAcl(ifindex,
                                        interface.direction,
                                        acl_index,
                                        RULE_TYPE_UNDEF_TIME_RANGE,
                                        (UI8_T *)"",
                                        counter_enable);

                assert(RULE_TYPE_OK == result);

                RULE_CTRL_UT_Proc_Validate_Rule();

                //
                //
                //
                {
                    RULE_TYPE_AclType_T ace_type;
                    UI32_T ace_index;
                    RULE_TYPE_Ace_Entry_T ace_entry;

                    ace_index = 0;
                    while (RULE_TYPE_OK == RULE_OM_GetNextAceByAcl(acl_index, &ace_type, &ace_index, &ace_entry))
                    {
                        UI32_T cx;
                        RULE_TYPE_RULE_INSTANCE_T rule_inst;

                        for (cx = 0; cx < _countof(rule_inst.counter); ++ cx)
                        {
                            result = RULE_CTRL_GetAclRuleCounter(ifindex, interface.direction,
                                                                 acl_index,
                                                                 ace_index, &ace_entry);
                            assert(RULE_TYPE_OK == result);
                        }
                    }

                    ace_index = 0;
                    while (RULE_TYPE_OK == RULE_OM_GetNextAceByAcl(acl_index, &ace_type, &ace_index, &ace_entry))
                    {
                        result = RULE_CTRL_ClearAclRuleCounter(ifindex, interface.direction,
                                                               acl_index,
                                                               ace_index);
                        assert(RULE_TYPE_OK == result);
                    }
                }

            }
        }
    }

    return 0;
}

int
RULE_CTRL_UT_One_Apply_One_ACL_On_One_Port_At_Same_Time()
{
    enum
    {
        MAX_ACE  = 5,

        MIN_DIRECTION = RULE_TYPE_INBOUND,

#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION = RULE_TYPE_OUTBOUND,
#else
        MAX_DIRECTION = RULE_TYPE_INBOUND,
#endif
    };

    struct
    {
        RULE_TYPE_AclType_T acl_type;
        UI32_T acl_index;
    } acls[] =
    {
        {
            RULE_TYPE_MAC_ACL
        },
        {
            RULE_TYPE_IP_EXT_ACL
        },
        {
            RULE_TYPE_IPV6_EXT_ACL
        },
    };

    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T i, j;

    UI32_T port_list[] =
    {
        1,
        2,
        3,
        SYS_ADPT_MAX_NBR_OF_SWITCH_PORT_PER_CHIP + 1,
        SYS_ADPT_MAX_NBR_OF_SWITCH_PORT_PER_CHIP + 2,
        SYS_ADPT_MAX_NBR_OF_SWITCH_PORT_PER_CHIP + 3,
    };

    {
        char acl_name[30];
        UI32_T acl_index;
        RULE_TYPE_AclType_T acl_type = RULE_TYPE_IP_STD_ACL;

        snprintf(acl_name, sizeof(acl_name), "aa");
        acl_name[sizeof(acl_name)-1] = '\0';

        RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace(acl_name, acl_type,
                                                 MAX_ACE, RULE_CTRL_UT_COMPRESS_DEFAULT,
                                                 &acl_index);

        for (j = 0; j < _countof(port_list); ++ j)
        {
            UI32_T ifindex = port_list[j];

            RULE_TYPE_INTERFACE_INFO_T interface;

            RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);

            for (interface.direction = MIN_DIRECTION; interface.direction <= MAX_DIRECTION; ++ interface.direction)
            {
                BOOL_T is_add = TRUE;
                RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;

                result = RULE_CTRL_SetAcl(ifindex,
                                          interface.direction,
                                          acl_index,
                                          is_add,
                                          RULE_TYPE_UNDEF_TIME_RANGE,
                                          counter_enable);
                assert(RULE_TYPE_OK == result);

                result = RULE_OM_SetAcl(ifindex,
                                        interface.direction,
                                        acl_index,
                                        RULE_TYPE_UNDEF_TIME_RANGE,
                                        (UI8_T *)"",
                                        counter_enable);

                assert(RULE_TYPE_OK == result);

                RULE_CTRL_UT_Proc_Validate_Rule();
            }
        }
    }

    for (i = 0; i < _countof(acls); ++ i)
    {
        char acl_name[30];
        UI32_T acl_index;

        snprintf(acl_name, sizeof(acl_name), "%lu", i);
        acl_name[sizeof(acl_name)-1] = '\0';

        RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace(acl_name, acls[i].acl_type,
                                                 MAX_ACE, RULE_CTRL_UT_COMPRESS_DEFAULT,
                                                 &acl_index);
        acls[i].acl_index = acl_index;

        for (j = 0; j < _countof(port_list); ++ j)
        {
            UI32_T ifindex = port_list[j];

            RULE_TYPE_INTERFACE_INFO_T interface;

            RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);

            for (interface.direction = MIN_DIRECTION; interface.direction <= MAX_DIRECTION; ++ interface.direction)
            {
                UI16_T time_range_index = RULE_TYPE_UNDEF_TIME_RANGE;
                RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;

                result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, interface.direction,
                                                    acl_index,
                                                    time_range_index,
                                                    counter_enable);
                assert(RULE_TYPE_OK != result);

                RULE_CTRL_UT_Proc_Validate_Rule();
            }
        }
    }

    return 0;
}

int
RULE_CTRL_UT_Capacity_Test_Max_ACE_In_One_ACL_Ideal()
{
    enum
    {
        ACL_TYPE = RULE_TYPE_MAC_ACL,
        ACE_TYPE = RULE_TYPE_MAC_ACL,
        MIN_DIRECTION = RULE_TYPE_INBOUND,

#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION = RULE_TYPE_OUTBOUND,
#else
        MAX_DIRECTION = RULE_TYPE_INBOUND,
#endif
    };

    const char                  *acl_name = "a1";
    RULE_TYPE_AclType_T         acl_type = ACL_TYPE;
    RULE_TYPE_AclType_T         ace_type = ACE_TYPE;

    RULE_TYPE_Ace_Entry_T       ace_entry;

    UI32_T                      ace_count;
    UI32_T                      acl_index;

    UI32_T                      rule_size = 2;
    RULE_TYPE_TCAMUtilization_T tcam;

    RULE_TYPE_RETURN_TYPE_T     result;

    RULE_CTRL_UT_Proc_Create_ACL(acl_name, acl_type, &acl_index);

    ace_count = 0;

    while (TRUE)
    {
        UI8_T src_mac[SYS_ADPT_MAC_ADDR_LEN];
        UI8_T src_mask[SYS_ADPT_MAC_ADDR_LEN];

        int i, j;

        ace_entry.ace_type = ace_type;
        result = RULE_OM_InitAce(&ace_entry);
        assert(result == RULE_TYPE_OK);

        memset(src_mac, 0, sizeof(src_mac));
        memset(src_mask, 0xff, sizeof(src_mask));

        assert(SYS_ADPT_MAX_NBRS_OF_ACE < (255*255));

        i = (ace_count+1) / 255;
        j = (ace_count+1) % 255;

        src_mac[ 4 ] = i;
        src_mac[ 5 ] = j;

        RULE_OM_UT_Proc_SetAceSrcMacAddress(&ace_entry, src_mac, src_mask);

        result = RULE_OM_AddAce2Acl(acl_index, ace_type, &ace_entry);
        if (result != RULE_TYPE_OK)
        {
            break;
        }

        ace_count ++;
    }

    assert(SYS_ADPT_MAX_NBRS_OF_ACE == ace_count);

#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
    result = RULE_OM_RebuildAggregateAcl(acl_index);
    assert(RULE_TYPE_OK == result);

    acl_index = RULE_OM_LocalGetAclByIndex(acl_index)->aggregate_acl_index;

    {
        ace_count = RULE_OM_LocalGetAclByIndex(acl_index)->ace_count;
        assert(ace_count <  SYS_ADPT_MAX_NBRS_OF_ACE);
    }
#endif // SYS_CPNT_ACL_AUTO_COMPRESS_ACE

    {
        RULE_TYPE_INTERFACE_INFO_T interface;

        UI32_T ifindex = 2;

        UI32_T device_id;

        UI16_T time_range_index = RULE_TYPE_UNDEF_TIME_RANGE;
        RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;

        RULE_CTRL_GetTCAMUtilization(&tcam);

        memset(&interface, 0, sizeof(interface));
        result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
        assert(RULE_TYPE_OK == result);

        for (interface.direction = MIN_DIRECTION; interface.direction <= MAX_DIRECTION; ++ interface.direction)
        {
            result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, interface.direction,
                                                acl_index,
                                                time_range_index,
                                                counter_enable);
            assert(RULE_TYPE_OK == result);

            //
            // FIXME: This check only support uport
            //
            assert(RULE_TYPE_INTERFACE_UPORT == interface.type);
            device_id = RULE_CTRL_UT_Proc_UPort_To_Device_Id(interface.uport.unit,
                                                             interface.uport.port);
            if (tcam.unit[interface.uport.unit-1].device[device_id].pce_free < RULE_OM_LocalGetAclByIndex(acl_index)->ace_count * rule_size)
            {
                assert(RULE_TYPE_OK != result);
            }
            else
            {
                assert(RULE_TYPE_OK == result);

                {
                    RULE_TYPE_CLASS_INSTANCE_PTR_T              class_inst_p;
                    RULE_TYPE_CLASS_INSTANCE_OBJECT_T           class_inst_obj;
                    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T rule_inst_iter;

                    class_inst_p = RULE_CTRL_Priv_GetAclInstanceById(&interface, acl_index);
                    assert(NULL != class_inst_p);

                    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_inst_p, &class_inst_obj);
                    class_inst_obj.get_element_iterator(&class_inst_obj, &rule_inst_iter);

                    assert(acl_index == class_inst_p->acl_id);

                    assert(RULE_TYPE_INST_ACL == class_inst_p->super.type);
                    assert(ace_count == rule_inst_iter.count(&rule_inst_iter));
                }
            }
        }
    }

    return 0;
}

int
RULE_CTRL_UT_Capacity_Test_Max_ACE_In_One_ACL_Worst()
{
    enum
    {
        ACL_TYPE = RULE_TYPE_MAC_ACL,
        ACE_TYPE = RULE_TYPE_MAC_ACL,
    };

    RULE_TYPE_RETURN_TYPE_T     result;
    const char                  *acl_name = "a1";
    RULE_TYPE_AclType_T         acl_type = ACL_TYPE;
    RULE_TYPE_AclType_T         ace_type = ACE_TYPE;

    RULE_TYPE_Ace_Entry_T       ace_entry;

    UI32_T                      ace_count;
    UI32_T                      acl_index;

    UI32_T                      rule_size = 2;
    RULE_TYPE_TCAMUtilization_T tcam;

    RULE_CTRL_UT_Proc_Create_ACL(acl_name, acl_type, &acl_index);

    ace_count = 0;

    while (TRUE)
    {
        UI8_T src_mac[SYS_ADPT_MAC_ADDR_LEN];
        UI8_T src_mask[SYS_ADPT_MAC_ADDR_LEN];

        int i, j;

        ace_entry.ace_type = ace_type;
        result = RULE_OM_InitAce(&ace_entry);
        assert(result == RULE_TYPE_OK);

        ace_entry.access = (ace_count%2) ?
                           RULE_TYPE_ACE_DENY : RULE_TYPE_ACE_PERMIT;

        memset(src_mac, 0, sizeof(src_mac));
        memset(src_mask, 0xff, sizeof(src_mask));

        assert(SYS_ADPT_MAX_NBRS_OF_ACE < (255*255));

        i = (ace_count+1) / 255;
        j = (ace_count+1) % 255;

        src_mac[ 4 ] = i;
        src_mac[ 5 ] = j;

        RULE_OM_UT_Proc_SetAceSrcMacAddress(&ace_entry, src_mac, src_mask);

        result = RULE_OM_AddAce2Acl(acl_index, ace_type, &ace_entry);
        if (result != RULE_TYPE_OK)
        {
            break;
        }

        ace_count ++;
    }

    assert(SYS_ADPT_MAX_NBRS_OF_ACE == ace_count);

#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
    result = RULE_OM_RebuildAggregateAcl(acl_index);
    assert(RULE_TYPE_OK == result);

    acl_index = RULE_OM_LocalGetAclByIndex(acl_index)->aggregate_acl_index;

    ace_count = RULE_OM_LocalGetAclByIndex(acl_index)->ace_count;

    assert(SYS_ADPT_MAX_NBRS_OF_ACE == ace_count);
#endif // SYS_CPNT_ACL_AUTO_COMPRESS_ACE


    {
        RULE_TYPE_INTERFACE_INFO_T interface;

        UI32_T ifindex = 2;
        RULE_TYPE_InOutDirection_T direction = RULE_TYPE_INBOUND;

        UI32_T device_id;

        UI16_T time_range_index = RULE_TYPE_UNDEF_TIME_RANGE;
        RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;

        RULE_CTRL_GetTCAMUtilization(&tcam);

        memset(&interface, 0, sizeof(interface));
        result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
        assert(RULE_TYPE_OK == result);
        interface.direction = direction;

        result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                            acl_index,
                                            time_range_index,
                                            counter_enable);
        assert(RULE_TYPE_OK == result);

        //
        // FIXME: This check only support uport
        //
        assert(RULE_TYPE_INTERFACE_UPORT == interface.type);
        device_id = RULE_CTRL_UT_Proc_UPort_To_Device_Id(interface.uport.unit,
                                                         interface.uport.port);
        if (tcam.unit[interface.uport.unit-1].device[device_id].pce_free < RULE_OM_LocalGetAclByIndex(acl_index)->ace_count * rule_size)
        {
            assert(RULE_TYPE_OK != result);
        }
        else
        {
            assert(RULE_TYPE_OK == result);

            {
                RULE_TYPE_CLASS_INSTANCE_PTR_T              class_inst_p;
                RULE_TYPE_CLASS_INSTANCE_OBJECT_T           class_inst_obj;
                RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T rule_inst_iter;

                class_inst_p = RULE_CTRL_Priv_GetAclInstanceById(&interface, acl_index);
                assert(NULL != class_inst_p);

                assert(acl_index == class_inst_p->acl_id);
                assert(RULE_TYPE_INST_ACL == class_inst_p->super.type);

                RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_inst_p, &class_inst_obj);
                class_inst_obj.get_element_iterator(&class_inst_obj, &rule_inst_iter);

                assert(ace_count == rule_inst_iter.count(&rule_inst_iter));
            }
        }
    }

    return 0;
}

int
RULE_CTRL_UT_Capacity_Test_Max_ACE_In_One_ACL_Normal()
{
    enum
    {
        ACL_TYPE = RULE_TYPE_MAC_ACL,
        ACE_TYPE = RULE_TYPE_MAC_ACL,
        MAX_UNIT = 1,
        MAX_PORT = 10,
        MAX_ACE  = 5,
        RULE_SIZE = 2,
    };

    const char              *acl_name = "a1";
    RULE_TYPE_AclType_T     acl_type = ACL_TYPE;
    RULE_TYPE_AclType_T     ace_type = ACE_TYPE;

    RULE_TYPE_Ace_Entry_T   ace_entry;

    UI32_T                  ace_count;
    UI32_T                  acl_index;

    UI32_T                  unit;
    UI32_T                  port;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CTRL_UT_Proc_Create_ACL(acl_name, acl_type, &acl_index);

    ace_count = 0;

    while (TRUE)
    {
        UI8_T src_mac[SYS_ADPT_MAC_ADDR_LEN];
        UI8_T src_mask[SYS_ADPT_MAC_ADDR_LEN];

        int i, j;

        ace_entry.ace_type = ace_type;
        result = RULE_OM_InitAce(&ace_entry);
        assert(result == RULE_TYPE_OK);

        ace_entry.access = (ace_count%2) ?
                           RULE_TYPE_ACE_DENY : RULE_TYPE_ACE_PERMIT;

        memset(src_mac, 0, sizeof(src_mac));
        memset(src_mask, 0xff, sizeof(src_mask));

        assert(SYS_ADPT_MAX_NBRS_OF_ACE < (255*255));

        i = (ace_count+1) / 255;
        j = (ace_count+1) % 255;

        src_mac[ 4 ] = i;
        src_mac[ 5 ] = j;

        RULE_OM_UT_Proc_SetAceSrcMacAddress(&ace_entry, src_mac, src_mask);

        result = RULE_OM_AddAce2Acl(acl_index, ace_type, &ace_entry);
        if (result != RULE_TYPE_OK)
        {
            break;
        }

        ace_count ++;

        if (MAX_ACE == ace_count)
        {
            break;
        }
    }

    assert(MAX_ACE == ace_count);

#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
    result = RULE_OM_RebuildAggregateAcl(acl_index);
    assert(RULE_TYPE_OK == result);

    acl_index = RULE_OM_LocalGetAclByIndex(acl_index)->aggregate_acl_index;

    ace_count = RULE_OM_LocalGetAclByIndex(acl_index)->ace_count;

    assert(MAX_ACE == ace_count);
#endif // SYS_CPNT_ACL_AUTO_COMPRESS_ACE

    for (unit = 1; unit <= MAX_UNIT; ++unit)
    {
        for (port = 1; port <= MAX_PORT; ++ port)
        {
            UI32_T ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);
            RULE_TYPE_InOutDirection_T direction = RULE_TYPE_INBOUND;

            RULE_TYPE_INTERFACE_INFO_T interface;

            UI16_T time_range_index = RULE_TYPE_UNDEF_TIME_RANGE;
            RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;

            memset(&interface, 0, sizeof(interface));
            result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
            assert(RULE_TYPE_OK == result);
            interface.direction = direction;

            result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                                acl_index,
                                                time_range_index,
                                                counter_enable);
            assert(RULE_TYPE_OK == result);

            {
                RULE_TYPE_CLASS_INSTANCE_PTR_T              class_inst_p;
                RULE_TYPE_CLASS_INSTANCE_OBJECT_T           class_inst_obj;
                RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T rule_inst_iter;

                class_inst_p = RULE_CTRL_Priv_GetAclInstanceById(&interface, acl_index);
                assert(NULL != class_inst_p);

                assert(acl_index == class_inst_p->acl_id);
                assert(RULE_TYPE_INST_ACL == class_inst_p->super.type);

                RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_inst_p, &class_inst_obj);
                class_inst_obj.get_element_iterator(&class_inst_obj, &rule_inst_iter);

                assert(ace_count == rule_inst_iter.count(&rule_inst_iter));
            }

            RULE_CTRL_UT_Proc_Validate_Rule();

        }
    }

    for (unit = 1; unit <= MAX_UNIT; ++unit)
    {
        for (port = 1; port <= MAX_PORT; ++ port)
        {
            UI32_T ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);
            RULE_TYPE_InOutDirection_T direction = RULE_TYPE_INBOUND;

            UI16_T time_range_index = RULE_TYPE_UNDEF_TIME_RANGE;
            RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;

            result = RULE_CTRL_UT_Proc_UnBind_ACL(ifindex, direction,
                                                  acl_index,
                                                  time_range_index,
                                                  counter_enable);
            assert(RULE_TYPE_OK == result);
        }
    }

    return 0;
}

int
RULE_CTRL_UT_Capacity_Test_Max_ACE_In_One_ACL_Modify_On_Fly()
{
    enum
    {
        ACL_TYPE  = RULE_TYPE_MAC_ACL,
        ACE_TYPE  = RULE_TYPE_MAC_ACL,
        MIN_IFINDEX = 1,
        MAX_IFINDEX = 10,
        DIRECTION = RULE_TYPE_INBOUND
    };

    const char              *acl_name = "a1";
    RULE_TYPE_AclType_T     acl_type = ACL_TYPE;
    RULE_TYPE_AclType_T     ace_type = ACE_TYPE;

    RULE_TYPE_Ace_Entry_T   ace_entry;

    UI32_T                  rule_size = 2;
    RULE_TYPE_TCAMUtilization_T tcam;

    UI32_T                  MAX_ACE;
    UI32_T                  ace_count;
    UI32_T                  acl_index;

    UI32_T                  ifindex;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CTRL_GetTCAMUtilization(&tcam);

    MAX_ACE = SYS_ADPT_MAX_NBRS_OF_ACE < (tcam.pce_free / rule_size) ?
                                                      SYS_ADPT_MAX_NBRS_OF_ACE :
                                                    (tcam.pce_free / rule_size);
    MAX_ACE = MAX_ACE / (MAX_IFINDEX - MIN_IFINDEX + 1);

    RULE_CTRL_UT_Proc_Create_ACL(acl_name, acl_type, &acl_index);

    ace_count = 0;

    {
        UI8_T src_mac[SYS_ADPT_MAC_ADDR_LEN];
        UI8_T src_mask[SYS_ADPT_MAC_ADDR_LEN];

        int i, j;

        ace_entry.ace_type = ace_type;
        result = RULE_OM_InitAce(&ace_entry);
        assert(result == RULE_TYPE_OK);

        ace_entry.access = (ace_count%2) ?
                           RULE_TYPE_ACE_DENY : RULE_TYPE_ACE_PERMIT;

        memset(src_mac, 0, sizeof(src_mac));
        memset(src_mask, 0xff, sizeof(src_mask));

        assert(SYS_ADPT_MAX_NBRS_OF_ACE < (255*255));

        i = (ace_count+1) / 255;
        j = (ace_count+1) % 255;

        src_mac[ 4 ] = i;
        src_mac[ 5 ] = j;

        RULE_OM_UT_Proc_SetAceSrcMacAddress(&ace_entry, src_mac, src_mask);

        result = RULE_OM_AddAce2Acl(acl_index, ace_type, &ace_entry);

        assert(RULE_TYPE_OK == result);
        ace_count ++;
    }

    assert(1 == ace_count);

#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
    result = RULE_OM_RebuildAggregateAcl(acl_index);
    assert(RULE_TYPE_OK == result);

    acl_index = RULE_OM_LocalGetAclByIndex(acl_index)->aggregate_acl_index;

    ace_count = RULE_OM_LocalGetAclByIndex(acl_index)->ace_count;

    assert(1 == ace_count);
#endif // SYS_CPNT_ACL_AUTO_COMPRESS_ACE

    for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
    {
        RULE_TYPE_INTERFACE_INFO_T interface;

        UI16_T time_range_index = RULE_TYPE_UNDEF_TIME_RANGE;
        RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;

        result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
        assert(RULE_TYPE_OK == result);
        interface.direction = DIRECTION;

        result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, DIRECTION,
                                            acl_index,
                                            time_range_index,
                                            counter_enable);
        assert(RULE_TYPE_OK == result);

        {
            RULE_TYPE_CLASS_INSTANCE_PTR_T              class_inst_p;
            RULE_TYPE_CLASS_INSTANCE_OBJECT_T           class_inst_obj;
            RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T rule_inst_iter;

            class_inst_p = RULE_CTRL_Priv_GetAclInstanceById(&interface, acl_index);
            assert(NULL != class_inst_p);

            assert(acl_index == class_inst_p->acl_id);
            assert(RULE_TYPE_INST_ACL == class_inst_p->super.type);

            RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_inst_p, &class_inst_obj);
            class_inst_obj.get_element_iterator(&class_inst_obj, &rule_inst_iter);

            assert(ace_count == rule_inst_iter.count(&rule_inst_iter));
        }

        RULE_CTRL_UT_Proc_Validate_Rule();
    }

    //
    // Add on Fly
    //
    for (ace_count = 1; ace_count <= MAX_ACE; ++ace_count)
    {
        BOOL_T is_add = TRUE;

        UI8_T src_mac[SYS_ADPT_MAC_ADDR_LEN];
        UI8_T src_mask[SYS_ADPT_MAC_ADDR_LEN];

        int i, j;

        //
        //
        ace_entry.ace_type = ace_type;
        result = RULE_OM_InitAce(&ace_entry);
        assert(result == RULE_TYPE_OK);

        ace_entry.access = (ace_count%2) ?
                           RULE_TYPE_ACE_DENY : RULE_TYPE_ACE_PERMIT;

        memset(src_mac, 0, sizeof(src_mac));
        memset(src_mask, 0xff, sizeof(src_mask));

        assert(SYS_ADPT_MAX_NBRS_OF_ACE < (255*255));

        i = (ace_count+1) / 255;
        j = (ace_count+1) % 255;

        src_mac[ 4 ] = i;
        src_mac[ 5 ] = j;

        RULE_OM_UT_Proc_SetAceSrcMacAddress(&ace_entry, src_mac, src_mask);

        result = RULE_OM_AddAce2Acl(acl_index, ace_type, &ace_entry);
        assert(RULE_TYPE_OK == result);

        //
        //

        result = RULE_CTRL_SetAce(acl_index, &ace_entry, is_add);

        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();
    }

    //
    // Del on Fly
    //
    for (ace_count = 1; ace_count <= (MAX_ACE-1); ++ace_count)
    {
        BOOL_T is_add = FALSE;

        UI8_T src_mac[SYS_ADPT_MAC_ADDR_LEN];
        UI8_T src_mask[SYS_ADPT_MAC_ADDR_LEN];

        int i, j;

        //
        //
        ace_entry.ace_type = ace_type;
        result = RULE_OM_InitAce(&ace_entry);
        assert(result == RULE_TYPE_OK);

        ace_entry.access = (ace_count%2) ?
                           RULE_TYPE_ACE_DENY : RULE_TYPE_ACE_PERMIT;

        memset(src_mac, 0, sizeof(src_mac));
        memset(src_mask, 0xff, sizeof(src_mask));

        assert(SYS_ADPT_MAX_NBRS_OF_ACE < (255*255));

        i = (ace_count+1) / 255;
        j = (ace_count+1) % 255;

        src_mac[ 4 ] = i;
        src_mac[ 5 ] = j;

        RULE_OM_UT_Proc_SetAceSrcMacAddress(&ace_entry, src_mac, src_mask);

        //
        //

        result = RULE_CTRL_SetAce(acl_index, &ace_entry, is_add);
        assert(RULE_TYPE_OK == result);

        result = RULE_OM_DelAceFromAcl(acl_index, ace_type, &ace_entry);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();
    }

    //
    // Unbind all ACL
    //

    for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
    {
        UI16_T time_range_index = RULE_TYPE_UNDEF_TIME_RANGE;
        RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;

        result = RULE_CTRL_UT_Proc_UnBind_ACL(ifindex, DIRECTION,
                                              acl_index,
                                              time_range_index,
                                              counter_enable);
        assert(RULE_TYPE_OK == result);
    }

    return 0;
}

int
RULE_CTRL_UT_Capacity_Test_Max_ACE_In_One_ACL_Modify_On_Fly_Undo()
{
    enum
    {
        ACL_TYPE  = RULE_TYPE_MAC_ACL,
        ACE_TYPE  = RULE_TYPE_MAC_ACL,
        MIN_IFINDEX = 1,
        MAX_IFINDEX = 10,
        DIRECTION = RULE_TYPE_INBOUND
    };

    const char              *acl_name = "a1";
    RULE_TYPE_AclType_T     acl_type = ACL_TYPE;
    RULE_TYPE_AclType_T     ace_type = ACE_TYPE;

    RULE_TYPE_Ace_Entry_T   ace_entry;

    UI32_T                  rule_size = 2;
    RULE_TYPE_TCAMUtilization_T tcam;

    UI32_T                  MAX_ACE;
    UI32_T                  ace_count;
    UI32_T                  acl_index;

    UI32_T                  ifindex;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CTRL_GetTCAMUtilization(&tcam);

    MAX_ACE = SYS_ADPT_MAX_NBRS_OF_ACE < (tcam.pce_free / rule_size) ?
                                                SYS_ADPT_MAX_NBRS_OF_ACE :
                                                (tcam.pce_free / rule_size);
    MAX_ACE = MAX_ACE / (MAX_IFINDEX - MIN_IFINDEX + 1);

    RULE_CTRL_UT_Proc_Create_ACL(acl_name, acl_type, &acl_index);

    for (ace_count = 0; ace_count < MAX_ACE; ++ace_count)
    {
        UI8_T src_mac[SYS_ADPT_MAC_ADDR_LEN];
        UI8_T src_mask[SYS_ADPT_MAC_ADDR_LEN];

        int i, j;

        ace_entry.ace_type = ace_type;
        result = RULE_OM_InitAce(&ace_entry);
        assert(result == RULE_TYPE_OK);

        ace_entry.access = (ace_count%2) ?
                           RULE_TYPE_ACE_DENY : RULE_TYPE_ACE_PERMIT;

        memset(src_mac, 0, sizeof(src_mac));
        memset(src_mask, 0xff, sizeof(src_mask));

        assert(SYS_ADPT_MAX_NBRS_OF_ACE < (255*255));

        i = (ace_count+1) / 255;
        j = (ace_count+1) % 255;

        src_mac[ 4 ] = i;
        src_mac[ 5 ] = j;

        RULE_OM_UT_Proc_SetAceSrcMacAddress(&ace_entry, src_mac, src_mask);

        result = RULE_OM_AddAce2Acl(acl_index, ace_type, &ace_entry);

        assert(RULE_TYPE_OK == result);
    }

#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
    result = RULE_OM_RebuildAggregateAcl(acl_index);
    assert(RULE_TYPE_OK == result);

    acl_index = RULE_OM_LocalGetAclByIndex(acl_index)->aggregate_acl_index;

    ace_count = RULE_OM_LocalGetAclByIndex(acl_index)->ace_count;

    assert(MAX_ACE == ace_count);
#endif // SYS_CPNT_ACL_AUTO_COMPRESS_ACE

    for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
    {
        RULE_TYPE_INTERFACE_INFO_T interface;

        UI16_T time_range_index = RULE_TYPE_UNDEF_TIME_RANGE;
        RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;

        result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
        assert(RULE_TYPE_OK == result);
        interface.direction = DIRECTION;

        result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, DIRECTION,
                                            acl_index,
                                            time_range_index,
                                            counter_enable);
        assert(RULE_TYPE_OK == result);

        {
            RULE_TYPE_CLASS_INSTANCE_PTR_T              class_inst_p;
            RULE_TYPE_CLASS_INSTANCE_OBJECT_T           class_inst_obj;
            RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T rule_inst_iter;

            class_inst_p = RULE_CTRL_Priv_GetAclInstanceById(&interface, acl_index);
            assert(NULL != class_inst_p);

            assert(acl_index == class_inst_p->acl_id);
            assert(RULE_TYPE_INST_ACL == class_inst_p->super.type);

            RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_inst_p, &class_inst_obj);
            class_inst_obj.get_element_iterator(&class_inst_obj, &rule_inst_iter);

            assert(ace_count == rule_inst_iter.count(&rule_inst_iter));
        }

        RULE_CTRL_UT_Proc_Validate_Rule();
    }

    //
    // Add on Fly
    //
    for (ace_count = MAX_ACE; ace_count < SYS_ADPT_MAX_NBRS_OF_ACE ; ++ ace_count)
    {
        BOOL_T is_add = TRUE;

        UI8_T src_mac[SYS_ADPT_MAC_ADDR_LEN];
        UI8_T src_mask[SYS_ADPT_MAC_ADDR_LEN];

        int i, j;

        //
        //
        ace_entry.ace_type = ace_type;
        result = RULE_OM_InitAce(&ace_entry);
        assert(result == RULE_TYPE_OK);

        ace_entry.access = (ace_count%2) ?
                           RULE_TYPE_ACE_DENY : RULE_TYPE_ACE_PERMIT;

        memset(src_mac, 0, sizeof(src_mac));
        memset(src_mask, 0xff, sizeof(src_mask));

        assert(SYS_ADPT_MAX_NBRS_OF_ACE < (255*255));

        i = (ace_count+1) / 255;
        j = (ace_count+1) % 255;

        src_mac[ 4 ] = i;
        src_mac[ 5 ] = j;

        RULE_OM_UT_Proc_SetAceSrcMacAddress(&ace_entry, src_mac, src_mask);

        result = RULE_OM_AddAce2Acl(acl_index, ace_type, &ace_entry);
        assert(RULE_TYPE_OK == result);

        //
        //

        result = RULE_CTRL_SetAce(acl_index, &ace_entry, is_add);

        if (RULE_TYPE_OK != result)
        {
            result = RULE_OM_DelAceFromAcl(acl_index, ace_type, &ace_entry);
            assert(RULE_TYPE_OK == result);

            RULE_CTRL_UT_Proc_Validate_Rule();
            break;
        }

        RULE_CTRL_UT_Proc_Validate_Rule();
    }

    //
    // Unbind all ACL
    //

    for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
    {
        UI16_T time_range_index = RULE_TYPE_UNDEF_TIME_RANGE;
        RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;

        result = RULE_CTRL_UT_Proc_UnBind_ACL(ifindex, DIRECTION,
                                              acl_index,
                                              time_range_index,
                                              counter_enable);
        assert(RULE_TYPE_OK == result);
    }

    return 0;
}

int
RULE_CTRL_UT_ACL_System_Capacity_Test()
{
    enum
    {
        ACL_TYPE = RULE_TYPE_MAC_ACL,
        ACE_TYPE = RULE_TYPE_MAC_ACL,
        MAX_UNDO = 100,
    };

    typedef struct
    {
        UI32_T                      ifindex;
        RULE_TYPE_InOutDirection_T  direction;

        UI32_T                      acl_index;
        UI16_T                      time_range_index;
        RULE_TYPE_COUNTER_ENABLE_T  counter_enable;
    } UNDO;

    UI32_T                      acl_count;
    UI32_T                      ace_count;

    UI32_T                      rule_size = 2;
    RULE_TYPE_TCAMUtilization_T tcam;

    UI32_T                      ifindex = 2;
    RULE_TYPE_InOutDirection_T  direction = RULE_TYPE_OUTBOUND;

    RULE_TYPE_INTERFACE_INFO_T  interface;

    BOOL_T                      is_ingress = FALSE;
    UI32_T                      unit = 1;
    UI32_T                      port = 1;
    UI32_T                      device_id;

    UI16_T                      time_range_index = RULE_TYPE_UNDEF_TIME_RANGE;
    RULE_TYPE_COUNTER_ENABLE_T  counter_enable = RULE_TYPE_COUNTER_DISABLE;

    UI32_T                      undo_count;
    UNDO                        undo[MAX_UNDO];

    RULE_TYPE_RETURN_TYPE_T     result;

    if (1)
    {
        printf("%s: skip this item due to save time\r\n", __FUNCTION__);
        return 0;
    }

    RULE_CTRL_GetTCAMUtilization(&tcam);


re_try:
    undo_count = 0;
    memset(undo, 0, sizeof(undo));

    acl_count = 0;
    ace_count = 0;

    while (TRUE)
    {
        char                    acl_name[SYS_ADPT_ACL_MAX_NAME_LEN + 1];
        RULE_TYPE_AclType_T     acl_type = ACL_TYPE;

        UI32_T                  acl_index;

        snprintf(acl_name, sizeof(acl_name), "acl-system-test-%lu", ++acl_count);
        acl_name[ sizeof(acl_name)-1 ] = '\0';

        result = RULE_OM_CreateAcl(acl_name, acl_type);
        if (RULE_TYPE_OK != result)
        {
            break;
        }

        result = RULE_OM_GetAclIdByName(acl_name, &acl_index);
        assert(RULE_TYPE_OK == result);

        device_id = RULE_CTRL_UT_Proc_UPort_To_Device_Id(unit, port);

        while (TRUE)
        {
            RULE_TYPE_Ace_Entry_T   ace_entry;
            UI8_T                   src_mac[SYS_TYPE_MAC_ADDR_LEN];
            UI8_T                   src_mask[SYS_TYPE_MAC_ADDR_LEN];
            UI32_T                  i, j;

            ace_entry.ace_type = acl_type;
            result = RULE_OM_InitAce(&ace_entry);
            assert(RULE_TYPE_OK == result);

            ace_entry.access = (ace_count%2) ?
                               RULE_TYPE_ACE_DENY : RULE_TYPE_ACE_PERMIT;

            memset(src_mac, 0, sizeof(src_mac));
            memset(src_mask, 0xff, sizeof(src_mask));

            assert(SYS_ADPT_MAX_NBRS_OF_ACE < (255*255));

            i = (ace_count+1) / 255;
            j = (ace_count+1) % 255;

            src_mac[ 4 ] = i;
            src_mac[ 5 ] = j;

            RULE_OM_UT_Proc_SetAceSrcMacAddress(&ace_entry, src_mac, src_mask);

            result = RULE_OM_AddAce2Acl(acl_index, acl_type, &ace_entry);
            if (RULE_TYPE_OK != result)
            {
                break;
            }

            ++ ace_count;

            if (ace_count*rule_size == tcam.unit[unit-1].device[device_id].pce_free)
            {
                break;
            }
        }

        memset(&interface, 0, sizeof(interface));
        result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
        assert(RULE_TYPE_OK == result);
        interface.direction = (TRUE == is_ingress) ? RULE_TYPE_INBOUND : RULE_TYPE_OUTBOUND;

        result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                            acl_index,
                                            time_range_index,
                                            counter_enable);
        assert(RULE_TYPE_OK == result);

        //
        // Add undo action
        //

        assert(undo_count < _countof(undo));

        undo[undo_count].ifindex = ifindex;
        undo[undo_count].direction = direction;

        undo[undo_count].acl_index = acl_index;
        undo[undo_count].time_range_index = time_range_index;
        undo[undo_count].counter_enable = counter_enable;

        ++undo_count;

        //
        // FIXME: Check check here !!!!
        //
        ++ifindex;

        if (SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT_ON_BOARD <= ++port)
        {
            port = 1;

            ifindex = 1;

            if (is_ingress == FALSE)
            {
                is_ingress = TRUE;
            }
            else
            {
                is_ingress = FALSE;
            }
        }

        if (ace_count*rule_size == tcam.unit[unit-1].device[device_id].pce_free)
        {
            break;
        }
    }

    assert(ace_count * rule_size == tcam.unit[unit-1].device[device_id].pce_free);


    {
        UI32_T _i;

        for (_i = 0; _i < undo_count; ++ _i)
        {
            result = RULE_CTRL_UT_Proc_UnBind_ACL(undo[_i].ifindex,
                                                  undo[_i].direction,
                                                  undo[_i].acl_index,
                                                  undo[_i].time_range_index,
                                                  undo[_i].counter_enable);
            assert(RULE_TYPE_OK == result);

            result = RULE_OM_DelAcl(undo[_i].acl_index);
            assert(RULE_TYPE_OK == result);
        }

        {
            int i_result;

            RULE_TYPE_TCAMUtilization_T tcam_2;

            RULE_CTRL_GetTCAMUtilization(&tcam_2);

            i_result = memcmp(&tcam, &tcam_2, sizeof(tcam));
            assert(0 == i_result);
        }
    }

// FIXME: time range
#if 0 && (SYS_CPNT_TIME_BASED_ACL == TRUE)
    if (time_range_index == RULE_TYPE_UNDEF_TIME_RANGE)
    {
        const char *time_range_name = "time-range";

        result = RULE_OM_CreateTimeRangeEntry(time_range_name, &time_range_index);
        assert(RULE_TYPE_OK == result);

        goto re_try;
    }
#endif // SYS_CPNT_TIME_BASED_ACL

    return 0;
}

int
RULE_CTRL_UT_IP_Source_Guard_VS_ACL_Priority()
{
#if (SYS_CPNT_IP_SOURCE_GUARD == TRUE && SYS_CPNT_QOS_V2_ALL_PORTS == TRUE)
    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T unit = 1;
    UI32_T port = 3;

    BOOL_T is_enable;
    BOOL_T b_result;

    is_enable = TRUE;

    {
        RULE_CTRL_UnitPortVidSip_T unit_port_vid_sip;

        memset(&unit_port_vid_sip, 0, sizeof(unit_port_vid_sip));

        unit_port_vid_sip.unit = unit;
        unit_port_vid_sip.port = port;
        unit_port_vid_sip.sip  = 0x01020304;
        unit_port_vid_sip.vid  = 1000;

        b_result = RULE_CTRL_Service(is_enable, RULE_CTRL_IP_SOURCE_GUARD_PERMIT_VID_SIP, &unit_port_vid_sip);
        assert(TRUE == b_result);
    }

    {
        enum
        {
            MAX_ACE = 5,
        };

        const char *acl_name = "a1";
        UI32_T acl_index;

        RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace(acl_name, RULE_TYPE_MAC_ACL,
                                                 MAX_ACE, RULE_CTRL_UT_COMPRESS_DISABLE,
                                                 &acl_index);

        //
        //        FIXME: There have one priority bug,
        //        RULE_CTRL_UT_Proc_Validate_Priority_Of_Rule
        //        RULE_TYPE_PACKET_IP_SG_PERMIT_HOST_STRICT vs RULE_TYPE_PACKET_ALL_PORTS_ACL_MATCH_ANY_ANY
        //        Assertion failed: (pce1->hw_idx < pce2->hw_idx), function
        //

        {
            UI32_T ifindex = RULE_TYPE_ALL_PORTS_1_IF_INDEX_NUMBER;
            BOOL_T is_add = TRUE;
            RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;

            result = RULE_CTRL_SetAcl(ifindex,
                                      RULE_TYPE_INBOUND,
                                      acl_index,
                                      is_add,
                                      RULE_TYPE_UNDEF_TIME_RANGE,
                                      counter_enable);
            assert(RULE_TYPE_OK == result);

            result = RULE_OM_SetAcl(ifindex, RULE_TYPE_INBOUND, acl_index,
                                    RULE_TYPE_UNDEF_TIME_RANGE, (UI8_T *)"", counter_enable);
            assert(RULE_TYPE_OK == result);
        }
    }

    RULE_CTRL_UT_Proc_Validate_Rule();

#endif // SYS_CPNT_IP_SOURCE_GUARD && SYS_CPNT_QOS_V2_ALL_PORTS

    return 0;
}

void
RULE_CTRL_UT_Proc_Bind_Policy_Map_With_Max_Class_Map_With_Match_Same_ACL_To_Port(
    UI32_T ifindex,
    RULE_TYPE_InOutDirection_T direction,
    RULE_CTRL_UT_PROC_BIND_POLICY_CLASS_MAP_FLAG_T flag,
    const char *policy_map_name)
{
    RULE_TYPE_INTERFACE_INFO_T  interface;

    UI32_T                      module_id;
    UI32_T                      device_id;
    UI32_T                      phy_port;

    UI32_T                      policy_map_index;

    RULE_TYPE_PolicyMap_T       policy_map;

    UI32_T                      policy_element_ix;

    RULE_TYPE_RETURN_TYPE_T     result;
    BOOL_T                      b_result;

    memset(&interface, 0, sizeof(interface));
    result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
    assert(RULE_TYPE_OK == result);
    interface.direction = direction;

    assert(RULE_TYPE_INTERFACE_UPORT == interface.type);

    b_result = DEV_SWDRV_Logical2PhyDevicePortID(interface.uport.unit,
                                                 interface.uport.port,
                                                 &module_id, &device_id, &phy_port);
    assert(TRUE == b_result);

    result = RULE_OM_GetPolicyMapIdByName(policy_map_name, &policy_map_index);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetPolicyMapByIndex(policy_map_index, &policy_map);
    assert(RULE_TYPE_OK == result);

    for (policy_element_ix = 0; policy_element_ix < policy_map.element_count;
                                                         ++policy_element_ix)
    {
        UI32_T policy_element_index = policy_map.policy_map_element_index_list[policy_element_ix];
        RULE_TYPE_PolicyElement_T   policy_element;
        RULE_TYPE_ClassMap_T        class_map;
        UI32_T                      class_map_index;
        UI32_T                      acl_index;

        result = RULE_OM_GetPolicyMapElement(policy_element_index, &policy_element);
        assert(RULE_TYPE_OK == result);

        class_map_index = policy_element.class_map_index;

        result = RULE_OM_GetClassMap(class_map_index, &class_map);
        assert(RULE_TYPE_OK == result);

        assert(0 < class_map.class_element_count);
        assert(RULE_TYPE_CLASS_ACL == class_map.class_type[0]);

        acl_index = class_map.class_index_list[0];

        if (RULE_CTRL_UT_PROC_BIND_POLICY_CLASS_MAP_FLAG_ADD_RULE == flag ||
            RULE_CTRL_UT_PROC_BIND_POLICY_CLASS_MAP_FLAG_DEL_RULE == flag)
        {
            UI32_T old_free_pce = shmem_data_p->stack_free_nbr_pce[interface.uport.unit-1][device_id];
            UI32_T free_pce;

            result = RULE_CTRL_SetQoSAcl(ifindex,
                                         direction,
                                         policy_map_index,
                                         policy_element.class_map_index,
                                         acl_index,
                                         policy_element.meter_index,
                                         policy_element.action_index,
                                         flag);

            free_pce = shmem_data_p->stack_free_nbr_pce[interface.uport.unit-1][device_id];

            if (RULE_TYPE_OK == result)
            {
                if (RULE_CTRL_UT_PROC_BIND_POLICY_CLASS_MAP_FLAG_ADD_RULE == flag)
                {
                    assert(free_pce < old_free_pce);
                }
                else
                {
                    assert(old_free_pce < free_pce);
                }
            }
            else
            {
                assert(free_pce == old_free_pce);
            }

            RULE_CTRL_UT_Proc_Validate_Rule();

            if (FALSE == b_result)
            {
                break;
            }
        }

    }
}

void
RULE_CTRL_UT_Proc_Bind_Policy_Map_With_Max_Class_Map_With_Match_Diff_ACL_To_Port(
    UI32_T ifindex,
    RULE_TYPE_InOutDirection_T direction,
    RULE_CTRL_UT_PROC_BIND_POLICY_CLASS_MAP_FLAG_T flag,
    const char *policy_map_name)
{
    RULE_TYPE_INTERFACE_INFO_T  interface;

    UI32_T                      module_id;
    UI32_T                      device_id;
    UI32_T                      phy_port;

    UI32_T                      policy_map_index;

    RULE_TYPE_PolicyMap_T       policy_map;

    UI32_T                      policy_element_ix;

    RULE_TYPE_RETURN_TYPE_T     result;
    BOOL_T                      b_result;

    memset(&interface, 0, sizeof(interface));
    result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
    assert(RULE_TYPE_OK == result);
    interface.direction = direction;

    assert(RULE_TYPE_INTERFACE_UPORT == interface.type);

    b_result = DEV_SWDRV_Logical2PhyDevicePortID(interface.uport.unit,
                                                 interface.uport.port,
                                                 &module_id, &device_id, &phy_port);
    assert(TRUE == b_result);

    result = RULE_OM_GetPolicyMapIdByName(policy_map_name, &policy_map_index);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetPolicyMapByIndex(policy_map_index, &policy_map);
    assert(RULE_TYPE_OK == result);

    if (RULE_CTRL_UT_PROC_BIND_POLICY_CLASS_MAP_FLAG_ADD_RULE == flag)
    {
        RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

        RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

        RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;
        RULE_TYPE_CLASS_INSTANCE_OBJECT_T policy_map_inst_obj;

        if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
        assert(NULL != if_entry_p);

        //
        // create policy-map instance
        //
        RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                  &if_class_obj);

        result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_POLICY_MAP,
                                                             &policy_map_inst_obj);
        assert(RULE_TYPE_OK == result);

        policy_map_inst_p = policy_map_inst_obj.inst;

        assert(NULL != policy_map_inst_p);

        policy_map_inst_p->id = policy_map_index;
        policy_map_inst_p->mvl_pkt_type = RULE_TYPE_PACKET_NIL;

        if_class_obj.add_class_obj(&if_class_obj, &policy_map_inst_obj);

        result = RULE_CTRL_Priv_SetPolicyMapInstance(&interface, policy_map_inst_p);
        assert(RULE_TYPE_OK == result);

        result = RULE_OM_BindPort2PolicyMap(ifindex, direction, policy_map_index);
        assert(RULE_TYPE_OK == result);
    }

    for (policy_element_ix = 0; policy_element_ix < policy_map.element_count;
                                                            ++policy_element_ix)
    {
        UI32_T policy_element_index = policy_map.policy_map_element_index_list[policy_element_ix];

        RULE_TYPE_PolicyElement_T   policy_element;
        RULE_TYPE_ClassMap_T        class_map;
        UI32_T                      class_map_index;
        UI32_T                      acl_index;

        result = RULE_OM_GetPolicyMapElement(policy_element_index, &policy_element);
        assert(RULE_TYPE_OK == result);

        class_map_index = policy_element.class_map_index;

        result = RULE_OM_GetClassMap(class_map_index, &class_map);
        assert(RULE_TYPE_OK == result);

        assert(0 < class_map.class_element_count);
        assert(RULE_TYPE_CLASS_ACL == class_map.class_type[0]);

        acl_index = class_map.class_index_list[0];

        if (RULE_CTRL_UT_PROC_BIND_POLICY_CLASS_MAP_FLAG_ADD_RULE == flag ||
            RULE_CTRL_UT_PROC_BIND_POLICY_CLASS_MAP_FLAG_DEL_RULE == flag)
        {
            UI32_T old_free_pce = shmem_data_p->stack_free_nbr_pce[interface.uport.unit-1][device_id];
            UI32_T free_pce;

            {
                RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

                RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

                RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;

                RULE_CTRL_INSTANCE_TYPE_ID_T param;

                if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
                ASSERT(NULL != if_entry_p);

                RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                          &if_class_obj);

                memset(&param, 0, sizeof(param));

                param.type = RULE_TYPE_INST_POLICY_MAP;
                param.id = policy_map_index;

                policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                                   RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                                   &param);
                assert(NULL != policy_map_inst_p);

                result = RULE_CTRL_LocalSetClassMap2DEV(&interface, policy_map_index, &policy_map,
                                                        policy_map_inst_p,
                                                        policy_element.class_map_index,
                                                        policy_element.meter_index,
                                                        policy_element.action_index);
            }

            free_pce = shmem_data_p->stack_free_nbr_pce[interface.uport.unit-1][device_id];

            if (RULE_TYPE_OK == result)
            {
                if (RULE_CTRL_UT_PROC_BIND_POLICY_CLASS_MAP_FLAG_ADD_RULE == flag)
                {
                    assert(free_pce < old_free_pce);
                }
                else
                {
                    assert(old_free_pce < free_pce);
                }
            }
            else
            {
                assert(free_pce == old_free_pce);
            }

            //
            // Here, it cannot use RULE_CTRL_UT_Proc_Validate_Rule to do fully
            // test. Becuase the port doesn't bind policy-map index yet that
            // means some class instances missed.
            //
            // RULE_CTRL_UT_Proc_Validate_Rule();
            //
            RULE_CTRL_UT_Proc_Validate_Number_Of_Rule();

            if (RULE_TYPE_OK != result)
            {
                if (RULE_CTRL_UT_PROC_BIND_POLICY_CLASS_MAP_FLAG_ADD_RULE == flag)
                {
                    result = RULE_CTRL_SetPolicyMap(ifindex, direction, policy_map_index, FALSE);
                    assert(RULE_TYPE_OK == result);

                    result = RULE_CTRL_Priv_SetPolicyMapInstance(&interface, NULL);
                    assert(RULE_TYPE_OK == result);

                    result = RULE_OM_UnBindPort2PolicyMap(ifindex, direction, policy_map_index);
                    assert(RULE_TYPE_OK == result);
                }

                return;
            }
        }

    }
}

int
RULE_CTRL_UT_Set_QoS_With_Match_ACL_Rule()
{
    const char  *policy_map_name = "p1";

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    BOOL_T      is_add;

    RULE_CTRL_UT_Proc_Create_Policy_Class_Map_With_Match_ACL(policy_map_name,
                                                 RULE_TYPE_CLASS_MAP_MATCH_ANY);

    ifindex = 2;
    direction = RULE_TYPE_INBOUND;

    is_add = TRUE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    is_add = FALSE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    ifindex = 2;
    direction = RULE_TYPE_INBOUND;

    is_add = TRUE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    is_add = FALSE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    return 0;
}

int
RULE_CTRL_UT_Set_QoS_With_Match_MF_Rule()
{
    enum
    {
        MIN_IFINDEX = 2,
        MAX_IFINDEX = 5,
        MIN_DIRECTION = RULE_TYPE_INBOUND,
#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION = RULE_TYPE_OUTBOUND,
#else
        MAX_DIRECTION = RULE_TYPE_INBOUND,
#endif
        MAX_RETRY = 2,
    };

    const char                  *policy_map_name = "p1";

    UI32_T                      ifindex;
    RULE_TYPE_InOutDirection_T  direction;
    UI32_T                      retry;

    BOOL_T                      is_add;

    RULE_CTRL_UT_Proc_Create_Policy_Class_Map_With_Match_MF_ACE(policy_map_name,
                                                 RULE_TYPE_CLASS_MAP_MATCH_ANY);

    for (retry = 0; retry <= MAX_RETRY; ++ retry)
    {
        for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
        {
            for (direction = MIN_DIRECTION; direction <= MAX_DIRECTION; ++ direction)
            {
                is_add = TRUE;

                RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
//                RULE_CTRL_DumpGlobalAce_BackDoor();
//                RULE_CTRL_UT_Proc_Validate_Rule();

                is_add = FALSE;

                RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
//                RULE_CTRL_DumpGlobalAce_BackDoor();
//                RULE_CTRL_UT_Proc_Validate_Rule();
            }
        }
    }

    ifindex = MAX_IFINDEX;
    direction = MAX_DIRECTION;

    is_add = TRUE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);

    return 0;
}

int
RULE_CTRL_UT_Set_QoS_With_Match_ACL_MF_Rule()
{
    enum
    {
        MIN_IFINDEX = 2,
        MAX_IFINDEX = 5,
        MIN_DIRECTION = RULE_TYPE_INBOUND,
#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION = RULE_TYPE_OUTBOUND,
#else
        MAX_DIRECTION = RULE_TYPE_INBOUND,
#endif
        MAX_RETRY = 2,
    };

    const char                  *policy_map_name = "p1";

    UI32_T                      ifindex;
    RULE_TYPE_InOutDirection_T  direction;
    UI32_T                      retry;

    BOOL_T                      is_add;

    RULE_CTRL_UT_Proc_Create_Policy_Match_Any_Class_Map_With_Match_ACL_MF(policy_map_name);

    for (retry = 0; retry <= MAX_RETRY; ++ retry)
    {
        for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
        {
            for (direction = MIN_DIRECTION; direction <= MAX_DIRECTION; ++ direction)
            {
                is_add = TRUE;

                RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);

                is_add = FALSE;

                RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
            }
        }
    }

    ifindex = MAX_IFINDEX;
    direction = MAX_DIRECTION;

    is_add = TRUE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);

    return 0;
}

int
RULE_CTRL_UT_Set_QoS_With_Match_ACL_Rule_CPU_Port()
{
    const char  *policy_map_name = "p1";

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    BOOL_T      is_add;

    RULE_CTRL_UT_Proc_Create_Policy_Class_Map_With_Match_ACL(policy_map_name,
                                                 RULE_TYPE_CLASS_MAP_MATCH_ANY);

    ifindex = SYS_ADPT_CPU_1_IF_INDEX_NUMBER;
    direction = RULE_TYPE_OUTBOUND;

    is_add = TRUE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    is_add = FALSE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    is_add = TRUE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    is_add = FALSE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    return 0;
}

int
RULE_CTRL_UT_Set_QoS_With_Match_MF_Rule_CPU_Port()
{
    const char                  *policy_map_name = "p1";

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    BOOL_T                      is_add;

    RULE_CTRL_UT_Proc_Create_Policy_Class_Map_With_Match_MF_ACE(policy_map_name,
                                                 RULE_TYPE_CLASS_MAP_MATCH_ANY);

    ifindex = SYS_ADPT_CPU_1_IF_INDEX_NUMBER;
    direction = RULE_TYPE_OUTBOUND;

    is_add = TRUE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    is_add = FALSE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    is_add = TRUE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    is_add = FALSE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    return 0;
}

int
RULE_CTRL_UT_Set_QoS_With_Match_ACL_Rule_Trunk_Port()
{
    const char  *policy_map_name = "p1";

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    BOOL_T      is_add;

    RULE_CTRL_UT_Proc_Create_Policy_Class_Map_With_Match_ACL(policy_map_name,
                                                 RULE_TYPE_CLASS_MAP_MATCH_ANY);

    ifindex = SYS_ADPT_CPU_1_IF_INDEX_NUMBER;
    direction = RULE_TYPE_INBOUND;

    for (ifindex = SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER;
         ifindex < SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER + SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM;
         ++ ifindex)
    {
        is_add = TRUE;

        RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
        RULE_CTRL_UT_Proc_Validate_Rule();

        is_add = FALSE;

        RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
        RULE_CTRL_UT_Proc_Validate_Rule();
    }

    return 0;
}

int
RULE_CTRL_UT_Set_QoS_With_Match_MF_Rule_Trunk_Port()
{
    const char                  *policy_map_name = "p1";

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    BOOL_T                      is_add;

    RULE_CTRL_UT_Proc_Create_Policy_Class_Map_With_Match_MF_ACE(policy_map_name,
                                                 RULE_TYPE_CLASS_MAP_MATCH_ANY);

    ifindex = SYS_ADPT_CPU_1_IF_INDEX_NUMBER;
    direction = RULE_TYPE_OUTBOUND;

    is_add = TRUE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    is_add = FALSE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    is_add = TRUE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    is_add = FALSE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    return 0;
}

int
RULE_CTRL_UT_Set_QoS_With_Match_Any_ACL_MF_Rule()
{
    enum
    {
        MAX_UNIT        = 1,
        MAX_PORT        = SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT_ON_BOARD,

#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION   = RULE_TYPE_OUTBOUND,
#else
        MAX_DIRECTION   = RULE_TYPE_INBOUND,
#endif // SYS_CPNT_QOS_V2_EGRESS_PORT

    };

    const char                  *policy_map_name = "p1";

    UI32_T                      unit;
    UI32_T                      port;

    UI32_T                      ifindex;

    RULE_TYPE_InOutDirection_T  direction;
    BOOL_T                      is_add;

    RULE_CTRL_UT_Proc_Create_Policy_Match_Any_Class_Map_With_Match_ACL_MF(policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    ifindex = 2;
    direction = RULE_TYPE_INBOUND;

    is_add = TRUE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    is_add = FALSE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    ifindex = 2;
    direction = RULE_TYPE_INBOUND;

    is_add = TRUE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    is_add = FALSE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    for (unit = 1; unit <= MAX_UNIT; ++unit)
    {
        for (port = 1; port <= MAX_PORT; ++port)
        {
            ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);

            for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
            {
                is_add = TRUE;
                RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex,
                                                          direction,
                                                          is_add,
                                                          policy_map_name);
                RULE_CTRL_UT_Proc_Validate_Rule();
            }
        }
    }

    for (unit = 1; unit <= MAX_UNIT; ++unit)
    {
        for (port = 1; port <= MAX_PORT; ++port)
        {
            ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);

            for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
            {
                is_add = FALSE;
                RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex,
                                                          direction,
                                                          is_add,
                                                          policy_map_name);
                RULE_CTRL_UT_Proc_Validate_Rule();
            }
        }
    }

    return 0;
}

int
RULE_CTRL_UT_Set_QoS_With_Match_All_ACL_MF_Rule()
{
#if (SYS_CPNT_QOS_V2_CLASS_MAP_MATCH_ALL == TRUE)
    enum
    {
        MAX_UNIT        = 1,
        MAX_PORT        = SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT_ON_BOARD,

#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION   = RULE_TYPE_OUTBOUND,
#else
        MAX_DIRECTION   = RULE_TYPE_INBOUND,
#endif // SYS_CPNT_QOS_V2_EGRESS_PORT

    };

    const char                  *policy_map_name = "p1";

    UI32_T                      unit;
    UI32_T                      port;

    UI32_T                      ifindex;

    RULE_TYPE_InOutDirection_T  direction;

    BOOL_T                      is_add;

    RULE_CTRL_UT_Proc_Create_Policy_Match_All_Class_Map_With_Match_ACL_MF(policy_map_name);

    ifindex = 2;
    direction = RULE_TYPE_INBOUND;

    is_add = TRUE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    is_add = FALSE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    ifindex = 2;
    direction = RULE_TYPE_INBOUND;

    is_add = TRUE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    is_add = FALSE;

    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_Validate_Rule();

    for (unit = 1; unit <= MAX_UNIT; ++unit)
    {
        for (port = 1; port <= MAX_PORT; ++port)
        {
            ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);

            for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
            {
                is_add = TRUE;
                RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex,
                                                          direction,
                                                          is_add,
                                                          policy_map_name);
                RULE_CTRL_UT_Proc_Validate_Rule();
            }
        }
    }

    for (unit = 1; unit <= MAX_UNIT; ++unit)
    {
        for (port = 1; port <= MAX_PORT; ++port)
        {
            ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);

            for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
            {
                is_add = FALSE;
                RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex,
                                                          direction,
                                                          is_add,
                                                          policy_map_name);
                RULE_CTRL_UT_Proc_Validate_Rule();
            }
        }
    }
#endif /* #if (SYS_CPNT_QOS_V2_CLASS_MAP_MATCH_ALL == TRUE) */

    return 0;
}

int
RULE_CTRL_UT_Set_QoS_With_Same_ACL_Rule_For_Undo_Test()
{
    const char *policy_map_name = "p1";

    UI32_T ifindex;

    RULE_TYPE_InOutDirection_T direction;

    RULE_CTRL_UT_Proc_Create_Policy_Map_With_Max_Class_Map_With_Match_Same_ACL(
                                                               policy_map_name);

    printf("%s no run due to bug!\r\n", __FUNCTION__);
    return 0;

    ifindex = 3;
    direction = RULE_TYPE_INBOUND;
    RULE_CTRL_UT_Proc_Bind_Policy_Map_With_Max_Class_Map_With_Match_Same_ACL_To_Port(ifindex,
                                                                                     direction,
                                                                                     RULE_CTRL_UT_PROC_BIND_POLICY_CLASS_MAP_FLAG_ADD_RULE,
                                                                                     policy_map_name);
    return 0;
}

int
RULE_CTRL_UT_Set_QoS_With_Diff_ACL_Rule_For_Undo_Test()
{
    enum
    {
#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION = RULE_TYPE_OUTBOUND,
#else
        MAX_DIRECTION = RULE_TYPE_INBOUND,
#endif
    };

    const char *policy_map_name = "p1";

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    RULE_CTRL_UT_Proc_Create_Policy_Map_With_Max_Class_Map_With_Match_Diff_ACL(
                                                               policy_map_name);

    ifindex = 3;
    for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
    {
        RULE_CTRL_UT_Proc_Bind_Policy_Map_With_Max_Class_Map_With_Match_Diff_ACL_To_Port(ifindex,
                                                                                         direction,
                                                                                         RULE_CTRL_UT_PROC_BIND_POLICY_CLASS_MAP_FLAG_ADD_RULE,
                                                                                         policy_map_name);
        RULE_CTRL_UT_Proc_Validate_Rule();
    }

    return 0;
}

int
RULE_CTRL_UT_Set_QoS_With_Diff_ACL_Rule_For_Undo_Out_Of_ACL_Instance()
{
    enum
    {
#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION = RULE_TYPE_OUTBOUND,
#else
        MAX_DIRECTION = RULE_TYPE_INBOUND,
#endif
        TOTAL_NUMBER_OF_CLASS_INSTANCE = _countof(shmem_data_p->_class_inst_pool_buf),
    };

    const char *policy_map_name = "p1";

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    UI32_T i;

    RULE_TYPE_SHM_POINTER_T *dup_class_inst_pool_ptr;

    dup_class_inst_pool_ptr = calloc(sizeof(RULE_TYPE_SHM_POINTER_T), TOTAL_NUMBER_OF_CLASS_INSTANCE);
    assert(NULL != dup_class_inst_pool_ptr);

    RULE_CTRL_UT_Proc_Create_Policy_Map_With_Max_Class_Map_With_Match_Diff_ACL(
                                                               policy_map_name);

    ifindex = 3;
    for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
    {
        for (i = 0; i < TOTAL_NUMBER_OF_CLASS_INSTANCE; ++ i)
        {
            dup_class_inst_pool_ptr[i] = RULE_CTRL_IN_Priv_CreateClassInstance(RULE_TYPE_INST_POLICY_MAP);
            if (RULE_TYPE_INST_POLICY_MAP != dup_class_inst_pool_ptr[i].type)
            {
                break;
            }
        }

        //
        // Reserve one instance for policy map
        //
        i--;
        assert(RULE_TYPE_INST_POLICY_MAP == dup_class_inst_pool_ptr[i].type);
        RULE_CTRL_IN_Priv_DestroyClassInstance(dup_class_inst_pool_ptr[i]);
        dup_class_inst_pool_ptr[i].type = RULE_TYPE_NIL;


        //
        // This function should fail to create ACL instance, and undo should
        // work well, too.
        //
        RULE_CTRL_UT_Proc_Bind_Policy_Map_With_Max_Class_Map_With_Match_Diff_ACL_To_Port(ifindex,
                                                                                         direction,
                                                                                         RULE_CTRL_UT_PROC_BIND_POLICY_CLASS_MAP_FLAG_ADD_RULE,
                                                                                         policy_map_name);

        for (i = 0; i < TOTAL_NUMBER_OF_CLASS_INSTANCE; ++i)
        {
            if (RULE_TYPE_NIL == dup_class_inst_pool_ptr[i].type) {
                continue;
            }

            RULE_CTRL_IN_Priv_DestroyClassInstance(dup_class_inst_pool_ptr[i]);
            dup_class_inst_pool_ptr[i].type = RULE_TYPE_NIL;
        }

        RULE_CTRL_UT_Proc_Validate_Rule();
    }

    free(dup_class_inst_pool_ptr);

    return 0;
}

int
RULE_CTRL_UT_SeT_QoS_With_MF_Rule_For_Undo_Out_Of_MF_Class_Instance()
{
    enum
    {
        MAX_UNIT = 1,
        MAX_PORT = 2,
#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION = RULE_TYPE_OUTBOUND,
#else
        MAX_DIRECTION = RULE_TYPE_INBOUND,
#endif
        TOTAL_NUMBER_OF_CLASS_INSTANCE = _countof(shmem_data_p->_class_inst_pool_buf) - 1,
    };

    const char *policy_map_name = "p1";
    RULE_TYPE_MatchType_T match_type = RULE_TYPE_CLASS_MAP_MATCH_ANY;

    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T unit;
    UI32_T port;

    RULE_TYPE_InOutDirection_T direction;

    UI32_T policy_map_index;
    RULE_TYPE_PolicyMap_T policy_map;

    RULE_TYPE_SHM_POINTER_T *dup_class_inst_pool_ptr;
    UI32_T i;

    dup_class_inst_pool_ptr = calloc(sizeof(RULE_TYPE_SHM_POINTER_T), TOTAL_NUMBER_OF_CLASS_INSTANCE);
    assert(NULL != dup_class_inst_pool_ptr);

    RULE_CTRL_UT_Proc_Create_Policy_Class_Map_With_Match_MF_ACE(policy_map_name, match_type);

    result = RULE_OM_GetPolicyMapIdByName(policy_map_name, &policy_map_index);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetPolicyMap(policy_map_index, &policy_map);
    assert(result == RULE_TYPE_OK);

    for (unit = 1; unit <= MAX_UNIT; ++unit)
    {
        for (port = 1; port <= MAX_PORT; ++port)
        {
            UI32_T ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);

            for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
            {
                UI32_T px;

                RULE_TYPE_INTERFACE_INFO_T interface;

                RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
                interface.direction = direction;

                for (px = 0; px < policy_map.element_count; ++px)
                {
                    UI32_T policy_element_index = policy_map.policy_map_element_index_list[px];
                    UI32_T class_map_index;

                    UI32_T cx;

                    RULE_TYPE_PolicyElement_T   policy_element;
                    RULE_TYPE_ClassMap_T        class_map;

                    result = RULE_OM_GetPolicyMapElement(policy_element_index, &policy_element);
                    assert(RULE_TYPE_OK == result);

                    class_map_index = policy_element.class_map_index;

                    result = RULE_OM_GetClassMap(class_map_index, &class_map);
                    assert(RULE_TYPE_OK == result);

                    assert(RULE_TYPE_CLASS_MAP_MATCH_ANY == class_map.class_map_match_type);

                    for (cx = 0; cx < class_map.class_element_count; ++cx)
                    {
                        RULE_TYPE_ClassType_T class_type = class_map.class_type[cx];
                        UI32_T class_id = class_map.class_index_list[cx];

                        for (i = 0; i < TOTAL_NUMBER_OF_CLASS_INSTANCE; ++ i)
                        {
                            dup_class_inst_pool_ptr[i] = RULE_CTRL_IN_Priv_CreateClassInstance(RULE_TYPE_INST_POLICY_MAP);
                            if (RULE_TYPE_INST_POLICY_MAP != dup_class_inst_pool_ptr[i].type)
                            {
                                break;
                            }
                        }

                        //
                        // Reserve two instance for policy map and class map
                        //
                        i--;
                        assert(RULE_TYPE_INST_POLICY_MAP == dup_class_inst_pool_ptr[i].type);
                        RULE_CTRL_IN_Priv_DestroyClassInstance(dup_class_inst_pool_ptr[i]);
                        dup_class_inst_pool_ptr[i].type = RULE_TYPE_NIL;

                        i--;
                        assert(RULE_TYPE_INST_POLICY_MAP == dup_class_inst_pool_ptr[i].type);
                        RULE_CTRL_IN_Priv_DestroyClassInstance(dup_class_inst_pool_ptr[i]);
                        dup_class_inst_pool_ptr[i].type = RULE_TYPE_NIL;

                        {
                            RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

                            RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

                            RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;
                            RULE_TYPE_CLASS_INSTANCE_OBJECT_T policy_map_inst_obj;

                            RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p;
                            RULE_TYPE_CLASS_INSTANCE_OBJECT_T class_map_inst_obj;

                            if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
                            assert(NULL != if_entry_p);

                            RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                                      &if_class_obj);

                            //
                            // create policy-map instance
                            //
                            result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_POLICY_MAP,
                                                                                 &policy_map_inst_obj);
                            assert(RULE_TYPE_OK == result);

                            policy_map_inst_p = policy_map_inst_obj.inst;

                            assert(NULL != policy_map_inst_p);

                            policy_map_inst_p->id = policy_map_index;
                            policy_map_inst_p->mvl_pkt_type = RULE_TYPE_PACKET_NIL;

                            if_class_obj.add_class_obj(&if_class_obj, &policy_map_inst_obj);

                            //
                            // create class-map instance
                            //
                            result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_CLASS_MAP,
                                                                                 &class_map_inst_obj);
                            assert(RULE_TYPE_OK == result);

                            class_map_inst_p = class_map_inst_obj.inst;

                            assert(NULL != class_map_inst_p);

                            class_map_inst_p->id = class_map_index;
                            class_map_inst_p->mvl_pkt_type = RULE_TYPE_PACKET_NIL;

                            assert(NULL != policy_map_inst_p);
                            assert(policy_map_inst_p == policy_map_inst_obj.inst);

                            policy_map_inst_obj.add_class_obj(&policy_map_inst_obj, &class_map_inst_obj);

                            //
                            // This function should fail to create MF class instance, and undo should
                            // work well, too.
                            //
                            assert(class_type == RULE_TYPE_CLASS_MF);

                            //
                            // go
                            //
                            result = RULE_CTRL_SetMf(ifindex,
                                                     direction,
                                                     policy_map_index,
                                                     policy_element.class_map_index,
                                                     class_id,
                                                     policy_element.meter_index,
                                                     policy_element.action_index,
                                                     TRUE);
                            assert(RULE_TYPE_OK != result);

                            //
                            // Destroy class-map
                            //
                            policy_map_inst_obj.remove_class_obj(&policy_map_inst_obj, &class_map_inst_obj);
                            RULE_CTRL_IN_Priv_DestroyClassInstanceObject(&class_map_inst_obj);

                            //
                            // Destroy policy-map
                            //
                            if_class_obj.remove_class_obj(&if_class_obj, &policy_map_inst_obj);
                            RULE_CTRL_IN_Priv_DestroyClassInstanceObject(&policy_map_inst_obj);

                            for (i = 0; i < TOTAL_NUMBER_OF_CLASS_INSTANCE; ++i)
                            {
                                if (RULE_TYPE_NIL == dup_class_inst_pool_ptr[i].type) {
                                    continue;
                                }

                                RULE_CTRL_IN_Priv_DestroyClassInstance(dup_class_inst_pool_ptr[i]);
                                dup_class_inst_pool_ptr[i].type = RULE_TYPE_NIL;
                            }

                            RULE_CTRL_UT_Proc_Validate_Rule();

                        }
                    }
                }
            }
        }
    }

    free(dup_class_inst_pool_ptr);

    return 0;
}

int
RULE_CTRL_UT_SeT_QoS_With_MF_Rule_For_Undo_Out_Of_MF_Rule_Instance()
{
    enum
    {
        MAX_UNIT = 1,
        MAX_PORT = 2,
#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION = RULE_TYPE_OUTBOUND,
#else
        MAX_DIRECTION = RULE_TYPE_INBOUND,
#endif
        TOTAL_NUMBER_OF_RULE_INSTANCE = _countof(shmem_data_p->_rule_inst_pool_buf),
    };

    const char *policy_map_name = "p1";
    RULE_TYPE_MatchType_T match_type = RULE_TYPE_CLASS_MAP_MATCH_ANY;

    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T unit;
    UI32_T port;
    RULE_TYPE_InOutDirection_T direction;

    UI32_T policy_map_index;
    RULE_TYPE_PolicyMap_T policy_map;

    RULE_TYPE_SHM_POINTER_T *dup_rule_inst_pool_ptr;
    UI32_T i;

    dup_rule_inst_pool_ptr = calloc(sizeof(RULE_TYPE_SHM_POINTER_T), TOTAL_NUMBER_OF_RULE_INSTANCE);
    assert(NULL != dup_rule_inst_pool_ptr);

    RULE_CTRL_UT_Proc_Create_Policy_Class_Map_With_Match_MF_ACE(policy_map_name, match_type);

    result = RULE_OM_GetPolicyMapIdByName(policy_map_name, &policy_map_index);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetPolicyMap(policy_map_index, &policy_map);
    assert(result == RULE_TYPE_OK);

    for (unit = 1; unit <= MAX_UNIT; ++unit)
    {
        for (port = 1; port <= MAX_PORT; ++port)
        {
            UI32_T ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);

            for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
            {
                UI32_T px;

                RULE_TYPE_INTERFACE_INFO_T interface;

                RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
                interface.direction = direction;

                for (px = 0; px < policy_map.element_count; ++px)
                {
                    UI32_T policy_element_index = policy_map.policy_map_element_index_list[px];
                    UI32_T class_map_index;

                    UI32_T cx;

                    RULE_TYPE_PolicyElement_T   policy_element;
                    RULE_TYPE_ClassMap_T        class_map;

                    result = RULE_OM_GetPolicyMapElement(policy_element_index, &policy_element);
                    assert(RULE_TYPE_OK == result);

                    class_map_index = policy_element.class_map_index;

                    result = RULE_OM_GetClassMap(class_map_index, &class_map);
                    assert(RULE_TYPE_OK == result);

                    assert(RULE_TYPE_CLASS_MAP_MATCH_ANY == class_map.class_map_match_type);

                    for (cx = 0; cx < class_map.class_element_count; ++cx)
                    {
                        RULE_TYPE_ClassType_T class_type = class_map.class_type[cx];
                        UI32_T class_id = class_map.class_index_list[cx];

                        for (i = 0; i < TOTAL_NUMBER_OF_RULE_INSTANCE; ++i)
                        {
                            dup_rule_inst_pool_ptr[i] = RULE_CTRL_IN_Priv_CreateRuleInstance(RULE_TYPE_INST_RULE);
                            assert(RULE_TYPE_INST_RULE == dup_rule_inst_pool_ptr[i].type);
                        }

                        assert(class_type == RULE_TYPE_CLASS_MF);

                        {
                            RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

                            RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

                            RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;
                            RULE_TYPE_CLASS_INSTANCE_OBJECT_T policy_map_inst_obj;

                            RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p;
                            RULE_TYPE_CLASS_INSTANCE_OBJECT_T class_map_inst_obj;

                            if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
                            assert(NULL != if_entry_p);

                            RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                                      &if_class_obj);

                            //
                            // create policy-map instance
                            //
                            result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_POLICY_MAP,
                                                                                 &policy_map_inst_obj);
                            assert(RULE_TYPE_OK == result);

                            policy_map_inst_p = policy_map_inst_obj.inst;

                            assert(NULL != policy_map_inst_p);

                            policy_map_inst_p->id = policy_map_index;
                            policy_map_inst_p->mvl_pkt_type = RULE_TYPE_PACKET_NIL;

                            if_class_obj.add_class_obj(&if_class_obj, &policy_map_inst_obj);

                            //
                            // create class-map instance
                            //
                            result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_CLASS_MAP,
                                                                                 &class_map_inst_obj);
                            assert(RULE_TYPE_OK == result);

                            class_map_inst_p = class_map_inst_obj.inst;

                            assert(NULL != class_map_inst_p);

                            class_map_inst_p->id = class_map_index;
                            class_map_inst_p->mvl_pkt_type = RULE_TYPE_PACKET_NIL;

                            assert(NULL != policy_map_inst_p);
                            assert(policy_map_inst_p == policy_map_inst_obj.inst);

                            policy_map_inst_obj.add_class_obj(&policy_map_inst_obj, &class_map_inst_obj);


                            //
                            // go
                            //
                            result = RULE_CTRL_SetMf(ifindex,
                                                     direction,
                                                     policy_map_index,
                                                     policy_element.class_map_index,
                                                     class_id,
                                                     policy_element.meter_index,
                                                     policy_element.action_index,
                                                     TRUE);
                            assert(RULE_TYPE_OK != result);

                            //
                            // Destroy class-map
                            //
                            policy_map_inst_obj.remove_class_obj(&policy_map_inst_obj, &class_map_inst_obj);
                            RULE_CTRL_IN_Priv_DestroyClassInstanceObject(&class_map_inst_obj);

                            //
                            // Destroy policy-map
                            //
                            if_class_obj.remove_class_obj(&if_class_obj, &policy_map_inst_obj);
                            RULE_CTRL_IN_Priv_DestroyClassInstanceObject(&policy_map_inst_obj);

                            for (i = 0; i < TOTAL_NUMBER_OF_RULE_INSTANCE; ++i)
                            {
                                assert(RULE_TYPE_INST_RULE == dup_rule_inst_pool_ptr[i].type);

                                RULE_CTRL_IN_Priv_DestroyRuleInstance(dup_rule_inst_pool_ptr[i]);
                                dup_rule_inst_pool_ptr[i].type = RULE_TYPE_NIL;
                            }

                            RULE_CTRL_UT_Proc_Validate_Rule();
                        }
                    }
                }
            }
        }
    }

    free(dup_rule_inst_pool_ptr);

    return 0;
}

int
RULE_CTRL_UT_Set_QoS_Policy_Map_For_Undo_Out_Of_Rule_Instance()
{
    enum
    {
        MAX_IFINDEX = 3,
#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION = RULE_TYPE_OUTBOUND,
#else
        MAX_DIRECTION = RULE_TYPE_INBOUND,
#endif
        TOTAL_NUMBER_OF_RULE_INSTANCE = _countof(shmem_data_p->_rule_inst_pool_buf),
    };

    const char *policy_map_name = "p1";
    RULE_TYPE_MatchType_T match_type = RULE_TYPE_CLASS_MAP_MATCH_ANY;

    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    UI32_T policy_map_index;
    RULE_TYPE_PolicyMap_T policy_map;

    RULE_TYPE_SHM_POINTER_T *dup_rule_inst_pool_ptr;
    UI32_T i;

    dup_rule_inst_pool_ptr = calloc(sizeof(RULE_TYPE_SHM_POINTER_T), TOTAL_NUMBER_OF_RULE_INSTANCE);
    assert(NULL != dup_rule_inst_pool_ptr);

    RULE_CTRL_UT_Proc_Create_Policy_Class_Map_With_Match_MF_ACE(policy_map_name, match_type);

    result = RULE_OM_GetPolicyMapIdByName(policy_map_name, &policy_map_index);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetPolicyMap(policy_map_index, &policy_map);
    assert(result == RULE_TYPE_OK);

    for (ifindex = 1; ifindex <= MAX_IFINDEX; ++ifindex)
    {
        for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
        {
            //
            // Assume all class map have the same rule number
            //
            UI32_T policy_element_index = policy_map.policy_map_element_index_list[0];

            RULE_TYPE_PolicyElement_T   policy_element;
            RULE_TYPE_ClassMap_T        class_map;

            UI32_T require_rule_num;

            assert(0 < policy_map.element_count);

            result = RULE_OM_GetPolicyMapElement(policy_element_index, &policy_element);
            assert(RULE_TYPE_OK == result);

            result = RULE_OM_GetClassMap(policy_element.class_map_index, &class_map);
            assert(RULE_TYPE_OK == result);

            require_rule_num = policy_map.element_count * class_map.class_element_count;

            //
            // It will cause last class-map failed to bind port
            //
            require_rule_num -= 1;

            assert(require_rule_num <= TOTAL_NUMBER_OF_RULE_INSTANCE);
            for (i = 0; i < TOTAL_NUMBER_OF_RULE_INSTANCE - require_rule_num; ++i)
            {
                dup_rule_inst_pool_ptr[i] = RULE_CTRL_IN_Priv_CreateRuleInstance(RULE_TYPE_INST_RULE);
                assert(RULE_TYPE_INST_RULE == dup_rule_inst_pool_ptr[i].type);
            }

            result = RULE_CTRL_SetPolicyMap(ifindex, direction, policy_map_index, TRUE);
            assert(RULE_TYPE_OK != result);

            for (i = 0; i < TOTAL_NUMBER_OF_RULE_INSTANCE - require_rule_num; ++i)
            {
                assert(RULE_TYPE_INST_RULE == dup_rule_inst_pool_ptr[i].type);

                RULE_CTRL_IN_Priv_DestroyRuleInstance(dup_rule_inst_pool_ptr[i]);
                dup_rule_inst_pool_ptr[i].type = RULE_TYPE_NIL;
            }

            RULE_CTRL_UT_Proc_Validate_Rule();
        }
    }

    free(dup_rule_inst_pool_ptr);

    return 0;
}

int
RULE_CTRL_UT_Set_QoS_Policy_Map_With_Match_All_Class_Map_For_Undo_Out_Of_Rule_Instance()
{
    enum
    {
        MAX_IFINDEX = 3,
#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION = RULE_TYPE_OUTBOUND,
#else
        MAX_DIRECTION = RULE_TYPE_INBOUND,
#endif
        TOTAL_NUMBER_OF_RULE_INSTANCE = _countof(shmem_data_p->_rule_inst_pool_buf),
    };

    const char *policy_map_name = "p1";

    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    UI32_T policy_map_index;
    RULE_TYPE_PolicyMap_T policy_map;

    RULE_TYPE_SHM_POINTER_T *dup_rule_inst_pool_ptr;
    UI32_T i;

    dup_rule_inst_pool_ptr = calloc(sizeof(RULE_TYPE_SHM_POINTER_T), TOTAL_NUMBER_OF_RULE_INSTANCE);
    assert(NULL != dup_rule_inst_pool_ptr);

    RULE_CTRL_UT_Proc_Create_Policy_Match_All_Class_Map_With_Match_ACL_MF(policy_map_name);

    result = RULE_OM_GetPolicyMapIdByName(policy_map_name, &policy_map_index);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetPolicyMap(policy_map_index, &policy_map);
    assert(result == RULE_TYPE_OK);

    for (ifindex = 1; ifindex <= MAX_IFINDEX; ++ifindex)
    {
        for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
        {
            UI32_T px;
            UI32_T require_rule_num = 0;

            //
            // Calculate the number of rule required by policy-map
            //
            for (px = 0; px < policy_map.element_count; ++ px)
            {
                UI32_T policy_element_index = policy_map.policy_map_element_index_list[px]; //0];

                RULE_TYPE_PolicyElement_T   policy_element;
                RULE_TYPE_ClassMap_T        class_map;

                assert(0 < policy_map.element_count);

                result = RULE_OM_GetPolicyMapElement(policy_element_index, &policy_element);
                assert(RULE_TYPE_OK == result);

                result = RULE_OM_GetClassMap(policy_element.class_map_index, &class_map);
                assert(RULE_TYPE_OK == result);

                assert(RULE_TYPE_CLASS_MAP_MATCH_ALL == class_map.class_map_match_type);

                {
                    UI32_T  agg_acl_index;
                    RULE_TYPE_Acl_T acl_entry;

                    result = RULE_OM_BuildMatchAllClassMapRule(policy_element.class_map_index, &agg_acl_index);
                    assert(RULE_TYPE_OK == result);

                    result = RULE_OM_GetAclByIndex(agg_acl_index, &acl_entry);
                    assert(RULE_TYPE_OK == result);

                    require_rule_num += acl_entry.ace_count;
                }
            }

            assert(0 < require_rule_num);
            //
            // It will cause last class-map failed to bind port
            //
            require_rule_num -= 1;


            assert(require_rule_num <= TOTAL_NUMBER_OF_RULE_INSTANCE);
            for (i = 0; i < TOTAL_NUMBER_OF_RULE_INSTANCE - require_rule_num; ++i)
            {
                dup_rule_inst_pool_ptr[i] = RULE_CTRL_IN_Priv_CreateRuleInstance(RULE_TYPE_INST_RULE);
                assert(RULE_TYPE_INST_RULE == dup_rule_inst_pool_ptr[i].type);
            }

            result = RULE_CTRL_SetPolicyMap(ifindex, direction, policy_map_index, TRUE);
            assert(RULE_TYPE_OK != result);

            for (i = 0; i < TOTAL_NUMBER_OF_RULE_INSTANCE - require_rule_num; ++i)
            {
                assert(RULE_TYPE_INST_RULE == dup_rule_inst_pool_ptr[i].type);

                RULE_CTRL_IN_Priv_DestroyRuleInstance(dup_rule_inst_pool_ptr[i]);
                dup_rule_inst_pool_ptr[i].type = RULE_TYPE_NIL;
            }

            RULE_CTRL_UT_Proc_Validate_Rule();
        }
    }

    free(dup_rule_inst_pool_ptr);

    return 0;
}

int
RULE_CTRL_UT_Set_QoS_Policy_Map_For_Undo_Out_Of_Rule_Instance_Check_Qos_Remark_Entry()
{
    enum
    {
        MAX_IFINDEX = 3,
        MAX_DIRECTION = RULE_TYPE_INBOUND,
        TOTAL_NUMBER_OF_RULE_INSTANCE = _countof(shmem_data_p->_rule_inst_pool_buf),
    };

    const char *policy_map_name = "p1";
    RULE_TYPE_MatchType_T match_type = RULE_TYPE_CLASS_MAP_MATCH_ANY;

    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    UI32_T policy_map_index;
    RULE_TYPE_PolicyMap_T policy_map;

    RULE_TYPE_SHM_POINTER_T *dup_rule_inst_pool_ptr;
    UI32_T i;

    dup_rule_inst_pool_ptr = calloc(sizeof(RULE_TYPE_SHM_POINTER_T), TOTAL_NUMBER_OF_RULE_INSTANCE);
    assert(NULL != dup_rule_inst_pool_ptr);

    RULE_CTRL_UT_Proc_Create_Policy_Class_Map_With_Match_MF_ACE_Ingress_Only(policy_map_name, match_type);

    result = RULE_OM_GetPolicyMapIdByName(policy_map_name, &policy_map_index);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetPolicyMap(policy_map_index, &policy_map);
    assert(result == RULE_TYPE_OK);

    for (ifindex = 1; ifindex <= MAX_IFINDEX; ++ifindex)
    {
        for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
        {
            //
            // Assume all class map have the same rule number
            //
            UI32_T policy_element_index = policy_map.policy_map_element_index_list[0];

            RULE_TYPE_PolicyElement_T   policy_element;
            RULE_TYPE_ClassMap_T        class_map;

            UI32_T require_rule_num;

            assert(0 < policy_map.element_count);

            result = RULE_OM_GetPolicyMapElement(policy_element_index, &policy_element);
            assert(RULE_TYPE_OK == result);

            result = RULE_OM_GetClassMap(policy_element.class_map_index, &class_map);
            assert(RULE_TYPE_OK == result);

            require_rule_num = policy_map.element_count * class_map.class_element_count;

            //
            // It will cause last class-map failed to bind port
            //
            require_rule_num -= 1;

            assert(require_rule_num <= TOTAL_NUMBER_OF_RULE_INSTANCE);
            for (i = 0; i < TOTAL_NUMBER_OF_RULE_INSTANCE - require_rule_num; ++i)
            {
                dup_rule_inst_pool_ptr[i] = RULE_CTRL_IN_Priv_CreateRuleInstance(RULE_TYPE_INST_RULE);
                assert(RULE_TYPE_INST_RULE == dup_rule_inst_pool_ptr[i].type);
            }

            result = RULE_CTRL_SetPolicyMap(ifindex, direction, policy_map_index, TRUE);
            assert(RULE_TYPE_OK != result);

            for (i = 0; i < TOTAL_NUMBER_OF_RULE_INSTANCE - require_rule_num; ++i)
            {
                assert(RULE_TYPE_INST_RULE == dup_rule_inst_pool_ptr[i].type);

                RULE_CTRL_IN_Priv_DestroyRuleInstance(dup_rule_inst_pool_ptr[i]);
                dup_rule_inst_pool_ptr[i].type = RULE_TYPE_NIL;
            }

            RULE_CTRL_UT_Proc_Validate_Rule();
        }
    }

    free(dup_rule_inst_pool_ptr);

    return 0;
}

int
RULE_CTRL_UT_Set_QoS_With_Modifying_Match_Cond_Of_Class_Map_On_Fly()
{
    enum
    {
        MIN_IFINDEX         = 1,
        MAX_IFINDEX         = 3,

        ACL_TYPE            = RULE_TYPE_MAC_ACL,
        ACE_TYPE            = RULE_TYPE_MAC_ACL,

#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION       = RULE_TYPE_OUTBOUND,
#else
        MAX_DIRECTION       = RULE_TYPE_INBOUND,
#endif

        MAX_POLICY_ELEMENT  = 5,
        MAX_ACE_IN_ACL      = 5,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    const char *policy_map_name = "p1";
    UI32_T policy_map_index;

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    //
    // Bind Policy-map and ACL on port
    //
    {
        RULE_CTRL_UT_Proc_Create_Policy_Match_Any_Class_Map_With_Match_ACL_MF(policy_map_name);

        result = RULE_OM_GetPolicyMapIdByName(policy_map_name, &policy_map_index);
        assert(RULE_TYPE_OK == result);

        for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
        {
            for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
            {
                RULE_CTRL_UT_Proc_Bind_Policy_Map(ifindex, direction, policy_map_index);

                RULE_CTRL_UT_Proc_Validate_Rule();
            }
        }
    }

    //
    // Create new class-map
    //
    {
        const char                      *class_map_name = "c1";
        UI32_T                          class_map_index;
        UI32_T                          class_index;

        result = RULE_OM_GetClassMapIndexByName(class_map_name, &class_map_index);
        assert(RULE_TYPE_OK == result);

        //
        // Match ACL
        //
        RULE_CTRL_UT_Proc_Add_ACL_Into_Class_Map(class_map_index,
                                                 "a-new-1",
                                                 RULE_TYPE_IP_EXT_ACL,
                                                 MAX_ACE_IN_ACL,
                                                 RULE_CTRL_UT_COMPRESS_DEFAULT,
                                                 &class_index);

        result = RULE_CTRL_AddClassMapElementConfig(class_map_index, RULE_TYPE_CLASS_ACL, class_index);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();

        result = RULE_CTRL_RemoveClassMapElementConfig(class_map_index, RULE_TYPE_CLASS_ACL, class_index);
        assert(RULE_TYPE_OK == result);

        result = RULE_CTRL_AddClassMapElementConfig(class_map_index, RULE_TYPE_CLASS_ACL, class_index);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();

        //
        // Match MF
        //
        RULE_CTRL_UT_Proc_Add_MF_Into_Class_Map(class_map_index, RULE_TYPE_MF_VLAN, 5001, &class_index);

        result = RULE_CTRL_AddClassMapElementConfig(class_map_index, RULE_TYPE_CLASS_MF, class_index);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();

        result = RULE_CTRL_RemoveClassMapElementConfig(class_map_index, RULE_TYPE_CLASS_MF, class_index);
        assert(RULE_TYPE_OK == result);

        result = RULE_CTRL_AddClassMapElementConfig(class_map_index, RULE_TYPE_CLASS_MF, class_index);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();

        //
        // Match MF
        //
        RULE_CTRL_UT_Proc_Add_MF_Into_Class_Map(class_map_index, RULE_TYPE_MF_VLAN, 6001, &class_index);

        result = RULE_CTRL_AddClassMapElementConfig(class_map_index, RULE_TYPE_CLASS_MF, class_index);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();

        result = RULE_CTRL_RemoveClassMapElementConfig(class_map_index, RULE_TYPE_CLASS_MF, class_index);
        assert(RULE_TYPE_OK == result);

        result = RULE_CTRL_AddClassMapElementConfig(class_map_index, RULE_TYPE_CLASS_MF, class_index);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();

        //
        // Match MF
        //
        RULE_CTRL_UT_Proc_Add_MF_Into_Class_Map(class_map_index, RULE_TYPE_MF_VLAN, 7001, &class_index);

        result = RULE_CTRL_AddClassMapElementConfig(class_map_index, RULE_TYPE_CLASS_MF, class_index);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();

        result = RULE_CTRL_RemoveClassMapElementConfig(class_map_index, RULE_TYPE_CLASS_MF, class_index);
        assert(RULE_TYPE_OK == result);

        result = RULE_CTRL_AddClassMapElementConfig(class_map_index, RULE_TYPE_CLASS_MF, class_index);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();

        //
        // Match ACL
        //
        RULE_CTRL_UT_Proc_Add_ACL_Into_Class_Map(class_map_index,
                                                 "a-new-2",
                                                 RULE_TYPE_IP_EXT_ACL,
                                                 MAX_ACE_IN_ACL,
                                                 RULE_CTRL_UT_COMPRESS_DEFAULT,
                                                 &class_index);

        result = RULE_CTRL_AddClassMapElementConfig(class_map_index, RULE_TYPE_CLASS_ACL, class_index);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();

        result = RULE_CTRL_RemoveClassMapElementConfig(class_map_index, RULE_TYPE_CLASS_ACL, class_index);
        assert(RULE_TYPE_OK == result);

        result = RULE_CTRL_AddClassMapElementConfig(class_map_index, RULE_TYPE_CLASS_ACL, class_index);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();

        //
        // Match MF
        //
        RULE_CTRL_UT_Proc_Add_MF_Into_Class_Map(class_map_index, RULE_TYPE_MF_DSCP, 43, &class_index);

        result = RULE_CTRL_AddClassMapElementConfig(class_map_index, RULE_TYPE_CLASS_MF, class_index);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();

        result = RULE_CTRL_RemoveClassMapElementConfig(class_map_index, RULE_TYPE_CLASS_MF, class_index);
        assert(RULE_TYPE_OK == result);

        result = RULE_CTRL_AddClassMapElementConfig(class_map_index, RULE_TYPE_CLASS_MF, class_index);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();
    }

    return 0;
}

int
RULE_CTRL_UT_Set_QoS_With_Modifying_Match_Cond_Of_Class_Map_On_Fly_Undo()
{
    enum
    {
        MIN_IFINDEX         = 1,
        MAX_IFINDEX         = 3,

        ACL_TYPE            = RULE_TYPE_MAC_ACL,
        ACE_TYPE            = RULE_TYPE_MAC_ACL,

#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION       = RULE_TYPE_OUTBOUND,
#else
        MAX_DIRECTION       = RULE_TYPE_INBOUND,
#endif

        MAX_POLICY_ELEMENT  = 5,
        MAX_ACE_IN_ACL      = SYS_ADPT_MAX_NBRS_OF_ACE / 2,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    const char *policy_map_name = "p1";
    UI32_T policy_map_index;

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    //
    // Bind Policy-map and ACL on port
    //
    {
        RULE_CTRL_UT_Proc_Create_Policy_Match_Any_Class_Map_With_Match_ACL_MF(policy_map_name);

        result = RULE_OM_GetPolicyMapIdByName(policy_map_name, &policy_map_index);
        assert(RULE_TYPE_OK == result);

        for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
        {
            for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
            {
                RULE_CTRL_UT_Proc_Bind_Policy_Map(ifindex, direction, policy_map_index);

                RULE_CTRL_UT_Proc_Validate_Rule();
            }
        }
    }

    //
    // Create new class-map
    //
    {
        const char                      *class_map_name = "c1";
        UI32_T                          class_map_index;
        UI32_T                          class_index;
        UI32_T                          i;

        result = RULE_OM_GetClassMapIndexByName(class_map_name, &class_map_index);
        assert(RULE_TYPE_OK == result);

        for (i = 0; ; ++ i)
        {
            char acl_name[SYS_ADPT_DIFFSERV_MAX_NAME_LENGTH];

            sprintf(acl_name, "a-new-%lu", i);

            //
            // Match ACL
            //
            RULE_CTRL_UT_Proc_Add_ACL_Into_Class_Map(class_map_index,
                                                     acl_name,
                                                     RULE_TYPE_IP_EXT_ACL,
                                                     MAX_ACE_IN_ACL,
                                                     RULE_CTRL_UT_COMPRESS_DISABLE,
                                                     &class_index);

            result = RULE_CTRL_AddClassMapElementConfig(class_map_index, RULE_TYPE_CLASS_ACL, class_index);

            if (RULE_TYPE_OK != result)
            {
                result = RULE_OM_RemoveClassMapElementByAclIndex(class_map_index, class_index);
                assert(RULE_TYPE_OK == result);

                RULE_CTRL_UT_Proc_Validate_Rule();
                break;
            }

            //
            // Match MF
            //
            RULE_CTRL_UT_Proc_Add_MF_Into_Class_Map(class_map_index, RULE_TYPE_MF_VLAN, 5000 + i, &class_index);

            result = RULE_CTRL_AddClassMapElementConfig(class_map_index, RULE_TYPE_CLASS_MF, class_index);

            if (RULE_TYPE_OK != result)
            {
                result = RULE_OM_RemoveClassMapElementByMfIndex(class_map_index, class_index);
                assert(RULE_TYPE_OK == result);

                RULE_CTRL_UT_Proc_Validate_Rule();
                break;
            }

        }
    }

    return 0;
}

int
RULE_CTRL_UT_Set_QoS_With_Modifying_ACE_On_Fly()
{
    enum
    {
        MIN_IFINDEX         = 1,
        MAX_IFINDEX         = 3,

        ACL_TYPE            = RULE_TYPE_MAC_ACL,
        ACE_TYPE            = RULE_TYPE_MAC_ACL,

#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION       = RULE_TYPE_OUTBOUND,
#else
        MAX_DIRECTION       = RULE_TYPE_INBOUND,
#endif

        MAX_POLICY_ELEMENT  = 5,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    const char *acl_name = "a2";
    UI32_T acl_index;

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    //
    // Bind Policy-map and ACL on port
    //
    {
        const char *policy_map_name = "p1";
        UI32_T policy_map_index;

        RULE_CTRL_UT_Proc_Create_Policy_Match_Any_Class_Map_With_Match_ACL_MF(policy_map_name);
        result = RULE_OM_GetAclIdByName(acl_name, &acl_index);

        result = RULE_OM_GetPolicyMapIdByName(policy_map_name, &policy_map_index);
        assert(RULE_TYPE_OK == result);

        for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
        {
            for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
            {
                UI16_T time_range_index = RULE_TYPE_UNDEF_TIME_RANGE;
                RULE_TYPE_COUNTER_ENABLE_T counter_enable = RULE_TYPE_COUNTER_ENABLE;

                RULE_CTRL_UT_Proc_Bind_Policy_Map(ifindex, direction, policy_map_index);

                if (RULE_TYPE_INBOUND == direction)
                {
                    result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                                        acl_index,
                                                        time_range_index,
                                                        counter_enable);
                    assert(RULE_TYPE_OK == result);
                }

                RULE_CTRL_UT_Proc_Validate_Rule();
            }
        }
    }

    //
    // Add on Fly
    //
    {
        RULE_TYPE_Acl_T acl_entry;
        RULE_TYPE_Ace_Entry_T ace_entry;

        BOOL_T is_add;

        result = RULE_OM_GetAclByIndex(acl_index, &acl_entry);
        assert(RULE_TYPE_OK == result);

        ace_entry.ace_type = acl_entry.acl_type;
        result = RULE_OM_InitAce(&ace_entry);
        assert(result == RULE_TYPE_OK);

        ace_entry.access = RULE_TYPE_ACE_PERMIT;

        result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
        assert(RULE_TYPE_OK == result);

        //
        //

        is_add = TRUE;
        result = RULE_CTRL_SetAce(acl_index, &ace_entry, is_add);

        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();

        is_add = FALSE;
        result = RULE_CTRL_SetAce(acl_index, &ace_entry, is_add);
        assert(RULE_TYPE_OK == result);

        result = RULE_OM_DelAceFromAcl(acl_index, ace_entry.ace_type, &ace_entry);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();
    }

    return 0;
}

int
RULE_CTRL_UT_Set_QoS_With_Modifying_Meter_On_Fly()
{
    enum
    {
        MAX_UNIT            = 1,
        MAX_PORT            = 3,

        MIN_IFINDEX         = 1,
        MAX_IFINDEX         = 3,

        MIN_DIRECTION       = RULE_TYPE_INBOUND,

#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION       = RULE_TYPE_OUTBOUND,
#else
        MAX_DIRECTION       = RULE_TYPE_INBOUND,
#endif

        ACL_TYPE            = RULE_TYPE_MAC_ACL,
        ACE_TYPE            = RULE_TYPE_MAC_ACL,

        MAX_POLICY_ELEMENT  = 5,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    {
        const char *policy_map_name = "p1";
        UI32_T policy_map_index;

        RULE_CTRL_UT_Proc_Create_Policy_Match_Any_Class_Map_With_Match_ACL_MF(policy_map_name);

        result = RULE_OM_GetPolicyMapIdByName(policy_map_name, &policy_map_index);
        assert(RULE_TYPE_OK == result);

        for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
        {
            for (direction = MIN_DIRECTION; direction <= MAX_DIRECTION; ++ direction)
            {
                RULE_CTRL_UT_Proc_Bind_Policy_Map(ifindex, direction, policy_map_index);
                RULE_CTRL_UT_Proc_Validate_Rule();
            }
        }

        //
        // Update meter config
        //
        {
            const char *class_map_name = "c2";
            UI32_T class_map_index;
            RULE_TYPE_TBParamEntry_T meter_entry;

            result = RULE_OM_GetClassMapIndexByName(class_map_name, &class_map_index);
            assert(RULE_TYPE_OK == result);

            memset(&meter_entry, 0, sizeof(meter_entry));
            meter_entry.meter_model = RULE_TYPE_METER_MODE_TRTCM_COLOR_AWARE;
            meter_entry.rate = 4000;
            meter_entry.burst_size = 5000;
            meter_entry.peak_rate = 6000;
            meter_entry.peak_burst_size = 7000;

            result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter_entry);
            assert(RULE_TYPE_OK == result);

            result = RULE_CTRL_UpdateMeterConfig(policy_map_index, class_map_index);
            assert(RULE_TYPE_OK == result);

            RULE_CTRL_UT_Proc_Validate_Rule();

            memset(&meter_entry, 0, sizeof(meter_entry));
            meter_entry.meter_model = RULE_TYPE_METER_MODE_TRTCM_COLOR_BLIND;
            meter_entry.rate = 4100;
            meter_entry.burst_size = 5100;
            meter_entry.peak_rate = 6100;
            meter_entry.peak_burst_size = 7100;

            result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter_entry);
            assert(RULE_TYPE_OK == result);

            result = RULE_CTRL_UpdateMeterConfig(policy_map_index, class_map_index);
            assert(RULE_TYPE_OK == result);

            RULE_CTRL_UT_Proc_Validate_Rule();

            memset(&meter_entry, 0, sizeof(meter_entry));
            meter_entry.meter_model = RULE_TYPE_METER_MODE_SRTCM_COLOR_AWARE;
            meter_entry.rate = 4200;
            meter_entry.burst_size = 5200;
            meter_entry.peak_rate = 6200;
            meter_entry.peak_burst_size = 7200;

            result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter_entry);
            assert(RULE_TYPE_OK == result);

            result = RULE_CTRL_UpdateMeterConfig(policy_map_index, class_map_index);
            assert(RULE_TYPE_OK == result);

            RULE_CTRL_UT_Proc_Validate_Rule();

            memset(&meter_entry, 0, sizeof(meter_entry));
            meter_entry.meter_model = RULE_TYPE_METER_MODE_SRTCM_COLOR_BLIND;
            meter_entry.rate = 4300;
            meter_entry.burst_size = 5300;
            meter_entry.peak_rate = 6300;
            meter_entry.peak_burst_size = 7300;

            result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter_entry);
            assert(RULE_TYPE_OK == result);

            result = RULE_CTRL_UpdateMeterConfig(policy_map_index, class_map_index);
            assert(RULE_TYPE_OK == result);

            RULE_CTRL_UT_Proc_Validate_Rule();

            memset(&meter_entry, 0, sizeof(meter_entry));
            meter_entry.meter_model = RULE_TYPE_METER_MODE_FLOW;
            meter_entry.rate = 4400;
            meter_entry.burst_size = 5400;

            result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter_entry);
            assert(RULE_TYPE_OK == result);

            result = RULE_CTRL_UpdateMeterConfig(policy_map_index, class_map_index);
            assert(RULE_TYPE_OK == result);

            RULE_CTRL_UT_Proc_Validate_Rule();

            memset(&meter_entry, 0, sizeof(meter_entry));
            meter_entry.meter_model = RULE_TYPE_METER_MODE_TRTCM_COLOR_AWARE;
            meter_entry.rate = 4500;
            meter_entry.burst_size = 5500;
            meter_entry.peak_rate = 6500;
            meter_entry.peak_burst_size = 7500;

            result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter_entry);
            assert(RULE_TYPE_OK == result);

            result = RULE_CTRL_UpdateMeterConfig(policy_map_index, class_map_index);
            assert(RULE_TYPE_OK == result);

            RULE_CTRL_UT_Proc_Validate_Rule();
        }

        //
        // Remove meter config
        //
        {
            const char *class_map_name = "c2";
            UI32_T class_map_index;

            result = RULE_OM_GetClassMapIndexByName(class_map_name, &class_map_index);
            assert(RULE_TYPE_OK == result);

            result = RULE_OM_Remove_MeterEntry(policy_map_index, class_map_index);
            assert(RULE_TYPE_OK == result);

            result = RULE_CTRL_RemoveMeterConfig(policy_map_index, class_map_index);
            assert(RULE_TYPE_OK == result);

            RULE_CTRL_UT_Proc_Validate_Rule();
        }

        //
        // Add meter config
        //
        {
            const char *class_map_name = "c2";
            UI32_T class_map_index;
            RULE_TYPE_TBParamEntry_T meter_entry;

            result = RULE_OM_GetClassMapIndexByName(class_map_name, &class_map_index);
            assert(RULE_TYPE_OK == result);

            memset(&meter_entry, 0, sizeof(meter_entry));
            meter_entry.meter_model = RULE_TYPE_METER_MODE_TRTCM_COLOR_AWARE;
            meter_entry.rate = 4000;
            meter_entry.burst_size = 5000;
            meter_entry.peak_rate = 6000;
            meter_entry.peak_burst_size = 7000;

            result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter_entry);
            assert(RULE_TYPE_OK == result);

            result = RULE_CTRL_AddMeterConfig(policy_map_index, class_map_index);
            assert(RULE_TYPE_OK == result);

            RULE_CTRL_UT_Proc_Validate_Rule();
        }
    }

    return 0;
}

int RULE_CTRL_UT_Set_QoS_With_Modifying_Action_On_Fly()
{
    enum
    {
        MIN_IFINDEX         = 1,
        MAX_IFINDEX         = 3,

        MIN_DIRECTION       = RULE_TYPE_INBOUND,

#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION       = RULE_TYPE_OUTBOUND,
#else
        MAX_DIRECTION       = RULE_TYPE_INBOUND,
#endif

        ACL_TYPE            = RULE_TYPE_MAC_ACL,
        ACE_TYPE            = RULE_TYPE_MAC_ACL,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    {
        const char *policy_map_name = "p1";
        UI32_T policy_map_index;

        RULE_CTRL_UT_Proc_Create_Policy_Match_Any_Class_Map_With_Match_ACL_MF(policy_map_name);

        result = RULE_OM_GetPolicyMapIdByName(policy_map_name, &policy_map_index);
        assert(RULE_TYPE_OK == result);

        for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
        {
            for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
            {
                RULE_CTRL_UT_Proc_Bind_Policy_Map(ifindex, direction, policy_map_index);
                RULE_CTRL_UT_Proc_Validate_Rule();
            }
        }

        //
        // Update action config
        //
        {
            const char *class_map_name = "c2";
            UI32_T class_map_index;

            result = RULE_OM_GetClassMapIndexByName(class_map_name, &class_map_index);
            assert(RULE_TYPE_OK == result);

            result = RULE_CTRL_UpdateActionConfig(policy_map_index, class_map_index);
            assert(RULE_TYPE_OK == result);

            RULE_CTRL_UT_Proc_Validate_Rule();
        }

        {
            const char *class_map_name = "c1";
            UI32_T class_map_index;

            result = RULE_OM_GetClassMapIndexByName(class_map_name, &class_map_index);
            assert(RULE_TYPE_OK == result);

            result = RULE_CTRL_UpdateActionConfig(policy_map_index, class_map_index);
            assert(RULE_TYPE_OK == result);

            RULE_CTRL_UT_Proc_Validate_Rule();
        }
    }

    return 0;
}

BOOL_T
RULE_CTRL_UT_Proc_Is_Active_Rule_Instance(
    const RULE_TYPE_INSTANCE_PTR_T in,
    void *cookie)
{
    if (RULE_CTRL_IS_RULE_INSTANCE_TYPE(in->type))
    {
        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;

        rule_inst_p = (RULE_TYPE_RULE_INSTANCE_PTR_T)in;

        if (TRUE == rule_inst_p->active)
        {
            return TRUE;
        }
    }

    return FALSE;
}

#if 0 /* FIXME: time range */
int
RULE_CTRL_UT_Time_Based_ACL_Apply_ACE_All_Use_Same_Time_Range()
{
#if (SYS_CPNT_TIME_BASED_ACL == TRUE)
    enum
    {
        MAX_UNIT            = 1,
        MAX_PORT            = 5,
#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION       = RULE_TYPE_INBOUND,
#else
        MAX_DIRECTION       = RULE_TYPE_OUTBOUND,
#endif

        ACL_TYPE            = RULE_TYPE_MAC_ACL,
        ACE_TYPE            = RULE_TYPE_MAC_ACL,

        MAX_POLICY_ELEMENT  = 5,
        MATCH_TYPE          = RULE_TYPE_CLASS_MAP_MATCH_ANY,
    };

    UI32_T                  unit;
    UI32_T                  port;
    UI32_T                  direction;

    const char *time_range_name = "t1";
    UI16_T time_range_index;

    RULE_TYPE_TIME_ACL_PERIODIC_TIME_T periodic;

    const char *acl_name = "a1";
    UI32_T acl_index;

    RULE_TYPE_Ace_Entry_T ace_entry;
    UI32_T active_ace_count = 0;

    RULE_TYPE_RETURN_TYPE_T result;
    BOOL_T                  b_result;

    //
    // Create Time-Range
    //
    result = RULE_OM_CreateTimeRangeEntry(time_range_name, &time_range_index);
    assert(RULE_TYPE_OK == result);

    memset(&periodic, 0, sizeof(periodic));

    periodic.start_type_of_wk   = RULE_TYPE_TIME_RANGE_TYPE_OF_WK_DAILY;
    periodic.end_type_of_wk     = RULE_TYPE_TIME_RANGE_TYPE_OF_WK_DAILY;
    periodic.start_hour         = 8;
    periodic.end_hour           = 12;

    result = RULE_OM_SetTimeRangePeriodic(time_range_index, &periodic);
    assert(RULE_TYPE_OK == result);

    //
    // Create ACL
    //
    result = RULE_OM_CreateAcl(acl_name, ACL_TYPE);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetAclIdByName(acl_name, &acl_index);
    assert(RULE_TYPE_OK == result);

    //
    // One
    ace_entry.ace_type = ACE_TYPE;
    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.u.mac.aceSourceMacAddr[5] = 0x01;
    memset(ace_entry.u.mac.aceSourceMacAddrBitmask, 0xff, sizeof(ace_entry.u.mac.aceSourceMacAddrBitmask));

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    active_ace_count ++;

    //
    // Two
    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.u.mac.aceSourceMacAddr[5] = 0x02;
    memset(ace_entry.u.mac.aceSourceMacAddrBitmask, 0xff, sizeof(ace_entry.u.mac.aceSourceMacAddrBitmask));

    ace_entry.time_range_index = time_range_index;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // Three
    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.u.mac.aceSourceMacAddr[5] = 0x03;
    memset(ace_entry.u.mac.aceSourceMacAddrBitmask, 0xff, sizeof(ace_entry.u.mac.aceSourceMacAddrBitmask));

    ace_entry.time_range_index = time_range_index;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // Four
    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.u.mac.aceSourceMacAddr[5] = 0x04;
    memset(ace_entry.u.mac.aceSourceMacAddrBitmask, 0xff, sizeof(ace_entry.u.mac.aceSourceMacAddrBitmask));

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    active_ace_count ++;

    //
    // Five
    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.u.mac.aceSourceMacAddr[5] = 0x05;
    memset(ace_entry.u.mac.aceSourceMacAddrBitmask, 0xff, sizeof(ace_entry.u.mac.aceSourceMacAddrBitmask));

    ace_entry.time_range_index = time_range_index;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // Set time out of time-range
    //
    {
        int year, month, day, hour, minute, second;

        year    = 2001;
        month   = 1;
        day     = 1;

        assert(0 < periodic.start_hour);
        hour    = periodic.start_hour - 1;

        minute  = 0;
        second  = 0;

        b_result = SYS_TIME_SetRealTimeClock(year, month, day, hour, minute, second);
        assert(TRUE == b_result);
    }

    //
    // Update OM
    //
    RULE_CTRL_LocalTimeBasedACLProcessTimerEvent();

    for (unit = 1; unit <= MAX_UNIT; ++unit)
    {
        for (port = 1; port <= MAX_PORT; ++ port)
        {
            UI32_T ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);

            for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
            {
                RULE_TYPE_INTERFACE_INFO_T interface;

                UI16_T time_range_index = RULE_TYPE_UNDEF_TIME_RANGE;
                RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;

                memset(&interface, 0, sizeof(interface));
                result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
                assert(RULE_TYPE_OK == result);
                interface.direction = direction;

                result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                                    acl_index,
                                                    time_range_index,
                                                    counter_enable);
                assert(RULE_TYPE_OK == result);

                {
                    RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;

                    acl_inst_p = RULE_CTRL_Priv_GetAclInstanceById(&interface, acl_index);
                    assert(NULL != acl_inst_p);

                    assert(active_ace_count == RULE_CTRL_IN_Priv_CountIf((RULE_TYPE_INSTANCE_PTR_T) acl_inst_p,
                                                                         RULE_CTRL_UT_Proc_Is_Active_Rule_Instance,
                                                                         NULL));
                }
            }
        }
    }

    //
    // Set time in time-range
    //
    {
        int year, month, day, hour, minute, second;

        year    = 2001;
        month   = 1;
        day     = 1;

        hour    = periodic.start_hour;

        minute  = 0;
        second  = 0;

        b_result = SYS_TIME_SetRealTimeClock(year, month, day, hour, minute, second);
        assert(TRUE == b_result);
    }

    RULE_CTRL_LocalTimeBasedACLProcessTimerEvent();

    for (unit = 1; unit <= MAX_UNIT; ++unit)
    {
        for (port = 1; port <= MAX_PORT; ++ port)
        {
            UI32_T ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);

            for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
            {
                RULE_TYPE_INTERFACE_INFO_T interface;

                memset(&interface, 0, sizeof(interface));
                result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
                assert(RULE_TYPE_OK == result);
                interface.direction = direction;

                {
                    RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;
                    RULE_TYPE_Acl_T acl_entry;

                    //
                    // --== Duplicated code start
                    //
                    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

                    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

                    RULE_CTRL_INSTANCE_TYPE_ID_T param;

                    if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
                    assert(NULL != if_entry_p);

                    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                              &if_class_obj);

                    memset(&param, 0, sizeof(param));

                    param.type = RULE_TYPE_INST_ACL;

                    acl_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                                RULE_CTRL_Priv_IsClassInstanceMatchType,
                                                                                                &param);
                    //
                    // --== End of duplicated code
                    //

                    assert(NULL != acl_inst_p);

                    result = RULE_OM_GetAclByIndex(acl_inst_p->acl_id, &acl_entry);
                    assert(RULE_TYPE_OK == result);

                    assert(acl_entry.ace_count == RULE_CTRL_IN_Priv_CountIf((RULE_TYPE_INSTANCE_PTR_T)acl_inst_p,
                                                                            RULE_CTRL_UT_Proc_Is_Active_Rule_Instance,
                                                                            NULL));
                }

            }
        }
    }

    RULE_CTRL_UT_Proc_Validate_Rule();

#endif // SYS_CPNT_TIME_BASED_ACL

    return 0;
}

int
RULE_CTRL_UT_Time_Based_ACL_Remove_ACE_All_Use_Same_Time_Range()
{
#if (SYS_CPNT_TIME_BASED_ACL == TRUE)
    enum
    {
        MAX_UNIT            = 1,
        MAX_PORT            = 5,
#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION       = RULE_TYPE_INBOUND,
#else
        MAX_DIRECTION       = RULE_TYPE_OUTBOUND,
#endif

        ACL_TYPE            = RULE_TYPE_MAC_ACL,
        ACE_TYPE            = RULE_TYPE_MAC_ACL,

        MAX_POLICY_ELEMENT  = 5,
        MATCH_TYPE          = RULE_TYPE_CLASS_MAP_MATCH_ANY,
    };

    UI32_T                  unit;
    UI32_T                  port;
    UI32_T                  direction;

    const char *time_range_name = "t1";
    UI16_T time_range_index;

    RULE_TYPE_TIME_ACL_PERIODIC_TIME_T periodic;

    const char *acl_name = "a1";
    UI32_T acl_index;

    RULE_TYPE_Ace_Entry_T ace_entry;
    UI32_T active_ace_count = 0;

    RULE_TYPE_RETURN_TYPE_T result;
    BOOL_T                  b_result;

    //
    // Create Time-Range
    //
    result = RULE_OM_CreateTimeRangeEntry(time_range_name, &time_range_index);
    assert(RULE_TYPE_OK == result);

    memset(&periodic, 0, sizeof(periodic));

    periodic.start_type_of_wk   = RULE_TYPE_TIME_RANGE_TYPE_OF_WK_DAILY;
    periodic.end_type_of_wk     = RULE_TYPE_TIME_RANGE_TYPE_OF_WK_DAILY;
    periodic.start_hour         = 8;
    periodic.end_hour           = 12;

    result = RULE_OM_SetTimeRangePeriodic(time_range_index, &periodic);
    assert(RULE_TYPE_OK == result);

    //
    // Create ACL
    //
    result = RULE_OM_CreateAcl(acl_name, ACL_TYPE);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetAclIdByName(acl_name, &acl_index);
    assert(RULE_TYPE_OK == result);

    //
    // One
    ace_entry.ace_type = ACE_TYPE;
    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.u.mac.aceSourceMacAddr[5] = 0x01;
    memset(ace_entry.u.mac.aceSourceMacAddrBitmask, 0xff, sizeof(ace_entry.u.mac.aceSourceMacAddrBitmask));

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    active_ace_count ++;

    //
    // Two
    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.u.mac.aceSourceMacAddr[5] = 0x02;
    memset(ace_entry.u.mac.aceSourceMacAddrBitmask, 0xff, sizeof(ace_entry.u.mac.aceSourceMacAddrBitmask));

    ace_entry.time_range_index = time_range_index;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // Three
    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.u.mac.aceSourceMacAddr[5] = 0x03;
    memset(ace_entry.u.mac.aceSourceMacAddrBitmask, 0xff, sizeof(ace_entry.u.mac.aceSourceMacAddrBitmask));

    ace_entry.time_range_index = time_range_index;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // Four
    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.u.mac.aceSourceMacAddr[5] = 0x04;
    memset(ace_entry.u.mac.aceSourceMacAddrBitmask, 0xff, sizeof(ace_entry.u.mac.aceSourceMacAddrBitmask));

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    active_ace_count ++;

    //
    // Five
    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.u.mac.aceSourceMacAddr[5] = 0x05;
    memset(ace_entry.u.mac.aceSourceMacAddrBitmask, 0xff, sizeof(ace_entry.u.mac.aceSourceMacAddrBitmask));

    ace_entry.time_range_index = time_range_index;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // Set time in time-range
    //
    {
        int year, month, day, hour, minute, second;

        year    = 2001;
        month   = 1;
        day     = 1;
        hour    = periodic.start_hour;
        minute  = 0;
        second  = 0;

        b_result = SYS_TIME_SetRealTimeClock(year, month, day, hour, minute, second);
        assert(TRUE == b_result);
    }

    //
    // Update OM
    //
    RULE_CTRL_LocalTimeBasedACLProcessTimerEvent();

    for (unit = 1; unit <= MAX_UNIT; ++unit)
    {
        for (port = 1; port <= MAX_PORT; ++ port)
        {
            UI32_T ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);

            for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
            {
                RULE_TYPE_INTERFACE_INFO_T interface;

                UI16_T time_range_index = RULE_TYPE_UNDEF_TIME_RANGE;
                RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;

                memset(&interface, 0, sizeof(interface));
                result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
                assert(RULE_TYPE_OK == result);
                interface.direction = direction;

                result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                                    acl_index,
                                                    time_range_index,
                                                    counter_enable);
                assert(RULE_TYPE_OK == result);

                {
                    RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;
                    RULE_TYPE_Acl_T acl_entry;

                    //
                    // --== Duplicated code start
                    //
                    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

                    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

                    RULE_CTRL_INSTANCE_TYPE_ID_T param;

                    if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
                    assert(NULL != if_entry_p);

                    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                              &if_class_obj);

                    memset(&param, 0, sizeof(param));

                    param.type = RULE_TYPE_INST_ACL;

                    acl_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                                RULE_CTRL_Priv_IsClassInstanceMatchType,
                                                                                                &param);
                    //
                    // --== End of duplicated code
                    //

                    assert(NULL != acl_inst_p);

                    result = RULE_OM_GetAclByIndex(acl_inst_p->acl_id, &acl_entry);
                    assert(RULE_TYPE_OK == result);

                    assert(acl_entry.ace_count == RULE_CTRL_IN_Priv_CountIf((RULE_TYPE_INSTANCE_PTR_T)acl_inst_p,
                                                                            RULE_CTRL_UT_Proc_Is_Active_Rule_Instance,
                                                                            NULL));
                }
            }
        }
    }

    //
    // Set time out of time-range
    //
    {
        int year, month, day, hour, minute, second;

        year    = 2001;
        month   = 1;
        day     = 1;

        assert(0 < periodic.start_hour);
        hour    = periodic.start_hour - 1;

        minute  = 0;
        second  = 0;

        b_result = SYS_TIME_SetRealTimeClock(year, month, day, hour, minute, second);
        assert(TRUE == b_result);
    }

    RULE_CTRL_LocalTimeBasedACLProcessTimerEvent();

    for (unit = 1; unit <= MAX_UNIT; ++unit)
    {
        for (port = 1; port <= MAX_PORT; ++ port)
        {
            UI32_T ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);

            for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
            {
                RULE_TYPE_INTERFACE_INFO_T interface;

                RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;

                memset(&interface, 0, sizeof(interface));
                result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
                assert(RULE_TYPE_OK == result);
                interface.direction = direction;

                acl_inst_p = RULE_CTRL_Priv_GetAclInstanceById(&interface, acl_index);

                assert(NULL != acl_inst_p);

                assert(active_ace_count == RULE_CTRL_IN_Priv_CountIf((RULE_TYPE_INSTANCE_PTR_T)acl_inst_p,
                                                                     RULE_CTRL_UT_Proc_Is_Active_Rule_Instance,
                                                                     NULL));
            }
        }
    }

    RULE_CTRL_UT_Proc_Validate_Rule();


#endif // SYS_CPNT_TIME_BASED_ACL

    return 0;
}

int
RULE_CTRL_UT_Time_Based_ACL_Apply_ACE_Use_Diff_Time_Range()
{
#if (SYS_CPNT_TIME_BASED_ACL == TRUE)
    enum
    {
        MAX_UNIT            = 1,
        MAX_PORT            = 5,
#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION       = RULE_TYPE_INBOUND,
#else
        MAX_DIRECTION       = RULE_TYPE_OUTBOUND,
#endif

        ACL_TYPE            = RULE_TYPE_MAC_ACL,
        ACE_TYPE            = RULE_TYPE_MAC_ACL,

        MAX_POLICY_ELEMENT  = 5,
        MATCH_TYPE          = RULE_TYPE_CLASS_MAP_MATCH_ANY,
    };

    UI32_T                  unit;
    UI32_T                  port;
    UI32_T                  direction;

    const char *time_range_name_1 = "every-day-at-8-12";
    UI16_T time_range_index_1;

    const char *time_range_name_2 = "every-day-at-10-14";
    UI16_T time_range_index_2;

    RULE_TYPE_TIME_ACL_PERIODIC_TIME_T periodic_1;
    RULE_TYPE_TIME_ACL_PERIODIC_TIME_T periodic_2;

    const char *acl_name = "a1";
    UI32_T acl_index;

    RULE_TYPE_Ace_Entry_T ace_entry;
    UI32_T active_ace_count = 0;

    RULE_TYPE_RETURN_TYPE_T result;
    BOOL_T                  b_result;

    //
    // Create Time-Range 1
    //
    result = RULE_OM_CreateTimeRangeEntry(time_range_name_1, &time_range_index_1);
    assert(RULE_TYPE_OK == result);

    memset(&periodic_1, 0, sizeof(periodic_1));

    periodic_1.start_type_of_wk   = RULE_TYPE_TIME_RANGE_TYPE_OF_WK_DAILY;
    periodic_1.end_type_of_wk     = RULE_TYPE_TIME_RANGE_TYPE_OF_WK_DAILY;
    periodic_1.start_hour         = 8;
    periodic_1.end_hour           = 12;

    result = RULE_OM_SetTimeRangePeriodic(time_range_index_1, &periodic_1);
    assert(RULE_TYPE_OK == result);

    //
    // Create Time-Range 2
    //
    result = RULE_OM_CreateTimeRangeEntry(time_range_name_2, &time_range_index_2);
    assert(RULE_TYPE_OK == result);

    memset(&periodic_2, 0, sizeof(periodic_2));

    periodic_2.start_type_of_wk   = RULE_TYPE_TIME_RANGE_TYPE_OF_WK_DAILY;
    periodic_2.end_type_of_wk     = RULE_TYPE_TIME_RANGE_TYPE_OF_WK_DAILY;
    periodic_2.start_hour         = 10;
    periodic_2.end_hour           = 14;

    result = RULE_OM_SetTimeRangePeriodic(time_range_index_2, &periodic_2);
    assert(RULE_TYPE_OK == result);

    //
    // Create ACL
    //
    result = RULE_OM_CreateAcl(acl_name, ACL_TYPE);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetAclIdByName(acl_name, &acl_index);
    assert(RULE_TYPE_OK == result);

    //
    // One
    ace_entry.ace_type = ACE_TYPE;
    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.u.mac.aceSourceMacAddr[5] = 0x01;
    memset(ace_entry.u.mac.aceSourceMacAddrBitmask, 0xff, sizeof(ace_entry.u.mac.aceSourceMacAddrBitmask));

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    active_ace_count ++;

    //
    // Two and Tree will not compress together because diff time range
    //

    //
    // Two
    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.u.mac.aceSourceMacAddr[5] = 0x02;
    memset(ace_entry.u.mac.aceSourceMacAddrBitmask, 0xff, sizeof(ace_entry.u.mac.aceSourceMacAddrBitmask));

    ace_entry.time_range_index = time_range_index_1;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // Three
    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.u.mac.aceSourceMacAddr[5] = 0x03;
    memset(ace_entry.u.mac.aceSourceMacAddrBitmask, 0xff, sizeof(ace_entry.u.mac.aceSourceMacAddrBitmask));

    ace_entry.time_range_index = time_range_index_2;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // Four
    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.u.mac.aceSourceMacAddr[5] = 0x04;
    memset(ace_entry.u.mac.aceSourceMacAddrBitmask, 0xff, sizeof(ace_entry.u.mac.aceSourceMacAddrBitmask));

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    active_ace_count ++;

    //
    // Five
    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.u.mac.aceSourceMacAddr[5] = 0x05; // 101
    memset(ace_entry.u.mac.aceSourceMacAddrBitmask, 0xff, sizeof(ace_entry.u.mac.aceSourceMacAddrBitmask));

    ace_entry.time_range_index = time_range_index_2;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // Six
    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.u.mac.aceSourceMacAddr[5] = 0x06; // 110
    memset(ace_entry.u.mac.aceSourceMacAddrBitmask, 0xff, sizeof(ace_entry.u.mac.aceSourceMacAddrBitmask));

    ace_entry.time_range_index = time_range_index_2;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // Seven
    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.u.mac.aceSourceMacAddr[5] = 0x07; // 111
    memset(ace_entry.u.mac.aceSourceMacAddrBitmask, 0xff, sizeof(ace_entry.u.mac.aceSourceMacAddrBitmask));

    ace_entry.time_range_index = time_range_index_2;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);


#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
    result = RULE_OM_RebuildAggregateAcl(acl_index);
    assert(RULE_TYPE_OK == result);

    {
        RULE_TYPE_Acl_T *acl_entry_p;

        acl_entry_p = RULE_OM_LocalGetAclByIndex(acl_index);
        assert(NULL != acl_entry_p);

        assert(TRUE == acl_entry_p->flag_aggregate_done);
        acl_index = acl_entry_p->aggregate_acl_index;
    }
#endif // SYS_CPNT_ACL_AUTO_COMPRESS_ACE

    for (unit = 1; unit <= MAX_UNIT; ++unit)
    {
        for (port = 1; port <= MAX_PORT; ++ port)
        {
            UI32_T ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);

            for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
            {
                RULE_TYPE_INTERFACE_INFO_T interface;

                UI16_T time_range_index = RULE_TYPE_UNDEF_TIME_RANGE;
                RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;

                memset(&interface, 0, sizeof(interface));
                result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
                assert(RULE_TYPE_OK == result);
                interface.direction = direction;

                result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                                    acl_index,
                                                    time_range_index,
                                                    counter_enable);
                assert(RULE_TYPE_OK == result);
            }
        }
    }

    {
        struct
        {
            int hour;
            UI32_T active_ace_count;
        } time_line[] =
        {
#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
            {0,  2},        // 1, 4
            {8,  3},        // 1, 4, 2
            {10, 6},        // 1, 4, 2, 3, 5, (6, 7)
            {14, 5},        // 1, 4, 3, 5, (6, 7)
            {15, 2},        // 1, 4
#else
            {0,  2},        // 1, 4
            {8,  3},        // 1, 4, 2
            {10, 7},        // 1, 4, 2, 3, 5, 6, 7
            {14, 6},        // 1, 4, 3, 5, 6, 7
            {15, 2},        // 1, 4
#endif
        };

        UI32_T i;

        for (i = 0; i < _countof(time_line); ++ i)
        {
            //
            // Set time in time-range
            //
            {
                int year, month, day, hour, minute, second;

                year    = 2001;
                month   = 1;
                day     = 1;

                hour    = time_line[i].hour;

                minute  = 0;
                second  = 0;

                b_result = SYS_TIME_SetRealTimeClock(year, month, day, hour, minute, second);
                assert(TRUE == b_result);
            }

            RULE_CTRL_LocalTimeBasedACLProcessTimerEvent();
            RULE_CTRL_UT_Proc_Validate_Rule();

            for (unit = 1; unit <= MAX_UNIT; ++unit)
            {
                for (port = 1; port <= MAX_PORT; ++ port)
                {
                    UI32_T ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);

                    for (direction = RULE_TYPE_INBOUND; direction <= MAX_DIRECTION; ++direction)
                    {
                        RULE_TYPE_INTERFACE_INFO_T interface;

                        memset(&interface, 0, sizeof(interface));
                        result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
                        assert(RULE_TYPE_OK == result);
                        interface.direction = direction;

                        {
                            RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;
                            RULE_TYPE_Acl_T acl_entry;

                            UI32_T active_rule_count;

                            //
                            // --== Duplicated code start
                            //
                            RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

                            RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

                            RULE_CTRL_INSTANCE_TYPE_ID_T param;

                            if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
                            assert(NULL != if_entry_p);

                            RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                                      &if_class_obj);

                            memset(&param, 0, sizeof(param));

                            param.type = RULE_TYPE_INST_ACL;

                            acl_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                                        RULE_CTRL_Priv_IsClassInstanceMatchType,
                                                                                                        &param);
                            //
                            // --== End of duplicated code
                            //

                            assert(NULL != acl_inst_p);

                            result = RULE_OM_GetAclByIndex(acl_inst_p->acl_id, &acl_entry);
                            assert(RULE_TYPE_OK == result);

                            active_rule_count = RULE_CTRL_IN_Priv_CountIf((RULE_TYPE_INSTANCE_PTR_T)acl_inst_p,
                                                                          RULE_CTRL_UT_Proc_Is_Active_Rule_Instance,
                                                                          NULL);
                            assert(time_line[i].active_ace_count == RULE_CTRL_IN_Priv_CountIf((RULE_TYPE_INSTANCE_PTR_T)acl_inst_p,
                                                                                              RULE_CTRL_UT_Proc_Is_Active_Rule_Instance,
                                                                                              NULL));
                        }

                    }
                }
            }

        }

    }

#endif // SYS_CPNT_TIME_BASED_ACL

    return 0;
}

#endif /* 0 */

/*------------------------------------------------------------------------------
 * Test Cases
 *------------------------------------------------------------------------------
 */
void
RULE_CTRL_UT_Proc_Validate_PTP_Event_ETH_Rule(
    BOOL_T enable_flag,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p)
{
    enum
    {
        UNIT = 1,
    };

    UI32_T ether_type = 0x88f7;

    if (TRUE == enable_flag)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ether_Type(&rule_entry_p->rule_pattern, ether_type, 0xffff);

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;
                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 == pce->policer_idx);

                result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                     remapped_pkt_type,
                                                                     &pcl_cfg);
                assert(RULE_TYPE_OK == result);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                b_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce);
                assert(TRUE == b_result);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    assert(pattern->etherType == L_STDLIB_Hton16(ether_type));
                    assert(mask->etherType == L_STDLIB_Hton16(0xffff));

                    assert(1 == pattern->common.isL2Valid);
                    assert(1 == mask->common.isL2Valid);
                }

                assert(CPSS_PACKET_CMD_TRAP_TO_CPU_E == action.pktCmd);
                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);
                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
            }

        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

int
RULE_CTRL_UT_Add_PTP_Event_ETH_Rule()
{
    enum
    {
        MAX_RETRY = 2,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_PTP_EVENT_ETH;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;

    BOOL_T enable_flag;
    RULE_TYPE_PacketType_T packet_type = RULE_TYPE_PacketType_PTP_EVENT_ETH;
    BOOL_T b_result;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        //
        // Add
        //
        enable_flag = TRUE;
        b_result = RULE_CTRL_TrapPacket2Cpu(enable_flag, packet_type, NULL);
        assert(TRUE == b_result);

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_PTP_Event_ETH_Rule(enable_flag,
                                                      &interface,
                                                      remapped_pkt_type,
                                                      class_inst_p);

        //
        // Remove
        //
        enable_flag = FALSE;
        b_result = RULE_CTRL_TrapPacket2Cpu(enable_flag, packet_type, NULL);
        assert(TRUE == b_result);

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);

        RULE_CTRL_UT_Proc_Validate_PTP_Event_ETH_Rule(enable_flag,
                                                      &interface,
                                                      remapped_pkt_type,
                                                      class_inst_p);
    }

    //
    // Install
    //
    enable_flag = TRUE;
    b_result = RULE_CTRL_TrapPacket2Cpu(enable_flag, packet_type, NULL);
    assert(TRUE == b_result);

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_PTP_Event_UDP_Rule(
    BOOL_T enable_flag,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p)
{
#define RULE_CTRL_PROTOCOL_UDP           17
#define RULE_CTRL_PORT_PTP_EVENT         319

    enum
    {
        UNIT = 1,
    };

    if (TRUE == enable_flag)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_L4_Source_Port(&rule_entry_p->rule_pattern, RULE_CTRL_PORT_PTP_EVENT, 0xffff);
            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_L4_Dest_Port(&rule_entry_p->rule_pattern, RULE_CTRL_PORT_PTP_EVENT, 0xffff);
            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Udp(&rule_entry_p->rule_pattern);

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;
                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 == pce->policer_idx);

                RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                            remapped_pkt_type, &pcl_cfg);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                assert(TRUE == RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                    pce));

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    assert(RULE_CTRL_PROTOCOL_UDP == pattern->commonExt.ipProtocol);
                    assert(0xff == mask->commonExt.ipProtocol);

                    {
                        UI16_T tmp_data = L_STDLIB_Hton16(RULE_CTRL_PORT_PTP_EVENT);
                        UI16_T tmp_mask = L_STDLIB_Hton16(0xffff);

                        assert(pattern->commonExt.l4Byte0 == ((unsigned char *)&tmp_data)[0]);
                        assert(pattern->commonExt.l4Byte1 == ((unsigned char *)&tmp_data)[1]);
                        assert(mask->commonExt.l4Byte0 == ((unsigned char *)&tmp_mask)[0]);
                        assert(mask->commonExt.l4Byte1 == ((unsigned char *)&tmp_mask)[1]);
                    }

                    {
                        UI16_T tmp_data = L_STDLIB_Hton16(RULE_CTRL_PORT_PTP_EVENT);
                        UI16_T tmp_mask = L_STDLIB_Hton16(0xffff);

                        assert(pattern->commonExt.l4Byte2 == ((unsigned char *)&tmp_data)[0]);
                        assert(pattern->commonExt.l4Byte3 == ((unsigned char *)&tmp_data)[1]);
                        assert(mask->commonExt.l4Byte2 == ((unsigned char *)&tmp_mask)[0]);
                        assert(mask->commonExt.l4Byte3 == ((unsigned char *)&tmp_mask)[1]);
                    }

                    assert(1 == pattern->common.isL2Valid);
                    assert(1 == mask->common.isL2Valid);

                    assert(1 == pattern->common.isIp);
                    assert(0xFF == mask->common.isIp);

                    assert(1 == pattern->commonExt.isL4Valid);
                    assert(0xFF == mask->commonExt.isL4Valid);
                }

                assert(CPSS_PACKET_CMD_TRAP_TO_CPU_E == action.pktCmd);
                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);
                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
            }

        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();

#undef RULE_CTRL_PROTOCOL_UDP
#undef RULE_CTRL_PORT_PTP_EVENT
}

int
RULE_CTRL_UT_Add_PTP_Event_UDP_Rule()
{
    enum
    {
        MAX_RETRY = 2,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_PTP_EVENT_UDP;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;

    BOOL_T enable_flag;
    RULE_TYPE_PacketType_T packet_type = RULE_TYPE_PacketType_PTP_EVENT_UDP;
    BOOL_T b_result;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        //
        // Add
        //
        enable_flag = TRUE;
        b_result = RULE_CTRL_TrapPacket2Cpu(enable_flag, packet_type, NULL);
        assert(TRUE == b_result);

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_PTP_Event_UDP_Rule(enable_flag,
                                                      &interface,
                                                      remapped_pkt_type,
                                                      class_inst_p);

        //
        // Remove
        //
        enable_flag = FALSE;
        b_result = RULE_CTRL_TrapPacket2Cpu(enable_flag, packet_type, NULL);
        assert(TRUE == b_result);

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);

        RULE_CTRL_UT_Proc_Validate_PTP_Event_UDP_Rule(enable_flag,
                                                      &interface,
                                                      remapped_pkt_type,
                                                      class_inst_p);
    }

    //
    // Install
    //
    enable_flag = TRUE;
    b_result = RULE_CTRL_TrapPacket2Cpu(enable_flag, packet_type, NULL);
    assert(TRUE == b_result);

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_PTP_General_UDP_Rule(
    BOOL_T enable_flag,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p)
{
#define RULE_CTRL_PROTOCOL_UDP           17
#define RULE_CTRL_PORT_PTP_GENERAL       320

    enum
    {
        UNIT = 1,
    };

    if (TRUE == enable_flag)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_L4_Source_Port(&rule_entry_p->rule_pattern, RULE_CTRL_PORT_PTP_GENERAL, 0xffff);
            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_L4_Dest_Port(&rule_entry_p->rule_pattern, RULE_CTRL_PORT_PTP_GENERAL, 0xffff);
            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Udp(&rule_entry_p->rule_pattern);

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;
                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 == pce->policer_idx);

                RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                            remapped_pkt_type, &pcl_cfg);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                assert(TRUE == RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                    pce));

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    assert(RULE_CTRL_PROTOCOL_UDP == pattern->commonExt.ipProtocol);
                    assert(0xff == mask->commonExt.ipProtocol);

                    {
                        UI16_T tmp_data = L_STDLIB_Hton16(RULE_CTRL_PORT_PTP_GENERAL);
                        UI16_T tmp_mask = L_STDLIB_Hton16(0xffff);

                        assert(pattern->commonExt.l4Byte0 == ((unsigned char *)&tmp_data)[0]);
                        assert(pattern->commonExt.l4Byte1 == ((unsigned char *)&tmp_data)[1]);
                        assert(mask->commonExt.l4Byte0 == ((unsigned char *)&tmp_mask)[0]);
                        assert(mask->commonExt.l4Byte1 == ((unsigned char *)&tmp_mask)[1]);
                    }

                    {
                        UI16_T tmp_data = L_STDLIB_Hton16(RULE_CTRL_PORT_PTP_GENERAL);
                        UI16_T tmp_mask = L_STDLIB_Hton16(0xffff);

                        assert(pattern->commonExt.l4Byte2 == ((unsigned char *)&tmp_data)[0]);
                        assert(pattern->commonExt.l4Byte3 == ((unsigned char *)&tmp_data)[1]);
                        assert(mask->commonExt.l4Byte2 == ((unsigned char *)&tmp_mask)[0]);
                        assert(mask->commonExt.l4Byte3 == ((unsigned char *)&tmp_mask)[1]);
                    }

                    assert(1 == pattern->common.isL2Valid);
                    assert(1 == mask->common.isL2Valid);

                    assert(1 == pattern->common.isIp);
                    assert(0xFF == mask->common.isIp);

                    assert(1 == pattern->commonExt.isL4Valid);
                    assert(0xFF == mask->commonExt.isL4Valid);
                }

                assert(CPSS_PACKET_CMD_TRAP_TO_CPU_E == action.pktCmd);
                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);
                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
            }

        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();

#undef RULE_CTRL_PROTOCOL_UDP
#undef RULE_CTRL_PORT_PTP_GENERAL
}

int
RULE_CTRL_UT_Add_PTP_General_UDP_Rule()
{
    enum
    {
        MAX_RETRY = 2,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_PTP_GENERAL_UDP;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;
    BOOL_T enable_flag;
    RULE_TYPE_PacketType_T packet_type = RULE_TYPE_PacketType_PTP_GENERAL_UDP;
    BOOL_T b_result;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        //
        // Add
        //
        enable_flag = TRUE;
        b_result = RULE_CTRL_TrapPacket2Cpu(enable_flag, packet_type, NULL);
        assert(TRUE == b_result);

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_PTP_General_UDP_Rule(enable_flag,
                                                        &interface,
                                                        remapped_pkt_type,
                                                        class_inst_p);

        //
        // Remove
        //
        enable_flag = FALSE;
        b_result = RULE_CTRL_TrapPacket2Cpu(enable_flag, packet_type, NULL);
        assert(TRUE == b_result);

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);

        RULE_CTRL_UT_Proc_Validate_PTP_General_UDP_Rule(enable_flag,
                                                        &interface,
                                                        remapped_pkt_type,
                                                        class_inst_p);
    }

    //
    // Install
    //
    enable_flag = TRUE;
    b_result = RULE_CTRL_TrapPacket2Cpu(enable_flag, packet_type, NULL);
    assert(TRUE == b_result);

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_My_MAC_for_Craft_Port_Rule(
    BOOL_T enable_flag,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p)
{
    enum
    {
        UNIT = 1,
    };

    UI8_T cpu_mac[SYS_ADPT_MAC_ADDR_LEN];
    UI8_T cpu_mask[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    STKTPLG_POM_GetLocalUnitBaseMac(cpu_mac);

    if (TRUE == enable_flag)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Dest_Mac_Address(&rule_entry_p->rule_pattern, cpu_mac, cpu_mask);

            {
                UI8_T craft_phy_port;
                UI8_T device_id;

                STKTPLG_BOARD_GetCraftPortInfo(&device_id, &craft_phy_port);

                assert(rule_inst_p->dev_rule_info.device == device_id);
            }

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;
                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 == pce->policer_idx);

                RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                            remapped_pkt_type, &pcl_cfg);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                assert(TRUE == RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                    pce));

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    assert(0 == memcmp(pattern->macDa.arEther, cpu_mac, sizeof(pattern->macDa.arEther)));
                    assert(0 == memcmp(mask->macDa.arEther, cpu_mask, sizeof(mask->macDa.arEther)));

                    assert(1 == pattern->common.isL2Valid);
                    assert(1 == mask->common.isL2Valid);
                }

                assert(CPSS_PACKET_CMD_TRAP_TO_CPU_E == action.pktCmd);
                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);
                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
            }

        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

int
RULE_CTRL_UT_Add_My_MAC_for_Craft_Port_Rule()
{
    enum
    {
        MAX_RETRY = 2,
    };

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_MY_MAC_CRAFT_PORT;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;
    BOOL_T enable_flag;
    RULE_TYPE_PacketType_T packet_type = RULE_TYPE_Packettype_MY_MAC_CRAFT_PORT;
    BOOL_T result;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        enable_flag = TRUE;
        result = RULE_CTRL_TrapPacket2Cpu(enable_flag, packet_type, NULL);
        assert(TRUE == result);

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_CRAFT_PORT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_My_MAC_for_Craft_Port_Rule(enable_flag,
                                                              &interface,
                                                              remapped_pkt_type,
                                                              class_inst_p);

        enable_flag = TRUE;
        result = RULE_CTRL_TrapPacket2Cpu(enable_flag, packet_type, NULL);

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_My_MAC_for_Craft_Port_Rule(enable_flag,
                                                              &interface,
                                                              remapped_pkt_type,
                                                              class_inst_p);

        //
        // Remove
        //

        enable_flag = FALSE;
        result = RULE_CTRL_TrapPacket2Cpu(enable_flag, packet_type, NULL);

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);

        RULE_CTRL_UT_Proc_Validate_My_MAC_for_Craft_Port_Rule(enable_flag,
                                                              &interface,
                                                              remapped_pkt_type,
                                                              class_inst_p);
    }

    return 0;
}

int
RULE_CTRL_UT_Add_Vlan_Translation_Rule()
{
#if (SYS_CPNT_VLAN_XLATE_BY_RULE == TRUE)

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type;

    RULE_TYPE_RETURN_TYPE_T     result;

    RULE_TYPE_INTERFACE_INFO_T  interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T                      old_vid;
    UI32_T                      new_vid;
    UI32_T                      rule_cnt;

    BOOL_T                      re_try = TRUE;

    BOOL_T                      enable_flag;

    //
    // Add egress rule
    //
    interface.type = RULE_TYPE_INTERFACE_UPORT;
    interface.uport.unit = 1;
    interface.uport.port = 2;
    interface.direction = RULE_TYPE_OUTBOUND;

    old_vid = 10;
    new_vid = 20;

    result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
    assert(RULE_TYPE_OK == result);

    remapped_pkt_type = (RULE_TYPE_INBOUND == interface.direction) ?
                                             RULE_TYPE_PACKET_VLAN_TRANSLATION :
                                       RULE_TYPE_PACKET_EGRESS_VLAN_TRANSLATION;

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);
    assert(RULE_TYPE_OK == result);
    assert(NULL != class_inst_p);

    enable_flag = (0 != new_vid) ? TRUE : FALSE;

    RULE_CTRL_UT_Proc_Validate_Vlan_Translation_Rule(enable_flag,
                                                     &interface,
                                                     remapped_pkt_type,
                                                     class_inst_p,
                                                     old_vid, new_vid);


    //RULE_CTRL_DumpDfltAceByPort_BackDoor(interface.uport.unit, interface.uport.port);

    //
    // Add egress rule
    //
    interface.direction = RULE_TYPE_INBOUND;

    result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
    assert(RULE_TYPE_OK == result);


    //RULE_CTRL_DumpDfltAceByPort_BackDoor(interface.uport.unit, interface.uport.port);

    remapped_pkt_type = (RULE_TYPE_INBOUND == interface.direction) ?
                                             RULE_TYPE_PACKET_VLAN_TRANSLATION :
                                       RULE_TYPE_PACKET_EGRESS_VLAN_TRANSLATION;

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);
    assert(RULE_TYPE_OK == result);
    assert(NULL != class_inst_p);

    enable_flag = (0 != new_vid) ? TRUE : FALSE;

    RULE_CTRL_UT_Proc_Validate_Vlan_Translation_Rule(enable_flag,
                                                     &interface,
                                                     remapped_pkt_type,
                                                     class_inst_p,
                                                     old_vid, new_vid);

    //
    // Remove egress rule
    //
    interface.direction = RULE_TYPE_OUTBOUND;
    new_vid = 0;
    result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
    assert(RULE_TYPE_OK == result);

    remapped_pkt_type = (RULE_TYPE_INBOUND == interface.direction) ?
                                             RULE_TYPE_PACKET_VLAN_TRANSLATION :
                                       RULE_TYPE_PACKET_EGRESS_VLAN_TRANSLATION;

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);
    assert(RULE_TYPE_OK != result);
    assert(NULL == class_inst_p);

    //
    // Remove ingress rule
    //
    interface.direction = RULE_TYPE_INBOUND;
    new_vid = 0;
    result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
    assert(RULE_TYPE_OK == result);

    remapped_pkt_type = (RULE_TYPE_INBOUND == interface.direction) ?
                                             RULE_TYPE_PACKET_VLAN_TRANSLATION :
                                       RULE_TYPE_PACKET_EGRESS_VLAN_TRANSLATION;

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);
    assert(RULE_TYPE_OK != result);
    assert(NULL == class_inst_p);

re_try_again:
    interface.direction = RULE_TYPE_OUTBOUND;

    rule_cnt = 0;
    class_inst_p = NULL;
    while (TRUE)
    {
        old_vid = 10   + rule_cnt;
        new_vid = 1000 + rule_cnt;

        result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
        if (RULE_TYPE_OK != result)
        {
            break;
        }

        remapped_pkt_type = (RULE_TYPE_INBOUND == interface.direction) ?
                                             RULE_TYPE_PACKET_VLAN_TRANSLATION :
                                       RULE_TYPE_PACKET_EGRESS_VLAN_TRANSLATION;

        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        enable_flag = (0 != new_vid) ? TRUE : FALSE;
        RULE_CTRL_UT_Proc_Validate_Vlan_Translation_Rule(enable_flag,
                                                         &interface,
                                                         remapped_pkt_type,
                                                         class_inst_p,
                                                         old_vid, new_vid);

//        RULE_CTRL_DumpDfltAceByPort_BackDoor(interface.uport.unit, interface.uport.port);

        rule_cnt ++;
    };

    assert(rule_cnt == SYS_ADPT_MAX_NBR_OF_VLAN_XLATE_PER_PORT);

    RULE_CTRL_UT_Proc_Validate_Number_Of_Rule();


    interface.direction = RULE_TYPE_INBOUND;

    rule_cnt = 0;
    class_inst_p = NULL;
    while (TRUE)
    {
        old_vid = 10   + rule_cnt;
        new_vid = 1000 + rule_cnt;

        result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
        if (RULE_TYPE_OK != result)
        {
            break;
        }

        remapped_pkt_type = (RULE_TYPE_INBOUND == interface.direction) ?
                                             RULE_TYPE_PACKET_VLAN_TRANSLATION :
                                       RULE_TYPE_PACKET_EGRESS_VLAN_TRANSLATION;

        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        enable_flag = (0 != new_vid) ? TRUE : FALSE;
        RULE_CTRL_UT_Proc_Validate_Vlan_Translation_Rule(enable_flag,
                                                         &interface,
                                                         remapped_pkt_type,
                                                         class_inst_p,
                                                         old_vid, new_vid);

//        RULE_CTRL_DumpDfltAceByPort_BackDoor(interface.uport.unit, interface.uport.port);

        rule_cnt ++;
    };

    assert(rule_cnt == SYS_ADPT_MAX_NBR_OF_VLAN_XLATE_PER_PORT);


    RULE_CTRL_UT_Proc_Validate_Number_Of_Rule();


    //
    // remove all and try again
    //
    interface.direction = RULE_TYPE_OUTBOUND;

    for (rule_cnt = 0; rule_cnt < SYS_ADPT_MAX_NBR_OF_VLAN_XLATE_PER_PORT; ++rule_cnt)
    {
        old_vid = 10   + rule_cnt;
        new_vid = 0;

        result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();
//        enable_flag = (0 != new_vid) ? TRUE : FALSE;
//        RULE_CTRL_UT_Proc_Validate_Vlan_Translation_Rule(enable_flag,
//                                                         &interface,
//                                                         remapped_pkt_type,
//                                                         class_inst_p,
//                                                         old_vid, new_vid);
//
//        RULE_CTRL_DumpDfltAceByPort_BackDoor(interface.uport.unit, interface.uport.port);
    }


    RULE_CTRL_UT_Proc_Validate_Number_Of_Rule();

    interface.direction = RULE_TYPE_INBOUND;

    for (rule_cnt = 0; rule_cnt < SYS_ADPT_MAX_NBR_OF_VLAN_XLATE_PER_PORT; ++rule_cnt)
    {
        old_vid = 10   + rule_cnt;
        new_vid = 0;

        result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();
//        enable_flag = (0 != new_vid) ? TRUE : FALSE;
//        RULE_CTRL_UT_Proc_Validate_Vlan_Translation_Rule(enable_flag,
//                                                         &interface,
//                                                         remapped_pkt_type,
//                                                         class_inst_p,
//                                                         old_vid, new_vid);
//
//        RULE_CTRL_DumpDfltAceByPort_BackDoor(interface.uport.unit, interface.uport.port);
    }

    RULE_CTRL_UT_Proc_Validate_Number_Of_Rule();


    if (TRUE == re_try)
    {
        re_try = FALSE;
        goto re_try_again;
    }

#endif // SYS_CPNT_VLAN_XLATE_BY_RULE

    return 0;
}

int
RULE_CTRL_UT_Add_Trunk_Vlan_Translation_Rule()
{
#if (SYS_CPNT_VLAN_XLATE_BY_RULE == TRUE)

    RULE_CONFIG_MVL_PACKET_TYPE_T  remapped_pkt_type;
    RULE_TYPE_RETURN_TYPE_T        result;
    RULE_TYPE_INTERFACE_INFO_T     interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;
    RULE_TYPE_CLASS_INSTANCE_PTR_T egr_class_inst_p[SYS_ADPT_MAX_NBR_OF_10_100_PORT_PER_TRUNK];
    UI32_T                         old_vid = 100, new_vid = 200;
    UI32_T                         rule_cnt, i;
    BOOL_T                         re_try = TRUE;
    BOOL_T                         enable_flag, retry;

    /* Add ingress rule
     */
    interface.direction = RULE_TYPE_INBOUND;
    interface.type = RULE_TYPE_INTERFACE_TRUNK;
    interface.trunk_id = 1;

    result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
    assert(RULE_TYPE_OK == result);

    remapped_pkt_type = RULE_TYPE_PACKET_TRUNK_VLAN_TRANSLATION;

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);
    assert(RULE_TYPE_OK == result);
    assert(NULL != class_inst_p);

    enable_flag = (0 != new_vid) ? TRUE : FALSE;

    RULE_CTRL_UT_Proc_Validate_Vlan_Translation_Rule(enable_flag,
                                                     &interface,
                                                     remapped_pkt_type,
                                                     class_inst_p,
                                                     old_vid, new_vid);

    /* Remove ingress rule
     */
    interface.direction = RULE_TYPE_INBOUND;
    interface.type = RULE_TYPE_INTERFACE_TRUNK;
    interface.trunk_id = 1;

    new_vid = 0;

    result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
    assert(RULE_TYPE_OK == result);

    remapped_pkt_type = RULE_TYPE_PACKET_TRUNK_VLAN_TRANSLATION;

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);
    assert(RULE_TYPE_OK != result);
    assert(NULL == class_inst_p);

re_try_again:

    interface.direction = RULE_TYPE_INBOUND;
    interface.type = RULE_TYPE_INTERFACE_TRUNK;
    interface.trunk_id = 1;

    rule_cnt = 0;
    class_inst_p = NULL;
    while (TRUE)
    {
        old_vid = 10   + rule_cnt;
        new_vid = 1000 + rule_cnt;

        result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
        if (RULE_TYPE_OK != result)
        {
            break;
        }

        remapped_pkt_type = RULE_TYPE_PACKET_TRUNK_VLAN_TRANSLATION;

        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);
        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        enable_flag = (0 != new_vid) ? TRUE : FALSE;
        RULE_CTRL_UT_Proc_Validate_Vlan_Translation_Rule(enable_flag,
                                                         &interface,
                                                         remapped_pkt_type,
                                                         class_inst_p,
                                                         old_vid, new_vid);

        // RULE_CTRL_DumpDfltAceByPort_BackDoor(interface.uport.unit, interface.uport.port);

        rule_cnt ++;
    };

    assert(rule_cnt == SYS_ADPT_MAX_NBR_OF_VLAN_XLATE_PER_PORT);


    RULE_CTRL_UT_Proc_Validate_Number_Of_Rule();

    //
    // remove all and try again
    //
    interface.direction = RULE_TYPE_INBOUND;
    interface.type = RULE_TYPE_INTERFACE_TRUNK;
    interface.trunk_id = 1;

    for (rule_cnt = 0; rule_cnt < SYS_ADPT_MAX_NBR_OF_VLAN_XLATE_PER_PORT; ++rule_cnt)
    {
        old_vid = 10   + rule_cnt;
        new_vid = 0;

        result = RULE_CTRL_SetPortVlanXlate(&interface, old_vid, new_vid);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();
    }

    RULE_CTRL_UT_Proc_Validate_Number_Of_Rule();


    if (TRUE == re_try)
    {
        re_try = FALSE;
        goto re_try_again;
    }

#endif // SYS_CPNT_VLAN_XLATE_BY_RULE
    
    return 0;
}

int
RULE_CTRL_UT_Add_WebAuth_Redir_HTTP_And_Permit_DHCP_DNS_Rule()
{
#if (SYS_CPNT_WEBAUTH == TRUE)
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_redir_http_p;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_permit_dhcp_client_p;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_permit_dns_p;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_deny_ip_p;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_permit_sip_p;

    RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_redir_http_p;
    RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_permit_dhcp_client_p;
    RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_permit_dns_p;
    RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_deny_ip_p;
    RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_permit_sip_p;

    RULE_CTRL_UnitPort_T    unit_port;
    RULE_CTRL_UnitPortSip_T unit_port_sip;

    UI32_T                  rule_prio_redir_http;
    UI32_T                  rule_prio_permit_dhcp_client;
    UI32_T                  rule_prio_permit_dns;
    UI32_T                  rule_prio_deny_ip;
    UI32_T                  rule_prio_permit_sip;

    BOOL_T                  is_enable;
    BOOL_T                  b_result;

    is_enable = TRUE;

    unit_port.unit = 1;
    unit_port.port = 2;

    interface.type = RULE_TYPE_INTERFACE_UPORT;
    interface.uport.unit = unit_port.unit;
    interface.uport.port = unit_port.port;
    interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

    //
    //
    //

    b_result = RULE_CTRL_Service(is_enable, RULE_CTRL_WEBAUTH_REDIR_HTTP, &unit_port);
    assert(b_result == TRUE);

    remapped_pkt_type = RULE_TYPE_PACKET_WA_REDIR_HTTP_CLIENT;

    class_inst_redir_http_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_redir_http_p);
    assert(RULE_TYPE_OK == result);
    assert(NULL != class_inst_redir_http_p);

    assert(1 == RULE_CTRL_UT_Proc_Count_Of_Rule_Instance(class_inst_redir_http_p));

    rule_inst_redir_http_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_redir_http_p,
                                                             &rule_inst_redir_http_p);
    assert(RULE_TYPE_OK == result);

    assert(0 != rule_inst_redir_http_p->dev_rule_info.rule_id);
    assert(TRUE == rule_inst_redir_http_p->active);

    //
    //
    //

    b_result = RULE_CTRL_Service(is_enable, RULE_CTRL_WEBAUTH_PERMIT_DHCPC, &unit_port);
    assert(b_result == TRUE);

    remapped_pkt_type = RULE_TYPE_PACKET_WA_PERMIT_DHCP_CLIENT;

    class_inst_permit_dhcp_client_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_permit_dhcp_client_p);
    assert(RULE_TYPE_OK == result);
    assert(NULL != class_inst_permit_dhcp_client_p);

    assert(1 == RULE_CTRL_UT_Proc_Count_Of_Rule_Instance(class_inst_permit_dhcp_client_p));

    rule_inst_permit_dhcp_client_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_permit_dhcp_client_p,
                                                             &rule_inst_permit_dhcp_client_p);
    assert(RULE_TYPE_OK == result);

    assert(0 != rule_inst_permit_dhcp_client_p->dev_rule_info.rule_id);
    assert(TRUE == rule_inst_permit_dhcp_client_p->active);

    //
    //
    //

    b_result = RULE_CTRL_Service(is_enable, RULE_CTRL_WEBAUTH_PERMIT_DNS, &unit_port);
    assert(b_result == TRUE);

    remapped_pkt_type = RULE_TYPE_PACKET_WA_PERMIT_DNS_CLIENT;

    class_inst_permit_dns_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_permit_dns_p);
    assert(RULE_TYPE_OK == result);
    assert(NULL != class_inst_permit_dns_p);

    assert(1 == RULE_CTRL_UT_Proc_Count_Of_Rule_Instance(class_inst_permit_dns_p));

    rule_inst_permit_dns_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_permit_dns_p,
                                                             &rule_inst_permit_dns_p);
    assert(RULE_TYPE_OK == result);

    assert(0 != rule_inst_permit_dns_p->dev_rule_info.rule_id);
    assert(TRUE == rule_inst_permit_dns_p->active);

    //
    //
    //

    b_result = RULE_CTRL_Service(is_enable, RULE_CTRL_WEBAUTH_DENY_IP, &unit_port);
    assert(b_result == TRUE);

    remapped_pkt_type = RULE_TYPE_PACKET_WA_DENY_IP_ANY;

    class_inst_deny_ip_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_deny_ip_p);
    assert(RULE_TYPE_OK == result);
    assert(NULL != class_inst_deny_ip_p);

    assert(1 == RULE_CTRL_UT_Proc_Count_Of_Rule_Instance(class_inst_deny_ip_p));

    rule_inst_deny_ip_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_deny_ip_p,
                                                             &rule_inst_deny_ip_p);
    assert(RULE_TYPE_OK == result);

    assert(0 != rule_inst_deny_ip_p->dev_rule_info.rule_id);
    assert(TRUE == rule_inst_deny_ip_p->active);

    //
    //
    //

    unit_port_sip.unit = unit_port.unit;
    unit_port_sip.port = unit_port.port;
    unit_port_sip.sip  = 0x01020304;

    b_result = RULE_CTRL_Service(is_enable, RULE_CTRL_WEBAUTH_PERMIT_SIP, &unit_port_sip);
    assert(b_result == TRUE);

    remapped_pkt_type = RULE_TYPE_PACKET_SIP;

    class_inst_permit_sip_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_permit_sip_p);
    assert(RULE_TYPE_OK == result);
    assert(NULL != class_inst_permit_sip_p);

    assert(1 == RULE_CTRL_UT_Proc_Count_Of_Rule_Instance(class_inst_permit_sip_p));

    rule_inst_permit_sip_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_permit_sip_p,
                                                             &rule_inst_permit_sip_p);
    assert(RULE_TYPE_OK == result);

    assert(0 != rule_inst_permit_sip_p->dev_rule_info.rule_id);
    assert(TRUE == rule_inst_permit_sip_p->active);

    //
    //
    //

    rule_prio_redir_http = RULE_CTRL_UT_Proc_Get_Absolute_Rule_Priority(rule_inst_redir_http_p->dev_rule_info.device,
                                                                        rule_inst_redir_http_p->dev_rule_info.rule_id);

    rule_prio_permit_dhcp_client = RULE_CTRL_UT_Proc_Get_Absolute_Rule_Priority(rule_inst_permit_dhcp_client_p->dev_rule_info.device,
                                                                                rule_inst_permit_dhcp_client_p->dev_rule_info.rule_id);

    rule_prio_permit_dns = RULE_CTRL_UT_Proc_Get_Absolute_Rule_Priority(rule_inst_permit_dns_p->dev_rule_info.device,
                                                                        rule_inst_permit_dns_p->dev_rule_info.rule_id);

    rule_prio_deny_ip = RULE_CTRL_UT_Proc_Get_Absolute_Rule_Priority(rule_inst_deny_ip_p->dev_rule_info.device,
                                                                     rule_inst_deny_ip_p->dev_rule_info.rule_id);

    rule_prio_permit_sip = RULE_CTRL_UT_Proc_Get_Absolute_Rule_Priority(rule_inst_permit_sip_p->dev_rule_info.device,
                                                                        rule_inst_permit_sip_p->dev_rule_info.rule_id);

    assert(rule_prio_redir_http < rule_prio_permit_sip);
    assert(rule_prio_deny_ip < rule_prio_permit_sip);

    assert(rule_prio_deny_ip < rule_prio_redir_http);
    assert(rule_prio_deny_ip < rule_prio_permit_dhcp_client);
    assert(rule_prio_deny_ip < rule_prio_permit_dns);

#endif // SYS_CPNT_WEBAUTH

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_IpSrcGrd_Permit_SA_VID_SIP_Rule_Status(
    BOOL_T is_enable,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    UI32_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    const RULE_CTRL_UnitPortSaVidSip_T *vid_sip_p)
{
    if (TRUE == is_enable)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        UI8_T mac_mask[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

        assert(NULL != class_inst_p);

        assert(1 == RULE_CTRL_UT_Proc_Count_Of_Rule_Instance(class_inst_p));

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        assert(0 != rule_inst_p->dev_rule_info.rule_id);
        assert(TRUE == rule_inst_p->active);

        rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
        assert(NULL != rule_entry_p);

        if (TRUE != RULE_CTRL_LocalIsNullMac(vid_sip_p->sa))
        {
            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Source_Mac_Address(&rule_entry_p->rule_pattern, vid_sip_p->sa, mac_mask);
        }

        if (0 != vid_sip_p->vid)
        {
            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Vlan(&rule_entry_p->rule_pattern, vid_sip_p->vid, 0xffff);
        }

        if (0 != vid_sip_p->sip)
        {
            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Source_Address(&rule_entry_p->rule_pattern, vid_sip_p->sip, 0xffffffff);
        }

        {
            DEVRM_PCE_T *pce;
            RULE_CTRL_PCL_CFG_T pcl_cfg;

            BOOL_T b_result;

            CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
            CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
            CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
            CPSS_DXCH_PCL_ACTION_STC action;

            b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                    rule_inst_p->dev_rule_info.rule_id,
                                    &pce);
            assert(TRUE == b_result);
            assert(NULL != pce);

            assert(-1 == pce->policer_idx);

            RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                        remapped_pkt_type,
                                                        &pcl_cfg);
            assert(pce->pcl_id == pcl_cfg.pcl_id);

            assert(TRUE == RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce));

            result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                    pce,
                                                    &ruleFormat, &mask_u, &pattern_u, &action);
            assert(RULE_TYPE_OK == result);

            {
                CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                assert(pattern->common.pclId == pcl_cfg.pcl_id);
                assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                if (0 != vid_sip_p->vid)
                {
                    assert(L_STDLIB_Hton16(vid_sip_p->vid) == pattern->common.vid);
                    assert(L_STDLIB_Hton16(0xfff) == mask->common.vid);
                }
                else
                {
                    assert(0 == pattern->common.vid);
                    assert(0 == mask->common.vid);
                }

                assert(0 == memcmp(vid_sip_p->sa, pattern->macSa.arEther, sizeof(vid_sip_p->sa)));
                assert(0xff == mask->macSa.arEther[0]);
                assert(0xff == mask->macSa.arEther[1]);
                assert(0xff == mask->macSa.arEther[2]);
                assert(0xff == mask->macSa.arEther[3]);
                assert(0xff == mask->macSa.arEther[4]);
                assert(0xff == mask->macSa.arEther[5]);

                if (0 != vid_sip_p->sip)
                {
                    assert(L_STDLIB_Hton32(vid_sip_p->sip) == pattern->sip.u32Ip);
                    assert(L_STDLIB_Hton32(0xffffffff) == mask->sip.u32Ip);
                }
                else
                {
                    assert(0 == pattern->sip.u32Ip);
                    assert(0 == mask->sip.u32Ip);
                }

                assert(L_STDLIB_Hton16(0x0800) == pattern->etherType);
                assert(L_STDLIB_Hton16(0xffff) == mask->etherType);
            }

            assert(CPSS_PACKET_CMD_FORWARD_E == action.pktCmd);
            assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);
            assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
            assert(GT_FALSE == action.vlan.nestedVlan);
        }
    }
    else
    {
        assert(NULL == class_inst_p);
    }
}

int
RULE_CTRL_UT_Add_IpSrcGrd_Permit_SA_VID_SIP_Rule()
{
#if (SYS_CPNT_IP_SOURCE_GUARD == TRUE)
    enum
    {
        MAX_UNIT = 1,
        MAX_PORT = 2,
        MAX_RETRY = 2
    };

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_SA_SIP_VID;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;
    UI32_T i;

    RULE_CTRL_UnitPortSaVidSip_T vid_sip;

    BOOL_T is_enable;

    BOOL_T b_result;

#if (SYS_CPNT_IPSG_STRICT_MODE == TRUE)
    remapped_pkt_type = RULE_TYPE_PACKET_IP_SG_PERMIT_HOST_STRICT;
#endif /* SYS_CPNT_IPSG_STRICT_MODE */

    memset(&interface, 0, sizeof(interface));

    for (interface.uport.unit = 1; interface.uport.unit <= MAX_UNIT;
                                                        ++ interface.uport.unit)
    {
        for (interface.uport.port = 1; interface.uport.port <= MAX_PORT;
                                                        ++ interface.uport.port)
        {
            interface.type = RULE_TYPE_INTERFACE_UPORT;
            interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

            ////////////////////////////////////////////////////////////////////

            //
            // Create rule
            //
            is_enable = TRUE;

            vid_sip.unit = interface.uport.unit;
            vid_sip.port = interface.uport.port;

            vid_sip.sa[0] = 0x01;
            vid_sip.sa[1] = 0x02;
            vid_sip.sa[2] = 0x03;
            vid_sip.sa[3] = 0x04;
            vid_sip.sa[4] = 0x05;
            vid_sip.sa[5] = 0x06;

            vid_sip.vid  = 1000;
            vid_sip.sip  = 0x01020304;

            b_result = RULE_CTRL_Service(is_enable,
                                         RULE_CTRL_IP_SOURCE_GUARD_PERMIT_SA_VID_SIP,
                                         &vid_sip);
            assert(TRUE == b_result);

//          RULE_CTRL_DumpDfltAceByPort_BackDoor(vid_sip.unit, vid_sip.port);

            class_inst_p = NULL;
            result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                      remapped_pkt_type,
                                                                      RULE_TYPE_INST_CPU_IF,
                                                                      remapped_pkt_type,
                                                                      &class_inst_p);
            assert(RULE_TYPE_OK == result);
            assert(NULL != class_inst_p);

            RULE_CTRL_UT_Proc_Validate_IpSrcGrd_Permit_SA_VID_SIP_Rule_Status(is_enable,
                                                                              &interface,
                                                                              remapped_pkt_type,
                                                                              class_inst_p,
                                                                              &vid_sip);

            ////////////////////////////////////////////////////////////////////////////

            //
            // Update rule (Not create entry)
            //
            is_enable = TRUE;

            for (i = 0; i < SYS_ADPT_DHCPSNP_MAX_NBR_OF_CLIENT_PER_PORT + 1; ++ i)
            {
                b_result = RULE_CTRL_Service(is_enable,
                                             RULE_CTRL_IP_SOURCE_GUARD_PERMIT_SA_VID_SIP,
                                             &vid_sip);
                assert(TRUE == b_result);
            }

            ////////////////////////////////////////////////////////////////////////////

            //
            // Remove rule
            //

            is_enable = FALSE;

            b_result = RULE_CTRL_Service(is_enable,
                                         RULE_CTRL_IP_SOURCE_GUARD_PERMIT_SA_VID_SIP,
                                         &vid_sip);
            assert(TRUE == b_result);

            class_inst_p = NULL;
            result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                      remapped_pkt_type,
                                                                      RULE_TYPE_INST_CPU_IF,
                                                                      remapped_pkt_type,
                                                                      &class_inst_p);
            assert(RULE_TYPE_OK != result);
            assert(NULL == class_inst_p);

            RULE_CTRL_UT_Proc_Validate_IpSrcGrd_Permit_SA_VID_SIP_Rule_Status(is_enable,
                                                                              &interface,
                                                                              remapped_pkt_type,
                                                                              class_inst_p,
                                                                              &vid_sip);

            ////////////////////////////////////////////////////////////////////////////

            //
            // Remove rule second (nothing to do)
            //

            is_enable = FALSE;

            b_result = RULE_CTRL_Service(is_enable,
                                         RULE_CTRL_IP_SOURCE_GUARD_PERMIT_SA_VID_SIP,
                                         &vid_sip);
            assert(TRUE == b_result);

            class_inst_p = NULL;
            result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                      remapped_pkt_type,
                                                                      RULE_TYPE_INST_CPU_IF,
                                                                      remapped_pkt_type,
                                                                      &class_inst_p);
            assert(RULE_TYPE_OK != result);
            assert(NULL == class_inst_p);

            RULE_CTRL_UT_Proc_Validate_IpSrcGrd_Permit_SA_VID_SIP_Rule_Status(is_enable,
                                                                              &interface,
                                                                              remapped_pkt_type,
                                                                              class_inst_p,
                                                                              &vid_sip);
            for (retry = 1; retry <= MAX_RETRY; ++ retry)
            {
                //
                // Capacity test
                //

                is_enable = TRUE;
                class_inst_p = NULL;

                for (i = 0; i < SYS_ADPT_DHCPSNP_MAX_NBR_OF_CLIENT_PER_PORT; ++ i)
                {
                    vid_sip.sa[0] = 0x01;
                    vid_sip.sa[1] = 0x02;
                    vid_sip.sa[2] = 0x03;
                    vid_sip.sa[3] = 0x04;
                    vid_sip.sa[4] = 0x05;
                    vid_sip.sa[5] = i;

                    vid_sip.vid  = i;

                    vid_sip.sip  = i;

                    b_result = RULE_CTRL_Service(is_enable,
                                                 RULE_CTRL_IP_SOURCE_GUARD_PERMIT_SA_VID_SIP,
                                                 &vid_sip);
                    assert(TRUE == b_result);

                    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                              remapped_pkt_type,
                                                                              RULE_TYPE_INST_CPU_IF,
                                                                              remapped_pkt_type,
                                                                              &class_inst_p);
                    assert(RULE_TYPE_OK == result);
                    assert(NULL != class_inst_p);

                    RULE_CTRL_UT_Proc_Validate_IpSrcGrd_Permit_SA_VID_SIP_Rule_Status(is_enable,
                                                                                      &interface,
                                                                                      remapped_pkt_type,
                                                                                      class_inst_p,
                                                                                      &vid_sip);
                }

                is_enable = TRUE;

                vid_sip.sa[0] = 0x01;
                vid_sip.sa[1] = 0x02;
                vid_sip.sa[2] = 0x03;
                vid_sip.sa[3] = 0x04;
                vid_sip.sa[4] = 0x05;
                vid_sip.sa[5] = i;

                vid_sip.vid  = i;

                vid_sip.sip  = i;

                b_result = RULE_CTRL_Service(is_enable,
                                             RULE_CTRL_IP_SOURCE_GUARD_PERMIT_SA_VID_SIP,
                                             &vid_sip);

                assert(FALSE == b_result);

                ///

                is_enable = FALSE;

                for (i = 0; i < SYS_ADPT_DHCPSNP_MAX_NBR_OF_CLIENT_PER_PORT; ++ i)
                {
                    vid_sip.sa[0] = 0x01;
                    vid_sip.sa[1] = 0x02;
                    vid_sip.sa[2] = 0x03;
                    vid_sip.sa[3] = 0x04;
                    vid_sip.sa[4] = 0x05;
                    vid_sip.sa[5] = i;

                    vid_sip.vid  = i;

                    vid_sip.sip  = i;

                    b_result = RULE_CTRL_Service(is_enable,
                                                 RULE_CTRL_IP_SOURCE_GUARD_PERMIT_SA_VID_SIP,
                                                 &vid_sip);

                    assert(TRUE == b_result);
                }
            }

        }
    }

#endif // SYS_CPNT_IP_SOURCE_GUARD

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_IpSrcGrd_Permit_VID_SIP_Rule_Status(
    BOOL_T is_enable,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    const RULE_CTRL_UnitPortVidSip_T *vid_sip_p)
{
    if (TRUE == is_enable)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        assert(1 == RULE_CTRL_UT_Proc_Count_Of_Rule_Instance(class_inst_p));

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        assert(0 != rule_inst_p->dev_rule_info.rule_id);
        assert(TRUE == rule_inst_p->active);

        rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
        assert(NULL != rule_entry_p);

        if (0 != vid_sip_p->vid)
        {
            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Vlan(&rule_entry_p->rule_pattern, vid_sip_p->vid, 0xffff);
        }

        if (0 != vid_sip_p->sip)
        {
            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Source_Address(&rule_entry_p->rule_pattern, vid_sip_p->sip, 0xffffffff);
        }

        {
            DEVRM_PCE_T *pce;
            RULE_CTRL_PCL_CFG_T pcl_cfg;

            BOOL_T b_result;

            CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
            CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
            CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
            CPSS_DXCH_PCL_ACTION_STC action;
            UI32_T ui32_result;

            b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                    rule_inst_p->dev_rule_info.rule_id,
                                    &pce);
            assert(TRUE == b_result);
            assert(NULL != pce);

            assert(-1 == pce->policer_idx);

            RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                        remapped_pkt_type, &pcl_cfg);
            assert(pce->pcl_id == pcl_cfg.pcl_id);

            assert(TRUE == RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce));

            ui32_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                         pce,
                                                         &ruleFormat, &mask_u, &pattern_u, &action);
            assert(ui32_result == RULE_TYPE_OK);

            {
                CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                assert(pattern->common.pclId == pcl_cfg.pcl_id);
                assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                if (0 != vid_sip_p->vid)
                {
                    assert(L_STDLIB_Hton16(vid_sip_p->vid) == pattern->common.vid);
                    assert(L_STDLIB_Hton16(0xfff) == mask->common.vid);
                }
                else
                {
                    assert(0 == pattern->common.vid);
                    assert(0 == mask->common.vid);
                }

                if (0 != vid_sip_p->sip)
                {
                    assert(L_STDLIB_Hton32(vid_sip_p->sip) == pattern->sip.u32Ip);
                    assert(L_STDLIB_Hton32(0xffffffff) == mask->sip.u32Ip);
                }
                else
                {
                    assert(0 == pattern->sip.u32Ip);
                    assert(0 == mask->sip.u32Ip);
                }

                assert(L_STDLIB_Hton16(0x0800) == pattern->etherType);
                assert(L_STDLIB_Hton16(0xffff) == mask->etherType);
            }

            assert(CPSS_PACKET_CMD_FORWARD_E == action.pktCmd);
            assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);
            assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
            assert(GT_FALSE == action.vlan.nestedVlan);
        }
    }
    else
    {
        assert(NULL == class_inst_p);
    }
}

int
RULE_CTRL_UT_Add_IpSrcGrd_Permit_VID_SIP_Rule()
{
#if (SYS_CPNT_IP_SOURCE_GUARD == TRUE)
    enum
    {
        MAX_UNIT = 1,
        MAX_PORT = 2,
        MAX_RETRY = 2
    };

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_SA_SIP_VID;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;
    UI32_T i;

    RULE_CTRL_UnitPortVidSip_T vid_sip;

    BOOL_T is_enable;

    BOOL_T b_result;

#if (SYS_CPNT_IPSG_STRICT_MODE == TRUE)
    remapped_pkt_type = RULE_TYPE_PACKET_IP_SG_PERMIT_HOST_STRICT;
#endif /* SYS_CPNT_IPSG_STRICT_MODE */

    memset(&interface, 0, sizeof(interface));

    for (interface.uport.unit = 1; interface.uport.unit <= MAX_UNIT;
         ++interface.uport.unit)
    {
        for (interface.uport.port = 1; interface.uport.port <= MAX_PORT;
                                                         ++interface.uport.port)
        {
            interface.type = RULE_TYPE_INTERFACE_UPORT;
            interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

            is_enable = TRUE;

            vid_sip.unit = interface.uport.unit;
            vid_sip.port = interface.uport.port;
            vid_sip.vid  = 1000;
            vid_sip.sip  = 0x01020304;

            b_result = RULE_CTRL_Service(is_enable,
                                         RULE_CTRL_IP_SOURCE_GUARD_PERMIT_VID_SIP,
                                         &vid_sip);
            assert(TRUE == b_result);

//          RULE_CTRL_DumpDfltAceByPort_BackDoor(vid_sip.unit, vid_sip.port);

            class_inst_p = NULL;
            result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                      remapped_pkt_type,
                                                                      RULE_TYPE_INST_CPU_IF,
                                                                      remapped_pkt_type,
                                                                      &class_inst_p);
            assert(RULE_TYPE_OK == result);
            assert(NULL != class_inst_p);

            RULE_CTRL_UT_Proc_Validate_IpSrcGrd_Permit_VID_SIP_Rule_Status(is_enable,
                                                                           &interface,
                                                                           remapped_pkt_type,
                                                                           class_inst_p,
                                                                           &vid_sip);

            for (i = 0; i < SYS_ADPT_DHCPSNP_MAX_NBR_OF_CLIENT_PER_PORT + 1; ++ i)
            {
                b_result = RULE_CTRL_Service(is_enable,
                                             RULE_CTRL_IP_SOURCE_GUARD_PERMIT_VID_SIP,
                                             &vid_sip);
                assert(TRUE == b_result);
            }

            is_enable = FALSE;

            b_result = RULE_CTRL_Service(is_enable,
                                         RULE_CTRL_IP_SOURCE_GUARD_PERMIT_VID_SIP,
                                         &vid_sip);
            assert(TRUE == b_result);

            class_inst_p = NULL;
            result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                      remapped_pkt_type,
                                                                      RULE_TYPE_INST_CPU_IF,
                                                                      remapped_pkt_type,
                                                                      &class_inst_p);
            assert(RULE_TYPE_OK != result);
            assert(NULL == class_inst_p);

            RULE_CTRL_UT_Proc_Validate_IpSrcGrd_Permit_VID_SIP_Rule_Status(is_enable,
                                                                           &interface,
                                                                           remapped_pkt_type,
                                                                           class_inst_p,
                                                                           &vid_sip);

            for (retry = 1; retry <= MAX_RETRY; ++ retry)
            {

                //
                // Capacity test
                //

                is_enable = TRUE;
                class_inst_p = NULL;

                for (i = 0; i < SYS_ADPT_DHCPSNP_MAX_NBR_OF_CLIENT_PER_PORT; ++ i)
                {
                    vid_sip.vid  = 1000;
                    vid_sip.sip  = i;

                    b_result = RULE_CTRL_Service(is_enable,
                                                 RULE_CTRL_IP_SOURCE_GUARD_PERMIT_VID_SIP,
                                                 &vid_sip);
                    assert(TRUE == b_result);

                    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                              remapped_pkt_type,
                                                                              RULE_TYPE_INST_CPU_IF,
                                                                              remapped_pkt_type,
                                                                              &class_inst_p);
                    assert(RULE_TYPE_OK == result);
                    assert(NULL != class_inst_p);

                    RULE_CTRL_UT_Proc_Validate_IpSrcGrd_Permit_VID_SIP_Rule_Status(is_enable,
                                                                                   &interface,
                                                                                   remapped_pkt_type,
                                                                                   class_inst_p,
                                                                                   &vid_sip);
                }

                is_enable = TRUE;

                vid_sip.sip  = i;

                b_result = RULE_CTRL_Service(is_enable,
                                             RULE_CTRL_IP_SOURCE_GUARD_PERMIT_VID_SIP,
                                             &vid_sip);

                assert(FALSE == b_result);

                ///

                is_enable = FALSE;

                for (i = 0; i < SYS_ADPT_DHCPSNP_MAX_NBR_OF_CLIENT_PER_PORT; ++ i)
                {
                    vid_sip.vid  = 1000;
                    vid_sip.sip  = i;

                    b_result = RULE_CTRL_Service(is_enable,
                                                 RULE_CTRL_IP_SOURCE_GUARD_PERMIT_VID_SIP,
                                                 &vid_sip);

                    assert(TRUE == b_result);
                }
            }

        }
    }

    //
    // Install all
    //
    for (interface.uport.unit = 1; interface.uport.unit <= MAX_UNIT;
                                                         ++interface.uport.unit)
    {
        for (interface.uport.port = 1; interface.uport.port <= MAX_PORT;
                                                         ++interface.uport.port)
        {
            interface.type = RULE_TYPE_INTERFACE_UPORT;
            interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

            is_enable = TRUE;

            vid_sip.unit = interface.uport.unit;
            vid_sip.port = interface.uport.port;

            for (i = 0; i < SYS_ADPT_DHCPSNP_MAX_NBR_OF_CLIENT_PER_PORT; ++ i)
            {
                vid_sip.vid  = 1000 + i;
                vid_sip.sip  = 0x01020304;

                b_result = RULE_CTRL_Service(is_enable,
                                             RULE_CTRL_IP_SOURCE_GUARD_PERMIT_VID_SIP,
                                             &vid_sip);
                assert(TRUE == b_result);
            }
        }
    }

#endif // SYS_CPNT_IP_SOURCE_GUARD

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_IpSrcGrd_Deny_Any_IP_Rule_Status(
    BOOL_T is_enable,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    const RULE_CTRL_UnitPort_T *param_p)
{
    if (TRUE == is_enable)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        assert(1 == RULE_CTRL_UT_Proc_Count_Of_Rule_Instance(class_inst_p));

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        assert(0 != rule_inst_p->dev_rule_info.rule_id);
        assert(TRUE == rule_inst_p->active);

        rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
        assert(NULL != rule_entry_p);

        RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip(&rule_entry_p->rule_pattern);

        {
            DEVRM_PCE_T *pce;
            RULE_CTRL_PCL_CFG_T pcl_cfg;

            BOOL_T b_result;

            CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
            CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
            CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
            CPSS_DXCH_PCL_ACTION_STC action;
            UI32_T ui32_result;

            b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                    rule_inst_p->dev_rule_info.rule_id,
                                    &pce);
            assert(TRUE == b_result);
            assert(NULL != pce);

            assert(-1 == pce->policer_idx);

            RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                        remapped_pkt_type,
                                                        &pcl_cfg);
            assert(pce->pcl_id == pcl_cfg.pcl_id);

            assert(TRUE == RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce));

            ui32_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                         pce,
                                                         &ruleFormat, &mask_u, &pattern_u, &action);
            assert(ui32_result == RULE_TYPE_OK);

            {
                CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *mask = &mask_u.ruleExtNotIpv6;
                CPSS_DXCH_PCL_RULE_FORMAT_EXT_NOT_IPV6_STC *pattern = &pattern_u.ruleExtNotIpv6;

                assert(pattern->common.pclId == pcl_cfg.pcl_id);
                assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                assert(L_STDLIB_Hton16(0x0800) == pattern->etherType);
                assert(L_STDLIB_Hton16(0xffff) == mask->etherType);
            }

#if (SYS_CPNT_IPSG_STRICT_MODE == TRUE)
            assert(CPSS_PACKET_CMD_DROP_SOFT_E == action.pktCmd);
#else
            assert(CPSS_PACKET_CMD_DROP_HARD_E == action.pktCmd);
#endif /* SYS_CPNT_IPSG_STRICT_MODE */

            assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);
            assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
            assert(GT_FALSE == action.vlan.nestedVlan);
            assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
        }
    }
    else
    {
        assert(NULL == class_inst_p);
    }
}

int
RULE_CTRL_UT_Add_IpSrcGrd_Deny_Any_IP_Rule()
{
#if (SYS_CPNT_IP_SOURCE_GUARD == TRUE)
    enum
    {
        MAX_UNIT = 1,
        MAX_PORT = 2,
        MAX_RETRY = 2
    };

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_IPSG_DENY_IP_ANY;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;

    RULE_CTRL_UnitPort_T    unit_port;

    BOOL_T is_enable;

    BOOL_T b_result;

#if (SYS_CPNT_IPSG_STRICT_MODE == TRUE)
    remapped_pkt_type = RULE_TYPE_PACKET_IP_SG_DENY_IP_ANY_STRICT;
#endif /* SYS_CPNT_IPSG_STRICT_MODE */

    memset(&interface, 0, sizeof(interface));

    for (interface.uport.unit = 1; interface.uport.unit <= MAX_UNIT;
                                                        ++ interface.uport.unit)
    {
        for (interface.uport.port = 1; interface.uport.port <= MAX_PORT;
                                                        ++ interface.uport.port)
        {
            interface.type = RULE_TYPE_INTERFACE_UPORT;
            interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

            for (retry = 1; retry <= MAX_RETRY; ++ retry)
            {
                is_enable = TRUE;

                memset(&unit_port, 0, sizeof(unit_port));

                unit_port.unit = interface.uport.unit;
                unit_port.port = interface.uport.port;

                b_result = RULE_CTRL_Service(is_enable,
                                             RULE_CTRL_IP_SOURCE_GUARD_DENY_IP,
                                             &unit_port);
                assert(TRUE == b_result);

//              RULE_CTRL_DumpDfltAceByPort_BackDoor(unit_port.unit, unit_port.port);

                class_inst_p = NULL;
                result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                          remapped_pkt_type,
                                                                          RULE_TYPE_INST_CPU_IF,
                                                                          remapped_pkt_type,
                                                                          &class_inst_p);
                assert(RULE_TYPE_OK == result);
                assert(NULL != class_inst_p);

                RULE_CTRL_UT_Proc_Validate_IpSrcGrd_Deny_Any_IP_Rule_Status(is_enable,
                                                                            &interface,
                                                                            remapped_pkt_type,
                                                                            class_inst_p,
                                                                            &unit_port);

                //
                //
                //

                is_enable = TRUE;

                b_result = RULE_CTRL_Service(is_enable,
                                             RULE_CTRL_IP_SOURCE_GUARD_DENY_IP,
                                             &unit_port);
                assert(TRUE == b_result);

                //
                // Remove
                //

                is_enable = FALSE;

                b_result = RULE_CTRL_Service(is_enable,
                                             RULE_CTRL_IP_SOURCE_GUARD_DENY_IP,
                                             &unit_port);
                assert(TRUE == b_result);

                class_inst_p = NULL;
                result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                          remapped_pkt_type,
                                                                          RULE_TYPE_INST_CPU_IF,
                                                                          remapped_pkt_type,
                                                                          &class_inst_p);
                assert(RULE_TYPE_OK != result);
                assert(NULL == class_inst_p);

                RULE_CTRL_UT_Proc_Validate_IpSrcGrd_Deny_Any_IP_Rule_Status(is_enable,
                                                                            &interface,
                                                                            remapped_pkt_type,
                                                                            class_inst_p,
                                                                            &unit_port);
            }
        }
    }

#endif // SYS_CPNT_IP_SOURCE_GUARD

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_Ip6SrcGrd_Permit_VID_SIP6_Rule_Status(
    BOOL_T is_enable,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    UI32_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    const RULE_CTRL_UnitPortVidSip6_T *vid_sip_p)
{
    if (TRUE == is_enable)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        UI8_T sip6_mask[] =
        {
            0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff
        };

        assert(NULL != class_inst_p);
        assert(1 == RULE_CTRL_UT_Proc_Count_Of_Rule_Instance(class_inst_p));

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        assert(0 != rule_inst_p->dev_rule_info.rule_id);
        assert(TRUE == rule_inst_p->active);

        rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
        assert(NULL != rule_entry_p);

        RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Vlan(&rule_entry_p->rule_pattern, vid_sip_p->vid, 0xffff);
        RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6_Source_Address(&rule_entry_p->rule_pattern, vid_sip_p->sip6, sip6_mask);

        {
            DEVRM_PCE_T *pce;
            RULE_CTRL_PCL_CFG_T pcl_cfg;

            BOOL_T b_result;

            CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
            CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
            CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
            CPSS_DXCH_PCL_ACTION_STC action;
            UI32_T ui32_result;

            b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                    rule_inst_p->dev_rule_info.rule_id,
                                    &pce);
            assert(TRUE == b_result);
            assert(NULL != pce);

            assert(-1 == pce->policer_idx);

            RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                        remapped_pkt_type,
                                                        &pcl_cfg);
            assert(pce->pcl_id == pcl_cfg.pcl_id);

            assert(TRUE == RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce));

            ui32_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                         pce,
                                                         &ruleFormat, &mask_u, &pattern_u, &action);
            assert(ui32_result == RULE_TYPE_OK);

            {
                CPSS_DXCH_PCL_RULE_FORMAT_EXT_IPV6_L2_STC *mask = &mask_u.ruleExtIpv6L2;
                CPSS_DXCH_PCL_RULE_FORMAT_EXT_IPV6_L2_STC *pattern = &pattern_u.ruleExtIpv6L2;

                assert(pattern->common.pclId == pcl_cfg.pcl_id);
                assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                assert(L_STDLIB_Hton16(vid_sip_p->vid) == pattern->common.vid);
                assert(L_STDLIB_Hton16(0xfff) == mask->common.vid);

                assert(0 == memcmp(vid_sip_p->sip6, pattern->sip.arIP, SYS_ADPT_IPV6_ADDR_LEN));
                assert(0xffffffff == mask->sip.u32Ip[0]);
                assert(0xffffffff == mask->sip.u32Ip[1]);
                assert(0xffffffff == mask->sip.u32Ip[2]);
                assert(0xffffffff == mask->sip.u32Ip[3]);
            }

            assert(CPSS_PACKET_CMD_FORWARD_E == action.pktCmd);
            assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);
            assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
            assert(GT_FALSE == action.vlan.nestedVlan);
            assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
        }
    }
    else
    {
        assert(NULL == class_inst_p);
    }
}

int
RULE_CTRL_UT_Add_Ip6SrcGrd_Permit_VID_SIP6_Rule()
{
#if (SYS_CPNT_IPV6_SOURCE_GUARD == TRUE)
    enum
    {
        MAX_UNIT = 1,
        MAX_PORT = 2,
        MAX_RETRY = 2,
    };

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_SIP6_VID;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;
    UI32_T i;

    RULE_CTRL_UnitPortVidSip6_T vid_sip6;

    BOOL_T is_enable;

    BOOL_T b_result;

#if (SYS_CPNT_IPSG_STRICT_MODE == TRUE)
    remapped_pkt_type = RULE_TYPE_PACKET_IP6_SG_PERMIT_HOST_STRICT;
#endif /* SYS_CPNT_IPSG_STRICT_MODE */

    memset(&interface, 0, sizeof(interface));

    for (interface.uport.unit = 1; interface.uport.unit <= MAX_UNIT;
                                                        ++ interface.uport.unit)
    {
        for (interface.uport.port = 1; interface.uport.port <= MAX_PORT;
                                                        ++ interface.uport.port)
        {
            interface.type = RULE_TYPE_INTERFACE_UPORT;
            interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

            is_enable = TRUE;

            memset(&vid_sip6, 0, sizeof(vid_sip6));

            vid_sip6.unit = interface.uport.unit;
            vid_sip6.port = interface.uport.port;
            vid_sip6.vid  = 1000;
            vid_sip6.sip6[0] = 0x20;
            vid_sip6.sip6[1] = 0x00;
            vid_sip6.sip6[15] = 0x01;

            b_result = RULE_CTRL_Service(is_enable,
                                         RULE_CTRL_IPV6_SOURCE_GUARD_PERMIT_VID_SIP6, &vid_sip6);
            assert(TRUE == b_result);

//          RULE_CTRL_DumpDfltAceByPort_BackDoor(vid_sip6.unit, vid_sip6.port);

            class_inst_p = NULL;
            result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                      remapped_pkt_type,
                                                                      RULE_TYPE_INST_CPU_IF,
                                                                      remapped_pkt_type,
                                                                      &class_inst_p);
            assert(RULE_TYPE_OK == result);
            assert(NULL != class_inst_p);

            RULE_CTRL_UT_Proc_Validate_Ip6SrcGrd_Permit_VID_SIP6_Rule_Status(is_enable,
                                                                             &interface,
                                                                             remapped_pkt_type,
                                                                             class_inst_p,
                                                                             &vid_sip6);

            //
            // Always success due to same key
            //
            for (i = 0; i < SYS_ADPT_DHCPSNP_MAX_NBR_OF_CLIENT_PER_PORT + 1; ++ i)
            {
                b_result = RULE_CTRL_Service(is_enable,
                                             RULE_CTRL_IPV6_SOURCE_GUARD_PERMIT_VID_SIP6, &vid_sip6);
                assert(TRUE == b_result);
            }

            is_enable = FALSE;

            b_result = RULE_CTRL_Service(is_enable,
                                         RULE_CTRL_IPV6_SOURCE_GUARD_PERMIT_VID_SIP6, &vid_sip6);

            assert(TRUE == b_result);

            class_inst_p = NULL;
            result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                      remapped_pkt_type,
                                                                      RULE_TYPE_INST_CPU_IF,
                                                                      remapped_pkt_type,
                                                                      &class_inst_p);
            assert(RULE_TYPE_OK != result);
            assert(NULL == class_inst_p);

            RULE_CTRL_UT_Proc_Validate_Ip6SrcGrd_Permit_VID_SIP6_Rule_Status(is_enable,
                                                                             &interface,
                                                                             remapped_pkt_type,
                                                                             class_inst_p,
                                                                             &vid_sip6);

            for (retry = 1; retry <= MAX_RETRY; ++ retry)
            {
                //
                // Capacity test
                //
                is_enable = TRUE;
                class_inst_p = NULL;

                for (i = 0; i < SYS_ADPT_DHCPSNP_MAX_NBR_OF_CLIENT_PER_PORT; ++ i)
                {
                    vid_sip6.vid  = 1000;
                    vid_sip6.sip6[0] = 0x20;
                    vid_sip6.sip6[1] = 0x20;
                    vid_sip6.sip6[15] = i;

                    b_result = RULE_CTRL_Service(is_enable,
                                                 RULE_CTRL_IPV6_SOURCE_GUARD_PERMIT_VID_SIP6, &vid_sip6);

                    assert(TRUE == b_result);

                    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                              remapped_pkt_type,
                                                                              RULE_TYPE_INST_CPU_IF,
                                                                              remapped_pkt_type,
                                                                              &class_inst_p);
                    assert(RULE_TYPE_OK == result);
                    assert(NULL != class_inst_p);

                    RULE_CTRL_UT_Proc_Validate_Ip6SrcGrd_Permit_VID_SIP6_Rule_Status(is_enable,
                                                                                     &interface,
                                                                                     remapped_pkt_type,
                                                                                     class_inst_p,
                                                                                     &vid_sip6);
                }

                is_enable = TRUE;

                vid_sip6.vid  = 1000;
                vid_sip6.sip6[0] = 0x20;
                vid_sip6.sip6[1] = 0x20;
                vid_sip6.sip6[15] = i;

                b_result = RULE_CTRL_Service(is_enable,
                                             RULE_CTRL_IPV6_SOURCE_GUARD_PERMIT_VID_SIP6, &vid_sip6);

                assert(FALSE == b_result);

                is_enable = FALSE;

                for (i = 0; i < SYS_ADPT_DHCPSNP_MAX_NBR_OF_CLIENT_PER_PORT; ++ i)
                {
                    vid_sip6.vid  = 1000;
                    vid_sip6.sip6[0] = 0x20;
                    vid_sip6.sip6[1] = 0x20;
                    vid_sip6.sip6[15] = i;

                    b_result = RULE_CTRL_Service(is_enable,
                                                 RULE_CTRL_IPV6_SOURCE_GUARD_PERMIT_VID_SIP6, &vid_sip6);

                    assert(TRUE == b_result);
                }

            }

        }
    }

#endif // SYS_CPNT_IPV6_SOURCE_GUARD

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_Ip6SrcGrd_Deny_Any_IP6_Rule_Status(
    BOOL_T is_enable,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    UI32_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    const RULE_CTRL_UnitPort_T *param_p)
{
    if (TRUE == is_enable)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);
        assert(1 == RULE_CTRL_UT_Proc_Count_Of_Rule_Instance(class_inst_p));

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        assert(0 != rule_inst_p->dev_rule_info.rule_id);
        assert(TRUE == rule_inst_p->active);

        rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
        assert(NULL != rule_entry_p);

        RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6(&rule_entry_p->rule_pattern);

        {
            DEVRM_PCE_T *pce;
            RULE_CTRL_PCL_CFG_T pcl_cfg;

            BOOL_T b_result;

            CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
            CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
            CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
            CPSS_DXCH_PCL_ACTION_STC action;

            b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                    rule_inst_p->dev_rule_info.rule_id,
                                    &pce);
            assert(TRUE == b_result);
            assert(NULL != pce);

            assert(-1 == pce->policer_idx);

            RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                        remapped_pkt_type,
                                                        &pcl_cfg);
            assert(pce->pcl_id == pcl_cfg.pcl_id);

            assert(TRUE == RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce));

            result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                    pce,
                                                    &ruleFormat, &mask_u, &pattern_u, &action);
            assert(RULE_TYPE_OK == result);

            {
                CPSS_DXCH_PCL_RULE_FORMAT_EXT_IPV6_L2_STC *mask = &mask_u.ruleExtIpv6L2;
                CPSS_DXCH_PCL_RULE_FORMAT_EXT_IPV6_L2_STC *pattern = &pattern_u.ruleExtIpv6L2;

                assert(pattern->common.pclId == pcl_cfg.pcl_id);
                assert(mask->common.pclId == pcl_cfg.pcl_id_mask);
            }

#if (SYS_CPNT_IPSG_STRICT_MODE == TRUE)
            assert(CPSS_PACKET_CMD_DROP_SOFT_E == action.pktCmd);
#else
            assert(CPSS_PACKET_CMD_DROP_HARD_E == action.pktCmd);
#endif /* SYS_CPNT_IPSG_STRICT_MODE */

            assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);
            assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
            assert(GT_FALSE == action.vlan.nestedVlan);
            assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
        }
    }
    else
    {
        assert(NULL == class_inst_p);
    }
}

int
RULE_CTRL_UT_Add_Ip6SrcGrd_Deny_Any_IP6_Rule()
{
#if (SYS_CPNT_IPV6_SOURCE_GUARD == TRUE)
    enum
    {
        MAX_UNIT = 1,
        MAX_PORT = 2,
        MAX_RETRY = 2,
    };

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_IP6_ANY;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;

    RULE_CTRL_UnitPort_T    unit_port;


    BOOL_T is_enable;

    BOOL_T b_result;

#if (SYS_CPNT_IPSG_STRICT_MODE == TRUE)
    remapped_pkt_type = RULE_TYPE_PACKET_IP6_SG_DENY_IP6_ANY_STRICT;
#endif /* SYS_CPNT_IPSG_STRICT_MODE */

    memset(&interface, 0, sizeof(interface));

    for (interface.uport.unit = 1; interface.uport.unit <= MAX_UNIT;
                                                        ++ interface.uport.unit)
    {
        for (interface.uport.port = 1; interface.uport.port <= MAX_PORT;
                                                        ++ interface.uport.port)
        {
            interface.type = RULE_TYPE_INTERFACE_UPORT;
            interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

            for (retry = 1; retry <= MAX_RETRY; ++ retry)
            {
                is_enable = TRUE;

                memset(&unit_port, 0, sizeof(unit_port));

                unit_port.unit = interface.uport.unit;
                unit_port.port = interface.uport.port;

                b_result = RULE_CTRL_Service(is_enable,
                                             RULE_CTRL_IPV6_SOURCE_GUARD_DENY_IP6, &unit_port);
                assert(TRUE == b_result);

//              RULE_CTRL_DumpDfltAceByPort_BackDoor(unit_port.unit, unit_port.port);

                class_inst_p = NULL;
                result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                          remapped_pkt_type,
                                                                          RULE_TYPE_INST_CPU_IF,
                                                                          remapped_pkt_type,
                                                                          &class_inst_p);
                assert(RULE_TYPE_OK == result);
                assert(NULL != class_inst_p);

                RULE_CTRL_UT_Proc_Validate_Ip6SrcGrd_Deny_Any_IP6_Rule_Status(is_enable,
                                                                              &interface,
                                                                              remapped_pkt_type,
                                                                              class_inst_p,
                                                                              &unit_port);

                is_enable = TRUE;

                b_result = RULE_CTRL_Service(is_enable,
                                             RULE_CTRL_IPV6_SOURCE_GUARD_DENY_IP6, &unit_port);
                assert(TRUE == b_result);

                //
                // Remove
                //

                is_enable = FALSE;

                b_result = RULE_CTRL_Service(is_enable,
                                             RULE_CTRL_IPV6_SOURCE_GUARD_DENY_IP6, &unit_port);
                assert(TRUE == b_result);

                class_inst_p = NULL;
                result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                          remapped_pkt_type,
                                                                          RULE_TYPE_INST_CPU_IF,
                                                                          remapped_pkt_type,
                                                                          &class_inst_p);
                assert(RULE_TYPE_OK != result);
                assert(NULL == class_inst_p);

                RULE_CTRL_UT_Proc_Validate_Ip6SrcGrd_Deny_Any_IP6_Rule_Status(is_enable,
                                                                              &interface,
                                                                              remapped_pkt_type,
                                                                              class_inst_p,
                                                                              &unit_port);
            }
        }
    }

#endif // SYS_CPNT_IPV6_SOURCE_GUARD

    return 0;
}

#if (SYS_CPNT_IPV6_SOURCE_GUARD == TRUE)
void
RULE_CTRL_UT_Proc_Validate_PermitIPv6LinkLocal_Rule_Status(
    BOOL_T is_enable,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    UI32_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p)
{
    if (TRUE == is_enable)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;
        UI8_T addr[SYS_ADPT_IPV6_ADDR_LEN] =
        {
            0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        };
        UI8_T mask[SYS_ADPT_IPV6_ADDR_LEN] =
        {
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        };

        assert(NULL != class_inst_p);

        assert(DEVRM_PMGR_GetNumberOfChips() == RULE_CTRL_UT_Proc_Count_Of_Rule_Instance(class_inst_p));

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        assert(0 != rule_inst_p->dev_rule_info.rule_id);
        assert(TRUE == rule_inst_p->active);

        rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
        assert(NULL != rule_entry_p);

        RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6(&rule_entry_p->rule_pattern);
        RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6_Source_Address(&rule_entry_p->rule_pattern,
                                                                          addr,
                                                                          mask);

        {
            DEVRM_PCE_T *pce;
            RULE_CTRL_PCL_CFG_T pcl_cfg;

            BOOL_T b_result;

            CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
            CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
            CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
            CPSS_DXCH_PCL_ACTION_STC action;

            b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                    rule_inst_p->dev_rule_info.rule_id,
                                    &pce);
            assert(TRUE == b_result);
            assert(NULL != pce);

            assert(-1 == pce->policer_idx);

            RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                        remapped_pkt_type,
                                                        &pcl_cfg);
            assert(pce->pcl_id == pcl_cfg.pcl_id);

            assert(TRUE == RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce));

            result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                    pce,
                                                    &ruleFormat, &mask_u, &pattern_u, &action);
            assert(RULE_TYPE_OK == result);

            {
                CPSS_DXCH_PCL_RULE_FORMAT_EXT_IPV6_L2_STC *mask = &mask_u.ruleExtIpv6L2;
                CPSS_DXCH_PCL_RULE_FORMAT_EXT_IPV6_L2_STC *pattern = &pattern_u.ruleExtIpv6L2;

                assert(pattern->common.pclId == pcl_cfg.pcl_id);
                assert(mask->common.pclId == pcl_cfg.pcl_id_mask);
            }

            assert(CPSS_PACKET_CMD_FORWARD_E == action.pktCmd);

            assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);
            assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
            assert(GT_FALSE == action.vlan.nestedVlan);
            assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
        }
    }
    else
    {
        assert(NULL == class_inst_p);
    }
}
#endif /* SYS_CPNT_IPV6_SOURCE_GUARD */

int
RULE_CTRL_UT_PermitIPv6LinkLocal()
{
#if (SYS_CPNT_IPV6_SOURCE_GUARD == TRUE)
    RULE_TYPE_RETURN_TYPE_T result;
    RULE_TYPE_INTERFACE_INFO_T interface;
    UI32_T remapped_pkt_type;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;
    BOOL_T is_enable = TRUE;

    remapped_pkt_type = RULE_TYPE_PACKET_IP6SG_PERMIT_LINKLOCAL;

#if (SYS_CPNT_IPSG_STRICT_MODE == TRUE)
    remapped_pkt_type = RULE_TYPE_PACKET_IP6SG_PERMIT_LINKLOCAL_STRICT;
#endif /* SYS_CPNT_IPSG_STRICT_MODE */

    memset(&interface, 0, sizeof(interface));

    result = RULE_CTRL_IPV6SG_PermitIp6LinkLocal(is_enable);
    assert(result == RULE_TYPE_OK);

    interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
    interface.direction = RULE_TYPE_INBOUND;


    //RULE_CTRL_DumpFunctionInfo();

    class_inst_p = NULL;
    result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                              remapped_pkt_type,
                                                              RULE_TYPE_INST_CPU_IF,
                                                              remapped_pkt_type,
                                                              &class_inst_p);
    assert(RULE_TYPE_OK == result);
    assert(NULL != class_inst_p);

    RULE_CTRL_UT_Proc_Validate_PermitIPv6LinkLocal_Rule_Status(is_enable,
                                                               &interface,
                                                               remapped_pkt_type,
                                                               class_inst_p);

#endif /* SYS_CPNT_IPV6_SOURCE_GUARD */
    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_IGMPSNP_Deny_Multicast_Data(
    BOOL_T enable_flag,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p)
{
#define RULE_CTRL_PROT_UDP          17

    UI8_T ipmc_addr[] = {0xe0, 0, 0, 0};
    UI8_T ipmc_addr_mask[] = {0xf0, 0, 0, 0};

    if (TRUE == enable_flag)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);
        assert(1 == RULE_CTRL_UT_Proc_Count_Of_Rule_Instance(class_inst_p));

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        assert(0 != rule_inst_p->dev_rule_info.rule_id);
        assert(TRUE == rule_inst_p->active);

        rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
        assert(NULL != rule_entry_p);

        RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Dest_Address(&rule_entry_p->rule_pattern,
                                                                L_STDLIB_Ntoh32(* (UI32_T *) ipmc_addr),
                                                                L_STDLIB_Ntoh32(* (UI32_T *) ipmc_addr_mask));
        RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Udp(&rule_entry_p->rule_pattern);


        {
            DEVRM_PCE_T *pce;
            DEVRM_PCL_T *pcl;

            RULE_CTRL_PCL_CFG_T pcl_cfg;

            CPSS_DXCH_POLICER_STAGE_TYPE_ENT policer_stage;

            BOOL_T b_result;

            result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                 remapped_pkt_type,
                                                                 &pcl_cfg);
            assert(RULE_TYPE_OK == result);

            b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                    rule_inst_p->dev_rule_info.rule_id,
                                    &pce);
            assert(TRUE == b_result);
            assert(NULL != pce);
            assert(-1 == pce->policer_idx);

            pcl = DEVRM_GetPcl(rule_inst_p->dev_rule_info.device, pce->pcl_id);
            assert(NULL != pcl);

            DEVRM_GetPolicerStageFromPce(rule_inst_p->dev_rule_info.device, pce, &policer_stage);

            {
                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT  ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT       pattern_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT       mask_u;
                CPSS_DXCH_PCL_ACTION_STC            action;

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(RULE_TYPE_OK == result);

                assert(pce->pcl_id == pattern_u.ruleExtNotIpv6.common.pclId);

                assert(pcl_cfg.pcl_id == pattern_u.ruleExtNotIpv6.common.pclId);
                assert(pcl_cfg.pcl_id_mask == mask_u.ruleExtNotIpv6.common.pclId);

                assert(* (UI32_T *) ipmc_addr      == pattern_u.ruleExtNotIpv6.dip.u32Ip);
                assert(* (UI32_T *) ipmc_addr_mask == mask_u.ruleExtNotIpv6.dip.u32Ip);

                assert(L_STDLIB_Hton16(0x0800) == pattern_u.ruleExtNotIpv6.etherType);
                assert(L_STDLIB_Hton16(0xffff) == mask_u.ruleExtNotIpv6.etherType);

                assert(RULE_CTRL_PROT_UDP == pattern_u.ruleExtNotIpv6.commonExt.ipProtocol);
                assert(0xff == mask_u.ruleExtNotIpv6.commonExt.ipProtocol);

                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);
                assert(CPSS_PACKET_CMD_DROP_HARD_E == action.pktCmd);

                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);

            }
        }
    }
    else
    {
        assert(NULL == class_inst_p);
    }

#undef RULE_CTRL_PROT_UDP
}

int
RULE_CTRL_UT_IGMPSNP_Deny_Multicast_Data()
{
#if (SYS_CPNT_IP_MULTICAST_DATA_DROP == TRUE) || (SYS_CPNT_MVR == TRUE)
    enum
    {
        MAX_UNIT = 1,
        MAX_PORT = 2,
        MAX_RETRY = 2,
    };

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_IP_MULTICAST_DATA_DROP;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;

    BOOL_T is_enable;

    BOOL_T b_result;

    memset(&interface, 0, sizeof(interface));

    for (interface.uport.unit = 1; interface.uport.unit <= MAX_UNIT;
                                                        ++ interface.uport.unit)
    {
        for (interface.uport.port = 1; interface.uport.port <= MAX_PORT;
                                                        ++ interface.uport.port)
        {
            interface.type = RULE_TYPE_INTERFACE_UPORT;
            interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

            for (retry = 1; retry <= MAX_RETRY; ++ retry)
            {
                is_enable = TRUE;

                b_result = RULE_CTRL_IGMPSNP_DenyMulticastData(is_enable,
                                                               interface.uport.unit,
                                                               interface.uport.port);
                assert(TRUE == b_result);

//              RULE_CTRL_DumpDfltAceByPort_BackDoor(unit, port);

                class_inst_p = NULL;
                b_result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                            remapped_pkt_type,
                                                                            RULE_TYPE_INST_CPU_IF,
                                                                            remapped_pkt_type,
                                                                            &class_inst_p);
                assert(RULE_TYPE_OK == b_result);
                assert(NULL != class_inst_p);

                RULE_CTRL_UT_Proc_Validate_IGMPSNP_Deny_Multicast_Data(is_enable,
                                                                       &interface,
                                                                       remapped_pkt_type,
                                                                       class_inst_p);

                is_enable = TRUE;

                b_result = RULE_CTRL_IGMPSNP_DenyMulticastData(is_enable,
                                                               interface.uport.unit,
                                                               interface.uport.port);
                assert(TRUE == b_result);

                //
                // Remove
                //

                is_enable = FALSE;

                b_result = RULE_CTRL_IGMPSNP_DenyMulticastData(is_enable,
                                                               interface.uport.unit,
                                                               interface.uport.port);
                assert(TRUE == b_result);

                class_inst_p = NULL;
                b_result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                            remapped_pkt_type,
                                                                            RULE_TYPE_INST_CPU_IF,
                                                                            remapped_pkt_type,
                                                                            &class_inst_p);
                assert(RULE_TYPE_OK != b_result);
                assert(NULL == class_inst_p);

                RULE_CTRL_UT_Proc_Validate_IGMPSNP_Deny_Multicast_Data(is_enable,
                                                                       &interface,
                                                                       remapped_pkt_type,
                                                                       class_inst_p);
            }
        }
    }

#endif /* SYS_CPNT_IP_MULTICAST_DATA_DROP || SYS_CPNT_MVR */

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_IP6_Deny_Multicast_Data(
    BOOL_T enable_flag,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p)
{
#define RULE_CTRL_PROT_UDP          17

    if (TRUE == enable_flag)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        UI8_T ip_addr[] =
            {
                0xff, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00,
            };

        UI8_T mask_addr[] =
        {
            0xff, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        };

        assert(NULL != class_inst_p);
        assert(1 == RULE_CTRL_UT_Proc_Count_Of_Rule_Instance(class_inst_p));

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        assert(0 != rule_inst_p->dev_rule_info.rule_id);
        assert(TRUE == rule_inst_p->active);

        rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
        assert(NULL != rule_entry_p);

        RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6_Dest_Address(&rule_entry_p->rule_pattern, ip_addr, mask_addr);

        {
            DEVRM_PCE_T *pce;
            DEVRM_PCL_T *pcl;

            RULE_CTRL_PCL_CFG_T pcl_cfg;

            CPSS_DXCH_POLICER_STAGE_TYPE_ENT policer_stage;

            BOOL_T b_result;

            result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                 remapped_pkt_type,
                                                                 &pcl_cfg);
            assert(RULE_TYPE_OK == result);

            b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                    rule_inst_p->dev_rule_info.rule_id,
                                    &pce);
            assert(TRUE == b_result);
            assert(NULL != pce);
            assert(-1 == pce->policer_idx);

            pcl = DEVRM_GetPcl(rule_inst_p->dev_rule_info.device, pce->pcl_id);
            assert(NULL != pcl);

            DEVRM_GetPolicerStageFromPce(rule_inst_p->dev_rule_info.device,
                                         pce, &policer_stage);

            {
                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT  ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT       pattern_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT       mask_u;
                CPSS_DXCH_PCL_ACTION_STC            action;

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(RULE_TYPE_OK == result);

                assert(pce->pcl_id == pattern_u.ruleExtIpv6L2.common.pclId);

                assert(pcl_cfg.pcl_id == pattern_u.ruleExtIpv6L2.common.pclId);
                assert(pcl_cfg.pcl_id_mask == mask_u.ruleExtIpv6L2.common.pclId);

                assert(0xff == pattern_u.ruleExtIpv6L2.dipBits127to120);
                assert(0xff == mask_u.ruleExtIpv6L2.dipBits127to120);

                assert(RULE_CTRL_PROT_UDP == pattern_u.ruleExtIpv6L2.commonExt.ipProtocol);
                assert(0xff == mask_u.ruleExtIpv6L2.commonExt.ipProtocol);

                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);
                assert(CPSS_PACKET_CMD_DROP_HARD_E == action.pktCmd);

                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
            }
        }
    }
    else
    {
        assert(NULL == class_inst_p);
    }

#undef RULE_CTRL_PROT_UDP
}

int
RULE_CTRL_UT_IP6_Deny_Multicast_Data()
{
#if (SYS_CPNT_IPV6_MULTICAST_DATA_DROP == TRUE) || (SYS_CPNT_MVR6 == TRUE)
    enum
    {
        MAX_UNIT = 1,
        MAX_PORT = 2,
        MAX_RETRY = 2,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_IP6_MULTICAST_DATA_DROP;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;

    BOOL_T is_enable;

    BOOL_T b_result;

    memset(&interface, 0, sizeof(interface));

    for (interface.uport.unit = 1; interface.uport.unit <= MAX_UNIT;
                                                        ++ interface.uport.unit)
    {
        for (interface.uport.port = 1; interface.uport.port <= MAX_PORT;
                                                        ++ interface.uport.port)
        {
            interface.type = RULE_TYPE_INTERFACE_UPORT;
            interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

            for (retry = 1; retry <= MAX_RETRY; ++ retry)
            {
                is_enable = TRUE;

                result = RULE_CTRL_IPV6_DenyMulticastData(is_enable,
                                                          interface.uport.unit,
                                                          interface.uport.port);
                assert(TRUE == result);

//              RULE_CTRL_DumpDfltAceByPort_BackDoor(unit, port);

                class_inst_p = NULL;
                result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                          remapped_pkt_type,
                                                                          RULE_TYPE_INST_CPU_IF,
                                                                          remapped_pkt_type,
                                                                          &class_inst_p);
                assert(RULE_TYPE_OK == result);
                assert(NULL != class_inst_p);

                RULE_CTRL_UT_Proc_Validate_IP6_Deny_Multicast_Data(is_enable,
                                                                   &interface,
                                                                   remapped_pkt_type,
                                                                   class_inst_p);

                is_enable = TRUE;

                b_result = RULE_CTRL_IPV6_DenyMulticastData(is_enable,
                                                            interface.uport.unit,
                                                            interface.uport.port);
                assert(TRUE == b_result);

                //
                // Remove
                //
                is_enable = FALSE;

                b_result = RULE_CTRL_IPV6_DenyMulticastData(is_enable,
                                                            interface.uport.unit,
                                                            interface.uport.port);
                assert(TRUE == b_result);

                class_inst_p = NULL;
                result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                          remapped_pkt_type,
                                                                          RULE_TYPE_INST_CPU_IF,
                                                                          remapped_pkt_type,
                                                                          &class_inst_p);
                assert(RULE_TYPE_OK != result);
                assert(NULL == class_inst_p);


                RULE_CTRL_UT_Proc_Validate_IP6_Deny_Multicast_Data(is_enable,
                                                                   &interface,
                                                                   remapped_pkt_type,
                                                                   class_inst_p);
            }
        }
    }

#endif /* SYS_CPNT_IPV6_MULTICAST_DATA_DROP || SYS_CPNT_MVR6 */

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_Nd_Status(
    BOOL_T is_enable,
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type,
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    UI32_T icmp6_type)
{
    enum
    {
        UNIT = 1
    };

    if (TRUE == is_enable)
    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_RULE_ENTRY_PTR_T rule_entry_p;

        assert(NULL != class_inst_p);

        rule_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p);
        assert(RULE_TYPE_OK == result);

        do
        {
            assert(0 != rule_inst_p->dev_rule_info.rule_id);
            assert(TRUE == rule_inst_p->active);

            rule_entry_p = RULE_CTRL_UT_Proc_Get_Rule_Entry_Of_Rule(rule_inst_p);
            assert(NULL != rule_entry_p);

            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6_Next_Header(&rule_entry_p->rule_pattern, 58, 0xff);
            RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Icmpv6_Type(&rule_entry_p->rule_pattern, icmp6_type, 0xff);

            if (UNIT == rule_inst_p->dev_rule_info.unit)
            {
                DEVRM_PCE_T *pce;
                RULE_CTRL_PCL_CFG_T pcl_cfg;

                BOOL_T b_result;

                CPSS_DXCH_PCL_RULE_FORMAT_TYPE_ENT ruleFormat;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT mask_u;
                CPSS_DXCH_PCL_RULE_FORMAT_UNT pattern_u;
                CPSS_DXCH_PCL_ACTION_STC action;

                b_result = DEVRM_GetPce(rule_inst_p->dev_rule_info.device,
                                        rule_inst_p->dev_rule_info.rule_id,
                                        &pce);
                assert(TRUE == b_result);
                assert(NULL != pce);

                assert(-1 == pce->policer_idx);

                result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(interface_p,
                                                                     remapped_pkt_type,
                                                                     &pcl_cfg);
                assert(RULE_TYPE_OK == result);
                assert(pce->pcl_id == pcl_cfg.pcl_id);

                b_result = RULE_CTRL_UT_Proc_Get_Sdk_Rule_State(rule_inst_p->dev_rule_info.device,
                                                                pce);
                assert(TRUE == b_result);

                result = RULE_CTRL_UT_Proc_Get_Sdk_Rule(rule_inst_p->dev_rule_info.device,
                                                        pce,
                                                        &ruleFormat, &mask_u, &pattern_u, &action);
                assert(result == RULE_TYPE_OK);

                {
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_IPV6_L2_STC *mask = &mask_u.ruleExtIpv6L2;
                    CPSS_DXCH_PCL_RULE_FORMAT_EXT_IPV6_L2_STC *pattern = &pattern_u.ruleExtIpv6L2;

                    assert(pattern->common.pclId == pcl_cfg.pcl_id);
                    assert(mask->common.pclId == pcl_cfg.pcl_id_mask);

                    assert(icmp6_type == pattern->commonExt.l4Byte0);
                    assert(0xff == mask->commonExt.l4Byte0);
                }

                assert(CPSS_DXCH_PCL_POLICER_DISABLE_ALL_E == action.policer.policerEnable);
                assert(CPSS_PACKET_CMD_TRAP_TO_CPU_E == action.pktCmd);
                assert(CPSS_PACKET_ATTRIBUTE_ASSIGN_DISABLED_E == action.vlan.modifyVlan);
                assert(GT_FALSE == action.vlan.nestedVlan);
                assert(CPSS_PACKET_ATTRIBUTE_MODIFY_KEEP_PREVIOUS_E == action.qos.modifyUp);
            }
        } while (RULE_TYPE_OK == (result = RULE_CTRL_UT_Proc_GetNext_Rule_Instance_Of_Rule(class_inst_p, &rule_inst_p)));
    }
    else
    {
        assert(NULL == class_inst_p);
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
}

int
RULE_CTRL_UT_IP6_Set_Nd_Rs_Packet_To_Cpu()
{
#if (SYS_CPNT_ND_BY_RULE == TRUE)
    enum
    {
        MAX_RETRY = 2,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_IP6_ND_RS;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;

    UI32_T icmp6_type = 133;

    BOOL_T is_enable;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        is_enable = TRUE;

        result = RULE_CTRL_IP6_SetNdRsPacketToCpu(is_enable);
        assert(RULE_TYPE_OK == result);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Nd_Status(is_enable,
                                             &interface,
                                             remapped_pkt_type,
                                             class_inst_p,
                                             icmp6_type);

        //
        // Enable twice
        //
        is_enable = TRUE;

        result = RULE_CTRL_IP6_SetNdRsPacketToCpu(is_enable);
        assert(RULE_TYPE_OK == result);

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Nd_Status(is_enable,
                                             &interface,
                                             remapped_pkt_type,
                                             class_inst_p,
                                             icmp6_type);

        //
        // Remove
        //
        is_enable = FALSE;

        result = RULE_CTRL_IP6_SetNdRsPacketToCpu(is_enable);
        assert(RULE_TYPE_OK == result);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Nd_Status(is_enable,
                                             &interface,
                                             remapped_pkt_type,
                                             class_inst_p,
                                             icmp6_type);
    }
#endif /* SYS_CPNT_ND_BY_RULE */

    return 0;
}

int
RULE_CTRL_UT_IP6_Set_Nd_Ra_Packet_To_Cpu()
{
#if (SYS_CPNT_ND_BY_RULE == TRUE)
    enum
    {
        MAX_RETRY = 2,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_IP6_ND_RA;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;

    UI32_T icmp6_type = 134;

    BOOL_T is_enable;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {

        is_enable = TRUE;

        result = RULE_CTRL_IP6_SetNdRaPacketToCpu(is_enable);
        assert(RULE_TYPE_OK == result);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Nd_Status(is_enable,
                                             &interface,
                                             remapped_pkt_type,
                                             class_inst_p,
                                             icmp6_type);

        //
        // Enable twice
        //
        is_enable = TRUE;

        result = RULE_CTRL_IP6_SetNdRaPacketToCpu(is_enable);
        assert(RULE_TYPE_OK == result);

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Nd_Status(is_enable,
                                             &interface,
                                             remapped_pkt_type,
                                             class_inst_p,
                                             icmp6_type);

        //
        // Remove
        //
        is_enable = FALSE;

        result = RULE_CTRL_IP6_SetNdRaPacketToCpu(is_enable);
        assert(RULE_TYPE_OK == result);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Nd_Status(is_enable,
                                             &interface,
                                             remapped_pkt_type,
                                             class_inst_p,
                                             icmp6_type);
    }

#endif /* SYS_CPNT_ND_BY_RULE */

    return 0;
}

int
RULE_CTRL_UT_IP6_Set_Nd_Ns_Packet_To_Cpu()
{
#if (SYS_CPNT_ND_BY_RULE == TRUE)
    enum
    {
        MAX_RETRY = 2,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_IP6_ND_NS;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;

    UI32_T icmp6_type = 135;

    BOOL_T is_enable;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {

        is_enable = TRUE;

        result = RULE_CTRL_IP6_SetNdNsPacketToCpu(is_enable);
        assert(RULE_TYPE_OK == result);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Nd_Status(is_enable,
                                             &interface,
                                             remapped_pkt_type,
                                             class_inst_p,
                                             icmp6_type);

        //
        // Enable twice
        //
        is_enable = TRUE;

        result = RULE_CTRL_IP6_SetNdNsPacketToCpu(is_enable);
        assert(RULE_TYPE_OK == result);

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Nd_Status(is_enable,
                                             &interface,
                                             remapped_pkt_type,
                                             class_inst_p,
                                             icmp6_type);

        //
        // Remove
        //
        is_enable = FALSE;

        result = RULE_CTRL_IP6_SetNdNsPacketToCpu(is_enable);
        assert(RULE_TYPE_OK == result);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Nd_Status(is_enable,
                                             &interface,
                                             remapped_pkt_type,
                                             class_inst_p,
                                             icmp6_type);
    }

#endif /* SYS_CPNT_ND_BY_RULE */

    return 0;
}

int
RULE_CTRL_UT_IP6_Set_Nd_Na_Packet_To_Cpu()
{
#if (SYS_CPNT_ND_BY_RULE == TRUE)
    enum
    {
        MAX_RETRY = 2,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_IP6_ND_NA;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;

    UI32_T icmp6_type = 136;

    BOOL_T is_enable;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {

        is_enable = TRUE;

        result = RULE_CTRL_IP6_SetNdNaPacketToCpu(is_enable);
        assert(RULE_TYPE_OK == result);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Nd_Status(is_enable,
                                             &interface,
                                             remapped_pkt_type,
                                             class_inst_p,
                                             icmp6_type);

        //
        // Enable twice
        //
        is_enable = TRUE;

        result = RULE_CTRL_IP6_SetNdNaPacketToCpu(is_enable);
        assert(RULE_TYPE_OK == result);

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Nd_Status(is_enable,
                                             &interface,
                                             remapped_pkt_type,
                                             class_inst_p,
                                             icmp6_type);

        //
        // Remove
        //
        is_enable = FALSE;

        result = RULE_CTRL_IP6_SetNdNaPacketToCpu(is_enable);
        assert(RULE_TYPE_OK == result);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Nd_Status(is_enable,
                                             &interface,
                                             remapped_pkt_type,
                                             class_inst_p,
                                             icmp6_type);
    }

#endif /* SYS_CPNT_ND_BY_RULE */

    return 0;
}

int
RULE_CTRL_UT_IP6_Set_Nd_Redirect_Packet_To_Cpu()
{
#if (SYS_CPNT_ND_BY_RULE == TRUE)
    enum
    {
        MAX_RETRY = 2,
    };

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = RULE_TYPE_PACKET_IP6_ND_REDIRECT;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;

    UI32_T retry;

    UI32_T icmp6_type = 137;

    BOOL_T is_enable;

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        is_enable = TRUE;

        result = RULE_CTRL_IP6_SetNdRedirectPacketToCpu(is_enable);
        assert(RULE_TYPE_OK == result);

        //  RULE_CTRL_DumpGlobalAce_BackDoor();

        memset(&interface, 0, sizeof(interface));
        interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
        interface.direction = RULE_TYPE_UNSPEC_DIRECTION;

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Nd_Status(is_enable,
                                             &interface,
                                             remapped_pkt_type,
                                             class_inst_p,
                                             icmp6_type);

        //
        // Enable twice
        //
        is_enable = TRUE;

        result = RULE_CTRL_IP6_SetNdRedirectPacketToCpu(is_enable);
        assert(RULE_TYPE_OK == result);

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK == result);
        assert(NULL != class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Nd_Status(is_enable,
                                             &interface,
                                             remapped_pkt_type,
                                             class_inst_p,
                                             icmp6_type);

        //
        // Remove
        //
        is_enable = FALSE;

        result = RULE_CTRL_IP6_SetNdRedirectPacketToCpu(is_enable);
        assert(RULE_TYPE_OK == result);

        // RULE_CTRL_DumpGlobalAce_BackDoor();

        class_inst_p = NULL;
        result = RULE_CTRL_UT_Proc_GetNext_Class_Instance_Of_Rule(&interface,
                                                                  remapped_pkt_type,
                                                                  RULE_TYPE_INST_CPU_IF,
                                                                  remapped_pkt_type,
                                                                  &class_inst_p);

        assert(RULE_TYPE_OK != result);
        assert(NULL == class_inst_p);

        RULE_CTRL_UT_Proc_Validate_Nd_Status(is_enable,
                                             &interface,
                                             remapped_pkt_type,
                                             class_inst_p,
                                             icmp6_type);
    }

#endif /* SYS_CPNT_ND_BY_RULE */

    return 0;
}

int
RULE_CTRL_UT_Proc_Add_ACL_Rule_On_Eth()
{
    enum
    {
        UNIT = 1,
        PORT = 2,
        MIN_IFINDEX = 1,
        MAX_IFINDEX = SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT, // RULE_TYPE_TOTAL_NBR_OF_UPORT,
        MIN_DIRECTION = RULE_TYPE_INBOUND,
#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
        MAX_DIRECTION = RULE_TYPE_OUTBOUND,
#else
        MAX_DIRECTION = RULE_TYPE_INBOUND,
#endif
        MAX_RETRY = 2,
        TIME_RANGE_INDEX = 0XFFFF,

#if (SYS_CPNT_ACL_COUNTER == TRUE)
        COUNTER_ENABLE_STATUS = RULE_TYPE_COUNTER_ENABLE,
#else
        COUNTER_ENABLE_STATUS = RULE_TYPE_COUNTER_DISABLE,
#endif
    };

    const char *acl_name = "bind_on_eth";
    RULE_TYPE_AclType_T acl_type = RULE_TYPE_MAC_ACL;
    UI32_T acl_index;

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    UI16_T time_range_index;
    RULE_TYPE_COUNTER_ENABLE_T counter_enable;

    UI32_T retry;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_Ace_Entry_T ace_entry;

    result = RULE_OM_CreateAcl(acl_name, acl_type);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetAclIdByName(acl_name, &acl_index);
    assert(RULE_TYPE_OK == result);

    //
    // ace 1
    //
    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_PERMIT;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // ace2
    //
    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_PERMIT;

    ace_entry.u.mac.aceSourceMacAddr[0] = 0xc4;
    ace_entry.u.mac.aceSourceMacAddr[1] = 0x2c;
    ace_entry.u.mac.aceSourceMacAddr[2] = 0x03;

    ace_entry.u.mac.aceSourceMacAddrBitmask[0] = 0xff;
    ace_entry.u.mac.aceSourceMacAddrBitmask[1] = 0xff;
    ace_entry.u.mac.aceSourceMacAddrBitmask[2] = 0xff;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // ace3
    //
    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_PERMIT;

    ace_entry.u.mac.aceSourceMacAddr[0] = 0xc8;
    ace_entry.u.mac.aceSourceMacAddr[1] = 0xbc;
    ace_entry.u.mac.aceSourceMacAddr[2] = 0xc8;

    ace_entry.u.mac.aceSourceMacAddrBitmask[0] = 0xff;
    ace_entry.u.mac.aceSourceMacAddrBitmask[1] = 0xff;
    ace_entry.u.mac.aceSourceMacAddrBitmask[2] = 0xff;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // ace4
    //
    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_DENY;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

#if (SYS_CPNT_ACL_MAC_IP_MIX == TRUE)
    //
    // ace5
    //
    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_SetAcePatternToDefaultByType(&ace_entry, RULE_TYPE_IP_EXT_ACL);
    assert(RULE_TYPE_OK == result);

    //ace_entry.u.mac.access = RULE_TYPE_ACE_PERMIT;
    ace_entry.access = RULE_TYPE_ACE_PERMIT;
    ace_entry.u.mac.aceEtherTypeOp = VAL_diffServMacAceEtherTypeOp_equal;
    ace_entry.u.mac.aceEtherTypeBitmask = MAX_diffServMacAceEtherTypeBitmask;
    ace_entry.u.mac.aceMinEtherType = 0x0800;
    ace_entry.u.mac.aceMaxEtherType = 0x0800;

    //ace_entry.u.ip.aceSourceIpAddr = 0xc0a80001;
    //ace_entry.u.ip.aceSourceIpAddrBitmask = 0xffffffff;
    ace_entry.u.mac.aceMinVid = 1;
    ace_entry.u.mac.aceMaxVid = 1;
    ace_entry.u.mac.aceVidBitmask = 0x0fff;
    ace_entry.u.mac.aceVidOp = 2;
    ace_entry.u.ip.aceProtocol = 2;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);
    //
    // ace6
    //
    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_SetAcePatternToDefaultByType(&ace_entry, RULE_TYPE_IP_EXT_ACL);
    assert(RULE_TYPE_OK == result);

    //ace_entry.u.mac.access = RULE_TYPE_ACE_PERMIT;
    ace_entry.access = RULE_TYPE_ACE_PERMIT;
    ace_entry.u.mac.aceEtherTypeOp = VAL_diffServMacAceEtherTypeOp_equal;
    ace_entry.u.mac.aceEtherTypeBitmask = MAX_diffServMacAceEtherTypeBitmask;
    ace_entry.u.mac.aceMinEtherType = 0x0800;
    ace_entry.u.mac.aceMaxEtherType = 0x0800;
    ace_entry.u.mac.aceMinVid = 1;
    ace_entry.u.mac.aceMaxVid = 1;
    ace_entry.u.mac.aceVidBitmask = 0x0fff;
    ace_entry.u.mac.aceVidOp = 2;

    //ace_entry.u.ip.aceSourceIpAddr = 0xc0a80001;
    //ace_entry.u.ip.aceSourceIpAddrBitmask = 0xffffffff;

    ace_entry.u.ip.aceProtocol = 17;
    ace_entry.u.ip.aceMinDestPort =1234;
    ace_entry.u.ip.aceMaxDestPort=1234;
    ace_entry.u.ip.aceDestPortOp =VAL_aclIpAceDestPortOp_equal;
    ace_entry.u.ip.aceDestPortBitmask = 0xffff;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);
#endif /* #if (SYS_CPNT_ACL_MAC_IP_MIX == TRUE) */

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
        {
            for (direction = MIN_DIRECTION; direction <= MAX_DIRECTION; ++ direction)
            {
                if (TRUE == RULE_TYPE_IS_TRUNK(ifindex) &&
                    RULE_TYPE_OUTBOUND == direction)
                {
                    continue;
                }

                time_range_index = TIME_RANGE_INDEX;
                counter_enable = COUNTER_ENABLE_STATUS;

                result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                                    acl_index,
                                                    time_range_index,
                                                    counter_enable);
                assert(RULE_TYPE_OK == result);
            }
        }

        for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
        {
            for (direction = MIN_DIRECTION; direction <= MAX_DIRECTION; ++ direction)
            {
                if (TRUE == RULE_TYPE_IS_TRUNK(ifindex) &&
                    RULE_TYPE_OUTBOUND == direction)
                {
                    continue;
                }

                time_range_index = TIME_RANGE_INDEX;
                counter_enable = COUNTER_ENABLE_STATUS;

                result = RULE_CTRL_UT_Proc_UnBind_ACL(ifindex, direction,
                                                      acl_index,
                                                      time_range_index,
                                                      counter_enable);
                assert(RULE_TYPE_OK == result);
            }
        }
    }

    for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
    {
        for (direction = MIN_DIRECTION; direction <= MAX_DIRECTION; ++ direction)
        {
            if (TRUE == RULE_TYPE_IS_TRUNK(ifindex) &&
                RULE_TYPE_OUTBOUND == direction)
            {
                continue;
            }

            time_range_index = TIME_RANGE_INDEX;
            counter_enable = COUNTER_ENABLE_STATUS;

            result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                                acl_index,
                                                time_range_index,
                                                counter_enable);
            assert(RULE_TYPE_OK == result);
        }
    }

    return 0;
}

int
RULE_CTRL_UT_Proc_Add_ACL_Rule_On_Trunk_Port()
{
    enum
    {
        UNIT = 1,
        PORT = 2,
        MIN_IFINDEX = SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER,
        MAX_IFINDEX = (SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER + SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM - 1),
        MIN_DIRECTION = RULE_TYPE_INBOUND,
        MAX_DIRECTION = RULE_TYPE_INBOUND,
        MAX_RETRY = 2,
        TIME_RANGE_INDEX = 0XFFFF,

#if (SYS_CPNT_ACL_COUNTER == TRUE)
        COUNTER_ENABLE_STATUS = RULE_TYPE_COUNTER_ENABLE,
#else
        COUNTER_ENABLE_STATUS = RULE_TYPE_COUNTER_DISABLE,
#endif
    };

    const char *acl_name = "bind_on_trunk_port";
    RULE_TYPE_AclType_T acl_type = RULE_TYPE_MAC_ACL;
    UI32_T acl_index;

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    UI16_T time_range_index;
    RULE_TYPE_COUNTER_ENABLE_T counter_enable;

    UI32_T retry;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_Ace_Entry_T ace_entry;

    result = RULE_OM_CreateAcl(acl_name, acl_type);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetAclIdByName(acl_name, &acl_index);
    assert(RULE_TYPE_OK == result);

    //
    // ace 1
    //
    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_PERMIT;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // ace2
    //
    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_PERMIT;
    ace_entry.u.mac.aceSourceMacAddr[0] = 0xc4;
    ace_entry.u.mac.aceSourceMacAddr[1] = 0x2c;
    ace_entry.u.mac.aceSourceMacAddr[2] = 0x03;

    ace_entry.u.mac.aceSourceMacAddrBitmask[0] = 0xff;
    ace_entry.u.mac.aceSourceMacAddrBitmask[1] = 0xff;
    ace_entry.u.mac.aceSourceMacAddrBitmask[2] = 0xff;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // ace3
    //
    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_PERMIT;
    ace_entry.u.mac.aceSourceMacAddr[0] = 0xc8;
    ace_entry.u.mac.aceSourceMacAddr[1] = 0xbc;
    ace_entry.u.mac.aceSourceMacAddr[2] = 0xc8;

    ace_entry.u.mac.aceSourceMacAddrBitmask[0] = 0xff;
    ace_entry.u.mac.aceSourceMacAddrBitmask[1] = 0xff;
    ace_entry.u.mac.aceSourceMacAddrBitmask[2] = 0xff;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // ace4
    //
    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_DENY;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
        {
            for (direction = MIN_DIRECTION; direction <= MAX_DIRECTION; ++ direction)
            {
                time_range_index = TIME_RANGE_INDEX;
                counter_enable = COUNTER_ENABLE_STATUS;

                result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                                    acl_index,
                                                    time_range_index,
                                                    counter_enable);
                assert(RULE_TYPE_OK == result);
            }
        }

        for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
        {
            for (direction = MIN_DIRECTION; direction <= MAX_DIRECTION; ++ direction)
            {
                time_range_index = TIME_RANGE_INDEX;
                counter_enable = COUNTER_ENABLE_STATUS;

                result = RULE_CTRL_UT_Proc_UnBind_ACL(ifindex, direction,
                                                      acl_index,
                                                      time_range_index,
                                                      counter_enable);
                assert(RULE_TYPE_OK == result);
            }
        }
    }

    for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
    {
        for (direction = MIN_DIRECTION; direction <= MAX_DIRECTION; ++ direction)
        {
            time_range_index = TIME_RANGE_INDEX;
            counter_enable = COUNTER_ENABLE_STATUS;

            result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                                acl_index,
                                                time_range_index,
                                                counter_enable);
            assert(RULE_TYPE_OK == result);
        }
    }

    return 0;
}

int
RULE_CTRL_UT_Proc_Add_ACL_Rule_On_CPU_Port()
{
    enum
    {
        UNIT = 1,
        PORT = 2,
        MIN_IFINDEX = SYS_ADPT_CPU_1_IF_INDEX_NUMBER,
        MAX_IFINDEX = SYS_ADPT_CPU_1_IF_INDEX_NUMBER,
        MIN_DIRECTION = RULE_TYPE_OUTBOUND,
        MAX_DIRECTION = RULE_TYPE_OUTBOUND,
        MAX_RETRY = 2,
        TIME_RANGE_INDEX = 0XFFFF,

#if (SYS_CPNT_ACL_COUNTER == TRUE)
        COUNTER_ENABLE_STATUS = RULE_TYPE_COUNTER_ENABLE,
#else
        COUNTER_ENABLE_STATUS = RULE_TYPE_COUNTER_DISABLE,
#endif
    };

    const char *acl_name = "bind_on_cpu_port";
    RULE_TYPE_AclType_T acl_type = RULE_TYPE_MAC_ACL;
    UI32_T acl_index;

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    UI16_T time_range_index;
    RULE_TYPE_COUNTER_ENABLE_T counter_enable;

    UI32_T retry;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_Ace_Entry_T ace_entry;

    result = RULE_OM_CreateAcl(acl_name, acl_type);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetAclIdByName(acl_name, &acl_index);
    assert(RULE_TYPE_OK == result);

    //
    // ace 1
    //
    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_PERMIT;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // ace2
    //
    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_PERMIT;
    ace_entry.u.mac.aceSourceMacAddr[0] = 0xc4;
    ace_entry.u.mac.aceSourceMacAddr[1] = 0x2c;
    ace_entry.u.mac.aceSourceMacAddr[2] = 0x03;

    ace_entry.u.mac.aceSourceMacAddrBitmask[0] = 0xff;
    ace_entry.u.mac.aceSourceMacAddrBitmask[1] = 0xff;
    ace_entry.u.mac.aceSourceMacAddrBitmask[2] = 0xff;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // ace3
    //
    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_PERMIT;
    ace_entry.u.mac.aceSourceMacAddr[0] = 0xc8;
    ace_entry.u.mac.aceSourceMacAddr[1] = 0xbc;
    ace_entry.u.mac.aceSourceMacAddr[2] = 0xc8;

    ace_entry.u.mac.aceSourceMacAddrBitmask[0] = 0xff;
    ace_entry.u.mac.aceSourceMacAddrBitmask[1] = 0xff;
    ace_entry.u.mac.aceSourceMacAddrBitmask[2] = 0xff;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // ace4
    //
    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_DENY;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
        {
            for (direction = MIN_DIRECTION; direction <= MAX_DIRECTION; ++ direction)
            {
                time_range_index = TIME_RANGE_INDEX;
                counter_enable = COUNTER_ENABLE_STATUS;

                result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                                    acl_index,
                                                    time_range_index,
                                                    counter_enable);
                assert(RULE_TYPE_OK == result);
            }
        }

        for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
        {
            for (direction = MIN_DIRECTION; direction <= MAX_DIRECTION; ++ direction)
            {
                time_range_index = TIME_RANGE_INDEX;
                counter_enable = COUNTER_ENABLE_STATUS;

                result = RULE_CTRL_UT_Proc_UnBind_ACL(ifindex, direction,
                                                      acl_index,
                                                      time_range_index,
                                                      counter_enable);
                assert(RULE_TYPE_OK == result);
            }
        }
    }

    for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
    {
        for (direction = MIN_DIRECTION; direction <= MAX_DIRECTION; ++ direction)
        {
            time_range_index = TIME_RANGE_INDEX;
            counter_enable = COUNTER_ENABLE_STATUS;

            result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                                acl_index,
                                                time_range_index,
                                                counter_enable);
            assert(RULE_TYPE_OK == result);
        }
    }

    return 0;
}

int
RULE_CTRL_UT_Proc_Add_ACL_Rule_On_All_Ports()
{
    enum
    {
        UNIT = 1,
        PORT = 2,
        MIN_IFINDEX = RULE_TYPE_ALL_PORTS_1_IF_INDEX_NUMBER,
        MAX_IFINDEX = RULE_TYPE_ALL_PORTS_1_IF_INDEX_NUMBER,
        MIN_DIRECTION = RULE_TYPE_INBOUND,
        MAX_DIRECTION = RULE_TYPE_INBOUND,
        MAX_RETRY = 2,
        TIME_RANGE_INDEX = 0XFFFF,

#if (SYS_CPNT_ACL_COUNTER == TRUE)
        COUNTER_ENABLE_STATUS = RULE_TYPE_COUNTER_ENABLE,
#else
        COUNTER_ENABLE_STATUS = RULE_TYPE_COUNTER_DISABLE,
#endif
    };

    const char *acl_name = "bind_on_global";
    RULE_TYPE_AclType_T acl_type = RULE_TYPE_MAC_ACL;
    UI32_T acl_index;

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    UI16_T time_range_index;
    RULE_TYPE_COUNTER_ENABLE_T counter_enable;

    UI32_T retry;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_Ace_Entry_T ace_entry;

    result = RULE_OM_CreateAcl(acl_name, acl_type);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetAclIdByName(acl_name, &acl_index);
    assert(RULE_TYPE_OK == result);

    //
    // ace 1
    //
    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_PERMIT;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // ace2
    //
    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_PERMIT;
    ace_entry.u.mac.aceSourceMacAddr[0] = 0xc4;
    ace_entry.u.mac.aceSourceMacAddr[1] = 0x2c;
    ace_entry.u.mac.aceSourceMacAddr[2] = 0x03;

    ace_entry.u.mac.aceSourceMacAddrBitmask[0] = 0xff;
    ace_entry.u.mac.aceSourceMacAddrBitmask[1] = 0xff;
    ace_entry.u.mac.aceSourceMacAddrBitmask[2] = 0xff;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // ace3
    //
    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_PERMIT;
    ace_entry.u.mac.aceSourceMacAddr[0] = 0xc8;
    ace_entry.u.mac.aceSourceMacAddr[1] = 0xbc;
    ace_entry.u.mac.aceSourceMacAddr[2] = 0xc8;

    ace_entry.u.mac.aceSourceMacAddrBitmask[0] = 0xff;
    ace_entry.u.mac.aceSourceMacAddrBitmask[1] = 0xff;
    ace_entry.u.mac.aceSourceMacAddrBitmask[2] = 0xff;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    //
    // ace4
    //
    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_DENY;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    for (retry = 1; retry <= MAX_RETRY; ++ retry)
    {
        for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
        {
            for (direction = MIN_DIRECTION; direction <= MAX_DIRECTION; ++ direction)
            {
                time_range_index = TIME_RANGE_INDEX;
                counter_enable = COUNTER_ENABLE_STATUS;

                result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                                    acl_index,
                                                    time_range_index,
                                                    counter_enable);
                assert(RULE_TYPE_OK == result);
            }
        }

        for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
        {
            for (direction = MIN_DIRECTION; direction <= MAX_DIRECTION; ++ direction)
            {
                time_range_index = TIME_RANGE_INDEX;
                counter_enable = COUNTER_ENABLE_STATUS;

                result = RULE_CTRL_UT_Proc_UnBind_ACL(ifindex, direction,
                                                      acl_index,
                                                      time_range_index,
                                                      counter_enable);
                assert(RULE_TYPE_OK == result);
            }
        }
    }

    for (ifindex = MIN_IFINDEX; ifindex <= MAX_IFINDEX; ++ ifindex)
    {
        for (direction = MIN_DIRECTION; direction <= MAX_DIRECTION; ++ direction)
        {
            time_range_index = TIME_RANGE_INDEX;
            counter_enable = COUNTER_ENABLE_STATUS;

            result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                                acl_index,
                                                time_range_index,
                                                counter_enable);
            assert(RULE_TYPE_OK == result);
        }
    }

    return 0;
}

int
RULE_CTRL_UT_Add_ACL_Rule()
{
    RULE_CTRL_UT_Proc_Add_ACL_Rule_On_Eth();
    RULE_CTRL_UT_Proc_Add_ACL_Rule_On_Trunk_Port();
    RULE_CTRL_UT_Proc_Add_ACL_Rule_On_CPU_Port();
    RULE_CTRL_UT_Proc_Add_ACL_Rule_On_All_Ports();
    return 0;
}

int
RULE_CTRL_UT_Add_QoS_With_MF_Rule()
{
    enum
    {
        MAX_POLICY_ELEMENT = 2
    };

    const char *policy_name = "p1";

    UI32_T policy_map_index;
    UI32_T class_id;

    RULE_TYPE_RETURN_TYPE_T     result;

    result = RULE_OM_Create_PolicyMap(policy_name, &policy_map_index);
    assert(RULE_TYPE_OK == result);

    for (class_id=1; class_id <= MAX_POLICY_ELEMENT; ++class_id)
    {
        char class_name[SYS_ADPT_DIFFSERV_MAX_NAME_LENGTH + 1];
        RULE_TYPE_MatchType_T match_type = RULE_TYPE_CLASS_MAP_MATCH_ANY;

        UI32_T class_map_index;
        UI32_T class_index;

        RULE_TYPE_UI_ClassMapElement_T class_element;

        snprintf(class_name, sizeof(class_name), "c%lu", class_id);

        result = RULE_OM_Create_ClassMap(class_name, match_type, &class_map_index);
        assert(RULE_TYPE_OK == result);

        class_element.class_type = RULE_TYPE_CLASS_MF;
        class_element.element.mf_entry.mf_type = RULE_TYPE_MF_VLAN;
        class_element.element.mf_entry.mf_value = 1;

        result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index,
                                                         &class_element, &class_index);
        assert(RULE_TYPE_OK == result);

        class_element.class_type = RULE_TYPE_CLASS_MF;
        class_element.element.mf_entry.mf_type = RULE_TYPE_MF_VLAN;
        class_element.element.mf_entry.mf_value = 2;

        result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index,
                                                         &class_element, &class_index);
        assert(RULE_TYPE_OK == result);

        result = RULE_OM_Add_PolicyMapElement_To_PolicyMap(policy_map_index,
                                                           class_map_index);
        assert(RULE_TYPE_OK == result);
    }

    {
        enum
        {
            UNIT = 1,
            PORT = 2,
            INOUT_PROFILE = RULE_TYPE_INBOUND,
            TIME_RANGE_INDEX = 0XFFFF
        };

        RULE_TYPE_PolicyMap_T           policy_map;

        UI32_T uport_ifindex;
        UI32_T unit;
        UI32_T port;
        UI32_T inout_profile;

        UI32_T ifindex;
        RULE_TYPE_InOutDirection_T direction;

        result = RULE_OM_GetPolicyMap(policy_map_index, &policy_map);
        assert(RULE_TYPE_OK == result);

        inout_profile = INOUT_PROFILE;
        unit = UNIT;
        port = PORT;

        uport_ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);

        ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(UNIT, PORT);
        direction = INOUT_PROFILE;

        result = RULE_CTRL_SetPolicyMap(uport_ifindex, inout_profile, policy_map_index, TRUE);
        assert(RULE_TYPE_OK == result);

        result = RULE_OM_BindPort2PolicyMap(uport_ifindex, inout_profile, policy_map_index);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();
    }

    return 0;
}

int
RULE_CTRL_UT_Proc_Add_Global_Rule()
{
    int result;

    result = RULE_CTRL_UT_Add_PTP_Event_ETH_Rule();
    assert(0 == result);

    result = RULE_CTRL_UT_Add_PTP_Event_UDP_Rule();
    assert(0 == result);

    result = RULE_CTRL_UT_Add_PTP_General_UDP_Rule();
    assert(0 == result);

    return 0;
}

int
RULE_CTRL_UT_Proc_Add_Dflt_Rule()
{
    int result;

    result = RULE_CTRL_UT_Add_WebAuth_Redir_HTTP_And_Permit_DHCP_DNS_Rule();
    assert(0 == result);

    result = RULE_CTRL_UT_Add_IpSrcGrd_Permit_VID_SIP_Rule();
    assert(0 == result);

    return 0;
}

int
RULE_CTRL_UT_Validate_Rule_Priority()
{
    int result;

    result = RULE_CTRL_UT_Add_QoS_With_MF_Rule();
    assert(0 == result);
    RULE_CTRL_UT_Proc_Validate_Rule();

    result = RULE_CTRL_UT_Add_ACL_Rule();
    assert(0 == result);
    RULE_CTRL_UT_Proc_Validate_Rule();

    result = RULE_CTRL_UT_Proc_Add_Dflt_Rule();
    assert(0 == result);
    RULE_CTRL_UT_Proc_Validate_Rule();

    result = RULE_CTRL_UT_Proc_Add_Global_Rule();
    assert(0 == result);
    RULE_CTRL_UT_Proc_Validate_Rule();

    RULE_CTRL_DumpGlobalAce_BackDoor();

    return 0;
}

int
RULE_CTRL_UT_ACL_Get_Counter()
{
    enum
    {
        IFINDEX = 2,
        TIME_RANGE_INDEX = 0XFFFF,
    };

    const char *acl_name = "a1";
    RULE_TYPE_AclType_T acl_type = RULE_TYPE_MAC_ACL;
    UI32_T acl_index;

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    UI16_T time_range_index;
    RULE_TYPE_COUNTER_ENABLE_T counter_enable;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_Ace_Entry_T ace_entry;

    result = RULE_OM_CreateAcl(acl_name, acl_type);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetAclIdByName(acl_name, &acl_index);
    assert(RULE_TYPE_OK == result);

    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_PERMIT;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_DENY;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    time_range_index = TIME_RANGE_INDEX;
    counter_enable = RULE_TYPE_COUNTER_ENABLE;

    ifindex = IFINDEX;
    direction = RULE_TYPE_INBOUND;

    result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                        acl_index,
                                        time_range_index,
                                        counter_enable);
    assert(RULE_TYPE_OK == result);


#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
    time_range_index = TIME_RANGE_INDEX;
    counter_enable = RULE_TYPE_COUNTER_ENABLE;

    ifindex = IFINDEX;
    direction = RULE_TYPE_OUTBOUND;

    result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                        acl_index,
                                        time_range_index,
                                        counter_enable);
    assert(RULE_TYPE_OK == result);
#endif // SYS_CPNT_QOS_V2_EGRESS_PORT

    //
    // Remove
    //

    time_range_index = TIME_RANGE_INDEX;
    counter_enable = RULE_TYPE_COUNTER_ENABLE;

    ifindex = IFINDEX;
    direction = RULE_TYPE_INBOUND;

    result = RULE_CTRL_UT_Proc_UnBind_ACL(ifindex, direction,
                                          acl_index,
                                          time_range_index,
                                          counter_enable);
    assert(RULE_TYPE_OK == result);

    //
    // Test result
    //
    RULE_CTRL_UT_Proc_Validate_Rule();

#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
    time_range_index = TIME_RANGE_INDEX;
    counter_enable = RULE_TYPE_COUNTER_ENABLE;

    ifindex = IFINDEX;
    direction = RULE_TYPE_OUTBOUND;

    result = RULE_CTRL_UT_Proc_UnBind_ACL(ifindex, direction,
                                          acl_index,
                                          time_range_index,
                                          counter_enable);
    assert(RULE_TYPE_OK == result);
#endif // SYS_CPNT_QOS_V2_EGRESS_PORT

    return 0;
}

int
RULE_CTRL_UT_ACL_ACL_Mirror()
{
    enum
    {
        IFINDEX = 2,
        TIME_RANGE_INDEX = 0XFFFF,
    };

    const char *acl_name = "a1";
    RULE_TYPE_AclType_T acl_type = RULE_TYPE_MAC_ACL;
    RULE_TYPE_Acl_T acl_entry;
    UI32_T acl_index;

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    UI16_T time_range_index;
    RULE_TYPE_COUNTER_ENABLE_T counter_enable;

    UI32_T ifindex_dest;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_Ace_Entry_T ace_entry;

    result = RULE_OM_CreateAcl(acl_name, acl_type);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetAclIdByName(acl_name, &acl_index);
    assert(RULE_TYPE_OK == result);

    ifindex_dest = 10;

    result = RULE_OM_AddAclMirrorEntry(ifindex_dest, acl_index);
    assert(RULE_TYPE_OK == result);


    //
    // Validates OM first
    //
    result = RULE_OM_GetAclByIndex(acl_index, &acl_entry);
    assert(RULE_TYPE_OK == result);

    assert(RULE_TYPE_MIRROR_ENABLE == acl_entry.mirror.enable);
    assert(ifindex_dest == acl_entry.mirror.dest_ifindex);


    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_PERMIT;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_DENY;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    time_range_index = TIME_RANGE_INDEX;
    counter_enable = RULE_TYPE_COUNTER_ENABLE;

    ifindex = IFINDEX;
    direction = RULE_TYPE_INBOUND;

    result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                        acl_index,
                                        time_range_index,
                                        counter_enable);
    assert(RULE_TYPE_OK == result);


#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
    time_range_index = TIME_RANGE_INDEX;
    counter_enable = RULE_TYPE_COUNTER_ENABLE;

    ifindex = IFINDEX;
    direction = RULE_TYPE_OUTBOUND;

    result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                        acl_index,
                                        time_range_index,
                                        counter_enable);
    assert(RULE_TYPE_OK == result);

#endif // SYS_CPNT_QOS_V2_EGRESS_PORT


    //
    //
    // re-building
    //
    //

    result = RULE_OM_RemoveAclMirrorEntry(ifindex_dest, acl_index);
    assert(RULE_TYPE_OK == result);


    //
    // Validates OM first
    //
    result = RULE_OM_GetAclByIndex(acl_index, &acl_entry);
    assert(RULE_TYPE_OK == result);

    assert(RULE_TYPE_MIRROR_DISABLE == acl_entry.mirror.enable);
    assert(0 == acl_entry.mirror.dest_ifindex);

    time_range_index = TIME_RANGE_INDEX;
    counter_enable = RULE_TYPE_COUNTER_ENABLE;

    ifindex = IFINDEX;
    direction = RULE_TYPE_INBOUND;

    result = RULE_CTRL_UT_Proc_UnBind_ACL(ifindex, direction,
                                          acl_index,
                                          time_range_index,
                                          counter_enable);
    assert(RULE_TYPE_OK == result);

    result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                        acl_index,
                                        time_range_index,
                                        counter_enable);
    assert(RULE_TYPE_OK == result);

#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
    time_range_index = TIME_RANGE_INDEX;
    counter_enable = RULE_TYPE_COUNTER_ENABLE;

    ifindex = IFINDEX;
    direction = RULE_TYPE_OUTBOUND;

    result = RULE_CTRL_UT_Proc_UnBind_ACL(ifindex, direction,
                                          acl_index,
                                          time_range_index,
                                          counter_enable);
    assert(RULE_TYPE_OK == result);

    result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                        acl_index,
                                        time_range_index,
                                        counter_enable);
    assert(RULE_TYPE_OK == result);

#endif // SYS_CPNT_QOS_V2_EGRESS_PORT

    return 0;
}

int
RULE_CTRL_UT_ACL_ACL_Mirror_On_Fly()
{
    enum
    {
        IFINDEX = 2,
        TIME_RANGE_INDEX = 0XFFFF,
    };

    const char *acl_name = "a1";
    RULE_TYPE_AclType_T acl_type = RULE_TYPE_MAC_ACL;
    RULE_TYPE_Acl_T acl_entry;
    UI32_T acl_index;

    RULE_TYPE_INTERFACE_INFO_T interface;

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    UI16_T time_range_index;
    RULE_TYPE_COUNTER_ENABLE_T counter_enable;

    UI32_T ifindex_dest;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_Ace_Entry_T ace_entry;

    result = RULE_OM_CreateAcl(acl_name, acl_type);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetAclIdByName(acl_name, &acl_index);
    assert(RULE_TYPE_OK == result);

    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_PERMIT;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_DENY;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    time_range_index = TIME_RANGE_INDEX;
    counter_enable = RULE_TYPE_COUNTER_ENABLE;

    ifindex = IFINDEX;
    direction = RULE_TYPE_INBOUND;

test_on_egress_port:

    result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
    assert(RULE_TYPE_OK == result);

    interface.direction = direction;

    result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                        acl_index,
                                        time_range_index,
                                        counter_enable);
    assert(RULE_TYPE_OK == result);

    //
    // Enable ACL mirror on Fly
    //

    ifindex_dest = 10;

    result = RULE_OM_AddAclMirrorEntry(ifindex_dest, acl_index);
    assert(RULE_TYPE_OK == result);

    //
    // Validates OM first
    //
    result = RULE_OM_GetAclByIndex(acl_index, &acl_entry);
    assert(RULE_TYPE_OK == result);

    assert(RULE_TYPE_MIRROR_ENABLE == acl_entry.mirror.enable);
    assert(ifindex_dest == acl_entry.mirror.dest_ifindex);

    result = RULE_CTRL_SetAclMirror(acl_index);
    assert(RULE_TYPE_OK == result);

    RULE_CTRL_UT_Proc_Validate_Rule();

    //
    // Disable ACL mirror on Fly
    //

    ifindex_dest = 10;

    result = RULE_OM_RemoveAclMirrorEntry(ifindex_dest, acl_index);
    assert(RULE_TYPE_OK == result);

    //
    // Validates OM first
    //
    result = RULE_OM_GetAclByIndex(acl_index, &acl_entry);
    assert(RULE_TYPE_OK == result);

    assert(RULE_TYPE_MIRROR_DISABLE == acl_entry.mirror.enable);
    assert(0 == acl_entry.mirror.dest_ifindex);

    result = RULE_CTRL_SetAclMirror(acl_index);
    assert(RULE_TYPE_OK == result);

    RULE_CTRL_UT_Proc_Validate_Rule();

#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
    if (RULE_TYPE_INBOUND == direction)
    {
        ifindex = IFINDEX;
        direction = RULE_TYPE_OUTBOUND;

        time_range_index = TIME_RANGE_INDEX;
        counter_enable = RULE_TYPE_COUNTER_ENABLE;

        goto test_on_egress_port;
    }
#endif // #if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)

    return 0;
}

void
RULE_CTRL_UT_Proc_Validate_Rule_Statistics_Entry(
    RULE_CTRL_RULE_STAT_T *rule_stat)
{
    UI32_T i;
    UI32_T total_nbr = 0;

    assert(NULL != rule_stat);

    for (i = 0; i < _countof(rule_stat->rule_nbr); ++ i)
    {
        total_nbr += rule_stat->rule_nbr[i];
    }

    assert(total_nbr == rule_stat->total_nbr);
}

UI32_T
RULE_CTRL_UT_Proc_Calculate_Hardware_Rule_Number(
    RULE_CTRL_RULE_STAT_T *rule_stat)
{
    UI32_T i;
    UI32_T hw_rule_nbr = 0;

    RULE_CTRL_UT_Proc_Validate_Rule_Statistics_Entry(rule_stat);

    for (i = 0; i < _countof(rule_stat->rule_nbr); ++ i)
    {
        if (0 != rule_stat->rule_nbr[i])
        {
            UI32_T key_mode;
            UI32_T rule_size;

            key_mode = RULE_CTRL_LocalGetKeyModeByACLType(i,
                                              i == RULE_TYPE_MF ? TRUE : FALSE);
            rule_size = RULE_CTRL_LocalGetRuleSizeByKeyMode(key_mode);

            hw_rule_nbr += rule_stat->rule_nbr[i] * rule_size;
        }
    }

    return hw_rule_nbr;
}

#if 0 /* FIXME: */
int
RULE_CTRL_UT_ACL_Show_Msg_When_Unbind_ACL_With_Time_Range_On_Egress_Port()
{
#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE) && (SYS_CPNT_TIME_BASED_ACL == TRUE)
    enum
    {
        IFINDEX = 8,
    };

    RULE_TYPE_INTERFACE_INFO_T interface;

    UI32_T ifindex = IFINDEX;
    RULE_TYPE_InOutDirection_T direction = RULE_TYPE_OUTBOUND;

    UI32_T acl_index;
    RULE_TYPE_COUNTER_ENABLE_T counter_enable = RULE_TYPE_COUNTER_DISABLE;

    const char *acl_name = "a1";
    RULE_TYPE_AclType_T acl_type = RULE_TYPE_IP_EXT_ACL;

    RULE_TYPE_Ace_Entry_T ace_entry;

    const char *time_range_name = "t1";
    UI16_T time_range_index;

    RULE_TYPE_RETURN_TYPE_T result;

    result = RULE_OM_CreateAcl(acl_name, acl_type);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetAclIdByName(acl_name, &acl_index);
    assert(RULE_TYPE_OK == result);


    ace_entry.ace_type = acl_type;
    result = RULE_OM_InitAce(&ace_entry);
    ace_entry.access = RULE_TYPE_ACE_DENY;

    result = RULE_OM_AddAce2Acl(acl_index, acl_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_CreateTimeRangeEntry(time_range_name, &time_range_index);
    assert(RULE_TYPE_OK == result);

    memset(&interface, 0, sizeof(interface));
    result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
    assert(RULE_TYPE_OK == result);

    interface.direction = direction;

    result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                        acl_index,
                                        time_range_index,
                                        counter_enable);
    assert(RULE_TYPE_OK == result);

    result = RULE_CTRL_UT_Proc_UnBind_ACL(ifindex, direction,
                                          acl_index,
                                          time_range_index,
                                          counter_enable);
    assert(RULE_TYPE_OK == result);
#endif // SYS_CPNT_QOS_V2_EGRESS_PORT && SYS_CPNT_TIME_BASED_ACL

    return 0;
}

int
RULE_CTRL_UT_Bind_Policy_Map_With_Bad_Action_On_Egress_Port()
{
#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
    RULE_TYPE_AclType_T acl_type = RULE_TYPE_IP_EXT_ACL;
    RULE_TYPE_RETURN_TYPE_T result;

    const char *policy_map_name = "policy1";
    UI32_T policy_map_index;

    {
        result = RULE_OM_Create_PolicyMap(policy_map_name, &policy_map_index);
        assert(RULE_TYPE_OK == result);
    }

    {
        const char *acl_name = "acl1";
        RULE_TYPE_Ace_Entry_T ace_entry;

        const char *class_map_name = "class1";
        RULE_TYPE_MatchType_T match_type = RULE_TYPE_CLASS_MAP_MATCH_ANY;
        UI32_T class_map_index;

        RULE_TYPE_UI_ClassMapElement_T ui_class_map_element;
        UI32_T class_index;

        RULE_TYPE_UI_Action_T   ui_action;
        RULE_TYPE_TBParamEntry_T    meter;

        result = RULE_OM_CreateAcl(acl_name, acl_type);
        assert(RULE_TYPE_OK == result);

        ace_entry.ace_type = acl_type;
        result = RULE_OM_InitAce(&ace_entry);
        assert(RULE_TYPE_OK == result);

        SET_IPV4(ace_entry.u.ip.aceSourceIpAddr, 192, 168, 1, 101);
        SET_IPV4(ace_entry.u.ip.aceSourceIpAddrBitmask, 255, 255, 255, 255);

        SET_IPV4(ace_entry.u.ip.aceDestIpAddr, 192, 168, 1, 201);
        SET_IPV4(ace_entry.u.ip.aceDestIpAddrBitmask, 255, 255, 255, 255);

        result = RULE_OM_Create_ClassMap(class_map_name, match_type, &class_map_index);
        assert(RULE_TYPE_OK == result);

        ui_class_map_element.class_type = RULE_TYPE_CLASS_ACL;
        strncpy(ui_class_map_element.element.acl_name, acl_name,
                               sizeof(ui_class_map_element.element.acl_name)-1);
        ui_class_map_element.element.acl_name[ sizeof(ui_class_map_element.element.acl_name)-1 ] = '\0';

        result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &ui_class_map_element, &class_index);
        assert(RULE_TYPE_OK == result);

        memset(&ui_action, 0, sizeof(ui_action));

        ui_action.in_action_type = IN_ACTION_INVALID;
        ui_action.out_action_type = OUT_ACTION_INVALID;
        ui_action.confirm_action_type = CONFIRM_ACTION_TRANSMIT;
        ui_action.class_action_type = CLASS_ACTION_INVALID;
        ui_action.exceed_action_type = EXCEED_ACTION_REMARK_DSCP_TRANSMIT;
        ui_action.exceed_action_value = 32;
        ui_action.violate_action_type = VIOLATE_ACTION_REMARK_DSCP_TRANSMIT;
        ui_action.violate_action_value = 63;

        meter.meter_model = RULE_TYPE_METER_MODE_SRTCM_COLOR_AWARE;
        meter.rate = 84;
        meter.burst_size = 4000;
        meter.peak_burst_size = 4000;

        result = RULE_OM_Add_PolicyMapElement_To_PolicyMap(policy_map_index, class_map_index);
        assert(RULE_TYPE_OK == result);

        result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter);
        assert(RULE_TYPE_OK == result);

        result = RULE_OM_SetUIActionEntry(policy_map_index, class_map_index, &ui_action);
        assert(RULE_TYPE_OK == result);
    }

    {
        UI32_T uport_ifindex = 4;
        RULE_TYPE_InOutDirection_T direction = RULE_TYPE_OUTBOUND;

        result = RULE_CTRL_SetPolicyMap(uport_ifindex, direction, policy_map_index, TRUE);

        assert(RULE_TYPE_E_HW_LIMIT_YELLOW_REMARK_DSCP == result ||
               RULE_TYPE_E_HW_LIMIT_RED_REMARK_DSCP == result);
    }
#endif // SYS_CPNT_QOS_V2_EGRESS_PORT

    return 0;
}

int
RULE_CTRL_UT_Bind_Policy_Map_On_Egress_Port()
{
#if (SYS_CPNT_QOS_V2_EGRESS_PORT == TRUE)
    RULE_TYPE_AclType_T acl_type = RULE_TYPE_IP_EXT_ACL;
    RULE_TYPE_RETURN_TYPE_T result;

    const char *policy_map_name = "policy1";
    UI32_T policy_map_index;

    UI32_T acl_index;

    {
        result = RULE_OM_Create_PolicyMap(policy_map_name, &policy_map_index);
        assert(RULE_TYPE_OK == result);
    }

    {
        const char *acl_name = "acl1";
        RULE_TYPE_Ace_Entry_T ace_entry;

        const char *class_map_name = "class1";
        RULE_TYPE_MatchType_T match_type = RULE_TYPE_CLASS_MAP_MATCH_ANY;
        UI32_T class_map_index;

        RULE_TYPE_UI_ClassMapElement_T ui_class_map_element;
        UI32_T class_index;

        RULE_TYPE_UI_Action_T   ui_action;
        RULE_TYPE_TBParamEntry_T    meter;

        result = RULE_OM_CreateAcl(acl_name, acl_type);
        assert(RULE_TYPE_OK == result);

        result = RULE_OM_GetAclIdByName(acl_name, &acl_index);
        assert(RULE_TYPE_OK == result);

        ace_entry.ace_type = acl_type;
        result = RULE_OM_InitAce(&ace_entry);
        assert(RULE_TYPE_OK == result);

        SET_IPV4(ace_entry.u.ip.aceSourceIpAddr, 192, 168, 1, 101);
        SET_IPV4(ace_entry.u.ip.aceSourceIpAddrBitmask, 255, 255, 255, 255);

        SET_IPV4(ace_entry.u.ip.aceDestIpAddr, 192, 168, 1, 201);
        SET_IPV4(ace_entry.u.ip.aceDestIpAddrBitmask, 255, 255, 255, 255);

        result = RULE_OM_AddAce2Acl(acl_index, acl_type, &ace_entry);
        assert(RULE_TYPE_OK == result);

#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
        RULE_OM_RebuildAggregateAcl(acl_index);
#endif // SYS_CPNT_ACL_AUTO_COMPRESS_ACE

        result = RULE_OM_Create_ClassMap(class_map_name, match_type, &class_map_index);
        assert(RULE_TYPE_OK == result);

        ui_class_map_element.class_type = RULE_TYPE_CLASS_ACL;
        strncpy(ui_class_map_element.element.acl_name, acl_name,
                sizeof(ui_class_map_element.element.acl_name)-1);
        ui_class_map_element.element.acl_name[ sizeof(ui_class_map_element.element.acl_name)-1 ] = '\0';

        result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &ui_class_map_element, &class_index);
        assert(RULE_TYPE_OK == result);

        memset(&ui_action, 0, sizeof(ui_action));

        ui_action.in_action_type = IN_ACTION_INVALID;
        ui_action.out_action_type = OUT_ACTION_INVALID;
        ui_action.confirm_action_type = CONFIRM_ACTION_TRANSMIT;
        ui_action.class_action_type = CLASS_ACTION_INVALID;
        ui_action.exceed_action_type = EXCEED_ACTION_TRANSMIT;
        ui_action.violate_action_type = VIOLATE_ACTION_DROP;

        meter.meter_model = RULE_TYPE_METER_MODE_SRTCM_COLOR_AWARE;
        meter.rate = 84;
        meter.burst_size = 4000;
        meter.peak_burst_size = 4000;

        result = RULE_OM_Add_PolicyMapElement_To_PolicyMap(policy_map_index, class_map_index);
        assert(RULE_TYPE_OK == result);

        result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter);
        assert(RULE_TYPE_OK == result);

        result = RULE_OM_SetUIActionEntry(policy_map_index, class_map_index, &ui_action);
        assert(RULE_TYPE_OK == result);
    }

    {
        UI32_T uport_ifindex = 4;
        RULE_TYPE_InOutDirection_T direction = RULE_TYPE_OUTBOUND;

//        result = RULE_MGR_BindPort2PolicyMap(uport_ifindex, direction, policy_map_index);
//        assert(RULE_TYPE_OK == result);
        RULE_CTRL_UT_Proc_Bind_Policy_Map(uport_ifindex, direction, policy_map_index);

        RULE_CTRL_UT_Proc_Validate_Rule();

        //
        // Cannot bind policy-map and ACL on egress port at the same time
        //

        result = RULE_CTRL_UT_Proc_Bind_ACL(uport_ifindex,
                                            direction,
                                            acl_index,
                                            RULE_TYPE_UNDEF_TIME_RANGE,
                                            RULE_TYPE_COUNTER_DISABLE);

        assert(RULE_TYPE_OK != result);

        RULE_CTRL_UT_Proc_Validate_Rule();

        //
        // Unbind policy-map then bind the ACL, it should be OK
        //
        result = RULE_MGR_UnBindPortFromPolicyMap(uport_ifindex, direction, policy_map_index);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();

        result = RULE_MGR_BindPort2Acl(uport_ifindex, acl_index,
                                       acl_type == RULE_TYPE_IP_EXT_ACL ?
                                       RULE_TYPE_IP_ACL :
                                       RULE_TYPE_MAC_ACL,
                                       direction == RULE_TYPE_INBOUND ? TRUE : FALSE,
                                       RULE_TYPE_UNDEF_TIME_RANGE,
                                       RULE_TYPE_COUNTER_DISABLE);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();

        result = RULE_MGR_UnBindPortFromAcl(uport_ifindex, acl_index,
                                            acl_type == RULE_TYPE_IP_EXT_ACL ?
                                            RULE_TYPE_IP_ACL :
                                            RULE_TYPE_MAC_ACL,
                                            direction == RULE_TYPE_INBOUND ? TRUE : FALSE);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Validate_Rule();
    }
#endif // SYS_CPNT_QOS_V2_EGRESS_PORT

    return 0;
}
#endif /* 0 */

void
RULE_CTRL_UT_Software_Bundle_Rate_Limit_Setup()
{
#if (SYS_CPNT_QOS_V2_SOFTWARE_BUNDLE_RATE_CONTROL == TRUE)
    UI32_T policy_map_index;
    UI32_T class_map_index;
    RULE_TYPE_UI_ClassMapElement_T class_element;
    UI32_T class_index;
    RULE_TYPE_UI_Action_T       ui_action;
    RULE_TYPE_TBParamEntry_T    meter;
    RULE_TYPE_UI_BundleGroup_T  ui_bundle_group;

    RULE_TYPE_RETURN_TYPE_T result;

    //
    // p3_in {
    //   bound {rate = 5M}
    //   c31 {rate = 5M, priority = 0}
    //   c32 {rate = 1M, priority = 4}
    //   c33 {rate = 1M, priority = 4}
    //  }
    //
    {
        const char *policy_map_name = "p3_in";

        result = RULE_OM_Create_PolicyMap(policy_map_name, &policy_map_index);
        assert(RULE_TYPE_OK == result);

        {
            const char *class_map_name = "c31";

            result = RULE_OM_Create_ClassMap(class_map_name, RULE_TYPE_CLASS_MAP_MATCH_ANY, &class_map_index);
            assert(RULE_TYPE_OK == result);

            class_element.class_type = RULE_TYPE_CLASS_MF;
            class_element.element.mf_entry.mf_type = RULE_TYPE_MF_VLAN;
            class_element.element.mf_entry.mf_value = 1005;

            result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index,
                                                             &class_element, &class_index);
            assert(RULE_TYPE_OK == result);


            class_element.class_type = RULE_TYPE_CLASS_MF;
            class_element.element.mf_entry.mf_type = RULE_TYPE_MF_COS;
            class_element.element.mf_entry.mf_value = 0;

            result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index,
                                                             &class_element, &class_index);
            assert(RULE_TYPE_OK == result);

            memset(&ui_action, 0, sizeof(ui_action));

            ui_action.in_action_type        = IN_ACTION_INVALID;
            ui_action.out_action_type       = OUT_ACTION_INVALID;
            ui_action.confirm_action_type   = CONFIRM_ACTION_TRANSMIT;
            ui_action.class_action_type     = CLASS_ACTION_INVALID;
            ui_action.exceed_action_type    = EXCEED_ACTION_DROP;
            ui_action.violate_action_type   = VIOLATE_ACTION_DROP;
            ui_action.class_action_type     = CLASS_ACTION_SET_PRIORITY;
            ui_action.class_action_value    = 0;

            meter.meter_model = RULE_TYPE_METER_MODE_FLOW;
            meter.rate = 5000;  // kbps
            meter.burst_size = 4000;

            result = RULE_OM_Add_PolicyMapElement_To_PolicyMap(policy_map_index, class_map_index);
            assert(RULE_TYPE_OK == result);

            result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter);
            assert(RULE_TYPE_OK == result);

            result = RULE_OM_SetUIActionEntry(policy_map_index, class_map_index, &ui_action);
            assert(RULE_TYPE_OK == result);
        }

        {
            const char *class_map_name = "c32";

            result = RULE_OM_Create_ClassMap(class_map_name, RULE_TYPE_CLASS_MAP_MATCH_ANY, &class_map_index);
            assert(RULE_TYPE_OK == result);

            class_element.class_type = RULE_TYPE_CLASS_MF;
            class_element.element.mf_entry.mf_type = RULE_TYPE_MF_VLAN;
            class_element.element.mf_entry.mf_value = 43;

            result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index,
                                                             &class_element, &class_index);
            assert(RULE_TYPE_OK == result);


            class_element.class_type = RULE_TYPE_CLASS_MF;
            class_element.element.mf_entry.mf_type = RULE_TYPE_MF_COS;
            class_element.element.mf_entry.mf_value = 4;

            result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index,
                                                             &class_element, &class_index);
            assert(RULE_TYPE_OK == result);

            memset(&ui_action, 0, sizeof(ui_action));

            ui_action.in_action_type        = IN_ACTION_INVALID;
            ui_action.out_action_type       = OUT_ACTION_INVALID;
            ui_action.confirm_action_type   = CONFIRM_ACTION_TRANSMIT;
            ui_action.class_action_type     = CLASS_ACTION_INVALID;
            ui_action.exceed_action_type    = EXCEED_ACTION_DROP;
            ui_action.violate_action_type   = VIOLATE_ACTION_DROP;

            ui_action.class_action_type     = CLASS_ACTION_SET_PRIORITY;
            ui_action.class_action_value    = 4;

            meter.meter_model = RULE_TYPE_METER_MODE_FLOW;
            meter.rate = 1000;  // kbps
            meter.burst_size = 4000;

            result = RULE_OM_Add_PolicyMapElement_To_PolicyMap(policy_map_index, class_map_index);
            assert(RULE_TYPE_OK == result);

            result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter);
            assert(RULE_TYPE_OK == result);

            result = RULE_OM_SetUIActionEntry(policy_map_index, class_map_index, &ui_action);
            assert(RULE_TYPE_OK == result);
        }

        {
            const char *class_map_name = "c33";

            result = RULE_OM_Create_ClassMap(class_map_name, RULE_TYPE_CLASS_MAP_MATCH_ANY, &class_map_index);
            assert(RULE_TYPE_OK == result);

            class_element.class_type = RULE_TYPE_CLASS_MF;
            class_element.element.mf_entry.mf_type = RULE_TYPE_MF_VLAN;
            class_element.element.mf_entry.mf_value = 4001;

            result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index,
                                                             &class_element, &class_index);
            assert(RULE_TYPE_OK == result);


            class_element.class_type = RULE_TYPE_CLASS_MF;
            class_element.element.mf_entry.mf_type = RULE_TYPE_MF_COS;
            class_element.element.mf_entry.mf_value = 4;

            result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index,
                                                             &class_element, &class_index);
            assert(RULE_TYPE_OK == result);

            memset(&ui_action, 0, sizeof(ui_action));

            ui_action.in_action_type        = IN_ACTION_INVALID;
            ui_action.out_action_type       = OUT_ACTION_INVALID;
            ui_action.confirm_action_type   = CONFIRM_ACTION_TRANSMIT;
            ui_action.exceed_action_type    = EXCEED_ACTION_DROP;
            ui_action.violate_action_type   = VIOLATE_ACTION_DROP;

            ui_action.class_action_type     = CLASS_ACTION_SET_PRIORITY;
            ui_action.class_action_value    = 4;

            meter.meter_model = RULE_TYPE_METER_MODE_FLOW;
            meter.rate = 1000;  // kbps
            meter.burst_size = 4000;

            result = RULE_OM_Add_PolicyMapElement_To_PolicyMap(policy_map_index, class_map_index);
            assert(RULE_TYPE_OK == result);

            result = RULE_OM_Set_MeterEntry(policy_map_index, class_map_index, &meter);
            assert(RULE_TYPE_OK == result);

            result = RULE_OM_SetUIActionEntry(policy_map_index, class_map_index, &ui_action);
            assert(RULE_TYPE_OK == result);
        }

        memset(&ui_bundle_group, 0, sizeof(ui_bundle_group));

        ui_bundle_group.index = 1;
        ui_bundle_group.bundle_rate_kbps = 5000;    // kbps
        ui_bundle_group.class_map_count = 3;
        strcpy(ui_bundle_group.class_map_name_list[0], "c31");
        strcpy(ui_bundle_group.class_map_name_list[1], "c32");
        strcpy(ui_bundle_group.class_map_name_list[2], "c33");
        ui_bundle_group.valid_status = TRUE;

        result = RULE_OM_SetUIBundleGroup(policy_map_index, &ui_bundle_group);
        assert(RULE_TYPE_OK == result);

        {
            UI32_T uport_ifindex = 3;
            RULE_TYPE_InOutDirection_T direction = RULE_TYPE_INBOUND;

            RULE_CTRL_UT_Proc_Bind_Policy_Map(uport_ifindex, direction, policy_map_index);

            //result = RULE_MGR_BindPort2PolicyMap(uport_ifindex, direction, policy_map_index);
            //assert(RULE_TYPE_OK == result);
        }
    }
#endif // SYS_CPNT_QOS_V2_SOFTWARE_BUNDLE_RATE_CONTROL
}

int
RULE_CTRL_UT_Convert_Count_To_Rate()
{
    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_CLASS_INSTANCE_T policy_map_inst;
    RULE_TYPE_CLASS_INSTANCE_T class_map_inst;
    RULE_TYPE_RULE_INSTANCE_T rule_inst;

    UI32_T kbps = 0;

//        UI32_T *current_rate_kbps_p = cookie;

    UI32_T i;

    memset(&rule_inst.counter, 0, sizeof(rule_inst.counter));

    for (i = 0; i < _countof(rule_inst.counter) + 1; ++ i)
    {
        RULE_TYPE_CounterRec_T *counter_p;

        rule_inst.current_counter_index = i % _countof(rule_inst.counter);

        counter_p = &rule_inst.counter[ rule_inst.current_counter_index ];

        counter_p->green_octets     += 20000;
        counter_p->yellow_octets    += 0;
        counter_p->red_octets       += 0;
        counter_p->last_update_tick += 100;
    }

    RULE_CTRL_LocalConvertCountToRate(&interface, &policy_map_inst, &class_map_inst, &rule_inst, &kbps);

    assert(kbps == (20000 * 8 / 1000));

    return 0;
}

int
RULE_CTRL_UT_Software_Bundle_Rate_Limit()
{
#if (SYS_CPNT_QOS_V2_SOFTWARE_BUNDLE_RATE_CONTROL == TRUE)
    UI32_T i;
    UI32_T count;

    RULE_TYPE_INTERFACE_INFO_T interface;

    memset(&interface, 0, sizeof(interface));
    interface.type = RULE_TYPE_INTERFACE_UPORT;
    interface.uport.unit = 1;
    interface.uport.port = 3;
    interface.direction = RULE_TYPE_INBOUND;

    RULE_CTRL_UT_Software_Bundle_Rate_Limit_Setup();

    //
    // Simulate to get count 5 times
    //
    for (i = 0; i < 5; ++i)
    {
        LOG("\r\nRun %lu\r\n", i);

        count += 5000000; // 5MB * 3 = 15MB = 120Mb
        RULE_CTRL_UT_Proc_Set_Count(&interface, count);

        RULE_CTRL_LocalBundleRateControlProcessTimerEvent();
    }

    //
    // reset
    //
    for (i = 5; i < 10; ++i)
    {
        LOG("\r\nRun %lu\r\n", i);

        count += 0;
        RULE_CTRL_UT_Proc_Set_Count(&interface, count);

        RULE_CTRL_LocalBundleRateControlProcessTimerEvent();
    }

#endif // SYS_CPNT_QOS_V2_SOFTWARE_BUNDLE_RATE_CONTROL

    return 0;
}

int
RULE_CTRL_UT_Time_Based_ACL_Process_Time_Simulation()
{
    enum
    {
        MAX_LOOP_COUNT              = 120,
        MAX_TIMER                   = 100,
        MAX_TIME_BASED_ACL_TIMER    = 6000
    };

    UI32_T i;
    UI32_T time_based_acl_timer;

    time_based_acl_timer = 0;
    for (i = 0; i < MAX_LOOP_COUNT; ++i)
    {
        time_based_acl_timer += MAX_TIMER;
        if (MAX_TIME_BASED_ACL_TIMER <= time_based_acl_timer)
        {
            time_based_acl_timer = 0;
            printf("process timer event %lu for time base ACL\r\n", i);
        }
    }

    return 0;
}

#pragma mark -
#pragma mark Test Cases for Class/Rule Instance
int
RULE_CTRL_UT_Create_Class_Instance()
{
    RULE_TYPE_SHM_POINTER_T ptr;
    UI32_T cnt = 0;

    while (1)
    {
        ptr = RULE_CTRL_IN_Priv_CreateClassInstance(RULE_TYPE_INST_POLICY_MAP);
        if (RULE_TYPE_NIL == ptr.type)
        {
            break;
        }

        ++ cnt;
    }

    assert(_countof(shmem_data_p->_class_inst_pool_buf) == cnt);

    return 0;
}

int
RULE_CTRL_UT_Create_Class_Instance_2()
{
    RULE_TYPE_SHM_POINTER_T ptr;
    UI32_T cnt = 0;

    while (1)
    {
        ptr = RULE_CTRL_IN_Priv_CreateClassInstance(RULE_TYPE_INST_ACL);
        if (RULE_TYPE_NIL == ptr.type)
        {
            break;
        }

        ++ cnt;
    }

    assert(_countof(shmem_data_p->_class_inst_pool_buf) == cnt);

    return 0;
}

int
RULE_CTRL_UT_Create_Class_Instance_Temp()
{
    RULE_TYPE_SHM_POINTER_T ptr;
    UI32_T cnt = 0;

    while (1)
    {
        ptr = RULE_CTRL_IN_Priv_CreateClassInstance(RULE_TYPE_INST_MF_ACE);
        if (RULE_TYPE_NIL == ptr.type)
        {
            break;
        }

        ++ cnt;
    }

    assert(_countof(shmem_data_p->_class_inst_pool_buf) == cnt);

    return 0;
}

int
RULE_CTRL_UT_Create_Rule_Instance()
{
    RULE_TYPE_SHM_POINTER_T ptr;
    UI32_T cnt = 0;

    while (1)
    {
        ptr = RULE_CTRL_IN_Priv_CreateRuleInstance(RULE_TYPE_INST_RULE);
        if (RULE_TYPE_NIL == ptr.type)
        {
            break;
        }

        ++ cnt;
    }

    assert(_countof(shmem_data_p->_rule_inst_pool_buf) == cnt);

    return 0;
}

int
RULE_CTRL_UT_Add_Class_Instance_Into_Class_Instance()
{
    const UI32_T    ACL_ID_BASE = 100;

    RULE_TYPE_SHM_POINTER_T  class_ptr;
    RULE_TYPE_SHM_POINTER_T  acl_ptr;
    RULE_TYPE_SHM_POINTER_T  ptr;

    RULE_TYPE_INSTANCE_T *class_map;
    RULE_TYPE_CLASS_INSTANCE_T *acl;

    UI16_T          acl_id;

    class_ptr = RULE_CTRL_IN_Priv_CreateClassInstance(RULE_TYPE_INST_CLASS_MAP);
    assert(RULE_TYPE_NIL != class_ptr.type);

    acl_id = ACL_ID_BASE;

    while (1)
    {
        acl_ptr = RULE_CTRL_IN_Priv_CreateClassInstance(RULE_TYPE_INST_ACL);
        if (RULE_TYPE_NIL == acl_ptr.type)
        {
            break;
        }

        acl = RULE_CTRL_IN_Ptr2Instance(acl_ptr);
        acl->acl_id = acl_id ++;

        RULE_CTRL_IN_LL_Priv_InsertEnd(class_ptr, acl_ptr);
    }

    assert(ACL_ID_BASE + (_countof(shmem_data_p->_class_inst_pool_buf)-1) == acl_id);

    acl_id = ACL_ID_BASE;

    class_map = RULE_CTRL_IN_Ptr2Instance(class_ptr);
    ptr = class_map->links.first_node;
    while (RULE_TYPE_NIL != ptr.type)
    {
        acl = RULE_CTRL_IN_Ptr2Instance(ptr);

        assert(acl->acl_id == acl_id++);

        ptr = acl->super.links.next;
    }

    assert(ACL_ID_BASE + (_countof(shmem_data_p->_class_inst_pool_buf)-1) == acl_id);

    return 0;
}

int
RULE_CTRL_UT_Add_Rule_Instance_Into_Class_Instance()
{
    RULE_TYPE_SHM_POINTER_T  class_ptr;
    RULE_TYPE_SHM_POINTER_T  rule_ptr;
    RULE_TYPE_SHM_POINTER_T  ptr;

    RULE_TYPE_INSTANCE_T *class;
    RULE_TYPE_RULE_INSTANCE_T *rule;

    UI16_T          ace_id;

    class_ptr = RULE_CTRL_IN_Priv_CreateClassInstance(RULE_TYPE_INST_CLASS_MAP);
    assert(RULE_TYPE_NIL != class_ptr.type);

    ace_id = 100;

    while (1)
    {
        rule_ptr = RULE_CTRL_IN_Priv_CreateRuleInstance(RULE_TYPE_INST_RULE);
        if (RULE_TYPE_NIL == rule_ptr.type)
        {
            break;
        }

        rule = RULE_CTRL_IN_Ptr2Instance(rule_ptr);
        rule->ace_id = ace_id ++;

        RULE_CTRL_IN_LL_Priv_InsertEnd(class_ptr, rule_ptr);
    }

    assert(100 + _countof(shmem_data_p->_rule_inst_pool_buf) == ace_id);

    ace_id = 100;

    class = RULE_CTRL_IN_Ptr2Instance(class_ptr);
    ptr = class->links.first_node;
    while (RULE_TYPE_NIL != ptr.type)
    {
        rule = RULE_CTRL_IN_Ptr2Instance(ptr);

        assert(rule->ace_id == ace_id++);

        ptr = rule->super.links.next;
    }

    assert(100 + _countof(shmem_data_p->_rule_inst_pool_buf) == ace_id);

    return 0;
}

int RULE_CTRL_UT_Create_Class_Instance_Object()
{
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T policy_map;
    RULE_TYPE_RETURN_TYPE_T ret;
    UI32_T cnt = 0;

    while (1)
    {
        ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_POLICY_MAP, &policy_map);
        if (RULE_TYPE_OK != ret)
        {
            break;
        }

        policy_map.inst->policy_map_id = cnt++;
    }

    assert(_countof(shmem_data_p->_class_inst_pool_buf) == cnt);

    return 0;
}

int
RULE_CTRL_UT_Create_Rule_Instance_Object()
{
    RULE_TYPE_RULE_INSTANCE_OBJECT_T ace;
    RULE_TYPE_RETURN_TYPE_T ret;
    UI32_T cnt = 0;

    while (1)
    {
        ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &ace);
        if (RULE_TYPE_OK != ret)
        {
            break;
        }

        ace.inst->ace_id = cnt++;
    }

    assert(_countof(shmem_data_p->_rule_inst_pool_buf) == cnt);

    return 0;
}

int
RULE_CTRL_UT_Create_Class_Rule_Instance_Object()
{
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T class_map;
    RULE_TYPE_RULE_INSTANCE_OBJECT_T mf_ace;
    RULE_TYPE_RETURN_TYPE_T ret;

    UI32_T cnt = 0;

    while (1)
    {
        ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_CLASS_MAP, &class_map);
        if (RULE_TYPE_OK != ret)
        {
            break;
        }

        class_map.inst->class_map_id = cnt++;
    }
    assert(_countof(shmem_data_p->_class_inst_pool_buf) == cnt);

    cnt = 0;
    while (1)
    {
        ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &mf_ace);
        if (RULE_TYPE_OK != ret)
        {
            break;
        }

        mf_ace.inst->ace_id = cnt++;
    }

    assert(_countof(shmem_data_p->_rule_inst_pool_buf) == cnt);

    return 0;
}

int
RULE_CTRL_UT_Append_ACE_Into_ACL()
{
    const UI32_T ACL_ID_BASE = 100;
    const UI32_T ACE_ID_BASE = 200;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T acl;
    RULE_TYPE_RULE_INSTANCE_OBJECT_T ace;

    RULE_TYPE_SHM_POINTER_T ptr;
    RULE_TYPE_RULE_INSTANCE_T *ace_in;

    RULE_TYPE_RETURN_TYPE_T ret;
    UI32_T acl_id = ACL_ID_BASE;
    UI32_T ace_id = ACE_ID_BASE;

    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL, &acl);
    assert(RULE_TYPE_OK == ret);

    acl.inst->id = acl_id;
    assert(acl.inst->acl_id == acl_id);

    while (1)
    {
        ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &ace);
        if (RULE_TYPE_OK != ret)
        {
            break;
        }

        ace.inst->id = ace_id ++;
        acl.add_rule_obj(&acl, &ace);
    }

    assert(RULE_TYPE_NIL == acl.inst->super.links.parent.type);
    assert(NULL == RULE_CTRL_IN_Ptr2Instance(acl.inst->super.links.parent));

    ace_id = ACE_ID_BASE;

    ptr = acl.inst->super.links.first_node;
    while (RULE_TYPE_NIL != ptr.type)
    {
        ace_in = RULE_CTRL_IN_Ptr2Instance(ptr);

        assert(ace_in->ace_id == ace_id++);

        assert(RULE_TYPE_NIL != ace_in->super.links.parent.type);
        assert(acl.inst == RULE_CTRL_IN_Ptr2Instance(ace_in->super.links.parent));

        ptr = ace_in->super.links.next;
    }

    return 0;
}

int
RULE_CTRL_UT_Append_MF_ACE_ACL_Into_Class_Map()
{
    const UI32_T CLASS_MAP_ID_BASE = 50;
    const UI32_T ACL_ID_BASE = 100;
    const UI32_T ACE_ID_BASE = 200;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T    class_map;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T    acl_1;
    RULE_TYPE_RULE_INSTANCE_OBJECT_T     mf_ace_2;
    RULE_TYPE_RULE_INSTANCE_OBJECT_T     mf_ace_3;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T    acl_4;
    RULE_TYPE_RULE_INSTANCE_OBJECT_T     ace;

    UI32_T class_map_id = CLASS_MAP_ID_BASE;
    UI32_T acl_id = ACL_ID_BASE;
    UI32_T ace_id = ACE_ID_BASE;

    RULE_TYPE_RETURN_TYPE_T ret;

    printf("%s no run\r\n", __FUNCTION__);
    return 0;

    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_CLASS_MAP, &class_map);
    assert(RULE_TYPE_OK == ret);

    class_map.inst->id = class_map_id;

    ////////////////////////////////////////////////////////////////////////////
    // acl 1

    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL, &acl_1);
    assert(RULE_TYPE_OK == ret);

    acl_1.inst->id = acl_id++;

    ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &ace);
    assert(RULE_TYPE_OK == ret);

    ace.inst->id = ace_id++;

    acl_1.add_rule_obj(&acl_1, &ace);

    ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &ace);
    assert(RULE_TYPE_OK == ret);

    ace.inst->id = ace_id++;

    acl_1.add_rule_obj(&acl_1, &ace);

    ////////////////////////////////////////////////////////////////////////////
    // mf ace 2

    ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_MF_ACE, &mf_ace_2);
    assert(RULE_TYPE_OK == ret);

    mf_ace_2.inst->id = ace_id++;

    ////////////////////////////////////////////////////////////////////////////
    // mf ace 3

    ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_MF_ACE, &mf_ace_3);
    assert(RULE_TYPE_OK == ret);

    mf_ace_3.inst->id = ace_id++;

    ////////////////////////////////////////////////////////////////////////////
    // acl 4

    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL, &acl_4);
    assert(RULE_TYPE_OK == ret);

    acl_4.inst->id = acl_id++;

    ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &ace);
    assert(RULE_TYPE_OK == ret);

    ace.inst->id = ace_id++;

    acl_4.add_rule_obj(&acl_4, &ace);

    ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &ace);
    assert(RULE_TYPE_OK == ret);

    ace.inst->id = ace_id++;

    acl_4.add_rule_obj(&acl_4, &ace);

    ////////////////////////////////////////////////////////////////////////////
    // add all into class map

    class_map.add_class_obj(&class_map, &acl_1);
    class_map.add_rule_obj(&class_map, &mf_ace_2);
    class_map.add_rule_obj(&class_map, &mf_ace_3);
    class_map.add_class_obj(&class_map, &acl_4);

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////

    {
        RULE_TYPE_SHM_POINTER_T ptr;
        RULE_TYPE_INSTANCE_T *in;
        RULE_TYPE_CLASS_INSTANCE_T *class_in;
        RULE_TYPE_RULE_INSTANCE_T *rule_in;

        UI32_T no = 1;

        ptr = class_map.inst->super.links.first_node;
        while (RULE_TYPE_NIL != ptr.type)
        {
            in = RULE_CTRL_IN_Ptr2Instance(ptr);

            switch (no)
            {
                case 1:
                    assert(in->type == RULE_TYPE_INST_ACL);

                    class_in = (RULE_TYPE_CLASS_INSTANCE_T *) in;
                    assert(class_in->id == ACL_ID_BASE);

                    {
                        RULE_TYPE_SHM_POINTER_T ace_ptr = class_in->super.links.first_node;
                        RULE_TYPE_RULE_INSTANCE_T *ace_in;

                        assert(RULE_TYPE_NIL != ace_ptr.type);
                        ace_in = RULE_CTRL_IN_Ptr2Instance(ace_ptr);
                        assert(ace_in->id == ACE_ID_BASE);

                        ace_ptr = ace_in->super.links.next;
                        assert(RULE_TYPE_NIL != ace_ptr.type);
                        ace_in = RULE_CTRL_IN_Ptr2Instance(ace_ptr);
                        assert(ace_in->id == ACE_ID_BASE+1);

                        ace_ptr = ace_in->super.links.next;
                        assert(RULE_TYPE_NIL == ace_ptr.type);
                    }
                    break;

                case 2:
                    assert(in->type == RULE_TYPE_INST_MF_ACE);

                    rule_in = (RULE_TYPE_RULE_INSTANCE_T *) in;
                    assert(rule_in->id == ACE_ID_BASE+2);
                    break;

                case 3:
                    assert(in->type == RULE_TYPE_INST_MF_ACE);

                    rule_in = (RULE_TYPE_RULE_INSTANCE_T *) in;
                    assert(rule_in->id == ACE_ID_BASE+3);
                    break;

                case 4:
                    assert(in->type == RULE_TYPE_INST_ACL);

                    class_in = (RULE_TYPE_CLASS_INSTANCE_T *) in;
                    assert(class_in->id == ACL_ID_BASE+1);

                    {
                        RULE_TYPE_SHM_POINTER_T ace_ptr = class_in->super.links.first_node;
                        RULE_TYPE_RULE_INSTANCE_T *ace_in;

                        assert(RULE_TYPE_NIL != ace_ptr.type);
                        ace_in = RULE_CTRL_IN_Ptr2Instance(ace_ptr);
                        assert(ace_in->id == ACE_ID_BASE+4);

                        ace_ptr = ace_in->super.links.next;
                        assert(RULE_TYPE_NIL != ace_ptr.type);
                        ace_in = RULE_CTRL_IN_Ptr2Instance(ace_ptr);
                        assert(ace_in->id == ACE_ID_BASE+5);

                        ace_ptr = ace_in->super.links.next;
                        assert(RULE_TYPE_NIL == ace_ptr.type);
                    }
                    break;

                default:
                    assert(0);
                    break;
            }

            ptr = in->links.next;
            ++no;
        }

        assert(5 == no);
    }

    return 0;
}

int
RULE_CTRL_UT_Append_All_Into_Policy_Map()
{
    //
    // access-list a1
    //      permit 1.1.1.1
    //      permit 1.1.1.2
    //      deny   1.1.1.3
    // access-list a2
    //      permit 1.1.1.4
    //      permit 1.1.1.5
    //      deny   1.1.1.6
    //
    // class-map c1
    //      match vlan 1
    //      match access-list a1
    //      match vlan 2
    //      match access-list a2
    //
    //  class-map c2
    //      match access-list a1
    //      match access-list a2
    //      match vlan 1
    //      match vlan 2
    //
    //  class-map c3
    //      match vlan 1
    //      match vlan 2
    //
    //  class-map c4
    //      match access-list a1
    //
    //  policy-map p1
    //      class c1
    //      class c2
    //      class c3
    //      class c4
    //
    const UI32_T POLICY_MAP_ID_BASE = 20;
    const UI32_T CLASS_MAP_ID_BASE  = 50;
    const UI32_T ACL_ID_BASE = 100;
    const UI32_T ACE_ID_BASE = 200;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T    policy_map;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T    class_map;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T    acl;
    RULE_TYPE_RULE_INSTANCE_OBJECT_T     mf_ace;

    UI32_T policy_map_id = POLICY_MAP_ID_BASE;
    UI32_T class_map_id = CLASS_MAP_ID_BASE;
    UI32_T acl_id = ACL_ID_BASE;
    UI32_T ace_id = ACE_ID_BASE;

    RULE_TYPE_RETURN_TYPE_T ret;

    printf("%s no run\r\n", __FUNCTION__);
    return 0;

    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_POLICY_MAP, &policy_map);
    assert(RULE_TYPE_OK == ret);

    policy_map.inst->id = policy_map_id++;

    ////////////////////////////////////////////////////////////////////////////
    // class-map c1

    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_CLASS_MAP, &class_map);
    assert(RULE_TYPE_OK == ret);

    class_map.inst->id = class_map_id++;

    policy_map.add_class_obj(&policy_map, &class_map);

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_MF_ACE, &mf_ace);
    assert(RULE_TYPE_OK == ret);

    mf_ace.inst->id = ace_id++;

    class_map.add_rule_obj(&class_map, &mf_ace);

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL, &acl);
    assert(RULE_TYPE_OK == ret);

    acl.inst->id = acl_id++;

    class_map.add_class_obj(&class_map, &acl);

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_MF_ACE, &mf_ace);
    assert(RULE_TYPE_OK == ret);

    mf_ace.inst->id = ace_id++;

    class_map.add_rule_obj(&class_map, &mf_ace);

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL, &acl);
    assert(RULE_TYPE_OK == ret);

    acl.inst->id = acl_id++;

    class_map.add_class_obj(&class_map, &acl);

    ////////////////////////////////////////////////////////////////////////////
    // class-map c2

    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_CLASS_MAP, &class_map);
    assert(RULE_TYPE_OK == ret);

    class_map.inst->id = class_map_id++;

    policy_map.add_class_obj(&policy_map, &class_map);

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL, &acl);
    assert(RULE_TYPE_OK == ret);

    acl.inst->id = acl_id++;

    class_map.add_class_obj(&class_map, &acl);

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL, &acl);
    assert(RULE_TYPE_OK == ret);

    acl.inst->id = acl_id++;

    class_map.add_class_obj(&class_map, &acl);

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_MF_ACE, &mf_ace);
    assert(RULE_TYPE_OK == ret);

    mf_ace.inst->id = ace_id++;

    class_map.add_rule_obj(&class_map, &mf_ace);

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_MF_ACE, &mf_ace);
    assert(RULE_TYPE_OK == ret);

    mf_ace.inst->id = ace_id++;

    class_map.add_rule_obj(&class_map, &mf_ace);

    ////////////////////////////////////////////////////////////////////////////
    // class-map c3

    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_CLASS_MAP, &class_map);
    assert(RULE_TYPE_OK == ret);

    class_map.inst->id = class_map_id++;

    policy_map.add_class_obj(&policy_map, &class_map);

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_MF_ACE, &mf_ace);
    assert(RULE_TYPE_OK == ret);

    mf_ace.inst->id = ace_id++;

    class_map.add_rule_obj(&class_map, &mf_ace);

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_MF_ACE, &mf_ace);
    assert(RULE_TYPE_OK == ret);

    mf_ace.inst->id = ace_id++;

    class_map.add_rule_obj(&class_map, &mf_ace);

    ////////////////////////////////////////////////////////////////////////////
    // class-map c4

    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_CLASS_MAP, &class_map);
    assert(RULE_TYPE_OK == ret);

    class_map.inst->id = class_map_id++;

    policy_map.add_class_obj(&policy_map, &class_map);

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL, &acl);
    assert(RULE_TYPE_OK == ret);

    acl.inst->id = acl_id++;

    class_map.add_class_obj(&class_map, &acl);


    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////

    {
        RULE_TYPE_SHM_POINTER_T ptr;
        RULE_TYPE_INSTANCE_T *in;
        RULE_TYPE_CLASS_INSTANCE_T *class_in;

        UI32_T no = 1;

        ptr = policy_map.inst->super.links.first_node;
        while (RULE_TYPE_NIL != ptr.type)
        {
            in = RULE_CTRL_IN_Ptr2Instance(ptr);

            switch (no)
            {
                case 1:
                    assert(in->type == RULE_TYPE_INST_CLASS_MAP);

                    class_in = (RULE_TYPE_CLASS_INSTANCE_T *) in;
                    assert(class_in->id == CLASS_MAP_ID_BASE);

                    {
                        RULE_TYPE_SHM_POINTER_T class_elem_ptr = class_in->super.links.first_node;
                        RULE_TYPE_INSTANCE_T *class_elem_in;
                        RULE_TYPE_RULE_INSTANCE_T *mf_in;
                        RULE_TYPE_CLASS_INSTANCE_T *acl_in;

                        assert(RULE_TYPE_NIL != class_elem_ptr.type);
                        class_elem_in = RULE_CTRL_IN_Ptr2Instance(class_elem_ptr);
                        assert(RULE_TYPE_INST_MF_ACE == class_elem_in->type);

                        mf_in = (RULE_TYPE_RULE_INSTANCE_T *)class_elem_in;
                        assert(mf_in->id == ACE_ID_BASE+0);

                        class_elem_ptr = class_elem_in->links.next;
                        assert(RULE_TYPE_NIL != class_elem_ptr.type);
                        class_elem_in = RULE_CTRL_IN_Ptr2Instance(class_elem_ptr);
                        assert(RULE_TYPE_INST_ACL == class_elem_in->type);

                        acl_in = (RULE_TYPE_CLASS_INSTANCE_T *)class_elem_in;
                        assert(acl_in->id == ACL_ID_BASE+0);

                        class_elem_ptr = class_elem_in->links.next;
                        assert(RULE_TYPE_NIL != class_elem_ptr.type);
                        class_elem_in = RULE_CTRL_IN_Ptr2Instance(class_elem_ptr);
                        assert(RULE_TYPE_INST_MF_ACE == class_elem_in->type);

                        mf_in = (RULE_TYPE_RULE_INSTANCE_T *)class_elem_in;
                        assert(mf_in->id == ACE_ID_BASE+1);

                        class_elem_ptr = class_elem_in->links.next;
                        assert(RULE_TYPE_NIL != class_elem_ptr.type);
                        class_elem_in = RULE_CTRL_IN_Ptr2Instance(class_elem_ptr);
                        assert(RULE_TYPE_INST_ACL == class_elem_in->type);

                        acl_in = (RULE_TYPE_CLASS_INSTANCE_T *)class_elem_in;
                        assert(acl_in->id == ACL_ID_BASE+1);

                        class_elem_ptr = class_elem_in->links.next;
                        assert(RULE_TYPE_NIL == class_elem_ptr.type);
                    }

                    break;

                case 2:
                    assert(in->type == RULE_TYPE_INST_CLASS_MAP);

                    class_in = (RULE_TYPE_CLASS_INSTANCE_T *) in;
                    assert(class_in->id == CLASS_MAP_ID_BASE+1);

                    {
                        RULE_TYPE_SHM_POINTER_T class_elem_ptr = class_in->super.links.first_node;
                        RULE_TYPE_INSTANCE_T *class_elem_in;
                        RULE_TYPE_RULE_INSTANCE_T *mf_in;
                        RULE_TYPE_CLASS_INSTANCE_T *acl_in;

                        assert(RULE_TYPE_NIL != class_elem_ptr.type);
                        class_elem_in = RULE_CTRL_IN_Ptr2Instance(class_elem_ptr);
                        assert(RULE_TYPE_INST_ACL == class_elem_in->type);

                        acl_in = (RULE_TYPE_CLASS_INSTANCE_T *)class_elem_in;
                        assert(acl_in->id == ACL_ID_BASE+2);

                        class_elem_ptr = class_elem_in->links.next;
                        assert(RULE_TYPE_NIL != class_elem_ptr.type);
                        class_elem_in = RULE_CTRL_IN_Ptr2Instance(class_elem_ptr);
                        assert(RULE_TYPE_INST_ACL == class_elem_in->type);

                        acl_in = (RULE_TYPE_CLASS_INSTANCE_T *)class_elem_in;
                        assert(acl_in->id == ACL_ID_BASE+3);

                        class_elem_ptr = class_elem_in->links.next;
                        assert(RULE_TYPE_NIL != class_elem_ptr.type);
                        class_elem_in = RULE_CTRL_IN_Ptr2Instance(class_elem_ptr);
                        assert(RULE_TYPE_INST_MF_ACE == class_elem_in->type);

                        mf_in = (RULE_TYPE_RULE_INSTANCE_T *)class_elem_in;
                        assert(mf_in->id == ACE_ID_BASE+2);

                        class_elem_ptr = class_elem_in->links.next;
                        assert(RULE_TYPE_NIL != class_elem_ptr.type);
                        class_elem_in = RULE_CTRL_IN_Ptr2Instance(class_elem_ptr);
                        assert(RULE_TYPE_INST_MF_ACE == class_elem_in->type);

                        mf_in = (RULE_TYPE_RULE_INSTANCE_T *)class_elem_in;
                        assert(mf_in->id == ACE_ID_BASE+3);

                        class_elem_ptr = class_elem_in->links.next;
                        assert(RULE_TYPE_NIL == class_elem_ptr.type);
                    }
                    break;

                case 3:
                    assert(in->type == RULE_TYPE_INST_CLASS_MAP);

                    class_in = (RULE_TYPE_CLASS_INSTANCE_T *) in;
                    assert(class_in->id == CLASS_MAP_ID_BASE+2);

                    {
                        RULE_TYPE_SHM_POINTER_T class_elem_ptr = class_in->super.links.first_node;
                        RULE_TYPE_INSTANCE_T *class_elem_in;
                        RULE_TYPE_RULE_INSTANCE_T *mf_in;

                        assert(RULE_TYPE_NIL != class_elem_ptr.type);
                        class_elem_in = RULE_CTRL_IN_Ptr2Instance(class_elem_ptr);
                        assert(RULE_TYPE_INST_MF_ACE == class_elem_in->type);

                        mf_in = (RULE_TYPE_RULE_INSTANCE_T *)class_elem_in;
                        assert(mf_in->id == ACE_ID_BASE+4);

                        class_elem_ptr = class_elem_in->links.next;
                        assert(RULE_TYPE_NIL != class_elem_ptr.type);
                        class_elem_in = RULE_CTRL_IN_Ptr2Instance(class_elem_ptr);
                        assert(RULE_TYPE_INST_MF_ACE == class_elem_in->type);

                        mf_in = (RULE_TYPE_RULE_INSTANCE_T *)class_elem_in;
                        assert(mf_in->id == ACE_ID_BASE+5);

                        class_elem_ptr = class_elem_in->links.next;
                        assert(RULE_TYPE_NIL == class_elem_ptr.type);
                    }
                    break;

                case 4:
                    assert(in->type == RULE_TYPE_INST_CLASS_MAP);

                    class_in = (RULE_TYPE_CLASS_INSTANCE_T *) in;
                    assert(class_in->id == CLASS_MAP_ID_BASE+3);

                    {
                        RULE_TYPE_SHM_POINTER_T class_elem_ptr = class_in->super.links.first_node;
                        RULE_TYPE_INSTANCE_T *class_elem_in;
                        RULE_TYPE_CLASS_INSTANCE_T *acl_in;

                        assert(RULE_TYPE_NIL != class_elem_ptr.type);
                        class_elem_in = RULE_CTRL_IN_Ptr2Instance(class_elem_ptr);
                        assert(RULE_TYPE_INST_ACL == class_elem_in->type);

                        acl_in = (RULE_TYPE_CLASS_INSTANCE_T *)class_elem_in;
                        assert(acl_in->id == ACL_ID_BASE+4);

                        class_elem_ptr = class_elem_in->links.next;
                        assert(RULE_TYPE_NIL == class_elem_ptr.type);
                    }
                    break;

                default:
                    assert(0);
                    break;
            }

            ptr = in->links.next;
            ++no;
        }

        assert(5 == no);
    }

    return 0;
}

int
RULE_CTRL_UT_Append_All_Into_Policy_Map_Use_Iterator()
{
    //
    // access-list a1
    //      permit 1.1.1.1
    //      permit 1.1.1.2
    //      deny   1.1.1.3
    // access-list a2
    //      permit 1.1.1.4
    //      permit 1.1.1.5
    //      deny   1.1.1.6
    //
    // class-map c1
    //      match vlan 1
    //      match access-list a1
    //      match vlan 2
    //      match access-list a2
    //
    //  class-map c2
    //      match access-list a1
    //      match access-list a2
    //      match vlan 1
    //      match vlan 2
    //
    //  class-map c3
    //      match vlan 1
    //      match vlan 2
    //
    //  class-map c4
    //      match access-list a1
    //
    //  policy-map p1
    //      class c1
    //      class c2
    //      class c3
    //      class c4
    //
    const UI32_T POLICY_MAP_ID_BASE = 20;
    const UI32_T CLASS_MAP_ID_BASE  = 50;
    const UI32_T ACL_ID_BASE = 100;
    const UI32_T ACE_ID_BASE = 200;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T    policy_map;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T    class_map;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T    acl;
    RULE_TYPE_RULE_INSTANCE_OBJECT_T     mf_ace;
    RULE_TYPE_RULE_INSTANCE_OBJECT_T     ace;

    UI32_T policy_map_id = POLICY_MAP_ID_BASE;
    UI32_T class_map_id = CLASS_MAP_ID_BASE;
    UI32_T acl_id = ACL_ID_BASE;
    UI32_T ace_id = ACE_ID_BASE;
    UI32_T i;

    RULE_TYPE_RETURN_TYPE_T ret;

    printf("%s no run\r\n", __FUNCTION__);
    return 0;

    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_POLICY_MAP, &policy_map);
    assert(RULE_TYPE_OK == ret);

    policy_map.inst->id = policy_map_id++;

    ////////////////////////////////////////////////////////////////////////////
    // class-map c1

    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_CLASS_MAP, &class_map);
    assert(RULE_TYPE_OK == ret);

    class_map.inst->id = class_map_id++;

    policy_map.add_class_obj(&policy_map, &class_map);

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_MF_ACE, &mf_ace);
    assert(RULE_TYPE_OK == ret);

    mf_ace.inst->id = ace_id++;

    class_map.add_rule_obj(&class_map, &mf_ace);

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL, &acl);
    assert(RULE_TYPE_OK == ret);

    acl.inst->id = acl_id++;

    class_map.add_class_obj(&class_map, &acl);

    for (i = 0; i < 3; i ++)
    {
        ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &ace);
        assert(RULE_TYPE_OK == ret);

        ace.inst->id = ace_id++;
        acl.add_rule_obj(&acl, &ace);
    }

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_MF_ACE, &mf_ace);
    assert(RULE_TYPE_OK == ret);

    mf_ace.inst->id = ace_id++;

    class_map.add_rule_obj(&class_map, &mf_ace);

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL, &acl);
    assert(RULE_TYPE_OK == ret);

    acl.inst->id = acl_id++;

    class_map.add_class_obj(&class_map, &acl);

    for (i = 0; i < 3; i ++)
    {
        ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &ace);
        assert(RULE_TYPE_OK == ret);

        ace.inst->id = ace_id++;
        acl.add_rule_obj(&acl, &ace);
    }

    ////////////////////////////////////////////////////////////////////////////
    // class-map c2

    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_CLASS_MAP, &class_map);
    assert(RULE_TYPE_OK == ret);

    class_map.inst->id = class_map_id++;

    policy_map.add_class_obj(&policy_map, &class_map);

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL, &acl);
    assert(RULE_TYPE_OK == ret);

    acl.inst->id = acl_id++;

    class_map.add_class_obj(&class_map, &acl);

    for (i = 0; i < 3; i ++)
    {
        ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &ace);
        assert(RULE_TYPE_OK == ret);

        ace.inst->id = ace_id++;
        acl.add_rule_obj(&acl, &ace);
    }

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL, &acl);
    assert(RULE_TYPE_OK == ret);

    acl.inst->id = acl_id++;

    class_map.add_class_obj(&class_map, &acl);

    for (i = 0; i < 3; i ++)
    {
        ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &ace);
        assert(RULE_TYPE_OK == ret);

        ace.inst->id = ace_id++;
        acl.add_rule_obj(&acl, &ace);
    }

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_MF_ACE, &mf_ace);
    assert(RULE_TYPE_OK == ret);

    mf_ace.inst->id = ace_id++;

    class_map.add_rule_obj(&class_map, &mf_ace);

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_MF_ACE, &mf_ace);
    assert(RULE_TYPE_OK == ret);

    mf_ace.inst->id = ace_id++;

    class_map.add_rule_obj(&class_map, &mf_ace);

    ////////////////////////////////////////////////////////////////////////////
    // class-map c3

    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_CLASS_MAP, &class_map);
    assert(RULE_TYPE_OK == ret);

    class_map.inst->id = class_map_id++;

    policy_map.add_class_obj(&policy_map, &class_map);

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_MF_ACE, &mf_ace);
    assert(RULE_TYPE_OK == ret);

    mf_ace.inst->id = ace_id++;

    class_map.add_rule_obj(&class_map, &mf_ace);

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_MF_ACE, &mf_ace);
    assert(RULE_TYPE_OK == ret);

    mf_ace.inst->id = ace_id++;

    class_map.add_rule_obj(&class_map, &mf_ace);

    ////////////////////////////////////////////////////////////////////////////
    // class-map c4

    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_CLASS_MAP, &class_map);
    assert(RULE_TYPE_OK == ret);

    class_map.inst->id = class_map_id++;

    policy_map.add_class_obj(&policy_map, &class_map);

    //===========================================
    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL, &acl);
    assert(RULE_TYPE_OK == ret);

    acl.inst->id = acl_id++;

    class_map.add_class_obj(&class_map, &acl);

    for (i = 0; i < 3; i ++)
    {
        ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &ace);
        assert(RULE_TYPE_OK == ret);

        ace.inst->id = ace_id++;
        acl.add_rule_obj(&acl, &ace);
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////

    //
    // Reset the temporal variables
    //
    memset(&class_map, 0, sizeof(class_map));
    memset(&acl, 0, sizeof(acl));
    memset(&mf_ace, 0, sizeof(mf_ace));
    memset(&ace, 0, sizeof(ace));

    //
    // Use eof + while
    //
    {
        RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T policy_elem_iter;
        UI32_T no = 1;

        policy_map.get_element_iterator(&policy_map, &policy_elem_iter);

        while (TRUE != policy_elem_iter.eof(&policy_elem_iter))
        {
            ++ no;
            policy_elem_iter.next(&policy_elem_iter);
        }

        assert(5 == no);
    }

    //
    // Use eof + for
    //
    {
        RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T policy_elem_iter;
        UI32_T no = 1;

        for (policy_map.get_element_iterator(&policy_map, &policy_elem_iter);
             TRUE != policy_elem_iter.eof(&policy_elem_iter);
             policy_elem_iter.next(&policy_elem_iter))
        {
            ++ no;
        }

        assert(5 == no);
    }

    policy_map_id = POLICY_MAP_ID_BASE;
    class_map_id = CLASS_MAP_ID_BASE;
    acl_id = ACL_ID_BASE;
    ace_id = ACE_ID_BASE;

    {
        RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T policy_elem_iter;

        UI32_T no = 1;

        policy_map.get_element_iterator(&policy_map, &policy_elem_iter);

        for (;
             TRUE != policy_elem_iter.eof(&policy_elem_iter);
             policy_elem_iter.next(&policy_elem_iter))
        {
            RULE_TYPE_INSTANCE_T *policy_elem_in = policy_elem_iter.get_instance(&policy_elem_iter);

            switch (no)
            {
                case 1:
                    assert(policy_elem_in->type == RULE_TYPE_INST_CLASS_MAP);

                    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(policy_elem_iter.get_ptr(&policy_elem_iter),
                                                                              &class_map);

                {
                    RULE_TYPE_CLASS_INSTANCE_OBJECT_T from_inst_class_map;

                    RULE_CTRL_IN_Priv_ConstructClassInstanceObject((RULE_TYPE_CLASS_INSTANCE_T *) policy_elem_iter.get_instance(&policy_elem_iter),
                                                                   &from_inst_class_map);

                    assert(0 == memcmp(&class_map, &from_inst_class_map, sizeof(class_map)));
                }

                    assert(class_map.inst->id == class_map_id);
                    class_map_id++;

                {
                    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T class_elem_iter;
                    RULE_TYPE_RULE_INSTANCE_T *mf_in;
                    RULE_TYPE_CLASS_INSTANCE_T *acl_in;

                    class_map.get_element_iterator(&class_map, &class_elem_iter);
                    assert(FALSE == class_elem_iter.eof(&class_elem_iter));

                    assert(NULL != class_elem_iter.get_instance(&class_elem_iter));
                    assert(RULE_TYPE_INST_MF_ACE == class_elem_iter.get_instance(&class_elem_iter)->type);
                    mf_in = (RULE_TYPE_RULE_INSTANCE_T *) class_elem_iter.get_instance(&class_elem_iter);
                    assert(mf_in->id == ace_id);
                    ace_id++;

                    class_elem_iter.next(&class_elem_iter);
                    assert(FALSE == class_elem_iter.eof(&class_elem_iter));

                    assert(NULL != class_elem_iter.get_instance(&class_elem_iter));
                    assert(RULE_TYPE_INST_ACL == class_elem_iter.get_instance(&class_elem_iter)->type);
                    acl_in = (RULE_TYPE_CLASS_INSTANCE_T *) class_elem_iter.get_instance(&class_elem_iter);
                    assert(acl_in->id == acl_id);
                    acl_id++;

                    {
                        RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T acl_elem_iter;

                        RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(class_elem_iter.get_ptr(&class_elem_iter),
                                                                 &acl);

                        acl.get_element_iterator(&acl, &acl_elem_iter);

                        for (i = 0; i < 3; i++)
                        {
                            RULE_TYPE_RULE_INSTANCE_T *ace_in = (RULE_TYPE_RULE_INSTANCE_T *) acl_elem_iter.get_instance(&acl_elem_iter);

                            assert(NULL != ace_in);
                            assert(TRUE != acl_elem_iter.eof(&acl_elem_iter));

                            assert(ace_in->id == ace_id);
                            ace_id++;

                            acl_elem_iter.next(&acl_elem_iter);
                        }

                        assert(RULE_TYPE_NIL == acl_elem_iter.get_ptr(&acl_elem_iter).type);
                        assert(NULL == acl_elem_iter.get_instance(&acl_elem_iter));
                        assert(TRUE == acl_elem_iter.eof(&acl_elem_iter));
                    }

                    class_elem_iter.next(&class_elem_iter);
                    assert(FALSE == class_elem_iter.eof(&class_elem_iter));

                    assert(NULL != class_elem_iter.get_instance(&class_elem_iter));
                    assert(RULE_TYPE_INST_MF_ACE == class_elem_iter.get_instance(&class_elem_iter)->type);
                    mf_in = (RULE_TYPE_RULE_INSTANCE_T *) class_elem_iter.get_instance(&class_elem_iter);
                    assert(mf_in->id == ace_id);
                    ace_id++;

                    class_elem_iter.next(&class_elem_iter);
                    assert(FALSE == class_elem_iter.eof(&class_elem_iter));

                    assert(NULL != class_elem_iter.get_instance(&class_elem_iter));
                    assert(RULE_TYPE_INST_ACL == class_elem_iter.get_instance(&class_elem_iter)->type);
                    acl_in = (RULE_TYPE_CLASS_INSTANCE_T *) class_elem_iter.get_instance(&class_elem_iter);
                    assert(acl_in->id == acl_id);
                    acl_id++;

                    {
                        RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T acl_elem_iter;

                        RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(class_elem_iter.get_ptr(&class_elem_iter),
                                                                 &acl);

                        acl.get_element_iterator(&acl, &acl_elem_iter);

                        for (i = 0; i < 3; i++)
                        {
                            RULE_TYPE_RULE_INSTANCE_T *ace_in = (RULE_TYPE_RULE_INSTANCE_T *) acl_elem_iter.get_instance(&acl_elem_iter);

                            assert(NULL != ace_in);
                            assert(TRUE != acl_elem_iter.eof(&acl_elem_iter));

                            assert(ace_in->id == ace_id);
                            ace_id++;

                            acl_elem_iter.next(&acl_elem_iter);
                        }

                        assert(RULE_TYPE_NIL == acl_elem_iter.get_ptr(&acl_elem_iter).type);
                        assert(NULL == acl_elem_iter.get_instance(&acl_elem_iter));
                        assert(TRUE == acl_elem_iter.eof(&acl_elem_iter));
                    }

                    class_elem_iter.next(&class_elem_iter);
                    assert(TRUE == class_elem_iter.eof(&class_elem_iter));

                    assert(NULL == class_elem_iter.get_instance(&class_elem_iter));
                }

                    break;

                case 2:
                    assert(policy_elem_in->type == RULE_TYPE_INST_CLASS_MAP);

                    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(policy_elem_iter.get_ptr(&policy_elem_iter),
                                                             &class_map);

                    assert(class_map.inst->id == class_map_id);
                    class_map_id++;

                {
                    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T class_elem_iter;
                    RULE_TYPE_RULE_INSTANCE_T *mf_in;
                    RULE_TYPE_CLASS_INSTANCE_T *acl_in;

                    class_map.get_element_iterator(&class_map, &class_elem_iter);
                    assert(FALSE == class_elem_iter.eof(&class_elem_iter));

                    assert(NULL != class_elem_iter.get_instance(&class_elem_iter));
                    assert(RULE_TYPE_INST_ACL == class_elem_iter.get_instance(&class_elem_iter)->type);
                    acl_in = (RULE_TYPE_CLASS_INSTANCE_T *) class_elem_iter.get_instance(&class_elem_iter);
                    assert(acl_in->id == acl_id);
                    acl_id++;

                    {
                        RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T acl_elem_iter;

                        RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(class_elem_iter.get_ptr(&class_elem_iter),
                                                                 &acl);

                        acl.get_element_iterator(&acl, &acl_elem_iter);

                        for (i = 0; i < 3; i++)
                        {
                            RULE_TYPE_RULE_INSTANCE_T *ace_in = (RULE_TYPE_RULE_INSTANCE_T *) acl_elem_iter.get_instance(&acl_elem_iter);

                            assert(NULL != ace_in);
                            assert(TRUE != acl_elem_iter.eof(&acl_elem_iter));

                            assert(ace_in->id == ace_id);
                            ace_id++;

                            acl_elem_iter.next(&acl_elem_iter);
                        }

                        assert(RULE_TYPE_NIL == acl_elem_iter.get_ptr(&acl_elem_iter).type);
                        assert(NULL == acl_elem_iter.get_instance(&acl_elem_iter));
                        assert(TRUE == acl_elem_iter.eof(&acl_elem_iter));
                    }

                    class_elem_iter.next(&class_elem_iter);
                    assert(FALSE == class_elem_iter.eof(&class_elem_iter));

                    assert(NULL != class_elem_iter.get_instance(&class_elem_iter));
                    assert(RULE_TYPE_INST_ACL == class_elem_iter.get_instance(&class_elem_iter)->type);
                    acl_in = (RULE_TYPE_CLASS_INSTANCE_T *) class_elem_iter.get_instance(&class_elem_iter);
                    assert(acl_in->id == acl_id);
                    acl_id++;

                    {
                        RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T acl_elem_iter;

                        RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(class_elem_iter.get_ptr(&class_elem_iter),
                                                                 &acl);

                        acl.get_element_iterator(&acl, &acl_elem_iter);

                        for (i = 0; i < 3; i++)
                        {
                            RULE_TYPE_RULE_INSTANCE_T *ace_in = (RULE_TYPE_RULE_INSTANCE_T *) acl_elem_iter.get_instance(&acl_elem_iter);

                            assert(NULL != ace_in);
                            assert(TRUE != acl_elem_iter.eof(&acl_elem_iter));

                            assert(ace_in->id == ace_id);
                            ace_id++;

                            acl_elem_iter.next(&acl_elem_iter);
                        }

                        assert(RULE_TYPE_NIL == acl_elem_iter.get_ptr(&acl_elem_iter).type);
                        assert(NULL == acl_elem_iter.get_instance(&acl_elem_iter));
                        assert(TRUE == acl_elem_iter.eof(&acl_elem_iter));
                    }

                    class_elem_iter.next(&class_elem_iter);
                    assert(FALSE == class_elem_iter.eof(&class_elem_iter));

                    assert(NULL != class_elem_iter.get_instance(&class_elem_iter));
                    assert(RULE_TYPE_INST_MF_ACE == class_elem_iter.get_instance(&class_elem_iter)->type);
                    mf_in = (RULE_TYPE_RULE_INSTANCE_T *) class_elem_iter.get_instance(&class_elem_iter);
                    assert(mf_in->id == ace_id);
                    ace_id++;

                    class_elem_iter.next(&class_elem_iter);
                    assert(FALSE == class_elem_iter.eof(&class_elem_iter));

                    assert(NULL != class_elem_iter.get_instance(&class_elem_iter));
                    assert(RULE_TYPE_INST_MF_ACE == class_elem_iter.get_instance(&class_elem_iter)->type);
                    mf_in = (RULE_TYPE_RULE_INSTANCE_T *) class_elem_iter.get_instance(&class_elem_iter);
                    assert(mf_in->id == ace_id);
                    ace_id++;

                    class_elem_iter.next(&class_elem_iter);
                    assert(TRUE == class_elem_iter.eof(&class_elem_iter));

                    assert(NULL == class_elem_iter.get_instance(&class_elem_iter));
                }

                    break;

                case 3:
                    assert(policy_elem_in->type == RULE_TYPE_INST_CLASS_MAP);

                    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(policy_elem_iter.get_ptr(&policy_elem_iter),
                                                             &class_map);

                    assert(class_map.inst->id == class_map_id);
                    class_map_id++;

                {
                    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T class_elem_iter;
                    RULE_TYPE_RULE_INSTANCE_T *mf_in;

                    class_map.get_element_iterator(&class_map, &class_elem_iter);
                    assert(FALSE == class_elem_iter.eof(&class_elem_iter));

                    assert(NULL != class_elem_iter.get_instance(&class_elem_iter));
                    assert(RULE_TYPE_INST_MF_ACE == class_elem_iter.get_instance(&class_elem_iter)->type);
                    mf_in = (RULE_TYPE_RULE_INSTANCE_T *) class_elem_iter.get_instance(&class_elem_iter);
                    assert(mf_in->id == ace_id);
                    ace_id++;

                    class_elem_iter.next(&class_elem_iter);
                    assert(FALSE == class_elem_iter.eof(&class_elem_iter));

                    assert(NULL != class_elem_iter.get_instance(&class_elem_iter));
                    assert(RULE_TYPE_INST_MF_ACE == class_elem_iter.get_instance(&class_elem_iter)->type);
                    mf_in = (RULE_TYPE_RULE_INSTANCE_T *) class_elem_iter.get_instance(&class_elem_iter);
                    assert(mf_in->id == ace_id);
                    ace_id++;

                    class_elem_iter.next(&class_elem_iter);
                    assert(TRUE == class_elem_iter.eof(&class_elem_iter));

                    assert(NULL == class_elem_iter.get_instance(&class_elem_iter));
                }

                    break;

                case 4:
                    assert(policy_elem_in->type == RULE_TYPE_INST_CLASS_MAP);

                    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(policy_elem_iter.get_ptr(&policy_elem_iter),
                                                             &class_map);

                    assert(class_map.inst->id == class_map_id);
                    class_map_id++;

                {
                    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T class_elem_iter;
                    RULE_TYPE_CLASS_INSTANCE_T *acl_in;

                    class_map.get_element_iterator(&class_map, &class_elem_iter);
                    assert(FALSE == class_elem_iter.eof(&class_elem_iter));

                    assert(NULL != class_elem_iter.get_instance(&class_elem_iter));
                    assert(RULE_TYPE_INST_ACL == class_elem_iter.get_instance(&class_elem_iter)->type);
                    acl_in = (RULE_TYPE_CLASS_INSTANCE_T *) class_elem_iter.get_instance(&class_elem_iter);
                    assert(acl_in->id == acl_id);
                    acl_id++;

                    {
                        RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T acl_elem_iter;

                        RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(class_elem_iter.get_ptr(&class_elem_iter),
                                                                 &acl);

                        acl.get_element_iterator(&acl, &acl_elem_iter);

                        for (i = 0; i < 3; i++)
                        {
                            RULE_TYPE_RULE_INSTANCE_T *ace_in = (RULE_TYPE_RULE_INSTANCE_T *) acl_elem_iter.get_instance(&acl_elem_iter);

                            assert(NULL != ace_in);
                            assert(TRUE != acl_elem_iter.eof(&acl_elem_iter));

                            assert(ace_in->id == ace_id);
                            ace_id++;

                            acl_elem_iter.next(&acl_elem_iter);
                        }

                        assert(RULE_TYPE_NIL == acl_elem_iter.get_ptr(&acl_elem_iter).type);
                        assert(NULL == acl_elem_iter.get_instance(&acl_elem_iter));
                        assert(TRUE == acl_elem_iter.eof(&acl_elem_iter));
                    }

                    class_elem_iter.next(&class_elem_iter);
                    assert(TRUE == class_elem_iter.eof(&class_elem_iter));

                    assert(NULL == class_elem_iter.get_instance(&class_elem_iter));
                }

                    break;

                default:
                    assert(0);
                    break;
            }

            memset(&class_map, 0, sizeof(class_map));
            ++no;
        }

        assert(5 == no);
    }

    return 0;
}

int
RULE_CTRL_UT_Add_Del_Rule_Instance_Object()
{
    const UI32_T ACL_ID_BASE = 100;
    const UI32_T ACE_ID_BASE = 200;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T            acl;
    RULE_TYPE_RULE_INSTANCE_OBJECT_T             ace;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T  ace_iter;

    UI32_T acl_id = ACL_ID_BASE;
    UI32_T ace_id = ACE_ID_BASE;
    UI32_T i;
    UI32_T retry_cnt = 5;

    RULE_TYPE_RETURN_TYPE_T ret;

    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL, &acl);
    assert(RULE_TYPE_OK == ret);

    acl.inst->id = acl_id++;

retry:

    ace_id = ACE_ID_BASE;
    i = 0;

    while (1)
    {
        ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &ace);
        if (RULE_TYPE_OK != ret)
        {
            break;
        }

        ace.inst->id = ace_id++;
        acl.add_rule_obj(&acl, &ace);

        i++;
    }

    assert(i == _countof(shmem_data_p->_rule_inst_pool_buf));

    ace_id = ACE_ID_BASE;
    i = 0;

    acl.get_element_iterator(&acl, &ace_iter);

    //
    // count don't change any status of current object
    //
    assert(_countof(shmem_data_p->_rule_inst_pool_buf) == ace_iter.count(&ace_iter));

    for (; TRUE != ace_iter.eof(&ace_iter); ace_iter.next(&ace_iter))
    {
        i ++;
    }

    assert(i == _countof(shmem_data_p->_rule_inst_pool_buf));

    assert(i == ace_iter.count(&ace_iter));

    ////////////////////////////////////////////////////////////////////////////
    // get-next

    ace_id = ACE_ID_BASE;
    i = 0;

    ace_iter.first(&ace_iter);

    while ( NULL != ace_iter.get_instance(&ace_iter) )
    {
        i ++;

        if (TRUE != ace_iter.has_next(&ace_iter))
        {
            break;
        }

        ace_iter.next(&ace_iter);
    }

    assert(i == _countof(shmem_data_p->_rule_inst_pool_buf));

    ////////////////////////////////////////////////////////////////////////////
    // get-next

    ace_id = ACE_ID_BASE;
    i = 0;

    for (ace_iter.first(&ace_iter);
         NULL != ace_iter.get_instance(&ace_iter);
         ace_iter.next(&ace_iter))
    {
        RULE_TYPE_RULE_INSTANCE_T *ace_in = (RULE_TYPE_RULE_INSTANCE_T *) ace_iter.get_instance(&ace_iter);

        assert(ace_in->id == ace_id ++);
        i ++;
    }

    assert(i == _countof(shmem_data_p->_rule_inst_pool_buf));

    ////////////////////////////////////////////////////////////////////////////
    // get-prev

    ace_id = _countof(shmem_data_p->_rule_inst_pool_buf) + ACE_ID_BASE;
    i = 0;

    for (ace_iter.last(&ace_iter);
         NULL != ace_iter.get_instance(&ace_iter);
         ace_iter.prev(&ace_iter))
    {
        RULE_TYPE_RULE_INSTANCE_T *ace_in = (RULE_TYPE_RULE_INSTANCE_T *) ace_iter.get_instance(&ace_iter);

        assert(ace_in->id == --ace_id);

        i ++;
    }

    assert(i == _countof(shmem_data_p->_rule_inst_pool_buf));

    ////////////////////////////////////////////////////////////////////////////
    // destroy all

    ace_id = _countof(shmem_data_p->_rule_inst_pool_buf) + ACE_ID_BASE;
    i = 0;

    for (ace_iter.last(&ace_iter);
         NULL != ace_iter.get_instance(&ace_iter);
         ace_iter.last(&ace_iter))
    {
        RULE_CTRL_IN_Priv_ConstructRuleInstanceObjectFromPointer(ace_iter.get_ptr(&ace_iter),
                                                &ace);

        assert(ace.inst->id == --ace_id);

        acl.remove_rule_obj(&acl, &ace);
        RULE_CTRL_IN_Priv_DestroyRuleInstance(ace_iter.get_ptr(&ace_iter));

        i ++;
    }

    assert(i == _countof(shmem_data_p->_rule_inst_pool_buf));

    if (0 < retry_cnt)
    {
        retry_cnt --;
        goto retry;
    }

    return 0;
}

int
RULE_CTRL_UT_Remove_Class_Instance_Object()
{
    const UI32_T ACL_ID_BASE = 100;
    const UI32_T ACE_ID_BASE = 200;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T            acl;
    RULE_TYPE_RULE_INSTANCE_OBJECT_T             ace;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T  ace_iter;

    UI32_T acl_id = ACL_ID_BASE;
    UI32_T ace_id = ACE_ID_BASE;
    UI32_T i;
    UI32_T retry_cnt = RULE_CTRL_MAX_NBR_OF_PCE_PER_UNIT + 5;

    RULE_TYPE_RETURN_TYPE_T ret;

retry:

    ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL, &acl);
    assert(RULE_TYPE_OK == ret);

    acl.inst->id = acl_id++;

    ace_id = ACE_ID_BASE;
    i = 0;

    while (1)
    {
        ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &ace);
        if (RULE_TYPE_OK != ret)
        {
            break;
        }

        ace.inst->id = ace_id++;
        acl.add_rule_obj(&acl, &ace);

        i++;
    }

    assert(i == _countof(shmem_data_p->_rule_inst_pool_buf));

    ////////////////////////////////////////////////////////////////////////////
    // test

    ace_id = ACE_ID_BASE;
    i = 0;

    acl.get_element_iterator(&acl, &ace_iter);

    for (ace_iter.first(&ace_iter);
         NULL != ace_iter.get_instance(&ace_iter);
         ace_iter.next(&ace_iter))
    {
        RULE_TYPE_RULE_INSTANCE_T *ace_in = (RULE_TYPE_RULE_INSTANCE_T *) ace_iter.get_instance(&ace_iter);

        assert(ace_in->id == ace_id ++);
        i ++;
    }

    assert(i == _countof(shmem_data_p->_rule_inst_pool_buf));

    ////////////////////////////////////////////////////////////////////////////
    // destroy all

    ace_id = _countof(shmem_data_p->_rule_inst_pool_buf) + ACE_ID_BASE;
    i = 0;

    for (ace_iter.last(&ace_iter);
         NULL != ace_iter.get_instance(&ace_iter);
         ace_iter.last(&ace_iter))
    {
        RULE_CTRL_IN_Priv_ConstructRuleInstanceObjectFromPointer(ace_iter.get_ptr(&ace_iter),
                                                &ace);

        assert(ace.inst->id == --ace_id);

        acl.remove_rule_obj(&acl, &ace);
        RULE_CTRL_IN_Priv_DestroyRuleInstance(ace_iter.get_ptr(&ace_iter));

        i ++;
    }

    assert(i == _countof(shmem_data_p->_rule_inst_pool_buf));

    RULE_CTRL_IN_Priv_DestroyClassInstance(acl.ptr);

    if (0 < retry_cnt)
    {
        retry_cnt --;
        goto retry;
    }

    return 0;
}

int
RULE_CTRL_UT_IndexOf_AtIndex()
{
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T            acl;
    RULE_TYPE_RULE_INSTANCE_OBJECT_T             ace;

    UI32_T i;

    RULE_TYPE_RETURN_TYPE_T ret;

    //
    // AtIndex
    //
    for (i = 0; i < _countof(shmem_data_p->_class_inst_pool_buf); ++ i)
    {
        RULE_TYPE_CLASS_INSTANCE_T *in;

        in = RULE_CTRL_IN_AtIndex(RULE_TYPE_INST_ACL, i);

        assert(RULE_TYPE_NIL == in->super.type);
    }

    assert(0 == RULE_CTRL_IN_AtIndex(RULE_TYPE_INST_ACL, _countof(shmem_data_p->_class_inst_pool_buf)));
    assert(0 == RULE_CTRL_IN_AtIndex(RULE_TYPE_INST_ACL, _countof(shmem_data_p->_class_inst_pool_buf)+1));


    for (i = 0; i < _countof(shmem_data_p->_rule_inst_pool_buf); ++ i)
    {
        RULE_TYPE_RULE_INSTANCE_T *in;

        in = RULE_CTRL_IN_AtIndex(RULE_TYPE_INST_RULE, i);

        assert(RULE_TYPE_NIL == in->super.type);
    }

    assert(0 == RULE_CTRL_IN_AtIndex(RULE_TYPE_INST_RULE, _countof(shmem_data_p->_rule_inst_pool_buf)));
    assert(0 == RULE_CTRL_IN_AtIndex(RULE_TYPE_INST_RULE, _countof(shmem_data_p->_rule_inst_pool_buf)+1));

    //
    // IndexOf
    //
    i = 0;
    while (1)
    {
        ret = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL, &acl);
        if (RULE_TYPE_OK != ret)
        {
            break;
        }

        assert(i == RULE_CTRL_IN_IndexOfClassInstance(acl.inst));
        assert(RULE_CTRL_IN_AtIndex(acl.inst->super.type, i) == acl.inst);

        i++;
    }

    assert(i == _countof(shmem_data_p->_class_inst_pool_buf));
    i = 0;

    while (1)
    {
        ret = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &ace);
        if (RULE_TYPE_OK != ret)
        {
            break;
        }

        assert(i == RULE_CTRL_IN_IndexOfRuleInstance(ace.inst));

        i++;
    }

    assert(i == _countof(shmem_data_p->_rule_inst_pool_buf));

    return 0;
}

int
RULE_CTRL_UT_Dump_Class_Instance()
{
#if (L4_SUPPORT_ACCTON_BACKDOOR == TRUE || 1)
    enum
    {
        MAX_ACL     = 5,
        MAX_ACE     = 5,
        MAX_MF_ACE  = 5,
    };

    UI32_T acl_id = 1;
    UI32_T ace_id = 1;
    UI32_T policy_map_id = 1;
    UI32_T i;
    UI32_T j;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T policy_map;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T acl[2];

    for (i = 0; i < _countof(acl); ++i)
    {
        result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL, &acl[i]);
        assert(RULE_TYPE_OK == result);

        acl[i].inst->acl_id = acl_id ++;

        for (j = 0; j < MAX_ACE; ++j)
        {
            RULE_TYPE_RULE_INSTANCE_OBJECT_T ace;

            result = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &ace);
            assert(RULE_TYPE_OK == result);

            ace.inst->ace_id = ace_id ++;

            acl[i].add_rule_obj(&acl[i], &ace);
        }
    }

    result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_POLICY_MAP, &policy_map);
    assert(RULE_TYPE_OK == result);

    policy_map.inst->policy_map_id = policy_map_id ++;

    for (i = 0; i < MAX_MF_ACE; ++i)
    {
        RULE_TYPE_CLASS_INSTANCE_OBJECT_T mf_ace;
        RULE_TYPE_RULE_INSTANCE_OBJECT_T  mf_rule_ace;

        result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_MF_ACE, &mf_ace);
        assert(RULE_TYPE_OK == result);

        mf_ace.inst->id = ace_id ++;

        policy_map.add_class_obj(&policy_map, &mf_ace);

        result = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &mf_rule_ace);
        assert(RULE_TYPE_OK == result);

        mf_rule_ace.inst->ace_id = mf_ace.inst->id;

        mf_ace.add_rule_obj(&mf_ace, &mf_rule_ace);
    }

    for (i = 0; i < MAX_ACL; ++i)
    {
        RULE_TYPE_CLASS_INSTANCE_OBJECT_T qos_acl;

        result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL, &qos_acl);
        assert(RULE_TYPE_OK == result);

        qos_acl.inst->acl_id = acl_id ++;

        policy_map.add_class_obj(&policy_map, &qos_acl);

        for (j = 0; j < MAX_ACE; ++j)
        {
            RULE_TYPE_RULE_INSTANCE_OBJECT_T ace;

            result = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &ace);
            assert(RULE_TYPE_OK == result);

            ace.inst->ace_id = ace_id ++;

            qos_acl.add_rule_obj(&qos_acl, &ace);
        }
    }

    for (i = 0; i < _countof(acl); ++i)
    {
        RULE_CTRL_Backdoor_DiffServ_DumpClassInstance(acl[i].inst);
    }

    RULE_CTRL_Backdoor_DiffServ_DumpClassInstance(policy_map.inst);
#endif // L4_SUPPORT_ACCTON_BACKDOOR
    return 0;
}

int
RULE_CTRL_UT_First_Child_If()
{
    enum
    {
        CLASS_INSTANCE_TYPE = RULE_TYPE_INST_CPU_IF,
        TOTAL_NUMBER_OF_CHILDREN = 10
    };

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_INSTANCE_TYPE_T class_inst_type;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T agg_inst_obj[TOTAL_NUMBER_OF_CHILDREN];

    UI32_T i;

    class_inst_type = RULE_TYPE_INST_ACL;
    result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(class_inst_type, &if_inst_obj);
    assert(RULE_TYPE_OK == result);

    for (i = 0; i < _countof(agg_inst_obj); ++ i)
    {
        class_inst_type = CLASS_INSTANCE_TYPE;
        result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(class_inst_type, &agg_inst_obj[i]);
        assert(RULE_TYPE_OK == result);

        agg_inst_obj[i].inst->id = i;

        if_inst_obj.add_class_obj(&if_inst_obj, &agg_inst_obj[i]);
    }

    for (i = 0; i < _countof(agg_inst_obj); ++ i)
    {
        RULE_TYPE_CLASS_INSTANCE_PTR_T in;
        RULE_TYPE_CLASS_INSTANCE_PTR_T next;

        RULE_CTRL_INSTANCE_TYPE_ID_T param;

        memset(&param, 0, sizeof(param));

        param.type = class_inst_type;
        param.id = i;

        in = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_inst_obj.inst,
                                                                            RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                            &param);
        assert(NULL != in);
        assert(in->super.type == param.type);
        assert(in->id == param.id);

        param.type = class_inst_type;
        param.id = i + 3;

        next = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetNextSiblingIf((RULE_TYPE_INSTANCE_PTR_T)in,
                                                                               RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                               &param);
        if (param.id < _countof(agg_inst_obj))
        {
            assert(NULL != next);
            assert(next->super.type == param.type);
            assert(next->id == param.id);
        }
        else
        {
            assert(NULL == next);
        }
    }

    RULE_CTRL_IN_Priv_DestroyClassInstanceObject(&if_inst_obj);
    return 0;
}

#pragma mark End of Test Cases for Class/Rule Instance
#pragma mark -

void
RULE_CTRL_UT_Test_Instance()
{
    //
    // Only Test the Instance on OM
    //
#define RULE_CTRL_UT_TEST(func) \
    UT_Test(RULE_CTRL_UT_Setup, RULE_CTRL_UT_Teardown, func)

    printf("%s (%d): skip instance test\r\n", __FUNCTION__, __LINE__);
    if (0)
    {
    RULE_CTRL_UT_TEST(RULE_CTRL_UT_Create_Class_Instance);
    RULE_CTRL_UT_TEST(RULE_CTRL_UT_Create_Class_Instance_2);
    RULE_CTRL_UT_TEST(RULE_CTRL_UT_Create_Class_Instance_Temp);

    RULE_CTRL_UT_TEST(RULE_CTRL_UT_Create_Rule_Instance);
    RULE_CTRL_UT_TEST(RULE_CTRL_UT_Add_Class_Instance_Into_Class_Instance);
    RULE_CTRL_UT_TEST(RULE_CTRL_UT_Add_Rule_Instance_Into_Class_Instance);

    RULE_CTRL_UT_TEST(RULE_CTRL_UT_Create_Class_Instance_Object);
    RULE_CTRL_UT_TEST(RULE_CTRL_UT_Create_Rule_Instance_Object);
    RULE_CTRL_UT_TEST(RULE_CTRL_UT_Create_Class_Rule_Instance_Object);
    }
    RULE_CTRL_UT_TEST(RULE_CTRL_UT_Append_ACE_Into_ACL);
    RULE_CTRL_UT_TEST(RULE_CTRL_UT_Append_MF_ACE_ACL_Into_Class_Map);
    RULE_CTRL_UT_TEST(RULE_CTRL_UT_Append_All_Into_Policy_Map);
    RULE_CTRL_UT_TEST(RULE_CTRL_UT_Append_All_Into_Policy_Map_Use_Iterator);

    RULE_CTRL_UT_TEST(RULE_CTRL_UT_Add_Del_Rule_Instance_Object);
    RULE_CTRL_UT_TEST(RULE_CTRL_UT_Remove_Class_Instance_Object);

    printf("%s (%d): skip instance test\r\n", __FUNCTION__, __LINE__);
    if (0)
    {
    RULE_CTRL_UT_TEST(RULE_CTRL_UT_IndexOf_AtIndex);
    RULE_CTRL_UT_TEST(RULE_CTRL_UT_Dump_Class_Instance);
    }

    RULE_CTRL_UT_TEST(RULE_CTRL_UT_First_Child_If);

#undef RULE_CTRL_UT_TEST
}

int
RULE_CTRL_UT_Array()
{
    RULE_LIB_ARRAY_METADATA_T metadata;
    RULE_LIB_ARRAY_T array;

    UI32_T i;

    typedef struct
    {
        UI32_T data1;
        UI8_T  data2;
        UI8_T  data3[2];
    } ENTRY;

    ENTRY arr[5];
    ENTRY ent;

    memset(&metadata, 0, sizeof(metadata));
    metadata.count_element = _countof(arr);
    metadata.cb_element = sizeof(ENTRY);

    RULE_LIB_ARRAY_ConstructObject(arr, &metadata, &array);

    assert(0 == array.metadata->size);
    assert(TRUE == array.empty(&array));

    //
    // Array push_back test
    //

    for (i = 0; i < _countof(arr) + 1; ++i)
    {
        BOOL_T b_result;

        memset(&ent, 0, sizeof(ent));
        ent.data1 = i;
        ent.data2 = i;
        ent.data3[0] = i;
        ent.data3[1] = i;

        b_result = array.push_back(&array, &ent);

        assert(TRUE != array.empty(&array));

        if (i < _countof(arr))
        {
            assert(TRUE == b_result);

            assert(i+1 == array.metadata->size);

            assert(0 == memcmp(array.front(&array), &arr[0], sizeof(arr[0])));
            assert(0 == memcmp(array.back(&array), &arr[i], sizeof(arr[i])));

            assert(0 == memcmp(array.at(&array, i), &ent, sizeof(ent)));
            assert(0 == memcmp(array.back(&array), &ent, sizeof(ent)));
        }
        else
        {
            assert(FALSE == b_result);
        }
    }

    for (i = 0; i < _countof(arr); ++i)
    {
        memset(&ent, 0, sizeof(ent));
        ent.data1 = i;
        ent.data2 = i;
        ent.data3[0] = i;
        ent.data3[1] = i;

        assert(0 == memcmp(array.at(&array, i), &ent, sizeof(ent)));
    }

    //
    // Array iterator test
    //

    {
        RULE_LIB_ARRAY_ITERATOR_T first = array.begin(&array);
        RULE_LIB_ARRAY_ITERATOR_T last = array.end(&array);

        i = 0;
        for (; TRUE != first.equal(&first, &last); first.next(&first))
        {
            memset(&ent, 0, sizeof(ent));
            ent.data1 = i;
            ent.data2 = i;
            ent.data3[0] = i;
            ent.data3[1] = i;

            assert(0 == memcmp(first.ptr(&first), &ent, sizeof(ent)));

            i++;
        }

        assert(i == _countof(arr));

    }

    //
    // Array pop_back test
    //

    i = 0;
    while (TRUE != array.empty(&array))
    {
        array.pop_back(&array);
        i++;
    }

    assert(i == _countof(arr));

    if (TRUE == array.empty(&array))
    {
        RULE_LIB_ARRAY_ITERATOR_T first = array.begin(&array);
        RULE_LIB_ARRAY_ITERATOR_T last = array.end(&array);

        assert(TRUE == first.equal(&first, &last));
    }

    return 0;
}

int
RULE_CTRL_UT_Array_Erase()
{
    RULE_LIB_ARRAY_METADATA_T metadata;
    RULE_LIB_ARRAY_T array;

    UI32_T i;

    typedef struct
    {
        UI32_T data1;
        UI8_T  data2;
        UI8_T  data3[2];
    } ENTRY;

    ENTRY arr[5];
    ENTRY ent;

    memset(&metadata, 0, sizeof(metadata));
    metadata.count_element = _countof(arr);
    metadata.cb_element = sizeof(ENTRY);

    RULE_LIB_ARRAY_ConstructObject(arr, &metadata, &array);

    assert(0 == array.metadata->size);
    assert(TRUE == array.empty(&array));

    for (i = 0; i < _countof(arr); ++i)
    {
        BOOL_T b_result;

        memset(&ent, 0, sizeof(ent));
        ent.data1 = i;
        ent.data2 = i;
        ent.data3[0] = i;
        ent.data3[1] = i;

        b_result = array.push_back(&array, &ent);
        assert(TRUE == b_result);
    }

    //
    // erase first element
    //
    array.erase(&array, 0);

    for (i = 1; i < _countof(arr); ++i)
    {
        memset(&ent, 0, sizeof(ent));
        ent.data1 = i;
        ent.data2 = i;
        ent.data3[0] = i;
        ent.data3[1] = i;

        assert(0 == memcmp(array.at(&array, i-1), &ent, sizeof(ent)));
    }

    //
    // again
    //
    array.clear(&array);
    assert(TRUE == array.empty(&array));

    for (i = 0; i < _countof(arr); ++i)
    {
        BOOL_T b_result;

        memset(&ent, 0, sizeof(ent));
        ent.data1 = i;
        ent.data2 = i;
        ent.data3[0] = i;
        ent.data3[1] = i;

        b_result = array.push_back(&array, &ent);
        assert(TRUE == b_result);
    }

    //
    // erase last element
    //
    array.erase(&array, _countof(arr)-1);

    for (i = 0; i < _countof(arr)-1; ++i)
    {
        memset(&ent, 0, sizeof(ent));
        ent.data1 = i;
        ent.data2 = i;
        ent.data3[0] = i;
        ent.data3[1] = i;

        assert(0 == memcmp(array.at(&array, i), &ent, sizeof(ent)));
    }

    //
    // again
    //
    array.clear(&array);
    assert(TRUE == array.empty(&array));

    for (i = 0; i < _countof(arr); ++i)
    {
        BOOL_T b_result;

        memset(&ent, 0, sizeof(ent));
        ent.data1 = i;
        ent.data2 = i;
        ent.data3[0] = i;
        ent.data3[1] = i;

        b_result = array.push_back(&array, &ent);
        assert(TRUE == b_result);
    }

    //
    // erase first second element
    //
    array.erase(&array, 1);

    memset(&ent, 0, sizeof(ent));

    assert(0 == memcmp(array.at(&array, 0), &ent, sizeof(ent)));

    for (i = 2; i < _countof(arr); ++i)
    {
        memset(&ent, 0, sizeof(ent));
        ent.data1 = i;
        ent.data2 = i;
        ent.data3[0] = i;
        ent.data3[1] = i;

        assert(0 == memcmp(array.at(&array, i-1), &ent, sizeof(ent)));
    }

    //
    // again
    //
    array.clear(&array);
    assert(TRUE == array.empty(&array));

    for (i = 0; i < _countof(arr); ++i)
    {
        BOOL_T b_result;

        memset(&ent, 0, sizeof(ent));
        ent.data1 = i;
        ent.data2 = i;
        ent.data3[0] = i;
        ent.data3[1] = i;

        b_result = array.push_back(&array, &ent);
        assert(TRUE == b_result);
    }

    //
    // erase last second element
    //
    array.erase(&array, _countof(arr)-2);

    memset(&ent, 0, sizeof(ent));

    assert(0 == memcmp(array.at(&array, 0), &ent, sizeof(ent)));

    for (i = 0; i < _countof(arr)-2; ++i)
    {
        memset(&ent, 0, sizeof(ent));
        ent.data1 = i;
        ent.data2 = i;
        ent.data3[0] = i;
        ent.data3[1] = i;

        assert(0 == memcmp(array.at(&array, i), &ent, sizeof(ent)));
    }

    i = _countof(arr)-1;
    memset(&ent, 0, sizeof(ent));
    ent.data1 = i;
    ent.data2 = i;
    ent.data3[0] = i;
    ent.data3[1] = i;

    assert(0 == memcmp(array.at(&array, i-1), &ent, sizeof(ent)));

    return 0;
}

static BOOL_T
RULE_CTRL_UT_Proc_Compare(void *e1, void *e2)
{
    typedef struct
    {
        UI32_T data1;
        UI8_T  data2;
        UI8_T  data3[2];
    } ENTRY;

    return (0 == memcmp(e1, e2, sizeof(ENTRY))) ? TRUE : FALSE;
}

int
RULE_CTRL_UT_Array_Find()
{
    RULE_LIB_ARRAY_METADATA_T metadata;
    RULE_LIB_ARRAY_T array;

    UI32_T i;

    typedef struct
    {
        UI32_T data1;
        UI8_T  data2;
        UI8_T  data3[2];
    } ENTRY;

    ENTRY arr[5];
    ENTRY ent;

    memset(&metadata, 0, sizeof(metadata));
    metadata.count_element = _countof(arr);
    metadata.cb_element = sizeof(ENTRY);

    RULE_LIB_ARRAY_ConstructObject(arr, &metadata, &array);

    assert(0 == array.metadata->size);
    assert(TRUE == array.empty(&array));

    //
    // Find an empty array
    //
    {
        RULE_LIB_ARRAY_ITERATOR_T result;
        RULE_LIB_ARRAY_ITERATOR_T first = array.begin(&array);
        RULE_LIB_ARRAY_ITERATOR_T last = array.end(&array);

        i = 0;

        memset(&ent, 0, sizeof(ent));
        ent.data1 = i;
        ent.data2 = i;
        ent.data3[0] = i;
        ent.data3[1] = i;

        result = RULE_LIB_ARRAY_FindIf(first, last, &ent, (RULE_LIB_ARRAY_FIND_IF_COMPARE_FUN_T)RULE_CTRL_UT_Proc_Compare);

        assert(TRUE == result.equal(&result, &last));

    }

    for (i = 0; i < _countof(arr); ++i)
    {
        BOOL_T b_result;

        memset(&ent, 0, sizeof(ent));
        ent.data1 = i;
        ent.data2 = i;
        ent.data3[0] = i;
        ent.data3[1] = i;

        b_result = array.push_back(&array, &ent);
        assert(TRUE == b_result);
    }

    for (i = 0; i < _countof(arr) + 1; ++i)
    {
        RULE_LIB_ARRAY_ITERATOR_T result;
        RULE_LIB_ARRAY_ITERATOR_T first = array.begin(&array);
        RULE_LIB_ARRAY_ITERATOR_T last = array.end(&array);

        memset(&ent, 0, sizeof(ent));
        ent.data1 = i;
        ent.data2 = i;
        ent.data3[0] = i;
        ent.data3[1] = i;

        result = RULE_LIB_ARRAY_FindIf(first, last, &ent, (RULE_LIB_ARRAY_FIND_IF_COMPARE_FUN_T)RULE_CTRL_UT_Proc_Compare);

        if (i < _countof(arr))
        {
            assert(result.i == i);
            assert(TRUE != result.equal(&result, &last));
        }
        else
        {
            assert(TRUE == result.equal(&result, &last));
        }
    }

    return 0;
}


static int
RULE_CTRL_UT_ConvetMacAceToDev()
{
    RULE_TYPE_Ace_Entry_T ace_entry;
    DEVRM_AceEntry_T      dev_entry;

    memset(&dev_entry, 0, sizeof(dev_entry));
    ace_entry.ace_type = RULE_TYPE_MAC_ACL;
    RULE_OM_InitAce(&ace_entry);

    ace_entry.u.mac.aceSourceMacAddr[5] = 0x01;
    memset(ace_entry.u.mac.aceSourceMacAddrBitmask, 0xff, sizeof(ace_entry.u.mac.aceSourceMacAddrBitmask));
    ace_entry.u.mac.aceEtherTypeOp = VAL_diffServMacAceEtherTypeOp_equal;
    ace_entry.u.mac.aceMinEtherType = RULE_TYPE_ETHERTYPE_IP;
    ace_entry.u.mac.aceEtherTypeBitmask = 0xffff;
    ace_entry.u.mac.aceVidOp = VAL_diffServMacAceVidOp_equal;
    ace_entry.u.mac.aceMinVid = 1;
    ace_entry.u.mac.aceVidBitmask = 0xffffffff;
#if (SYS_CPNT_ACL_MAC_IP_MIX == TRUE)
    RULE_OM_SetAcePatternToDefaultByType(&ace_entry, RULE_TYPE_IP_EXT_ACL);
    ace_entry.u.ip.aceSourceIpAddr = 0xc0fa80001;   // 192.168.0.1
    ace_entry.u.ip.aceSourceIpAddrBitmask = 0xffffffff;

    ace_entry.u.ip.aceProtocol = 6;
    ace_entry.u.ip.aceDestPortOp = VAL_diffServIpAceSourcePortOp_equal;
    ace_entry.u.ip.aceDestPortBitmask = MAX_diffServIpAceDestPortBitmask;
    ace_entry.u.ip.aceMinDestPort = ace_entry.u.ip.aceMinDestPort = 80;

    ace_entry.u.ip.aceSourcePortOp = VAL_diffServIpAceDestPortOp_equal;
    ace_entry.u.ip.aceSourcePortBitmask = MAX_diffServIpAceSourcePortBitmask;
    ace_entry.u.ip.aceMinSourcePort = ace_entry.u.ip.aceMaxSourcePort = 8080;

#endif /* #if (SYS_CPNT_ACL_MAC_IP_MIX == TRUE) */


    RULE_CTRL_LocalConvertAce2Dev(&ace_entry, &dev_entry);

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Source_Mac_Address(&dev_entry,
                                                                     ace_entry.u.mac.aceSourceMacAddr,
                                                                     ace_entry.u.mac.aceSourceMacAddrBitmask);

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Dest_Mac_Address(&dev_entry);

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ether_Type(&dev_entry,
                                                             ace_entry.u.mac.aceMinEtherType,
                                                             ace_entry.u.mac.aceEtherTypeBitmask);
    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Vlan(&dev_entry,
                                                       ace_entry.u.mac.aceMinVid,
                                                       ace_entry.u.mac.aceVidBitmask);
#if (SYS_CPNT_ACL_MAC_IP_MIX == TRUE)
    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip(&dev_entry);
    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Source_Address(&dev_entry,
                                                                    ace_entry.u.ip.aceSourceIpAddr,
                                                                    ace_entry.u.ip.aceSourceIpAddrBitmask);

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ip_Dest_Address(&dev_entry);

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ip_Protocol(&dev_entry,
                                                              ace_entry.u.ip.aceProtocol,
                                                              0xff);

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_L4_Source_Port(&dev_entry,
                                                                 ace_entry.u.ip.aceMinSourcePort,
                                                                 ace_entry.u.ip.aceSourcePortBitmask);
    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_L4_Dest_Port(&dev_entry,
                                                                 ace_entry.u.ip.aceMinDestPort,
                                                                 ace_entry.u.ip.aceDestPortBitmask);
#endif /* #if (SYS_CPNT_ACL_MAC_IP_MIX == TRUE) */

    return 0;
}

static int
RULE_CTRL_UT_ConvetMacAceToDev2()
{
    RULE_TYPE_Ace_Entry_T ace_entry;
    DEVRM_AceEntry_T      dev_entry;

    memset(&dev_entry, 0, sizeof(dev_entry));
    ace_entry.ace_type = RULE_TYPE_MAC_ACL;
    RULE_OM_InitAce(&ace_entry);

    ace_entry.u.mac.aceSourceMacAddr[5] = 0x01;
    memset(ace_entry.u.mac.aceSourceMacAddrBitmask, 0xff, sizeof(ace_entry.u.mac.aceSourceMacAddrBitmask));
    ace_entry.u.mac.aceEtherTypeOp = VAL_diffServMacAceEtherTypeOp_equal;
    ace_entry.u.mac.aceMinEtherType = RULE_TYPE_ETHERTYPE_IPV6;
    ace_entry.u.mac.aceEtherTypeBitmask = 0xffff;
    ace_entry.u.mac.aceVidOp = VAL_diffServMacAceVidOp_equal;
    ace_entry.u.mac.aceMinVid = 1;
    ace_entry.u.mac.aceVidBitmask = 0xffffffff;
#if (SYS_CPNT_ACL_MAC_IP_MIX == TRUE)
    RULE_OM_SetAcePatternToDefaultByType(&ace_entry, RULE_TYPE_IPV6_EXT_ACL);

    ace_entry.u.ipv6.aceSourceIpAddr[0] = 1;
    memset(ace_entry.u.ipv6.aceSourceIpAddrBitmask, 0xff,
           sizeof(ace_entry.u.ipv6.aceSourceIpAddrBitmask));

    ace_entry.u.ipv6.aceNextHeader = 6;
    ace_entry.u.ipv6.aceDestPortOp = VAL_diffServIpAceSourcePortOp_equal;
    ace_entry.u.ipv6.aceDestPortBitmask = MAX_diffServIpAceDestPortBitmask;
    ace_entry.u.ipv6.aceMinDestPort = ace_entry.u.ipv6.aceMinDestPort = 80;

    ace_entry.u.ipv6.aceSourcePortOp = VAL_diffServIpAceDestPortOp_equal;
    ace_entry.u.ipv6.aceSourcePortBitmask = MAX_diffServIpAceSourcePortBitmask;
    ace_entry.u.ipv6.aceMinSourcePort = ace_entry.u.ipv6.aceMaxSourcePort = 8080;

#endif /* #if (SYS_CPNT_ACL_MAC_IP_MIX == TRUE) */


    RULE_CTRL_LocalConvertAce2Dev(&ace_entry, &dev_entry);

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Source_Mac_Address(&dev_entry,
                                                                     ace_entry.u.mac.aceSourceMacAddr,
                                                                     ace_entry.u.mac.aceSourceMacAddrBitmask);

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Dest_Mac_Address(&dev_entry);

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ether_Type(&dev_entry,
                                                             ace_entry.u.mac.aceMinEtherType,
                                                             ace_entry.u.mac.aceEtherTypeBitmask);
    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Vlan(&dev_entry,
                                                       ace_entry.u.mac.aceMinVid,
                                                       ace_entry.u.mac.aceVidBitmask);
#if (SYS_CPNT_ACL_MAC_IP_MIX == TRUE)
    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6(&dev_entry);
    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6_Source_Address(&dev_entry,
                                                                    ace_entry.u.ipv6.aceSourceIpAddr,
                                                                    ace_entry.u.ipv6.aceSourceIpAddrBitmask);

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Not_Qualify_Ipv6_Dest_Address(&dev_entry);

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6_Next_Header(&dev_entry,
                                                                   ace_entry.u.ipv6.aceNextHeader,
                                                                   0xff);

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_Ipv6_Source_Address(&dev_entry,
                                                                      ace_entry.u.ipv6.aceSourceIpAddr,
                                                                      ace_entry.u.ipv6.aceSourceIpAddrBitmask);

    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_L4_Source_Port(&dev_entry,
                                                                 ace_entry.u.ipv6.aceMinSourcePort,
                                                                 ace_entry.u.ipv6.aceSourcePortBitmask);
    RULE_CTRL_UT_Proc_Rule_Pattern_Should_Qualify_L4_Dest_Port(&dev_entry,
                                                                 ace_entry.u.ipv6.aceMinDestPort,
                                                                 ace_entry.u.ipv6.aceDestPortBitmask);
#endif /* #if (SYS_CPNT_ACL_MAC_IP_MIX == TRUE) */

    return 0;
}

int
RULE_CTRL_UT_ConvetAceToDev()
{
    RULE_CTRL_UT_ConvetMacAceToDev();
    RULE_CTRL_UT_ConvetMacAceToDev2();

    return 0;
}

int
RULE_CTRL_UT_EPR_Bind_Policy_Map_Failed_With_Remark_DSCP_In_Action()
{
    const char *policy_map_name = "p1";
    RULE_TYPE_MatchType_T match_type = RULE_TYPE_CLASS_MAP_MATCH_ANY;

    {
        const char                      *class_map_name = "c1";
        const char                      *acl_name = "a1";

        UI32_T                          policy_map_index;
        UI32_T                          class_map_index;
        UI32_T                          acl_index;

        RULE_TYPE_AclType_T             acl_type = RULE_TYPE_IP_EXT_ACL;

        RULE_TYPE_Ace_Entry_T           ace_entry;

        RULE_TYPE_UI_ClassMapElement_T  class_element;
        UI32_T                          class_index;

        RULE_TYPE_UI_Action_T           ui_action;

        UI32_T                          ui32_result;

        ui32_result = RULE_OM_Create_PolicyMap(policy_map_name, &policy_map_index);
        assert(RULE_TYPE_OK == ui32_result);

        ui32_result = RULE_OM_Create_ClassMap(class_map_name, match_type, &class_map_index);
        assert(RULE_TYPE_OK == ui32_result);

        //
        // Match ACL
        //

        ui32_result = RULE_OM_CreateAcl(acl_name, acl_type);
        assert(RULE_TYPE_OK == ui32_result);

        ui32_result = RULE_OM_GetAclIdByName(acl_name, &acl_index);
        assert(RULE_TYPE_OK == ui32_result);

        ace_entry.ace_type = RULE_TYPE_IP_EXT_ACL;
        RULE_OM_InitAce(&ace_entry);

        ace_entry.u.ip.aceSourceIpAddr = 0x01020304;
        ace_entry.u.ip.aceSourceIpAddrBitmask = 0xffffffff;

        ui32_result = RULE_OM_AddAce2Acl(acl_index, acl_type, &ace_entry);
        assert(RULE_TYPE_OK == ui32_result);

        ace_entry.u.ip.aceSourceIpAddr = 0x05060708;
        ace_entry.u.ip.aceSourceIpAddrBitmask = 0xffffffff;

        ui32_result = RULE_OM_AddAce2Acl(acl_index, acl_type, &ace_entry);
        assert(RULE_TYPE_OK == ui32_result);

        ace_entry.u.ip.aceSourceIpAddr = 0x090a0b0c;
        ace_entry.u.ip.aceSourceIpAddrBitmask = 0xffffffff;

        ui32_result = RULE_OM_AddAce2Acl(acl_index, acl_type, &ace_entry);
        assert(RULE_TYPE_OK == ui32_result);

        class_element.class_type = RULE_TYPE_CLASS_ACL;
        strncpy(class_element.element.acl_name, acl_name, sizeof(class_element.element.acl_name)-1);
        class_element.element.acl_name[ sizeof(class_element.element.acl_name)-1 ] = '\0';

        ui32_result = RULE_OM_Add_ClassMapElement_To_ClassMap(class_map_index, &class_element, &class_index);
        assert(RULE_TYPE_OK == ui32_result);

        //
        // Action, meter configuration
        // This function be used for many common test cases, so use 'common' action
        //

        memset(&ui_action, 0, sizeof(ui_action));

        ui_action.in_action_type        = IN_ACTION_INVALID;
        ui_action.out_action_type       = OUT_ACTION_INVALID;
        ui_action.confirm_action_type   = CONFIRM_ACTION_TRANSMIT;
        ui_action.class_action_type     = CLASS_ACTION_INVALID;
        ui_action.exceed_action_type    = EXCEED_ACTION_INVALID;
        ui_action.violate_action_type   = VIOLATE_ACTION_INVALID;

        ui_action.in_action_type        = IN_ACTION_NEW_IP_DSCP;
        ui_action.in_action_value       = 32;

        ui32_result = RULE_OM_Add_PolicyMapElement_To_PolicyMap(policy_map_index, class_map_index);
        assert(RULE_TYPE_OK == ui32_result);

        ui32_result = RULE_OM_SetUIActionEntry(policy_map_index, class_map_index, &ui_action);
        assert(RULE_TYPE_OK == ui32_result);
    }

    {
        UI32_T ifindex = 2;
        RULE_TYPE_InOutDirection_T direction = RULE_TYPE_INBOUND;

        UI32_T policy_map_index;

        RULE_TYPE_RETURN_TYPE_T result;

        result = RULE_OM_GetPolicyMapIdByName(policy_map_name, &policy_map_index);
        assert(RULE_TYPE_OK == result);

        RULE_CTRL_UT_Proc_Bind_Policy_Map(ifindex, direction, policy_map_index);
    }

    return 0;
}

int foo()
{
    typedef struct
    {
        UI32_T min;
        UI32_T max;
    } QUOTA_T;

    typedef struct
    {
        RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type;
        RULE_TYPE_INTERFACE_TYPE_E if_type;
        UI32_T rule_cnt;
        QUOTA_T quota;
    } PACKET_TYPE_ENTRY_T;

    PACKET_TYPE_ENTRY_T remapped_pkt_type_tbl[] =
    {
#undef QUOTA
#define QUOTA(x, y) {x, y}
#define PACKET_TYPE(pktType, ifType, remapAceType, quota) {pktType, ifType, remapAceType##_RULE_CNT, quota},

        RULE_CONFIG_PACKET_TYPE_TABLE

#undef PACKET_TYPE
    };

    UI32_T i;

    for (i = 0; i < _countof(remapped_pkt_type_tbl); ++i)
    {
        RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type = remapped_pkt_type_tbl[i].remapped_pkt_type;

        assert(i == remapped_pkt_type);

        assert(remapped_pkt_type_tbl[i].rule_cnt == remapped_pkt_type_tbl[i].quota.max);

        if (RULE_TYPE_INTERFACE_ALL_UNIT == remapped_pkt_type_tbl[i].if_type ||
            RULE_TYPE_INTERFACE_UNIT == remapped_pkt_type_tbl[i].if_type ||
            RULE_TYPE_INTERFACE_CRAFT_PORT == remapped_pkt_type_tbl[i].if_type)
        {
            //
            // FIXME: bad case here !!
            //
            if (RULE_TYPE_PACKET_ALL_PORTS_ACL == remapped_pkt_type ||
                RULE_TYPE_PACKET_ALL_PORTS_ACL_MATCH_ANY_ANY == remapped_pkt_type)
            {
                continue;
            }

            assert(remapped_pkt_type_tbl[i].quota.min <= remapped_pkt_type_tbl[i].quota.max);
        }
        else if (RULE_TYPE_INTERFACE_UPORT == remapped_pkt_type_tbl[i].if_type ||
                 RULE_TYPE_INTERFACE_TRUNK == remapped_pkt_type_tbl[i].if_type ||
                 RULE_TYPE_INTERFACE_CPU_PORT == remapped_pkt_type_tbl[i].if_type)
        {
            assert(0 == remapped_pkt_type_tbl[i].quota.min);
        }

        assert(remapped_pkt_type_tbl[i].quota.min <= remapped_pkt_type_tbl[i].quota.max);

//        printf("pktType=%d, rule_cnt=%lu, quota:min=%lu, quota:max=%lu\r\n",
//               remapped_pkt_type,
//               remapped_pkt_type_tbl[i].rule_cnt,
//               remapped_pkt_type_tbl[i].quota.min,
//               remapped_pkt_type_tbl[i].quota.max);
    }

    return 0;
}

int
RULE_CTRL_UT_Check_Rule_Quota()
{
    enum
    {
        RULE_SIZE = 2,
    };

    typedef struct
    {
        RULE_TYPE_INTERFACE_TYPE_E if_type;
        UI32_T min;
        UI32_T max;
    } QUOTA_T, *QUOTA_PTR_T;

    QUOTA_T quota[] =
    {
#undef QUOTA
#define QUOTA(x, y) x, y
#define PACKET_TYPE(pktType, ifType, remapAceType, quota) {ifType, quota},

        RULE_CONFIG_PACKET_TYPE_TABLE

#undef PACKET_TYPE
    };

    UI32_T  dup_stack_free_nbr_pce[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                  [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type;

    assert(sizeof(dup_stack_free_nbr_pce) == sizeof(shmem_data_p->stack_free_nbr_pce));
    memcpy(dup_stack_free_nbr_pce, shmem_data_p->stack_free_nbr_pce,
                                                sizeof(dup_stack_free_nbr_pce));

    memset(shmem_data_p->stack_free_nbr_pce, 0, sizeof(shmem_data_p->stack_free_nbr_pce));

    for (remapped_pkt_type = 0; remapped_pkt_type < RULE_TYPE_PACKET_MAX_TYPE; ++ remapped_pkt_type)
    {
        QUOTA_PTR_T quota_p = &quota[remapped_pkt_type];
        UI32_T unit;
        UI32_T device_id;

        if (RULE_TYPE_INTERFACE_ALL_UNIT == quota_p->if_type ||
            RULE_TYPE_INTERFACE_UNIT == quota_p->if_type ||
            RULE_TYPE_INTERFACE_CRAFT_PORT == quota_p->if_type ||
            RULE_TYPE_INTERFACE_CPU_PORT == quota_p->if_type ||
            RULE_TYPE_INTERFACE_TRUNK == quota_p->if_type ||
            RULE_TYPE_INTERFACE_UPORT == quota_p->if_type)
        {
            for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
            {
                for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT; ++ device_id)
                {
                    // min to guarantee
                    shmem_data_p->stack_free_nbr_pce[unit - 1][device_id] += (RULE_SIZE * quota_p->min);
                }
            }
        }
    }

    for (remapped_pkt_type = 0; remapped_pkt_type < RULE_TYPE_PACKET_MAX_TYPE; ++ remapped_pkt_type)
    {
        QUOTA_PTR_T quota_p = &quota[remapped_pkt_type];

        RULE_TYPE_RETURN_TYPE_T result;
        RULE_TYPE_INTERFACE_INFO_T interface;

        memset(&interface, 0, sizeof(interface));

        if (RULE_TYPE_INTERFACE_ALL_UNIT == quota_p->if_type ||
            RULE_TYPE_INTERFACE_UNIT == quota_p->if_type ||
            RULE_TYPE_INTERFACE_CPU_PORT == quota_p->if_type ||
            RULE_TYPE_INTERFACE_CRAFT_PORT == quota_p->if_type)
        {
            interface.type = quota_p->if_type;

            {
                DEVRM_PCL_LOOKUP_NUMBER_T lookup_num;

                RULE_CTRL_Priv_ConvertPacketTypeToToDirectionLookupNum(remapped_pkt_type,
                                                                       &interface.direction,
                                                                       &lookup_num);
            }

            result = RULE_CTRL_Priv_CheckRuleQuota(&interface, remapped_pkt_type, 1);

            assert((0 < quota_p->min && RULE_TYPE_OK == result) ||
                   (0 == quota_p->min && RULE_TYPE_OK != result));

            result = RULE_CTRL_Priv_CheckRuleQuota(&interface, remapped_pkt_type, quota_p->min);

            assert(RULE_TYPE_OK == result);

        }
        else if (RULE_TYPE_INTERFACE_UPORT == quota_p->if_type)
        {
            interface.type = quota_p->if_type;

            {
                DEVRM_PCL_LOOKUP_NUMBER_T lookup_num;

                RULE_CTRL_Priv_ConvertPacketTypeToToDirectionLookupNum(remapped_pkt_type,
                                                                       &interface.direction,
                                                                       &lookup_num);
            }

            for (interface.uport.unit = 1;
                 interface.uport.unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK;
                 ++ interface.uport.unit)
            {
                for (interface.uport.port = 1;
                     interface.uport.port <= SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT;
                     ++ interface.uport.port)
                {
                    result = RULE_CTRL_Priv_CheckRuleQuota(&interface, remapped_pkt_type, 1);

                    assert((0 < quota_p->min && RULE_TYPE_OK == result) ||
                           (0 == quota_p->min && RULE_TYPE_OK != result));

                    result = RULE_CTRL_Priv_CheckRuleQuota(&interface, remapped_pkt_type, quota_p->min);

                    assert(RULE_TYPE_OK == result);
                }
            }
        }
        else if (RULE_TYPE_INTERFACE_TRUNK == quota_p->if_type)
        {
            interface.type = quota_p->if_type;

            {
                DEVRM_PCL_LOOKUP_NUMBER_T lookup_num;

                RULE_CTRL_Priv_ConvertPacketTypeToToDirectionLookupNum(remapped_pkt_type,
                                                                       &interface.direction,
                                                                       &lookup_num);
            }

            for (interface.trunk_id = 1;
                 interface.trunk_id <= SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM;
                 ++ interface.trunk_id)
            {
                result = RULE_CTRL_Priv_CheckRuleQuota(&interface, remapped_pkt_type, 1);

                assert((0 < quota_p->min && RULE_TYPE_OK == result) ||
                       (0 == quota_p->min && RULE_TYPE_OK != result));

                result = RULE_CTRL_Priv_CheckRuleQuota(&interface, remapped_pkt_type, quota_p->min);

                assert(RULE_TYPE_OK == result);
            }
        }
    }

    memcpy(shmem_data_p->stack_free_nbr_pce, dup_stack_free_nbr_pce, sizeof(dup_stack_free_nbr_pce));

    return 0;
}

int
RULE_CTRL_UT_Check_Rule_Quota_Greed()
{
    enum
    {
        RULE_SIZE = 2,
    };

    typedef struct
    {
        RULE_TYPE_INTERFACE_TYPE_E if_type;
        UI32_T min;
        UI32_T max;
    } QUOTA_T, *QUOTA_PTR_T;

    QUOTA_T quota[] =
    {
#undef QUOTA
#define QUOTA(x, y) x, y
#define PACKET_TYPE(pktType, ifType, remapAceType, quota) {ifType, quota},

        RULE_CONFIG_PACKET_TYPE_TABLE

#undef PACKET_TYPE
    };

    UI32_T  dup_stack_free_nbr_pce[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                  [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type;

    assert(sizeof(dup_stack_free_nbr_pce) == sizeof(shmem_data_p->stack_free_nbr_pce));
    memcpy(dup_stack_free_nbr_pce, shmem_data_p->stack_free_nbr_pce,
                                                sizeof(dup_stack_free_nbr_pce));

    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_INTERFACE_INFO_T interface;

        interface.type = RULE_TYPE_INTERFACE_UPORT;
        interface.uport.unit = 1;
        interface.uport.port = 1;
        interface.direction = RULE_TYPE_INBOUND;

        remapped_pkt_type = RULE_TYPE_PACKET_ACL;

        for (;;)
        {
            UI32_T unit;
            UI32_T device_id;

            result = RULE_CTRL_Priv_CheckRuleQuota(&interface, remapped_pkt_type, 1);
            if (RULE_TYPE_OK != result)
            {
                break;
            }

            for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
            {
                for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT; ++ device_id)
                {
                    assert(RULE_SIZE <= shmem_data_p->stack_free_nbr_pce[unit-1][device_id]);
                    shmem_data_p->stack_free_nbr_pce[unit-1][device_id] -= RULE_SIZE;
                }
            }
        }
    }

    for (remapped_pkt_type = 0; remapped_pkt_type < RULE_TYPE_PACKET_MAX_TYPE; ++ remapped_pkt_type)
    {
        QUOTA_PTR_T quota_p = &quota[remapped_pkt_type];

        RULE_TYPE_RETURN_TYPE_T result;
        RULE_TYPE_INTERFACE_INFO_T interface;

        UI32_T unit;
        UI32_T device_id;

        memset(&interface, 0, sizeof(interface));

        if (RULE_TYPE_INTERFACE_ALL_UNIT == quota_p->if_type ||
            RULE_TYPE_INTERFACE_UNIT == quota_p->if_type ||
            RULE_TYPE_INTERFACE_CPU_PORT == quota_p->if_type ||
            RULE_TYPE_INTERFACE_CRAFT_PORT == quota_p->if_type)
        {
            interface.type = quota_p->if_type;

            {
                DEVRM_PCL_LOOKUP_NUMBER_T lookup_num;

                RULE_CTRL_Priv_ConvertPacketTypeToToDirectionLookupNum(remapped_pkt_type,
                                                                       &interface.direction,
                                                                       &lookup_num);
            }

            result = RULE_CTRL_Priv_CheckRuleQuota(&interface, remapped_pkt_type, quota_p->min);

            assert(RULE_TYPE_OK == result);

            for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
            {
                for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT; ++ device_id)
                {
                    //
                    // min to guarantee
                    //
                    assert((RULE_SIZE * quota_p->min) <= shmem_data_p->stack_free_nbr_pce[unit-1][device_id]);
                    shmem_data_p->stack_free_nbr_pce[unit - 1][device_id] -= (RULE_SIZE * quota_p->min);
                }
            }
        }
        else if (RULE_TYPE_INTERFACE_UPORT == quota_p->if_type)
        {
            interface.type = quota_p->if_type;

            {
                DEVRM_PCL_LOOKUP_NUMBER_T lookup_num;

                RULE_CTRL_Priv_ConvertPacketTypeToToDirectionLookupNum(remapped_pkt_type,
                                                                       &interface.direction,
                                                                       &lookup_num);
            }

            for (interface.uport.unit = 1;
                 interface.uport.unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK;
                 ++ interface.uport.unit)
            {
                for (interface.uport.port = 1;
                     interface.uport.port <= SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT;
                     ++ interface.uport.port)
                {
                    result = RULE_CTRL_Priv_CheckRuleQuota(&interface, remapped_pkt_type, quota_p->min);

                    assert(RULE_TYPE_OK == result);

                    device_id = RULE_CTRL_UT_Proc_UPort_To_Device_Id(interface.uport.unit,
                                                                     interface.uport.port);

                    unit = interface.uport.unit;

                    //
                    // min to guarantee
                    //
                    assert((RULE_SIZE * quota_p->min) <= shmem_data_p->stack_free_nbr_pce[unit-1][device_id]);
                    shmem_data_p->stack_free_nbr_pce[unit - 1][device_id] -= (RULE_SIZE * quota_p->min);
                }
            }
        }
        else if (RULE_TYPE_INTERFACE_TRUNK == quota_p->if_type)
        {
            interface.type = quota_p->if_type;

            {
                DEVRM_PCL_LOOKUP_NUMBER_T lookup_num;

                RULE_CTRL_Priv_ConvertPacketTypeToToDirectionLookupNum(remapped_pkt_type,
                                                                       &interface.direction,
                                                                       &lookup_num);
            }

            for (interface.trunk_id = 1;
                 interface.trunk_id <= SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM;
                 ++ interface.trunk_id)
            {
                result = RULE_CTRL_Priv_CheckRuleQuota(&interface, remapped_pkt_type, quota_p->min);

                assert(RULE_TYPE_OK == result);

                for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
                {
                    for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT; ++ device_id)
                    {
                        //
                        // min to guarantee
                        //
                        assert((RULE_SIZE * quota_p->min) <= shmem_data_p->stack_free_nbr_pce[unit-1][device_id]);
                        shmem_data_p->stack_free_nbr_pce[unit - 1][device_id] -= (RULE_SIZE * quota_p->min);
                    }
                }
            }
        }
    }

    memcpy(shmem_data_p->stack_free_nbr_pce, dup_stack_free_nbr_pce, sizeof(dup_stack_free_nbr_pce));

    return 0;
}

/* FIXME: Call a removed function RULE_CTRL_Priv_GetClassInstanceOfPacketType
 */
/*
int
RULE_CTRL_UT_Check_Rule_Quota_Greed_By_Instance()
{
    typedef struct
    {
        RULE_TYPE_INTERFACE_TYPE_E if_type;
        UI32_T min;
        UI32_T max;
    } QUOTA_T, *QUOTA_PTR_T;

    QUOTA_T quota[] =
    {
#undef QUOTA
#define QUOTA(x, y) x, y
#define PACKET_TYPE(pktType, ifType, remapAceType, quota) {ifType, quota},

        RULE_CONFIG_PACKET_TYPE_TABLE

#undef PACKET_TYPE
    };

    UI32_T  dup_stack_free_nbr_pce[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
    [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];

    RULE_CONFIG_MVL_PACKET_TYPE_T remapped_pkt_type;

    assert(sizeof(dup_stack_free_nbr_pce) == sizeof(shmem_data_p->stack_free_nbr_pce));
    memcpy(dup_stack_free_nbr_pce, shmem_data_p->stack_free_nbr_pce,
           sizeof(dup_stack_free_nbr_pce));

    {
        RULE_TYPE_RETURN_TYPE_T result;

        RULE_TYPE_INTERFACE_INFO_T interface;

        RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

        RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

        interface.type = RULE_TYPE_INTERFACE_UPORT;
        interface.uport.unit = 1;
        interface.uport.port = 1;
        interface.direction = RULE_TYPE_INBOUND;

        remapped_pkt_type = RULE_TYPE_PACKET_ACL;

        if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
        assert(NULL != if_entry_p);

        RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                  &if_class_obj);

        for (;;)
        {
            result = RULE_CTRL_Priv_CheckRuleQuota(&interface, remapped_pkt_type, 1);
            if (RULE_TYPE_OK != result)
            {
                break;
            }

            {
                UI32_T device_id;

                RULE_TYPE_CLASS_INSTANCE_PTR_T agg_class_inst_p;
                RULE_TYPE_CLASS_INSTANCE_OBJECT_T agg_class_inst_obj;

                RULE_TYPE_CLASS_INSTANCE_OBJECT_T class_inst_obj;
                RULE_TYPE_RULE_INSTANCE_OBJECT_T rule_inst_obj;

                agg_class_inst_p = RULE_CTRL_Priv_GetClassInstanceOfPacketType(&if_class_obj,
                                                                               remapped_pkt_type);
                if (NULL == agg_class_inst_p)
                {
                    result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL,
                                                                         &agg_class_inst_obj);
                    assert(RULE_TYPE_OK == result);

                    agg_class_inst_obj.inst->mvl_pkt_type = remapped_pkt_type;

                    if_class_obj.add_class_obj(&if_class_obj, &agg_class_inst_obj);
                }

                result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL,
                                                                     &class_inst_obj);
                assert(RULE_TYPE_OK == result);
                class_inst_obj.inst->mvl_pkt_type = remapped_pkt_type;


                agg_class_inst_obj.add_class_obj(&agg_class_inst_obj, &class_inst_obj);

                assert(RULE_TYPE_INTERFACE_UPORT == interface.type);
                device_id = RULE_CTRL_UT_Proc_UPort_To_Device_Id(interface.uport.unit,
                                                                 interface.uport.port);

                result = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE,
                                                                    &rule_inst_obj);
                assert(RULE_TYPE_OK == result);

                class_inst_obj.add_rule_obj(&class_inst_obj, &rule_inst_obj);

                rule_inst_obj.inst->dev_rule_info.rule_id = RULE_CTRL_LocalAllocateLogicalRuleID(interface.uport.unit,
                                                                                                 device_id,
                                                                                                 RULE_TYPE_IP_EXT_ACL);
                assert(0 != rule_inst_obj.inst->dev_rule_info.rule_id);
                rule_inst_obj.inst->dev_rule_info.unit = interface.uport.unit;
                rule_inst_obj.inst->dev_rule_info.device = device_id;
                rule_inst_obj.inst->active = FALSE;

                {
                    RULE_CTRL_PCL_CFG_T pcl_cfg;

                    result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(&interface,
                                                                         remapped_pkt_type,
                                                                         &pcl_cfg);
                    rule_inst_obj.inst->dev_rule_info.pcl_id = pcl_cfg.pcl_id;
                }
            }

        }
    }

    RULE_CTRL_UT_Proc_Validate_Rule();

    for (remapped_pkt_type = 0; remapped_pkt_type < RULE_TYPE_PACKET_MAX_TYPE; ++ remapped_pkt_type)
    {
        QUOTA_PTR_T quota_p = &quota[remapped_pkt_type];

        RULE_TYPE_RETURN_TYPE_T result;
        RULE_TYPE_INTERFACE_INFO_T interface;

        UI32_T unit;
        UI32_T device_id;

        memset(&interface, 0, sizeof(interface));

        if (RULE_TYPE_INTERFACE_ALL_UNIT == quota_p->if_type ||
            RULE_TYPE_INTERFACE_UNIT == quota_p->if_type ||
            RULE_TYPE_INTERFACE_CPU_PORT == quota_p->if_type ||
            RULE_TYPE_INTERFACE_CRAFT_PORT == quota_p->if_type)
        {
            RULE_TYPE_RETURN_TYPE_T result;

            RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

            RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

            UI32_T i;

            interface.type = quota_p->if_type;

            {
                DEVRM_PCL_LOOKUP_NUMBER_T lookup_num;

                RULE_CTRL_Priv_ConvertPacketTypeToToDirectionLookupNum(remapped_pkt_type,
                                                                       &interface.direction,
                                                                       &lookup_num);
            }

            if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
            assert(NULL != if_entry_p);

            RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                      &if_class_obj);

            result = RULE_CTRL_Priv_CheckRuleQuota(&interface, remapped_pkt_type, quota_p->min);
            assert(RULE_TYPE_OK == result);

            for (i = 0; i < quota_p->min; ++i)
            {
                UI32_T unit;
                UI32_T device_id;

                RULE_TYPE_CLASS_INSTANCE_PTR_T agg_class_inst_p;
                RULE_TYPE_CLASS_INSTANCE_OBJECT_T agg_class_inst_obj;

                RULE_TYPE_CLASS_INSTANCE_OBJECT_T class_inst_obj;
                RULE_TYPE_RULE_INSTANCE_OBJECT_T rule_inst_obj;

                agg_class_inst_p = RULE_CTRL_Priv_GetClassInstanceOfPacketType(&if_class_obj,
                                                                               remapped_pkt_type);
                if (NULL == agg_class_inst_p)
                {
                    result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL,
                                                                         &agg_class_inst_obj);
                    assert(RULE_TYPE_OK == result);

                    agg_class_inst_obj.inst->mvl_pkt_type = remapped_pkt_type;

                    if_class_obj.add_class_obj(&if_class_obj, &agg_class_inst_obj);
                }

                result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL,
                                                                     &class_inst_obj);
                assert(RULE_TYPE_OK == result);
                class_inst_obj.inst->mvl_pkt_type = remapped_pkt_type;

                agg_class_inst_obj.add_class_obj(&agg_class_inst_obj, &class_inst_obj);

                for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++ unit)
                {
                    for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT; ++ device_id)
                    {
                        result = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE,
                                                                            &rule_inst_obj);
                        assert(RULE_TYPE_OK == result);

                        class_inst_obj.add_rule_obj(&class_inst_obj, &rule_inst_obj);

                        rule_inst_obj.inst->dev_rule_info.rule_id = RULE_CTRL_LocalAllocateLogicalRuleID(unit,
                                                                                                         device_id,
                                                                                                         RULE_TYPE_IP_EXT_ACL);
                        assert(0 != rule_inst_obj.inst->dev_rule_info.rule_id);
                        rule_inst_obj.inst->dev_rule_info.unit = unit;
                        rule_inst_obj.inst->dev_rule_info.device = device_id;
                        rule_inst_obj.inst->active = FALSE;

                        {
                            RULE_CTRL_PCL_CFG_T pcl_cfg;

                            result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(&interface,
                                                                                 remapped_pkt_type,
                                                                                 &pcl_cfg);
                            rule_inst_obj.inst->dev_rule_info.pcl_id = pcl_cfg.pcl_id;
                        }
                    }
                }
            }
        }
        else if (RULE_TYPE_INTERFACE_UPORT == quota_p->if_type)
        {
            interface.type = quota_p->if_type;

            {
                DEVRM_PCL_LOOKUP_NUMBER_T lookup_num;

                RULE_CTRL_Priv_ConvertPacketTypeToToDirectionLookupNum(remapped_pkt_type,
                                                                       &interface.direction,
                                                                       &lookup_num);
            }

            for (interface.uport.unit = 1;
                 interface.uport.unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK;
                 ++ interface.uport.unit)
            {
                for (interface.uport.port = 1;
                     interface.uport.port <= SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT;
                     ++ interface.uport.port)
                {
                    result = RULE_CTRL_Priv_CheckRuleQuota(&interface, remapped_pkt_type, quota_p->min);

                    assert(RULE_TYPE_OK == result);

                    device_id = RULE_CTRL_UT_Proc_UPort_To_Device_Id(interface.uport.unit,
                                                                     interface.uport.port);

                    unit = interface.uport.unit;
                }
            }
        }
        else if (RULE_TYPE_INTERFACE_TRUNK == quota_p->if_type)
        {
            interface.type = quota_p->if_type;

            {
                DEVRM_PCL_LOOKUP_NUMBER_T lookup_num;

                RULE_CTRL_Priv_ConvertPacketTypeToToDirectionLookupNum(remapped_pkt_type,
                                                                       &interface.direction,
                                                                       &lookup_num);
            }

            for (interface.trunk_id = 1;
                 interface.trunk_id <= SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM;
                 ++ interface.trunk_id)
            {
                result = RULE_CTRL_Priv_CheckRuleQuota(&interface, remapped_pkt_type, quota_p->min);

                assert(RULE_TYPE_OK == result);
            }
        }
    }

    RULE_CTRL_UT_Proc_Validate_Rule();
    return 0;
}
*/

void
RULE_CTRL_UT_Proc_Validate_PCL_Enable_status(
    BOOL_T is_enable,
    CPSS_INTERFACE_INFO_STC   *interfaceInfoPtr,
    const RULE_CTRL_PCL_CFG_T *pcl_cfg_p)
{
    GT_STATUS                       rc;

    CPSS_PCL_DIRECTION_ENT          direction;
    CPSS_PCL_LOOKUP_NUMBER_ENT      lookupNum;

    CPSS_DXCH_PCL_LOOKUP_CFG_STC    lookupCfg;

    RULE_TYPE_INTERFACE_INFO_T g_interface;
    RULE_CTRL_IF_ENTRY_PTR_T   g_if_entry_p = NULL;


    direction = (RULE_TYPE_INBOUND == pcl_cfg_p->interface.direction) ? CPSS_PCL_DIRECTION_INGRESS_E :
    CPSS_PCL_DIRECTION_EGRESS_E;

    lookupNum = (DEVRM_PCL_LOOKUP_0_0 == pcl_cfg_p->lookup_num ||
                 DEVRM_PCL_LOOKUP_0_1 == pcl_cfg_p->lookup_num) ? CPSS_PCL_LOOKUP_0_E :
                (DEVRM_PCL_LOOKUP_1   == pcl_cfg_p->lookup_num) ? CPSS_PCL_LOOKUP_1_E : 0xCCCCCCCC;

    rc = cpssDxChPclCfgTblGet(interfaceInfoPtr->devNum, interfaceInfoPtr, direction, lookupNum, &lookupCfg);
    assert(GT_OK == rc);

    memset(&g_interface, 0, sizeof(g_interface));
    g_interface.direction = (direction == CPSS_PCL_DIRECTION_INGRESS_E) ? RULE_TYPE_INBOUND : RULE_TYPE_OUTBOUND;
    g_interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;

    g_if_entry_p = RULE_CTRL_Priv_GetIfEntry(&g_interface);
    assert(g_if_entry_p != NULL);

    /* If still has global rule, the lookup status shall be enabled
     */
    if (0 != g_if_entry_p->lookup_rule_cnt[pcl_cfg_p->lookup_num])
    {
        is_enable = TRUE;
    }

    if (pcl_cfg_p->lookup_num == DEVRM_PCL_LOOKUP_0_1)
    {
        assert(is_enable == lookupCfg.dualLookup);
    }
    else
    {
        assert(is_enable == lookupCfg.enableLookup);
    }

}

static void
RULE_CTRL_UT_Proc_ValidatePclLookupStatus(
    BOOL_T is_enable,
    RULE_TYPE_INTERFACE_INFO_T *interface_p,
    RULE_CTRL_PCL_CFG_T *pcl_cfg_p)
{
    GT_U8                           devNum = 0;

    CPSS_INTERFACE_INFO_STC         interfaceInfo;

    UI32_T unit = 1;
    UI32_T port;
    UI32_T trunk_id;
    UI32_T module_id, device_id, phy_port;

    BOOL_T b_result;

    assert(NULL != interface_p);
    assert(NULL != pcl_cfg_p);

    if (interface_p->type == RULE_TYPE_INTERFACE_ALL_UNIT)
    {
        for (port = 1; port <= SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT_ON_BOARD; ++ port)
        {
            b_result = DEV_SWDRV_Logical2PhyDevicePortID(unit, port, &module_id, &device_id, &phy_port);
            assert(TRUE == b_result);

            memset(&interfaceInfo, 0, sizeof(interfaceInfo));

            interfaceInfo.type = CPSS_INTERFACE_PORT_E;
            interfaceInfo.devPort.devNum  = device_id;
            interfaceInfo.devPort.portNum = phy_port;
            interfaceInfo.devNum = device_id;

            RULE_CTRL_UT_Proc_Validate_PCL_Enable_status(is_enable, &interfaceInfo, pcl_cfg_p);
        }

        for (trunk_id = 1; trunk_id <= SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM; ++ trunk_id)
        {
            memset(&interfaceInfo, 0, sizeof(interfaceInfo));

            interfaceInfo.type = CPSS_INTERFACE_TRUNK_E;
            interfaceInfo.devPort.devNum  = devNum;
            interfaceInfo.trunkId = (GT_U16)DEV_SWDRV_CONVER_TRUNKID_A2C(interfaceInfo.devNum, trunk_id);
            interfaceInfo.devNum = devNum;

            RULE_CTRL_UT_Proc_Validate_PCL_Enable_status(is_enable, &interfaceInfo, pcl_cfg_p);
        }
    }
    else if (interface_p->type == RULE_TYPE_INTERFACE_UPORT)
    {
        UI32_T module_id;
        UI32_T device_id;
        UI32_T phy_port;

        b_result = DEV_SWDRV_PMGR_Logical2PhyDevicePortID(interface_p->uport.unit,
                                                          interface_p->uport.port,
                                                          &module_id,
                                                          &device_id,
                                                          &phy_port);
        assert(b_result == TRUE);

        memset(&interfaceInfo, 0, sizeof(interfaceInfo));

        interfaceInfo.type = CPSS_INTERFACE_PORT_E;
        interfaceInfo.devPort.devNum  = device_id;
        interfaceInfo.devPort.portNum = phy_port;
        interfaceInfo.devNum = device_id;

        RULE_CTRL_UT_Proc_Validate_PCL_Enable_status(is_enable, &interfaceInfo, pcl_cfg_p);

    }
    else if(interface_p->type == RULE_TYPE_INTERFACE_CPU_PORT)
    {
        UI32_T device_id;
        UI32_T phy_port = 63;

        for (device_id = 0; device_id < RULE_CTRL_GetNumberOfChips(unit); device_id++)
        {
            memset(&interfaceInfo, 0, sizeof(interfaceInfo));

            interfaceInfo.type = CPSS_INTERFACE_PORT_E;
            interfaceInfo.devPort.devNum  = device_id;
            interfaceInfo.devPort.portNum = phy_port;
            interfaceInfo.devNum = device_id;
        }

        RULE_CTRL_UT_Proc_Validate_PCL_Enable_status(is_enable, &interfaceInfo, pcl_cfg_p);
    }
    else
    {
        assert(0);
    }

    return;
}


int
RULE_CTRL_UT_DynamicBindingPclToGlobal()
{
    BOOL_T enable_flag, flood, to_cpu;
    RULE_TYPE_RETURN_TYPE_T result;
    UI32_T repeat;

    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_CTRL_PCL_CFG_T pcl_cfg;
    UI32_T remapped_pkt_type = RULE_TYPE_PACKET_IGMP;


    enable_flag = FALSE;

//    RULE_CTRL_DumpFunctionInfo();

    memset(&interface, 0, sizeof(interface));

    result = RULE_CTRL_Priv_ConvertPacketTypeToAceType(remapped_pkt_type, &interface.type);
    assert(result == RULE_TYPE_OK);
    assert(interface.type == RULE_TYPE_INTERFACE_ALL_UNIT);

    result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(&interface,
                                                         remapped_pkt_type,
                                                         &pcl_cfg);
    assert (RULE_TYPE_OK == result);
    assert(pcl_cfg.lookup_num == 0);

    RULE_CTRL_UT_Proc_ValidatePclLookupStatus(enable_flag, &interface, &pcl_cfg);


    flood = TRUE;
    to_cpu = TRUE;

    for (repeat = 0; repeat < 3; repeat++)
    {
        RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

        if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);

        enable_flag = TRUE;

        RULE_CTRL_UT_Proc_Set_Igmp_Rule(enable_flag, flood, to_cpu);

        assert(if_entry_p->lookup_rule_cnt[pcl_cfg.lookup_num] == 1);
        RULE_CTRL_UT_Proc_ValidatePclLookupStatus(enable_flag, &interface, &pcl_cfg);

        enable_flag = FALSE;
        RULE_CTRL_UT_Proc_Set_Igmp_Rule(enable_flag, flood, to_cpu);

        assert(if_entry_p->lookup_rule_cnt[pcl_cfg.lookup_num] == 0);
        RULE_CTRL_UT_Proc_ValidatePclLookupStatus(enable_flag, &interface, &pcl_cfg);
    }

    {
        RULE_CONFIG_MVL_PACKET_TYPE_T mv_remapped_pkt_type = RULE_TYPE_PACKET_MAC_BASED_VLAN;
        RULE_CTRL_PCL_CFG_T mv_pcl_cfg;
        RULE_TYPE_INTERFACE_INFO_T mv_interface;

        UI8_T  mac[SYS_ADPT_MAC_ADDR_LEN];
        UI8_T  mask[SYS_ADPT_MAC_ADDR_LEN];

        UI16_T vid;
        UI8_T  priority;
        RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

        memset(&mv_interface, 0, sizeof(mv_interface));

        result = RULE_CTRL_Priv_ConvertPacketTypeToAceType(mv_remapped_pkt_type, &mv_interface.type);
        assert(result == RULE_TYPE_OK);
        assert(mv_interface.type == RULE_TYPE_INTERFACE_ALL_UNIT);

        result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(&mv_interface,
                                                             mv_remapped_pkt_type,
                                                             &mv_pcl_cfg);
        assert (RULE_TYPE_OK == result);
        assert(mv_pcl_cfg.lookup_num == 0);

        if_entry_p = RULE_CTRL_Priv_GetIfEntry(&mv_interface);

        RULE_CTRL_UT_Proc_ValidatePclLookupStatus(FALSE, &interface, &pcl_cfg);

        memset(mac, 0, sizeof(mac));
        mac[4] = 0xff;
        mac[5] = 1;

        memset(mask, 0xff, sizeof(mask));

        vid = 1000;
        priority = 6;

        enable_flag = TRUE;

        RULE_CTRL_UT_Proc_Set_Mac_Vlan_Rule(enable_flag, mac, mask, vid, priority);
        RULE_CTRL_UT_Proc_Set_Igmp_Rule(enable_flag, flood, to_cpu);

        assert(if_entry_p->lookup_rule_cnt[pcl_cfg.lookup_num] == 2);
        RULE_CTRL_UT_Proc_ValidatePclLookupStatus(TRUE, &interface, &pcl_cfg);


        enable_flag = FALSE;

        RULE_CTRL_UT_Proc_Set_Mac_Vlan_Rule(enable_flag, mac, mask, vid, priority);
        assert(if_entry_p->lookup_rule_cnt[pcl_cfg.lookup_num] == 1);
        RULE_CTRL_UT_Proc_ValidatePclLookupStatus(TRUE, &interface, &pcl_cfg);

        RULE_CTRL_UT_Proc_Set_Igmp_Rule(enable_flag, flood, to_cpu);

        assert(if_entry_p->lookup_rule_cnt[pcl_cfg.lookup_num] == 0);
        RULE_CTRL_UT_Proc_ValidatePclLookupStatus(FALSE, &interface, &pcl_cfg);
    }

    return 0;
}

int
RULE_CTRL_UT_DynamicBindingPclToUserPort()
{

    enum
    {
        MAX_ACE = 5,
    };

    const char *acl_name = "a1";
    RULE_TYPE_RETURN_TYPE_T result;
    UI32_T remapped_pkt_type = RULE_TYPE_PACKET_ACL;
    UI32_T acl_index;
    UI32_T device, unit, port;

    unit = 1;
    port = 5;
    device = RULE_CTRL_UT_Proc_UPort_To_Device_Id(unit, port);

    RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace(acl_name, RULE_TYPE_MAC_ACL,
                                             MAX_ACE, RULE_CTRL_UT_COMPRESS_DISABLE,
                                             &acl_index);

    {
        RULE_TYPE_INTERFACE_INFO_T interface;
        UI32_T ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);
        BOOL_T is_add = TRUE;
        UI16_T time_range_index = RULE_TYPE_UNDEF_TIME_RANGE;
        RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;
        RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;
        DEVRM_PCL_LOOKUP_NUMBER_T lookup_num;
        RULE_CTRL_PCL_CFG_T pcl_cfg;

        result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
        assert (RULE_TYPE_OK == result);

        result = RULE_CTRL_Priv_ConvertPacketTypeToToDirectionLookupNum(remapped_pkt_type,
                                                                        &interface.direction,
                                                                        &lookup_num);
        assert (RULE_TYPE_OK == result);

        result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(&interface,
                                                             remapped_pkt_type,
                                                             &pcl_cfg);

        if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);

        RULE_CTRL_UT_Proc_ValidatePclLookupStatus(FALSE, &interface, &pcl_cfg);
        result = RULE_CTRL_SetAcl(ifindex,
                                  RULE_TYPE_INBOUND,
                                  acl_index,
                                  is_add,
                                  time_range_index,
                                  counter_enable);
        assert(RULE_TYPE_OK == result);

        assert(if_entry_p->lookup_rule_cnt[lookup_num] == MAX_ACE);
        RULE_CTRL_UT_Proc_ValidatePclLookupStatus(TRUE, &interface, &pcl_cfg);

        is_add = FALSE;
        result = RULE_CTRL_SetAcl(ifindex,
                                  RULE_TYPE_INBOUND,
                                  acl_index,
                                  is_add,
                                  time_range_index,
                                  counter_enable);
        assert(RULE_TYPE_OK == result);
        assert(if_entry_p->lookup_rule_cnt[lookup_num] == 0);
        RULE_CTRL_UT_Proc_ValidatePclLookupStatus(FALSE, &interface, &pcl_cfg);
    }

    {
        /* 0-0 + 0-1 rule */
        RULE_TYPE_INTERFACE_INFO_T interface;
        UI32_T ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);
        BOOL_T is_add = TRUE;
        UI16_T time_range_index = RULE_TYPE_UNDEF_TIME_RANGE;
        RULE_TYPE_COUNTER_ENABLE_T counter_enable = FALSE;
        RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;
        DEVRM_PCL_LOOKUP_NUMBER_T lookup_num;
        RULE_CTRL_PCL_CFG_T pcl_cfg;

        result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
        assert (RULE_TYPE_OK == result);

        result = RULE_CTRL_Priv_ConvertPacketTypeToToDirectionLookupNum(remapped_pkt_type,
                                                                        &interface.direction,
                                                                        &lookup_num);
        assert (RULE_TYPE_OK == result);

        result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(&interface,
                                                             remapped_pkt_type,
                                                             &pcl_cfg);

        if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);

        RULE_CTRL_UT_Proc_ValidatePclLookupStatus(FALSE, &interface, &pcl_cfg);
        result = RULE_CTRL_SetAcl(ifindex,
                                  RULE_TYPE_INBOUND,
                                  acl_index,
                                  is_add,
                                  time_range_index,
                                  counter_enable);
        assert(RULE_TYPE_OK == result);

        assert(if_entry_p->lookup_rule_cnt[lookup_num] == MAX_ACE);
        RULE_CTRL_UT_Proc_ValidatePclLookupStatus(TRUE, &interface, &pcl_cfg);

        {
            RULE_CTRL_PCL_CFG_T rt_pcl_cfg;
            DEVRM_PCL_LOOKUP_NUMBER_T rt_lookup_num;

            remapped_pkt_type = RULE_TYPE_PACKET_RATE_LIMIT;

            result = RULE_CTRL_Priv_ConvertPacketTypeToToDirectionLookupNum(remapped_pkt_type,
                                                                            &interface.direction,
                                                                            &rt_lookup_num);
            assert (RULE_TYPE_OK == result);
            assert(rt_lookup_num != lookup_num);

            result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(&interface,
                                                                 remapped_pkt_type,
                                                                 &rt_pcl_cfg);
            assert (RULE_TYPE_OK == result);

            assert(if_entry_p->lookup_rule_cnt[rt_lookup_num] == 0);
            RULE_CTRL_UT_Proc_ValidatePclLookupStatus(FALSE, &interface, &rt_pcl_cfg);

            RULE_CTRL_SetRateLimit(unit, port, 0, 10);

            assert(if_entry_p->lookup_rule_cnt[rt_lookup_num] == 1);
            assert(if_entry_p->lookup_rule_cnt[lookup_num] == MAX_ACE);
            RULE_CTRL_UT_Proc_ValidatePclLookupStatus(TRUE, &interface, &rt_pcl_cfg);
            RULE_CTRL_UT_Proc_ValidatePclLookupStatus(TRUE, &interface, &pcl_cfg);

            RULE_CTRL_DeleteRateLimit(unit, port, 0);

            assert(if_entry_p->lookup_rule_cnt[rt_lookup_num] == 0);
            assert(if_entry_p->lookup_rule_cnt[lookup_num] == MAX_ACE);
            RULE_CTRL_UT_Proc_ValidatePclLookupStatus(FALSE, &interface, &rt_pcl_cfg);
            RULE_CTRL_UT_Proc_ValidatePclLookupStatus(TRUE, &interface, &pcl_cfg);
        }

        is_add = FALSE;
        result = RULE_CTRL_SetAcl(ifindex,
                                  RULE_TYPE_INBOUND,
                                  acl_index,
                                  is_add,
                                  time_range_index,
                                  counter_enable);
        assert(RULE_TYPE_OK == result);
        assert(if_entry_p->lookup_rule_cnt[lookup_num] == 0);
        RULE_CTRL_UT_Proc_ValidatePclLookupStatus(FALSE, &interface, &pcl_cfg);
    }

    return 0;
}

int
RULE_CTRL_UT_DynamicBindingPclToCpuPort()
{
    const char  *policy_map_name = "p1";

    RULE_TYPE_INTERFACE_INFO_T interface;
    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;
    RULE_TYPE_RETURN_TYPE_T result;

    BOOL_T      is_add;
    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;
    DEVRM_PCL_LOOKUP_NUMBER_T lookup_num;
    RULE_CTRL_PCL_CFG_T pcl_cfg;
    UI32_T remapped_pkt_type = RULE_TYPE_PACKET_CPU_PORT_EGRESS_QOS;

    ifindex = SYS_ADPT_CPU_1_IF_INDEX_NUMBER;
    direction = RULE_TYPE_OUTBOUND;

    result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
    assert (RULE_TYPE_OK == result);
    assert(interface.type == RULE_TYPE_INTERFACE_CPU_PORT);

    result = RULE_CTRL_Priv_ConvertPacketTypeToToDirectionLookupNum(remapped_pkt_type,
                                                                    &interface.direction,
                                                                    &lookup_num);
    assert (RULE_TYPE_OK == result);

    result = RULE_CTRL_Priv_ConvertPacketTypeToPclConfig(&interface,
                                                         remapped_pkt_type,
                                                         &pcl_cfg);

    if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);

    RULE_CTRL_UT_Proc_Create_Policy_Class_Map_With_Match_ACL(policy_map_name,
                                                             RULE_TYPE_CLASS_MAP_MATCH_ANY);


    RULE_CTRL_UT_Proc_ValidatePclLookupStatus(FALSE, &interface, &pcl_cfg);
    assert(if_entry_p->lookup_rule_cnt[lookup_num] == 0);

    is_add = TRUE;
    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_ValidatePclLookupStatus(TRUE, &interface, &pcl_cfg);
    assert(if_entry_p->lookup_rule_cnt[lookup_num] != 0);

    is_add = FALSE;
    RULE_CTRL_UT_Proc_Bind_Policy_Map_To_Port(ifindex, direction, is_add, policy_map_name);
    RULE_CTRL_UT_Proc_ValidatePclLookupStatus(FALSE, &interface, &pcl_cfg);
    assert(if_entry_p->lookup_rule_cnt[lookup_num] == 0);

    return 0;
}

// FIXME: PBR - TEST VALIDATE
#if (SYS_CPNT_PBR == TRUE)

#define PBR_DEBUG_PRINT                                 FALSE

#define PBR_LOG(fmt, ...)                        \
    printf("%s[%d]:", __FUNCTION__, __LINE__ );  \
    printf(fmt, ##__VA_ARGS__);

void RULE_CTRL_UT_Priv_BindPbrAcl_Validate(
    BOOL_T enable,
    UI32_T vlan,
    UI32_T seq_num,
    UI32_T acl_id,
    UI32_T total_ace,
    const RULE_TYPE_PBR_ACTION_T *pbr_action_p)
{
    RULE_TYPE_RETURN_TYPE_T result;
    RULE_TYPE_INTERFACE_INFO_T interface;
    RULE_TYPE_Acl_T       acl_entry;
    RULE_TYPE_Ace_Entry_T ace_entry;

    UI32_T ace_index;
    RULE_TYPE_AclType_T ace_type;

    UI32_T remapped_pkt_type = RULE_TYPE_PACKET_PBR;

    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

    RULE_TYPE_CLASS_INSTANCE_PTR_T pbr_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T pbr_inst_obj;

    RULE_TYPE_CLASS_INSTANCE_PTR_T pbr_class_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T pbr_class_inst_obj;

    //RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T acl_inst_iter;
    RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T acl_inst_obj;

    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T ace_inst_iter;
    RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T ace_inst_obj;

    RULE_CTRL_INSTANCE_TYPE_ID_T param;

    memset(&interface, 0, sizeof(interface));
    interface.type = RULE_TYPE_INTERFACE_ALL_UNIT;
    interface.direction = RULE_TYPE_INBOUND;

    if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
    ASSERT(NULL != if_entry_p);
    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                              &if_class_obj);

    memset(&param, 0, sizeof(param));
    param.type = RULE_TYPE_INST_PBR;
    param.id = vlan;
    pbr_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                &param);
    if(pbr_inst_p == NULL)
    {
        assert(enable == FALSE);
        return;
    }
    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(pbr_inst_p,
                                                   &pbr_inst_obj);

    memset(&param, 0, sizeof(param));
    param.type = RULE_TYPE_INST_CLASS_MAP;
    param.id = seq_num;
    pbr_class_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) pbr_inst_obj.inst,
                                                                                RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                &param);
    if(pbr_class_inst_p == NULL)
    {
        assert(enable == FALSE);
        return;
    }
    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(pbr_class_inst_p,
                                                   &pbr_class_inst_obj);

    memset(&param, 0, sizeof(param));
    param.type = RULE_TYPE_INST_ACL;
    param.id = acl_id;
    acl_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) pbr_class_inst_obj.inst,
                                                                                      RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                      &param);
    if (enable == FALSE)
    {
        assert(acl_inst_p == NULL);
        return;
    }

    assert(acl_inst_p != NULL);
    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(acl_inst_p,
                                                   &acl_inst_obj);

    acl_inst_obj.get_element_iterator(&acl_inst_obj, &ace_inst_iter);
    assert(ace_inst_iter.count(&ace_inst_iter) == total_ace);

    ace_index = 0;
    for (ace_inst_p = NULL, ace_inst_iter.first(&ace_inst_iter);
         NULL != ace_inst_iter.get_instance(&ace_inst_iter);
         ace_inst_iter.next(&ace_inst_iter))
    {

        while (1)
        {
            /* get next permit ace
             */
            result = (RULE_TYPE_RETURN_TYPE_T) RULE_OM_GetNextAceByAcl(acl_id, &ace_type, &ace_index, &ace_entry);
            assert(RULE_TYPE_OK == result);

            if (ace_entry.access == RULE_TYPE_ACE_PERMIT)
            {
                break;
            }
        }

        ace_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T) ace_inst_iter.get_instance(&ace_inst_iter);

        RULE_CTRL_IN_Priv_ConstructClassInstanceObject(ace_inst_p,
                                                       &ace_inst_obj);

        assert(ace_inst_p->id == ace_index);
        assert(ace_inst_p->mvl_pkt_type == RULE_TYPE_PACKET_PBR);

        /* FIXME: check rule pattern and action
         */
    }
}

int
RULE_CTRL_UT_BindPbrAcl()
{
    enum
    {
        MAX_ACE_ID = 5
    };

    BOOL_T debug_print = PBR_DEBUG_PRINT;
    const char *acl_name = "a1";
    RULE_TYPE_RETURN_TYPE_T result;
    UI32_T remapped_pkt_type = RULE_TYPE_PACKET_ACL;
    UI32_T acl_index;
    UI32_T device, unit, port;
    UI32_T vlan, seq_num;
    BOOL_T is_add;
    RULE_TYPE_PBR_ACTION_T pbr_action;
    const UI32_T total_ace = (MAX_ACE_ID - 1) / 2; /* only permit */

    RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace(acl_name,
                                             RULE_TYPE_IP_EXT_ACL,
                                             MAX_ACE_ID,
                                             RULE_CTRL_UT_COMPRESS_DISABLE,
                                             &acl_index);

    /* first pbr route map 
     */
    vlan = 1;
    seq_num = 11;
    pbr_action.cmd = RULE_TYPE_PBR_PACKET_CMD_PERMIT;
    pbr_action.qos.dscp.is_modified = TRUE;
    pbr_action.qos.dscp.value = 20;
    pbr_action.redirect.action = RULE_TYPE_PBR_REDIRECT_ACTION_ROUNT;
    pbr_action.redirect.ltt_index.row = 9999;
    pbr_action.redirect.ltt_index.column = 0;

    is_add = TRUE;
    result = RULE_CTRL_SetPbrAcl(is_add, vlan, seq_num, acl_index, &pbr_action);
    assert(RULE_TYPE_OK == result);
    RULE_CTRL_UT_Priv_BindPbrAcl_Validate(is_add, vlan, seq_num, acl_index, total_ace, &pbr_action);

    if (debug_print)
    {
        PBR_LOG("========================= Binding PBR ================================\r\n");
        RULE_CTRL_DumpGlobalAce_BackDoor();
    }

    is_add = FALSE;
    result = RULE_CTRL_SetPbrAcl(is_add, vlan, seq_num, acl_index, NULL);
    assert(RULE_TYPE_OK == result);
    RULE_CTRL_UT_Priv_BindPbrAcl_Validate(is_add, vlan, seq_num, acl_index, total_ace, &pbr_action);

    if (debug_print)
    {
        PBR_LOG("========================= After remove PBR ===========================\r\n");
        RULE_CTRL_DumpGlobalAce_BackDoor();
    }

    /* second pbr route map
     */
    vlan = 1;
    seq_num = 12;
    pbr_action.cmd = RULE_TYPE_PBR_PACKET_CMD_PERMIT;
    pbr_action.qos.dscp.is_modified = TRUE;
    pbr_action.qos.dscp.value = 30;

    is_add = TRUE;
    result = RULE_CTRL_SetPbrAcl(is_add, vlan, seq_num, acl_index, &pbr_action);
    assert(RULE_TYPE_OK == result);
    RULE_CTRL_UT_Priv_BindPbrAcl_Validate(is_add, vlan, seq_num, acl_index, total_ace, &pbr_action);

    if (debug_print)
    {
        PBR_LOG("========================= Binding PBR ================================\r\n");
        RULE_CTRL_DumpGlobalAce_BackDoor();
    }

    is_add = FALSE;
    result = RULE_CTRL_SetPbrAcl(is_add, vlan, seq_num, acl_index, NULL);
    assert(RULE_TYPE_OK == result);
    RULE_CTRL_UT_Priv_BindPbrAcl_Validate(is_add, vlan, seq_num, acl_index, total_ace, &pbr_action);

    if (debug_print)
    {
        PBR_LOG("========================= After remove PBR ===========================\r\n");
        RULE_CTRL_DumpGlobalAce_BackDoor();
    }

    return 0;
}

int
RULE_CTRL_UT_BindPbrAcl_With2Acl()
{
    enum
    {
        MAX_ACE_ID = 5
    };

    BOOL_T debug_print = PBR_DEBUG_PRINT;
    const char *acl_name = "a1";
    const char *acl_name_2 = "a2";
    RULE_TYPE_RETURN_TYPE_T result;
    UI32_T remapped_pkt_type = RULE_TYPE_PACKET_ACL;
    UI32_T acl_index, acl_index_2;
    UI32_T device, unit, port;
    UI32_T vlan, seq_num;
    BOOL_T is_add;
    RULE_TYPE_PBR_ACTION_T pbr_action;
    const UI32_T total_ace = (MAX_ACE_ID - 1) / 2;

    RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace(acl_name,
                                             RULE_TYPE_IP_EXT_ACL,
                                             MAX_ACE_ID,
                                             RULE_CTRL_UT_COMPRESS_DISABLE,
                                             &acl_index);

    RULE_CTRL_UT_Proc_Create_Acl_And_Add_Ace(acl_name_2,
                                             RULE_TYPE_IP_EXT_ACL,
                                             MAX_ACE_ID,
                                             RULE_CTRL_UT_COMPRESS_DISABLE,
                                             &acl_index_2);

    vlan = 1;
    seq_num = 11;
    pbr_action.cmd = RULE_TYPE_PBR_PACKET_CMD_PERMIT;
    pbr_action.qos.dscp.is_modified = TRUE;
    pbr_action.qos.dscp.value = 20;
    pbr_action.redirect.action = RULE_TYPE_PBR_REDIRECT_ACTION_ROUNT;
    pbr_action.redirect.ltt_index.row = 9999;
    pbr_action.redirect.ltt_index.column = 0;

    is_add = TRUE;
    result = RULE_CTRL_SetPbrAcl(is_add, vlan, seq_num, acl_index, &pbr_action);
    assert(RULE_TYPE_OK == result);
    RULE_CTRL_UT_Priv_BindPbrAcl_Validate(is_add, vlan, seq_num, acl_index, total_ace, &pbr_action);

    result = RULE_CTRL_SetPbrAcl(is_add, vlan, seq_num, acl_index_2, &pbr_action);
    assert(RULE_TYPE_OK == result);
    RULE_CTRL_UT_Priv_BindPbrAcl_Validate(is_add, vlan, seq_num, acl_index_2, total_ace, &pbr_action);

    if (debug_print)
    {
        PBR_LOG("========================= Binding PBR ================================\r\n");
        RULE_CTRL_DumpGlobalAce_BackDoor();
    }

    is_add = FALSE;
    result = RULE_CTRL_SetPbrAcl(is_add, vlan, seq_num, acl_index, NULL);
    assert(RULE_TYPE_OK == result);
    RULE_CTRL_UT_Priv_BindPbrAcl_Validate(is_add, vlan, seq_num, acl_index, total_ace, &pbr_action);

    result = RULE_CTRL_SetPbrAcl(is_add, vlan, seq_num, acl_index_2, NULL);
    assert(RULE_TYPE_OK == result);
    RULE_CTRL_UT_Priv_BindPbrAcl_Validate(is_add, vlan, seq_num, acl_index_2, total_ace, &pbr_action);

    if (debug_print)
    {
        PBR_LOG("========================= After remove PBR ===========================\r\n");
        RULE_CTRL_DumpGlobalAce_BackDoor();
    }

    return 0;
}

#endif /* SYS_CPNT_PBR */

#if (SYS_CPNT_STACKING == TRUE)
#pragma mark - == Stacking test cases ==

static BOOL_T
RULE_CTRL_UT_HasRuleOfUnit(
    UI32_T unit,
    RULE_TYPE_SHM_POINTER_T ptr)
{
    RULE_TYPE_CLASS_INSTANCE_T                  *in;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T           this;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T iter;

    in = RULE_CTRL_IN_Ptr2Instance(ptr);

    RULE_CTRL_IN_VALIDATE_CLASS_INST(in);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(in, &this);
    this.get_element_iterator(&this, &iter);

    for (iter.first(&iter); NULL != iter.get_instance(&iter); iter.next(&iter))
    {
        RULE_TYPE_SHM_POINTER_T child = iter.get_ptr(&iter);

        if (TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(child.type))
        {
            if (TRUE == RULE_CTRL_UT_HasRuleOfUnit(unit, child))
            {
                return TRUE;
            }
        }
        else if (TRUE == RULE_CTRL_IS_RULE_INSTANCE_TYPE(child.type))
        {
            RULE_TYPE_RULE_INSTANCE_T                   *rule_inst;
            RULE_TYPE_RULE_INSTANCE_OBJECT_T            rule_inst_obj;

            rule_inst = RULE_CTRL_IN_Ptr2Instance(child);

            RULE_CTRL_IN_Priv_ConstructRuleInstanceObject(rule_inst, &rule_inst_obj);

            if (rule_inst_obj.inst->dev_rule_info.unit == unit)
            {
                return TRUE;
            }
        }
        else
        {
            ASSERT(0);
        }
    }

    return FALSE;
}

int
RULE_CTRL_UT_HandleHotRemoval()
{
    RULE_CTRL_IF_ENTRY_PTR_T           if_entry_p;
    RULE_TYPE_INTERFACE_INFO_T         interface;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T  if_class_obj;
    RULE_TYPE_RETURN_TYPE_T            result;
    UI32_T ifindex;
    UI32_T unit = STKTPLG_OM_IFINDEX_TO_UNIT(1);

    RULE_CTRL_TrapPacket2Cpu(TRUE, RULE_TYPE_PacketType_ARP_REQUEST, NULL);
    RULE_CTRL_TrapPacket2Cpu(TRUE, RULE_TYPE_PacketType_MY_MAC_ARP, NULL);

    RULE_CTRL_UT_Proc_Add_ACL_Rule_On_Eth();

//    if (1)
//        RULE_CTRL_DumpGlobalAce_BackDoor();

    for (ifindex = 1; ifindex <= SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT; ++ifindex)
    {
        assert(TRUE == RULE_TYPE_IS_UPORT(ifindex));

        RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
        interface.direction = RULE_TYPE_INBOUND;

        if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
        assert(NULL != if_entry_p);

        RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                  &if_class_obj);

        {
            RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T class_inst_iter;

            if_class_obj.get_element_iterator(&if_class_obj, &class_inst_iter);

            assert(0 != class_inst_iter.count(&class_inst_iter));
        }
    }

    STKPLG_OM_PRIV_SetUnitState(unit, FALSE);
    RULE_CTRL_HandleHotRemoval(1, SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT);

    for (ifindex = 1; ifindex <= SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT; ++ifindex)
    {
        assert(TRUE == RULE_TYPE_IS_UPORT(ifindex));

        RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
        interface.direction = RULE_TYPE_INBOUND;

        if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
        assert(NULL != if_entry_p);

        RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                  &if_class_obj);

        {
            RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T class_inst_iter;

            if_class_obj.get_element_iterator(&if_class_obj, &class_inst_iter);

            assert(0 == class_inst_iter.count(&class_inst_iter));
        }
    }

    {
        result = RULE_CTRL_Ifindex_To_Interface(RULE_TYPE_ALL_PORTS_1_IF_INDEX_NUMBER,
                                                &interface);
        ASSERT(result == RULE_TYPE_OK);

        for (interface.direction = RULE_TYPE_INBOUND;
             interface.direction <= RULE_TYPE_OUTBOUND;
             ++ interface.direction)
        {
            if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
            assert(NULL != if_entry_p);

            RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                      &if_class_obj);

            {
                RULE_TYPE_CLASS_INSTANCE_PTR_T               if_class_inst_p;
                RULE_TYPE_CLASS_INSTANCE_OBJECT_T            class_inst_obj;
                RULE_TYPE_CLASS_INSTANCE_OBJECT_T            if_class_inst_obj;
                RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T  rule_inst_iter;

                if_class_inst_p = if_class_obj.inst;

                RULE_CTRL_IN_Priv_ConstructClassInstanceObject(if_class_inst_p,
                                                               &class_inst_obj);

                if_class_inst_p = if_class_obj.inst;

                RULE_CTRL_IN_Priv_ConstructClassInstanceObject(if_class_inst_p,
                                                               &if_class_inst_obj);

                if_class_inst_obj.get_element_iterator(&if_class_inst_obj, &rule_inst_iter);

                for (rule_inst_iter.first(&rule_inst_iter);
                     NULL != rule_inst_iter.get_instance(&rule_inst_iter);
                     rule_inst_iter.next(&rule_inst_iter))
                {
                    RULE_TYPE_CLASS_INSTANCE_PTR_T      class_inst_p;
                    RULE_TYPE_CLASS_INSTANCE_OBJECT_T   class_inst_obj;

                    class_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T) rule_inst_iter.get_instance(&rule_inst_iter);

                    if (NULL != class_inst_p &&
                        RULE_TYPE_NIL != class_inst_p->super.type)
                    {
                        RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_inst_p, &class_inst_obj);

                        assert(FALSE == RULE_CTRL_UT_HasRuleOfUnit(unit, class_inst_obj.ptr));

                    }
                }
            }
        }
    }

//    if (1)
//        RULE_CTRL_DumpGlobalAce_BackDoor();

    STKPLG_OM_PRIV_SetUnitState(unit, TRUE);

    return 0;
}

BOOL_T
RULE_CTRL_UT_Priv_ISC_Handler(
    ISC_Key_T *key,
    L_MM_Mref_Handle_T *mref_handle_p)
{
    RULE_CTRL_IscBuf_T *buf_p;
    RULE_CTRL_IscReplyBuf_T reply_buf;
    UI32_T  service;

    ISC_HANDLER_T *isc_handler_p;
    ISC_OM_T *isc_om_p;

    isc_handler_p = ISC_UT_GetHandlerById(ISC_RULE_CTRL_SID);
    isc_om_p = ISC_UT_GetOmById(ISC_RULE_CTRL_SID);
    assert(isc_om_p != NULL);

    memset(isc_om_p, 0, sizeof(*isc_om_p));

    buf_p = (RULE_CTRL_IscBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &service);
    assert(buf_p != NULL);

    service = buf_p->ServiceID;
    assert(service < RULE_CTRL_NBR_OF_SERVICE_ID);

    switch (service)
    {
        case RULE_CTRL_DEVRM_GETCOUNTER:

            memset(&reply_buf, 0, sizeof(reply_buf));

            isc_om_p->u.rule_ctrl.green_cnt = rand();
            reply_buf.data.acl_counter.green_cnt = isc_om_p->u.rule_ctrl.green_cnt;

            isc_om_p->u.rule_ctrl.yellow_cnt = rand();
            reply_buf.data.acl_counter.yellow_cnt = isc_om_p->u.rule_ctrl.yellow_cnt;

            isc_om_p->u.rule_ctrl.red_cnt = rand();
            reply_buf.data.acl_counter.red_cnt = isc_om_p->u.rule_ctrl.red_cnt;

            reply_buf.return_value.b_result = TRUE;

            isc_om_p->u.rule_ctrl.unit = buf_p->unit;
            isc_om_p->u.rule_ctrl.device_id = buf_p->RULECTRLINFO.device_id;
            isc_om_p->u.rule_ctrl.pcl_id = buf_p->RULECTRLINFO.pcl_id;
            isc_om_p->u.rule_ctrl.dev_rule_id = buf_p->RULECTRLINFO.dev_rule_id;
            break;

        case RULE_CTRL_DEVRM_CLEARCOUNTER:
            isc_om_p->u.rule_ctrl.unit = buf_p->unit;
            isc_om_p->u.rule_ctrl.port = buf_p->port;

            isc_om_p->u.rule_ctrl.device_id = buf_p->RULECTRLINFO.device_id;
            isc_om_p->u.rule_ctrl.pcl_id = buf_p->RULECTRLINFO.pcl_id;
            isc_om_p->u.rule_ctrl.dev_rule_id = buf_p->RULECTRLINFO.dev_rule_id;

            isc_om_p->u.rule_ctrl.green_cnt = 0;
            isc_om_p->u.rule_ctrl.yellow_cnt = 0;
            isc_om_p->u.rule_ctrl.red_cnt = 0;

            memset(isc_handler_p->reply_buf, 0, sizeof(isc_handler_p->reply_buf));
            break;

        case RULE_CTRL_DEVRM_GETDEVINFO:
            isc_om_p->u.rule_ctrl.unit = buf_p->unit;

            isc_om_p->u.rule_ctrl.number_of_chips = rand();
            reply_buf.data.device_info.num_of_chips = isc_om_p->u.rule_ctrl.number_of_chips;

            break;

        default:
            return FALSE;
    }

    reply_buf.return_value.b_result = TRUE;

    memcpy(&isc_handler_p->reply_buf, &reply_buf, sizeof(reply_buf));
    return TRUE;
}

int
RULE_CTRL_UT_STACK_GetAndClearCounter()
{
    typedef  struct
    {
        UI32_T unit;
        UI32_T device_id;
        UI32_T pcl_id;
        UI32_T dev_rule_id;
    } INPUT_T;

    INPUT_T in[] =
    {
        { 2, 0, 1, 1},
        { 2, 1, 2, 3},
    };

    BOOL_T result;
    UI32_T green_cnt;
    UI32_T yellow_cnt;
    UI32_T red_cnt;
    UI32_T i;

    ISC_HANDLER_T *isc_rule_ctrl_handler_p;
    ISC_OM_T *isc_om_p;

    isc_rule_ctrl_handler_p = ISC_UT_GetHandlerById(ISC_RULE_CTRL_SID);

    isc_rule_ctrl_handler_p->fn = RULE_CTRL_UT_Priv_ISC_Handler;

    isc_om_p = ISC_UT_GetOmById(ISC_RULE_CTRL_SID);

    for (i = 0; i < _countof(in); ++i)
    {
        INPUT_T *in_p = &in[i];

        result = RULE_CTRL_LocalGetCounter(in_p->unit,
                                           in_p->device_id,
                                           in_p->pcl_id,
                                           in_p->dev_rule_id,
                                           &green_cnt,
                                           &yellow_cnt,
                                           &red_cnt);

        assert(result == TRUE);
        assert(isc_om_p->u.rule_ctrl.unit == in_p->unit);
        assert(isc_om_p->u.rule_ctrl.device_id == in_p->device_id);
        assert(isc_om_p->u.rule_ctrl.pcl_id == in_p->pcl_id);
        assert(isc_om_p->u.rule_ctrl.dev_rule_id == in_p->dev_rule_id);
        assert(isc_om_p->u.rule_ctrl.green_cnt == green_cnt);
        assert(isc_om_p->u.rule_ctrl.yellow_cnt == yellow_cnt);
        assert(isc_om_p->u.rule_ctrl.red_cnt == red_cnt);

        result = RULE_CTRL_LocalClearCounter(in_p->unit,
                                             in_p->device_id,
                                             in_p->pcl_id,
                                             in_p->dev_rule_id);

        assert(result == TRUE);
        assert(isc_om_p->u.rule_ctrl.unit == in_p->unit);
        assert(isc_om_p->u.rule_ctrl.device_id == in_p->device_id);
        assert(isc_om_p->u.rule_ctrl.pcl_id == in_p->pcl_id);
        assert(isc_om_p->u.rule_ctrl.dev_rule_id == in_p->dev_rule_id);
        assert(isc_om_p->u.rule_ctrl.green_cnt == 0);
        assert(isc_om_p->u.rule_ctrl.yellow_cnt == 0);
        assert(isc_om_p->u.rule_ctrl.red_cnt == 0);
    }

    return 0;
}

int
RULE_CTRL_UT_SLAVE_ACL_Get_Counter()
{
    enum
    {
        IFINDEX = 2,
        TIME_RANGE_INDEX = 0XFFFF,
    };

    const char *acl_name = "a1";
    RULE_TYPE_AclType_T acl_type = RULE_TYPE_MAC_ACL;
    UI32_T acl_index;

    UI32_T ifindex;
    RULE_TYPE_InOutDirection_T direction;

    UI16_T time_range_index;
    RULE_TYPE_COUNTER_ENABLE_T counter_enable;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_Ace_Entry_T ace_entry;

    result = RULE_OM_CreateAcl(acl_name, acl_type);
    assert(RULE_TYPE_OK == result);

    result = RULE_OM_GetAclIdByName(acl_name, &acl_index);
    assert(RULE_TYPE_OK == result);

    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_PERMIT;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.ace_type = acl_type;

    result = RULE_OM_InitAce(&ace_entry);
    assert(RULE_TYPE_OK == result);

    ace_entry.access = RULE_TYPE_ACE_DENY;

    result = RULE_OM_AddAce2Acl(acl_index, ace_entry.ace_type, &ace_entry);
    assert(RULE_TYPE_OK == result);

    time_range_index = TIME_RANGE_INDEX;
    counter_enable = RULE_TYPE_COUNTER_ENABLE;

    ifindex = IFINDEX;
    direction = RULE_TYPE_INBOUND;

    result = RULE_CTRL_UT_Proc_Bind_ACL(ifindex, direction,
                                        acl_index,
                                        time_range_index,
                                        counter_enable);
    assert(RULE_TYPE_OK == result);

    {
        RULE_TYPE_AclType_T ace_type;
        UI32_T ace_index = 0;
        RULE_TYPE_Ace_Entry_T ace;

        while (RULE_TYPE_OK == RULE_OM_GetNextAceByAcl(acl_index,
                                                       &ace_type,
                                                       &ace_index,
                                                       &ace))
        {
            RULE_TYPE_RETURN_TYPE_T result;
            RULE_TYPE_INTERFACE_INFO_T interface;

            RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;
            RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;
            RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;
            RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p;
            RULE_TYPE_CLASS_INSTANCE_OBJECT_T ace_inst_obj;
            RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T rule_inst_iter;
            RULE_CTRL_INSTANCE_TYPE_ID_T param;

            RULE_TYPE_Ace_Entry_T test_ace;

            /* get acl counter by slave function */
            memset(&interface, 0, sizeof(interface));

            result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
            assert(RULE_TYPE_OK == result);

            interface.direction = direction;

            if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
            ASSERT(NULL != if_entry_p);

            RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                      &if_class_obj);
            memset(&param, 0, sizeof(param));

            param.type = RULE_TYPE_INST_ACL;
            param.id = acl_index;

            acl_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                        RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                        &param);

            assert(NULL != acl_inst_p);
            assert(RULE_TYPE_COUNTER_ENABLE == acl_inst_p->counter_enable);

            memset(&param, 0, sizeof(param));

            param.type = RULE_TYPE_INST_ACE;
            param.id = ace_index;

            ace_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) acl_inst_p,
                                                                                        RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                        &param);

            assert(NULL != ace_inst_p);

            RULE_CTRL_IN_Priv_ConstructClassInstanceObject(ace_inst_p, &ace_inst_obj);
            ace_inst_obj.get_element_iterator(&ace_inst_obj, &rule_inst_iter);

            memset(&test_ace.counter, 0, sizeof(test_ace.counter));

            for (rule_inst_iter.first(&rule_inst_iter);
                 NULL != rule_inst_iter.get_instance(&rule_inst_iter);
                 rule_inst_iter.next(&rule_inst_iter))
            {
                RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
                RULE_TYPE_CounterRec_T *counter_p;

                rule_inst_p = (RULE_TYPE_RULE_INSTANCE_PTR_T)rule_inst_iter.get_instance(&rule_inst_iter);

                assert(rule_inst_p->current_counter_index < _countof(rule_inst_p->counter));

                counter_p = &rule_inst_p->counter[(rule_inst_p->current_counter_index + 1)
                                                  % _countof(rule_inst_p->counter)];

                RULE_CTRL_UT_Proc_Set_Billing_Counter(rule_inst_p->dev_rule_info.device,
                                                      rule_inst_p->dev_rule_info.rule_id,
                                                      rand() % 1000,
                                                      rand() % 1000,
                                                      rand() % 1000);

                {
                    ISC_Key_T key;
                    RULE_CTRL_IscBuf_T* isc_buf_p;
                    L_MM_Mref_Handle_T* mref_handle_p;
                    UI32_T              pdu_len;

                    ISC_OM_T *isc_om_p;
                    ISC_HANDLER_T *isc_handler_p;
                    RULE_CTRL_IscReplyBuf_T iscReply;

                    isc_handler_p = ISC_UT_GetHandlerById(ISC_RULE_CTRL_SID);
                    isc_handler_p->fn = RULE_CTRL_UT_Priv_ISC_Handler;

                    isc_om_p = ISC_UT_GetOmById(ISC_RULE_CTRL_SID);

                    key.pvc_no = ISC_RULE_CTRL_SID;
                    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(RULE_CTRL_IscBuf_T),
                                                          L_MM_USER_ID2(SYS_MODULE_RULE_CTRL, RULE_CTRL_DEVRM_GETCOUNTER));

                    isc_buf_p = (RULE_CTRL_IscBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
                    assert (isc_buf_p != NULL);

                    isc_buf_p->ServiceID = RULE_CTRL_DEVRM_GETCOUNTER;
                    isc_buf_p->unit = rule_inst_p->dev_rule_info.unit;
                    isc_buf_p->RULECTRLINFO.device_id = rule_inst_p->dev_rule_info.device;
                    isc_buf_p->RULECTRLINFO.pcl_id = rule_inst_p->dev_rule_info.pcl_id;
                    isc_buf_p->RULECTRLINFO.dev_rule_id = rule_inst_p->dev_rule_info.rule_id;

                    RULE_CTRL_Slave_Get_Couner(&key, isc_buf_p);

                    memcpy(&iscReply, &isc_handler_p->reply_buf, sizeof(iscReply));

                    assert(TRUE == iscReply.return_value.b_result);

                    counter_p->green_packets = iscReply.data.acl_counter.green_cnt;
                    counter_p->yellow_packets = iscReply.data.acl_counter.yellow_cnt;
                    counter_p->red_packets = iscReply.data.acl_counter.red_cnt;
                }

                rule_inst_p->current_counter_index = (rule_inst_p->current_counter_index + 1)
                % _countof(rule_inst_p->counter);

                ASSERT(rule_inst_p->current_counter_index < _countof(rule_inst_p->counter));
                ASSERT(counter_p == &rule_inst_p->counter[rule_inst_p->current_counter_index]);

                counter_p->last_update_tick = SYSFUN_GetSysTick();
                counter_p->total_packets = counter_p->green_packets + counter_p->yellow_packets
                + counter_p->red_packets;

                test_ace.counter.green_packets += counter_p->green_packets;
                test_ace.counter.yellow_packets += counter_p->yellow_packets;
                test_ace.counter.red_packets += counter_p->red_packets;
            }

            test_ace.counter.last_update_tick = SYSFUN_GetSysTick();
            test_ace.counter.total_packets = test_ace.counter.green_packets +
                                             test_ace.counter.yellow_packets +
                                             test_ace.counter.red_packets;

            /* get acl counter by master function */
            result = RULE_CTRL_GetAclRuleCounter(ifindex, direction, acl_index, ace_index, &ace);
            assert(RULE_TYPE_OK == result);

            /* test slave and master result */
            assert(test_ace.counter.total_packets == ace.counter.total_packets);
        }
    }

    return 0;
}

int
RULE_CTRL_UT_STACK_GetDevInfo()
{
    typedef  struct
    {
        UI32_T unit;
    } INPUT_T;

    INPUT_T in[] =
    {
        { 2},
        { 3},
    };

    BOOL_T result;
    DEVRM_DevInfo_T dev_info;
    UI32_T i;

    ISC_HANDLER_T *isc_rule_ctrl_handler_p;
    ISC_OM_T *isc_om_p;

    isc_rule_ctrl_handler_p = ISC_UT_GetHandlerById(ISC_RULE_CTRL_SID);

    isc_rule_ctrl_handler_p->fn = RULE_CTRL_UT_Priv_ISC_Handler;

    isc_om_p = ISC_UT_GetOmById(ISC_RULE_CTRL_SID);

    for (i = 0; i < _countof(in); ++i)
    {
        INPUT_T *in_p = &in[i];

        result = RULE_CTRL_LocalGetDevInfo(in_p->unit, &dev_info);

        assert(result == TRUE);
        assert(isc_om_p->u.rule_ctrl.unit == in_p->unit);
        assert(isc_om_p->u.rule_ctrl.number_of_chips == dev_info.num_of_chips);
    }

    return 0;
}

#endif /* SYS_CPNT_STACKING */

int
RULE_CTRL_UT_RunTestCaese()
{
#define RULE_CTRL_UT_TEST(func) \
    UT_Test(RULE_CTRL_UT_Setup, RULE_CTRL_UT_Teardown_With_Validating_Rule, func)

//    rule_ctrl_ut_option.debug = TRUE;

    //
    // The self test
    //
    {
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_SelfTest_Create_Acl_And_Add_Ace);
    }

    //
    // Priority test
    //
    if (1)
    {
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_IP6_Set_Nd_Rs_Packet_To_Cpu);
    }

    if (l4_options.run_rule_ctrl)
    {
        RULE_CTRL_UT_TEST(foo);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Check_Rule_Quota);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Check_Rule_Quota_Greed);

        if (0)
        {
            //RULE_CTRL_UT_TEST(RULE_CTRL_UT_Check_Rule_Quota_Greed_By_Instance);
        }

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Get_Next_Ifindex);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Convert_Between_Ifindex_Interface);


        //
        // Test for libraries
        //
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Array);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Array_Erase);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Array_Find);

        // Test static function
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_ConvetAceToDev);

        //
        // Test for the global rule core functions
        //
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Remapped_Packet_Type);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Rule_Count);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Static_Constant_Value);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Get_PCL_Config);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Is_Match_Any_Any_Ace);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Global_My_Mac_Craft_Port_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Global_My_Mac_Arp_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Global_Rip_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Global_Igmp_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Global_DhcpSnp_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Global_Pvst_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Global_Cdp_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Global_Pvst_Cdp_Mixed_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Global_Dos_Echo_Chargen_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Global_Dos_Tcp_Udp_Flooding_Mixed_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Global_Mvr_Receiver_Vlan_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Global_Mac_Vlan_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Global_Mac_Mirror_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Global_Ip_Subnet_Vlan_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Global_Igmp_Rule_2);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Global_L2pt_Tunnel_Pdu_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Global_Pppoe_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Global_DropArpPacket);

        //
        // Test for the default rule core functions
        //
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Dflt_Vlan_Translation_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Dflt_Rate_Limit_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Dflt_Service_QinQ_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_Dflt_Ip_Subnet_VLAN_Per_Port_Rule);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_All_Global_And_Dflt_Rule);

        //
        // Test for ACL/QoS instance functons
        //
        RULE_CTRL_UT_Test_Instance();
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Get_Utilization);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Get_TCAM_Utilization); // FIXME: delete this
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Get_TCAM_Entry);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_GetNextTcamEntry);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Apply_ACL);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Apply_ACL_With_Counter_Enabled);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_One_Apply_One_ACL_On_One_Port_At_Same_Time);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Capacity_Test_Max_ACE_In_One_ACL_Ideal);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Capacity_Test_Max_ACE_In_One_ACL_Worst);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Capacity_Test_Max_ACE_In_One_ACL_Normal);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Capacity_Test_Max_ACE_In_One_ACL_Modify_On_Fly);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Capacity_Test_Max_ACE_In_One_ACL_Modify_On_Fly_Undo);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_ACL_System_Capacity_Test);
//        RULE_CTRL_UT_TEST(RULE_CTRL_UT_IP_Source_Guard_VS_ACL_Priority);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_QoS_With_Match_ACL_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_QoS_With_Match_MF_Rule);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_QoS_With_Match_ACL_MF_Rule);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_QoS_With_Match_ACL_Rule_Trunk_Port);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_QoS_With_Match_MF_Rule_Trunk_Port);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_QoS_With_Match_ACL_Rule_CPU_Port);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_QoS_With_Match_MF_Rule_CPU_Port);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_QoS_With_Match_Any_ACL_MF_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_QoS_With_Match_All_ACL_MF_Rule);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_QoS_With_Same_ACL_Rule_For_Undo_Test);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_QoS_With_Diff_ACL_Rule_For_Undo_Test);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_QoS_With_Diff_ACL_Rule_For_Undo_Out_Of_ACL_Instance);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_SeT_QoS_With_MF_Rule_For_Undo_Out_Of_MF_Class_Instance);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_SeT_QoS_With_MF_Rule_For_Undo_Out_Of_MF_Rule_Instance);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_QoS_Policy_Map_For_Undo_Out_Of_Rule_Instance);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_QoS_Policy_Map_With_Match_All_Class_Map_For_Undo_Out_Of_Rule_Instance);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_QoS_Policy_Map_For_Undo_Out_Of_Rule_Instance_Check_Qos_Remark_Entry);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_QoS_With_Modifying_Match_Cond_Of_Class_Map_On_Fly);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_QoS_With_Modifying_Match_Cond_Of_Class_Map_On_Fly_Undo);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_QoS_With_Modifying_ACE_On_Fly);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_QoS_With_Modifying_Meter_On_Fly);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Set_QoS_With_Modifying_Action_On_Fly);

#if 0 /* FIXME: time range */
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Time_Based_ACL_Apply_ACE_All_Use_Same_Time_Range);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Time_Based_ACL_Remove_ACE_All_Use_Same_Time_Range);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Time_Based_ACL_Apply_ACE_Use_Diff_Time_Range);
#endif /* 0 */

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Add_PTP_Event_ETH_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Add_PTP_Event_UDP_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Add_PTP_General_UDP_Rule);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Add_My_MAC_for_Craft_Port_Rule);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Add_Trunk_Vlan_Translation_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Add_Vlan_Translation_Rule);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Add_WebAuth_Redir_HTTP_And_Permit_DHCP_DNS_Rule);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Add_IpSrcGrd_Permit_SA_VID_SIP_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Add_IpSrcGrd_Permit_VID_SIP_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Add_IpSrcGrd_Deny_Any_IP_Rule);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Add_Ip6SrcGrd_Permit_VID_SIP6_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Add_Ip6SrcGrd_Deny_Any_IP6_Rule);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_PermitIPv6LinkLocal);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_IGMPSNP_Deny_Multicast_Data);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_IP6_Deny_Multicast_Data);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_IP6_Set_Nd_Rs_Packet_To_Cpu);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_IP6_Set_Nd_Ra_Packet_To_Cpu);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_IP6_Set_Nd_Ns_Packet_To_Cpu);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_IP6_Set_Nd_Na_Packet_To_Cpu);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_IP6_Set_Nd_Redirect_Packet_To_Cpu);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Add_ACL_Rule);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Add_QoS_With_MF_Rule);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Validate_Rule_Priority);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_ACL_Get_Counter);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_ACL_ACL_Mirror);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_ACL_ACL_Mirror_On_Fly);

#if 0 /* FIXME: rewrite these test with no rule_mgr*/
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_ACL_Show_Msg_When_Unbind_ACL_With_Time_Range_On_Egress_Port);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Bind_Policy_Map_With_Bad_Action_On_Egress_Port);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Bind_Policy_Map_On_Egress_Port);
#endif /* 0 */

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Convert_Count_To_Rate);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Software_Bundle_Rate_Limit);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_Time_Based_ACL_Process_Time_Simulation);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_EPR_Bind_Policy_Map_Failed_With_Remark_DSCP_In_Action);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_DynamicBindingPclToGlobal);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_DynamicBindingPclToUserPort);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_DynamicBindingPclToCpuPort);

#if (SYS_CPNT_PBR == TRUE)
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_BindPbrAcl);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_BindPbrAcl_With2Acl);
#endif /* SYS_CPNT_PBR */

#if (SYS_CPNT_STACKING == TRUE)
        // not validate rule of dev_rm
        UT_Test(RULE_CTRL_UT_Setup, RULE_CTRL_UT_Teardown, RULE_CTRL_UT_HandleHotRemoval);

        RULE_CTRL_UT_TEST(RULE_CTRL_UT_STACK_GetAndClearCounter);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_SLAVE_ACL_Get_Counter);
        RULE_CTRL_UT_TEST(RULE_CTRL_UT_STACK_GetDevInfo);
#endif /* SYS_CPNT_STACKING */

    }
    else
    {
        printf("%s (%d): Skip all rule case test cases\r\n", __FUNCTION__, __LINE__);
    }

    return 0;

#undef RULE_CTRL_UT_TEST
}


