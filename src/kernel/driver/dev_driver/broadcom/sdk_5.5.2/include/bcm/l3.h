/*
 * $Id: l3.h,v 1.95.2.1 Broadcom SDK $
 * 
 * $Copyright: Copyright 2008 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#ifndef __BCM_L3_H__
#define __BCM_L3_H__

#if defined(INCLUDE_L3)

#include <bcm/types.h>
#include <shared/l3.h>

/* Flags for L3 interface structure. */
#define BCM_L3_L2ONLY           (1 << 0)   /* L2 switch only on interface. */
#define BCM_L3_UNTAG            (1 << 1)   /* Packet goes out untagged. */
#define BCM_L3_S_HIT            (1 << 2)   /* Source IP address match. */
#define BCM_L3_D_HIT            (1 << 3)   /* Destination IP address match. */
#define BCM_L3_HIT              (BCM_L3_S_HIT | BCM_L3_D_HIT) 
#define BCM_L3_HIT_CLEAR        (1 << 4)   /* Clear HIT bit. */
#define BCM_L3_ADD_TO_ARL       (1 << 5)   /* Add interface address MAC to ARL. */
#define BCM_L3_WITH_ID          (1 << 6)   /* ID is provided. */
#define BCM_L3_NEGATE           (1 << 7)   /* Negate a set. */
#define BCM_L3_REPLACE          (1 << 8)   /* Replace existing entry. */
#define BCM_L3_TGID             (1 << 9)   /* Port belongs to trunk. */
#define BCM_L3_RPE              (1 << 10)  /* Pick up new priority (COS). */
#define BCM_L3_IPMC             (1 << 11)  /* Set IPMC for real IPMC entry. */
#define BCM_L3_L2TOCPU          (1 << 12)  /* Packet to CPU unrouted, XGS12: Set
                                              IPMC for UC address. */
#define BCM_L3_DEFIP_CPU        (1 << 13)  /* Strata: DEFIP CPU bit set. */
#define BCM_L3_DEFIP_LOCAL      BCM_L3_DEFIP_CPU /* XGS: Local DEFIP route. */
#define BCM_L3_MULTIPATH        (1 << 14)  /* Specify ECMP treatment. */
#define BCM_L3_LPM_DEFROUTE     (1 << 15)  /* Default route in LPM. */
#define BCM_L3_HOST_AS_ROUTE    (1 << 16)  /* Use LPM if host table full. */
#define BCM_L3_IP6              (1 << 17)  /* IPv6. */
#define BCM_L3_RPF              (1 << 18)  /* RPF check. */
#define BCM_L3_SRC_DISCARD      (1 << 19)  /* Source Match Discard. */
#define BCM_L3_DST_DISCARD      (1 << 20)  /* Destination match discard. */
#define BCM_L3_SECONDARY        (1 << 21)  /* Secondary L3 interface. */
#define BCM_L3_ROUTE_LABEL      (1 << 22)  /* Indicates that MPLS label in route
                                              entry is valid. */

/* IP constants. */
#define BCM_IP4_ADDRLEN         (4)        
#define BCM_IP6_ADDRLEN         (16)       

/* Reserved VRF values . */
#define BCM_L3_VRF_OVERRIDE     _SHR_L3_VRF_OVERRIDE /* Matches before VRF specific
                                              entries. */
#define BCM_L3_VRF_GLOBAL       _SHR_L3_VRF_GLOBAL /* Matches after VRF specific
                                              entries. */
#define BCM_L3_VRF_DEFAULT      _SHR_L3_VRF_DEFAULT /* Default VRF ID. */

/* Backward compatibility. */
#define BCM_L3_TUNNEL_TYPE_IP6_IP4  BCM_L3_TUNNEL_TYPE_6TO4 

#define BCM_IP6_BYTE(a, n)      (((uint8 *) (a))[n]) 

#define BCM_IP6_HALF(a, n)      (((uint16 *) (a))[n]) 

#define BCM_IP6_WORD(a, n)      (((uint8 *) (a))[n]) 

#define BCM_IP4_MULTICAST(a)    \
    (((a) & 0xf0000000) == 0xe0000000) 

#define BCM_IP6_MULTICAST(a)    \
    ((BCM_IP6_BYTE(a, 0)) == 0xff) 

#define BCM_IP6_ADDR_EQ(a1, a2)  \
    (sal_memcmp((a1), (a2), BCM_IP6_ADDRLEN) == 0) 

#define BCM_IP6_LOOPBACK(a)     \
    ((BCM_IP6_WORD((a), 0) | BCM_IP6_WORD((a), 1) | \
      BCM_IP6_WORD((a), 2) | BCM_IP6_HALF((a), 6) | \
      BCM_IP6_BYTE((a), 14)) == 0 && BCM_IP6_BYTE((a), 15) == 1) 

#define BCM_IP6_V4_MAPPED(a)    \
    ((BCM_IP6_WORD((a), 0) | BCM_IP6_WORD((a), 1) | \
      BCM_IP6_HALF((a), 4)) == 0 && BCM_IP6_HALF((a), 5) == 0xffff) 

#define BCM_IP6_V4_COMPATIBLE(a)  \
    (BCM_IP6_WORD((a), 0) | BCM_IP6_WORD((a), 1) | BCM_IP6_WORD((a), 2) == 0) 

/* Creates IPv6 mask. */
extern int bcm_ip6_mask_create(
    bcm_ip6_t ip6, 
    int len);

/* Calculates bit length of the IPv6 network address mask. */
extern int bcm_ip6_mask_length(
    bcm_ip6_t mask);

/* Creates IPv4 mask for a specific prefix length. */
extern bcm_ip_t bcm_ip_mask_create(
    int len);

/* Calculates bit length of the IPv4 network address mask. */
extern int bcm_ip_mask_length(
    bcm_ip_t ip);

/* 
 * L3 Interface Structure.
 * 
 * Contains information required for manipulating L3 interfaces.
 */
typedef struct bcm_l3_intf_s {
    uint32 l3a_flags;           /* See BCM_L3_XXX flag definitions. */
    bcm_vrf_t l3a_vrf;          /* Virtual router instance. */
    bcm_if_t l3a_intf_id;       /* Interface ID. */
    bcm_mac_t l3a_mac_addr;     /* MAC address. */
    bcm_vlan_t l3a_vid;         /* VLAN ID. */
    int l3a_tunnel_idx;         /* Tunnel (initiator) index. */
    int l3a_ttl;                /* TTL threshold. */
    int l3a_mtu;                /* MTU. */
    bcm_if_group_t l3a_group;   /* Interface group number. */
} bcm_l3_intf_t;

/* 
 * L3 Egress Structure.
 * 
 * Description of an L3 forwarding destination.
 */
typedef struct bcm_l3_egress_s {
    uint32 flags;                   /* Interface flags (BCM_L3_TGID,
                                       BCM_L3_L2TOCPU). */
    bcm_if_t intf;                  /* L3 interface (source MAC, tunnel). */
    bcm_mac_t mac_addr;             /* Next hop forwarding destination mac. */
    bcm_vlan_t vlan;                /* Next hop vlan id. */
    bcm_module_t module;            /* Module packet switched to (if
                                       !BCM_L3_TGID). */
    bcm_port_t port;                /* Port packet switched to (if
                                       !BCM_L3_TGID). */
    bcm_trunk_t trunk;              /* Trunk packet switched to (if
                                       BCM_L3_TGID). */
    bcm_mpls_label_t mpls_label;    /* MPLS label. */
    bcm_if_t encap_id;              /* Encapsulation index. */
    bcm_failover_t failover_id;     /* Failover Object Index. */
    bcm_if_t failover_if_id;        /* Failover Egress Object index. */
} bcm_l3_egress_t;

/* 
 * L3 Host Structure.
 * 
 * Contains information required for manipulating L3 host table entries.
 * 
 * The BCM_L3_IP6 flag in l3a_flags must be set to specify whether the
 * IPv4 or IPv6 addresses are valid.
 */
typedef struct bcm_l3_host_s {
    uint32 l3a_flags;           /* See BCM_L3_xxx flag definitions. */
    bcm_vrf_t l3a_vrf;          /* Virtual router instance. */
    bcm_ip_t l3a_ip_addr;       /* Destination host IP address (IPv4). */
    bcm_ip6_t l3a_ip6_addr;     /* Destination host IP address (IPv6). */
    bcm_cos_t l3a_pri;          /* New priority in packet. */
    bcm_if_t l3a_intf;          /* L3 intf associated with this address. */
    bcm_mac_t l3a_nexthop_mac;  /* Next hop MAC addr. */
    bcm_module_t l3a_modid;     /* Module ID packet is switched to. */
    bcm_port_t l3a_port_tgid;   /* Port/TGID packet is switched to. */
    bcm_port_t l3a_stack_port;  /* Used if modid not local (Strata Only). */
    int l3a_ipmc_ptr;           /* Pointer to IPMC table. */
    int l3a_lookup_class;       /* Classification lookup class ID. */
} bcm_l3_host_t;

/* Backward compatibility. */
typedef bcm_l3_host_t bcm_l3_ip_t;

/* 
 * L3 Key Structure.
 * 
 * Defines L3 table hash key structure.
 * 
 *   - For unicast addresses, key is DIP address or SIP to update HIT bit
 *   - For multicast addresses, the key is either IPMC group address
 *     (IPMC group address + src IP address), or
 *     (IPMC group address + src IP address + VID)
 *     depending on the chip being used and the (G, S, V) mode enable.
 * 
 * The BCM_L3_IP6 flag in l3k_flags is set to specify whether the IPv4 or
 * IPv6 addresses are valid.
 */
typedef struct bcm_l3_key_s {
    uint32 l3k_flags;           /* Set BCM_L3_IP6 for IPv6, default is IPv4, no
                                   other flags are relevant. */
    bcm_ip_t l3k_ip_addr;       /* Destination IP address (IPv4). */
    bcm_ip6_t l3k_ip6_addr;     /* Destination IP address (IPv6). */
    bcm_ip_t l3k_sip_addr;      /* Source IP address (IPv4). */
    bcm_ip6_t l3k_sip6_addr;    /* Source IP address (IPv6). */
    bcm_vlan_t l3k_vid;         /* VLAN ID. */
    bcm_vrf_t l3k_vrf;          /* BCM5660x: Virtual router instance. */
} bcm_l3_key_t;

/* 
 * L3 Route Structure
 * 
 * Contains information required for manipulating L3 route table entries.
 * 
 * @pThe BCM_L3_IP6 flag in l3a_flags must be set to specify whether the
 * IPv4 or IPv6 addresses are valid.
 */
typedef struct bcm_l3_route_s {
    uint32 l3a_flags;                   /* See BCM_L3_xxx flag definitions. */
    bcm_vrf_t l3a_vrf;                  /* Virtual router instance. */
    bcm_ip_t l3a_subnet;                /* IP subnet address (IPv4). */
    bcm_ip6_t l3a_ip6_net;              /* IP subnet address (IPv6). */
    bcm_ip_t l3a_ip_mask;               /* IP subnet mask (IPv4). */
    bcm_ip6_t l3a_ip6_mask;             /* IP subnet mask (IPv6). */
    bcm_if_t l3a_intf;                  /* L3 interface associated with route. */
    bcm_ip_t l3a_nexthop_ip;            /* Next hop IP address (XGS1/2, IPv4). */
    bcm_mac_t l3a_nexthop_mac;          /* Next hop MAC address. */
    bcm_module_t l3a_modid;             /* Module ID. */
    bcm_port_t l3a_port_tgid;           /* Port or trunk group ID. */
    bcm_port_t l3a_stack_port;          /* Used if modid is not local (Strata
                                           Only). */
    bcm_vlan_t l3a_vid;                 /* BCM5695 only - for per-VLAN def
                                           route. */
    bcm_cos_t l3a_pri;                  /* Priority (COS). */
    uint32 l3a_tunnel_option;           /* Tunnel option value. */
    bcm_mpls_label_t l3a_mpls_label;    /* MPLS label. */
    int l3a_lookup_class;               /* Classification class ID. */
} bcm_l3_route_t;

/* 
 * L3 Information Structure.
 * 
 * Contains information about L3 hardware capacity and utilization.
 * 
 * Note that in chips that implement the longest prefix match route table
 * as a trie, one IP route may consume up to 128 table entries in the
 * worst case.
 */
typedef struct bcm_l3_info_s {
    int l3info_max_vrf;         /* Maximum number of virtual routers allowed. */
    int l3info_used_vrf;        /* Number of virtual routers created so far. */
    int l3info_max_intf;        /* Maximum L3 interfaces the chip supports. */
    int l3info_max_intf_group;  /* Maximum L3 interface groups the chip
                                   supports. */
    int l3info_max_host;        /* L3 host table size(unit is IPv4 unicast). */
    int l3info_max_route;       /* L3 route table size (unit is IPv4 route). */
    int l3info_max_ecmp;        /* Maximum ECMP paths allowed. */
    int l3info_used_intf;       /* L3 interfaces used. */
    int l3info_used_host;       /* L3 host entries used. */
    int l3info_used_route;      /* L3 route entries used. */
    int l3info_max_lpm_block;   /* Maximum LPM blocks. */
    int l3info_used_lpm_block;  /* LPM blocks used. */
    int l3info_max_l3;          /* Superseded by l3info_max_host. */
    int l3info_max_defip;       /* Superseded by l3info_max_route. */
    int l3info_used_l3;         /* Superseded by l3info_occupied_host. */
    int l3info_used_defip;      /* Superseded by l3info_occupied_route. */
} bcm_l3_info_t;

/* Renamed bcm_l3_info_t fields. */
#define l3info_occupied_intf    l3info_used_intf 
#define l3info_occupied_host    l3info_used_host 
#define l3info_occupied_route   l3info_used_route 
#define l3info_occupied_l3      l3info_used_l3 
#define l3info_occupied_defip   l3info_used_defip 
#define bcm_l3_detach           bcm_l3_cleanup 

/* bcm_l3_host_traverse_cb */
typedef int (*bcm_l3_host_traverse_cb)(
    int unit, 
    int index, 
    bcm_l3_host_t *info, 
    void *user_data);

/* bcm_l3_route_traverse_cb */
typedef int (*bcm_l3_route_traverse_cb)(
    int unit, 
    int index, 
    bcm_l3_route_t *info, 
    void *user_data);

/* bcm_l3_egress_traverse_cb */
typedef int (*bcm_l3_egress_traverse_cb)(
    int unit, 
    bcm_if_t intf, 
    bcm_l3_egress_t *info, 
    void *user_data);

/* bcm_l3_egress_multipath_traverse_cb */
typedef int (*bcm_l3_egress_multipath_traverse_cb)(
    int unit, 
    bcm_if_t mpintf, 
    int intf_count, 
    bcm_if_t *intf_array, 
    void *user_data);

/* Initialize the BCM L3 subsystem. */
extern int bcm_l3_init(
    int unit);

/* De-initialize the BCM L3 subsystem. */
extern int bcm_l3_cleanup(
    int unit);

#define bcm_l3_detach           bcm_l3_cleanup 

/* Enable/disable L3 function without clearing any L3 tables. */
extern int bcm_l3_enable_set(
    int unit, 
    int enable);

/* Enable/disable L3 function without clearing any L3 tables. */
extern int bcm_l3_ip4_enable_set(
    int unit, 
    int enable);

/* Enable/disable L3 function without clearing any L3 tables. */
extern int bcm_l3_ip6_enable_set(
    int unit, 
    int enable);

/* Get the status of hardware tables. */
extern int bcm_l3_info(
    int unit, 
    bcm_l3_info_t *l3info);

/* bcm_l3_untagged_update */
extern int bcm_l3_untagged_update(
    int unit);

/* Initialize a bcm_l3_intf_t/bcmx_l3_intf_t structure. */
extern void bcm_l3_intf_t_init(
    bcm_l3_intf_t *intf);

/* Create a new L3 interface. */
extern int bcm_l3_intf_create(
    int unit, 
    bcm_l3_intf_t *intf);

/* Delete an L3 interface. */
extern int bcm_l3_intf_delete(
    int unit, 
    bcm_l3_intf_t *intf);

/* Delete all L3 interfaces. */
extern int bcm_l3_intf_delete_all(
    int unit);

/* Search for L3 interface by MAC address and VLAN. */
extern int bcm_l3_intf_find(
    int unit, 
    bcm_l3_intf_t *intf);

/* Search for L3 interface by VLAN only. */
extern int bcm_l3_intf_find_vlan(
    int unit, 
    bcm_l3_intf_t *intf);

/* Given the L3 interface number, return the interface information. */
extern int bcm_l3_intf_get(
    int unit, 
    bcm_l3_intf_t *intf);

/* Initialize a bcm_l3_egress_t/bcmx_l3_egress_t structure. */
extern void bcm_l3_egress_t_init(
    bcm_l3_egress_t *egr);

/* Create an Egress forwarding object. */
extern int bcm_l3_egress_create(
    int unit, 
    uint32 flags, 
    bcm_l3_egress_t *egr, 
    bcm_if_t *if_id);

/* Destroy an Egress forwarding object. */
extern int bcm_l3_egress_destroy(
    int unit, 
    bcm_if_t intf);

/* Get an Egress forwarding object. */
extern int bcm_l3_egress_get(
    int unit, 
    bcm_if_t intf, 
    bcm_l3_egress_t *egr);

/* Find an interface pinting to an Egress forwarding object. */
extern int bcm_l3_egress_find(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_if_t *intf);

/* 
 * Traverse through the egress object table and run callback at each
 * valid entry.
 */
extern int bcm_l3_egress_traverse(
    int unit, 
    bcm_l3_egress_traverse_cb trav_fn, 
    void *user_data);

/* Create a Multipath Egress forwarding object. */
extern int bcm_l3_egress_multipath_create(
    int unit, 
    uint32 flags, 
    int intf_count, 
    bcm_if_t *intf_array, 
    bcm_if_t *mpintf);

/* Destroy an Egress Multipath forwarding object. */
extern int bcm_l3_egress_multipath_destroy(
    int unit, 
    bcm_if_t mpintf);

/* Get an Egress Multipath forwarding object. */
extern int bcm_l3_egress_multipath_get(
    int unit, 
    bcm_if_t mpintf, 
    int intf_size, 
    bcm_if_t *intf_array, 
    int *intf_count);

/* 
 * Add an Egress forwarding object to an Egress Multipath forwarding
 * object.
 */
extern int bcm_l3_egress_multipath_add(
    int unit, 
    bcm_if_t mpintf, 
    bcm_if_t intf);

/* 
 * Delete an Egress forwarding object from an Egress Multipath forwarding
 * object.
 */
extern int bcm_l3_egress_multipath_delete(
    int unit, 
    bcm_if_t mpintf, 
    bcm_if_t intf);

/* Find an interface pinting to an Egress Multipath forwarding object. */
extern int bcm_l3_egress_multipath_find(
    int unit, 
    int intf_count, 
    bcm_if_t *intf_array, 
    bcm_if_t *mpintf);

/* 
 * Traverse through the multipath egress object table and run callback at
 * each valid entry.
 */
extern int bcm_l3_egress_multipath_traverse(
    int unit, 
    bcm_l3_egress_multipath_traverse_cb trav_fn, 
    void *user_data);

/* Initialize a bcm_l3_host_t/bcmx_l3_host_t structure. */
extern void bcm_l3_host_t_init(
    bcm_l3_host_t *ip);

/* Look up an L3 host table entry based on IP address. */
extern int bcm_l3_host_find(
    int unit, 
    bcm_l3_host_t *info);

/* Add an entry into the L3 switching table. */
extern int bcm_l3_host_add(
    int unit, 
    bcm_l3_host_t *info);

/* Delete an entry from the L3 host table. */
extern int bcm_l3_host_delete(
    int unit, 
    bcm_l3_host_t *ip_addr);

/* Delete L3 entries based on IP prefix (network). */
extern int bcm_l3_host_delete_by_network(
    int unit, 
    bcm_l3_route_t *ip_addr);

/* 
 * Deletes L3 entries that match or do not match a specified L3 interface
 * number.
 */
extern int bcm_l3_host_delete_by_interface(
    int unit, 
    bcm_l3_host_t *info);

/* Deletes all L3 host table entries. */
extern int bcm_l3_host_delete_all(
    int unit, 
    bcm_l3_host_t *info);

/* Return list of conflicts in the L3 table. */
extern int bcm_l3_host_conflict_get(
    int unit, 
    bcm_l3_key_t *ipkey, 
    bcm_l3_key_t *cf_array, 
    int cf_max, 
    int *cf_count);

/* Run L3 table aging. */
extern int bcm_l3_host_age(
    int unit, 
    uint32 flags, 
    bcm_l3_host_traverse_cb age_cb, 
    void *user_data);

/* Traverse through the L3 table and run callback at each valid L3 entry. */
extern int bcm_l3_host_traverse(
    int unit, 
    uint32 flags, 
    uint32 start, 
    uint32 end, 
    bcm_l3_host_traverse_cb cb, 
    void *user_data);

/* bcm_l3_host_invalidate_entry */
extern int bcm_l3_host_invalidate_entry(
    int unit, 
    bcm_ip_t info);

/* bcm_l3_host_validate_entry */
extern int bcm_l3_host_validate_entry(
    int unit, 
    bcm_ip_t info);

/* Initialize a bcm_l3_route_t/bcmx_l3_route_t_init structure. */
extern void bcm_l3_route_t_init(
    bcm_l3_route_t *route);

/* Add an IP route to the L3 route table. */
extern int bcm_l3_route_add(
    int unit, 
    bcm_l3_route_t *info);

/* Delete an IP route from the DEFIP table. */
extern int bcm_l3_route_delete(
    int unit, 
    bcm_l3_route_t *info);

/* Delete routes based on matching or non-matching L3 interface number. */
extern int bcm_l3_route_delete_by_interface(
    int unit, 
    bcm_l3_route_t *info);

/* Delete all routes. */
extern int bcm_l3_route_delete_all(
    int unit, 
    bcm_l3_route_t *info);

/* Look up a route given the network and netmask. */
extern int bcm_l3_route_get(
    int unit, 
    bcm_l3_route_t *info);

/* Given a network, return all the paths for this route. */
extern int bcm_l3_route_multipath_get(
    int unit, 
    bcm_l3_route_t *the_route, 
    bcm_l3_route_t *path_array, 
    int max_path, 
    int *path_count);

/* Age the route table. */
extern int bcm_l3_route_age(
    int unit, 
    uint32 flags, 
    bcm_l3_route_traverse_cb age_out, 
    void *user_data);

/* Traverse through the routing table and run callback at each route. */
extern int bcm_l3_route_traverse(
    int unit, 
    uint32 flags, 
    uint32 start, 
    uint32 end, 
    bcm_l3_route_traverse_cb trav_fn, 
    void *user_data);

/* Set the maximum ECMP paths allowed for a route (XGS only). */
extern int bcm_l3_route_max_ecmp_set(
    int unit, 
    int max);

/* Get the maximum ECMP paths allowed for a route (XGS only). */
extern int bcm_l3_route_max_ecmp_get(
    int unit, 
    int *max);

/* 
 * Extract list of IPv6 prefixes which are forwarded based on lower 32
 * bit of IPv6 address, treated as IPv4 address.
 */
extern int bcm_l3_ip6_prefix_map_get(
    int unit, 
    int map_size, 
    bcm_ip6_t *ip6_array, 
    int *ip6_count);

/* 
 * Add IPv6 prefix to the list of prefixes which are forwarded based on
 * lower 32 bit of IPv6 address, treated as IPv4 address.
 */
extern int bcm_l3_ip6_prefix_map_add(
    int unit, 
    bcm_ip6_t ip6_addr);

/* 
 * Remove IPv6 prefix from the list of prefixes which are forwarded based
 * on lower 32 bit of IPv6 address, treated as IPv4 address.
 */
extern int bcm_l3_ip6_prefix_map_delete(
    int unit, 
    bcm_ip6_t ip6_addr);

/* 
 * Remove all the IPv6 prefixes from the list of prefixes which are
 * forwarded based on lower 32 bit of IPv6 address, treated as IPv4
 * address.
 */
extern int bcm_l3_ip6_prefix_map_delete_all(
    int unit);

/* bcm_l3_age_cb */
typedef void (*bcm_l3_age_cb)(
    int , 
    bcm_ip_t );

/* Create a new L3 interface. */
extern int bcm_l3_interface_create(
    int unit, 
    bcm_mac_t mac_addr, 
    bcm_vlan_t vid, 
    int add_to_arl);

/* Create a new L3 interface with specified interface ID. */
extern int bcm_l3_interface_id_create(
    int unit, 
    bcm_mac_t mac_addr, 
    bcm_vlan_t vid, 
    int intf_idx, 
    int add_to_arl);

/* Create/update a new/existing L3 interface with specified interface ID. */
extern int bcm_l3_interface_id_update(
    int unit, 
    bcm_mac_t mac_addr, 
    bcm_vlan_t vid, 
    int intf_idx, 
    int add_to_arl);

/* Search for L3 interface based on MAC address and VLAN. */
extern int bcm_l3_interface_lookup(
    int unit, 
    bcm_mac_t mac_addr, 
    bcm_vlan_t vid, 
    int *intf_id);

/* Delete a L3 interface. */
extern int bcm_l3_interface_destroy(
    int unit, 
    int intf_id);

/* Given the L3 interface number, return the MAC and VLAN. */
extern int bcm_l3_interface_find(
    int unit, 
    int intf_id, 
    bcm_vlan_t *vid, 
    bcm_mac_t mac_addr);

/* Find the L3 interface by VLAN ID. */
extern int bcm_l3_interface_find_by_vlan(
    int unit, 
    bcm_vlan_t vid, 
    int *intf_id);

/* Lookup L3 host entry based on IP address. */
extern int bcm_l3_ip_find(
    int unit, 
    bcm_l3_ip_t *info);

/* bcm_l3_ip_find_index */
extern int bcm_l3_ip_find_index(
    int unit, 
    int index, 
    bcm_l3_ip_t *info);

/* Add an entry into L3 host table. */
extern int bcm_l3_ip_add(
    int unit, 
    bcm_l3_ip_t *info);

/* Delete an entry from the L3 host table. */
extern int bcm_l3_ip_delete(
    int unit, 
    bcm_ip_t ip_addr);

/* Delete L3 host entries based on IP prefix (network). */
extern int bcm_l3_ip_delete_by_prefix(
    int unit, 
    bcm_ip_t ip_addr, 
    bcm_ip_t mask);

/* Delete L3 host entries that match L3 interface number. */
extern int bcm_l3_ip_delete_by_interface(
    int unit, 
    int intf);

/* Delete all L3 host table entries. */
extern int bcm_l3_ip_delete_all(
    int unit);

/* 
 * Update L3 host entry with new information, the L3 host entry is
 * identified by the key of the entry which is the IP address for
 * unicast.
 */
extern int bcm_l3_ip_update_entry_by_key(
    int unit, 
    bcm_l3_ip_t *info);

/* Return list of conflicts in the L3 table. */
extern int bcm_l3_conflict_get(
    int unit, 
    bcm_l3_key_t *ipkey, 
    bcm_l3_key_t *cf_array, 
    int cf_max, 
    int *cf_count);

/* Invalidate L3 entry without clearing so it can be re-validated later. */
extern int bcm_l3_invalidate_entry(
    int unit, 
    bcm_ip_t l3_addr);

/* Invalidate L3 entry without clearing so it can be re-validated later. */
extern int bcm_l3_validate_entry(
    int unit, 
    bcm_ip_t l3_addr);

/* Run L3 table aging. */
extern int bcm_l3_age(
    int unit, 
    uint32 flags, 
    bcm_l3_age_cb age_out);

/* Return L3 status information. */
extern int bcm_l3_status(
    int unit, 
    int *free_l3intf, 
    int *free_l3, 
    int *free_defip, 
    int *free_lpm_blk);

/* Add an IP route to the route table. */
extern int bcm_l3_defip_add(
    int unit, 
    bcm_l3_route_t *info);

/* Delete an IP route from the route table. */
extern int bcm_l3_defip_delete(
    int unit, 
    bcm_l3_route_t *info);

/* Given the net/prefix, return route info. */
extern int bcm_l3_defip_get(
    int unit, 
    bcm_l3_route_t *info);

/* bcm_l3_defip_find_index */
extern int bcm_l3_defip_find_index(
    int unit, 
    int index, 
    bcm_l3_route_t *info);

/* Delete routes based on matching L3 interface number. */
extern int bcm_l3_defip_delete_by_interface(
    int unit, 
    int intf);

/* Delete all routes. */
extern int bcm_l3_defip_delete_all(
    int unit);

/* Age the route table. */
extern int bcm_l3_defip_age(
    int unit, 
    bcm_l3_route_traverse_cb age_out);

/* Set the maximum ECMP paths allowed for a route (XGS only). */
extern int bcm_l3_defip_max_ecmp_set(
    int unit, 
    int max);

/* Get the maximum ECMP paths allowed for a route (XGS only). */
extern int bcm_l3_defip_max_ecmp_get(
    int unit, 
    int *max);

/* Initialize a bcm_l3_key_t_init structure. */
extern void bcm_l3_key_t_init(
    bcm_l3_key_t *key);

/* Initialize a bcm_l3_info_t_init structure. */
extern void bcm_l3_info_t_init(
    bcm_l3_info_t *info);

/* Types of counters per L3 object. */
typedef enum bcm_l3_stat_e {
    bcmL3StatOutPackets, 
    bcmL3StatOutBytes, 
    bcmL3StatDropPackets, 
    bcmL3StatDropBytes 
} bcm_l3_stat_t;

/* Extract L3 egress statistics from the chip. */
extern int bcm_l3_egress_stat_get(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_l3_stat_t stat, 
    uint64 *val);

/* Extract L3 egress statistics from the chip. */
extern int bcm_l3_egress_stat_get32(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_l3_stat_t stat, 
    uint32 *val);

/* 
 * Set the specified L3 statistic to the indicated value for the
 * specified L3 egress.
 */
extern int bcm_l3_egress_stat_set(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_l3_stat_t stat, 
    uint64 val);

/* 
 * Set the specified L3 statistic to the indicated value for the
 * specified L3 egress.
 */
extern int bcm_l3_egress_stat_set32(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_l3_stat_t stat, 
    uint32 val);

/* Enable/disable collection of statistics on the indicated L3 egress. */
extern int bcm_l3_egress_stat_enable_set(
    int unit, 
    bcm_l3_egress_t *egr, 
    int enable);

/* Extract L3 host statistics from the chip. */
extern int bcm_l3_host_stat_get(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_stat_t stat, 
    uint64 *val);

/* Extract L3 host statistics from the chip. */
extern int bcm_l3_host_stat_get32(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_stat_t stat, 
    uint32 *val);

/* 
 * Set the specified L3 statistic to the indicated value for the
 * specified L3 host.
 */
extern int bcm_l3_host_stat_set(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_stat_t stat, 
    uint64 val);

/* 
 * Set the specified L3 statistic to the indicated value for the
 * specified L3 host.
 */
extern int bcm_l3_host_stat_set32(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_stat_t stat, 
    uint32 val);

/* Enable/disable collection of statistics for the indicated L3 host. */
extern int bcm_l3_host_stat_enable_set(
    int unit, 
    bcm_l3_host_t *host, 
    int enable);

extern int bcm_l3_route_stat_get(
    int unit, 
    bcm_l3_route_t *route, 
    bcm_l3_stat_t stat, 
    uint64 *val);

extern int bcm_l3_route_stat_get32(
    int unit, 
    bcm_l3_route_t *route, 
    bcm_l3_stat_t stat, 
    uint32 *val);

extern int bcm_l3_route_stat_set(
    int unit, 
    bcm_l3_route_t *route, 
    bcm_l3_stat_t stat, 
    uint64 val);

extern int bcm_l3_route_stat_set32(
    int unit, 
    bcm_l3_route_t *route, 
    bcm_l3_stat_t stat, 
    uint32 val);

/* Enable/disable collection of statistics for the indicated L3 route. */
extern int bcm_l3_route_stat_enable_set(
    int unit, 
    bcm_l3_route_t *route, 
    int enable);

#endif /* defined(INCLUDE_L3) */

#endif /* __BCM_L3_H__ */
