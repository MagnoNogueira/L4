/*
 * $Id: mpls.h,v 1.43.2.4 Broadcom SDK $
 * 
 * $Copyright: Copyright 2008 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#ifndef __BCM_MPLS_H__
#define __BCM_MPLS_H__

#if defined(INCLUDE_L3)

#include <bcm/types.h>
#include <bcm/l3.h>
#include <bcm/multicast.h>
#include <bcm/policer.h>

/* MPLS EXP Map Structure. */
typedef struct bcm_mpls_exp_map_s {
    int priority;       /* Internal priority. */
    bcm_color_t color;  /* Color. */
    uint8 exp;          /* EXP value. */
    uint8 pkt_pri;      /* Packet priority value. */
    uint8 pkt_cfi;      /* Packet CFI value. */
} bcm_mpls_exp_map_t;

/* MPLS Egress Label Structure. */
#define BCM_MPLS_EGRESS_LABEL_TTL_SET       0x00000001 
#define BCM_MPLS_EGRESS_LABEL_TTL_COPY      0x00000002 
#define BCM_MPLS_EGRESS_LABEL_TTL_DECREMENT 0x00000004 
#define BCM_MPLS_EGRESS_LABEL_EXP_SET       0x00000008 
#define BCM_MPLS_EGRESS_LABEL_EXP_REMARK    0x00000010 
#define BCM_MPLS_EGRESS_LABEL_EXP_COPY      0x00000020 
#define BCM_MPLS_EGRESS_LABEL_PRI_SET       0x00000040 
#define BCM_MPLS_EGRESS_LABEL_PRI_REMARK    0x00000080 

/* bcm_mpls_egress_label_s */
typedef struct bcm_mpls_egress_label_s {
    uint32 flags;           /* BCM_MPLS_EGRESS_LABEL_xxx. */
    bcm_mpls_label_t label; 
    int qos_map_id;         /* EXP map ID. */
    uint8 exp; 
    uint8 ttl; 
    uint8 pkt_pri; 
    uint8 pkt_cfi; 
} bcm_mpls_egress_label_t;

/* MPLS port match criteria. */
typedef enum bcm_mpls_port_match_e {
    BCM_MPLS_PORT_MATCH_INVALID,        /* Illegal. */
    BCM_MPLS_PORT_MATCH_NONE,           /* No source match criteria. */
    BCM_MPLS_PORT_MATCH_PORT,           /* {Module, Port} or Trunk. */
    BCM_MPLS_PORT_MATCH_PORT_VLAN,      /* Mod/port/trunk + outer VLAN. */
    BCM_MPLS_PORT_MATCH_PORT_VLAN_STACKED, /* Mod/port/trunk + outer/inner VLAN. */
    BCM_MPLS_PORT_MATCH_LABEL,          /* MPLS label. */
    BCM_MPLS_PORT_MATCH_LABEL_PORT,     /* MPLS label + Mod/port/trunk. */
    BCM_MPLS_PORT_MATCH_LABEL_VLAN,     /* MPLS label + VLAN. */
    BCM_MPLS_PORT_MATCH_COUNT           /* Must be last. */
} bcm_mpls_port_match_t;

/* MPLS interface flags. */
#define BCM_MPLS_PORT_REPLACE               0x00000001 /* Replace existing
                                                          entry. */
#define BCM_MPLS_PORT_WITH_ID               0x00000002 /* Add using the
                                                          specified ID. */
#define BCM_MPLS_PORT_DROP                  0x00000004 /* Drop matching packets. */
#define BCM_MPLS_PORT_NETWORK               0x00000008 /* Network-facing
                                                          interface. */
#define BCM_MPLS_PORT_CONTROL_WORD          0x00000010 /* Use control word
                                                          (VPWS). */
#define BCM_MPLS_PORT_SEQUENCED             0x00000020 /* Use sequence number
                                                          (VPWS). */
#define BCM_MPLS_PORT_COUNTED               0x00000040 /* Maintain packet/byte
                                                          counts. */
#define BCM_MPLS_PORT_INT_PRI_SET           0x00000080 /* Use specified int_pri
                                                          value for internal
                                                          priority. */
#define BCM_MPLS_PORT_INT_PRI_MAP           0x00000100 /* Use specified exp_map
                                                          to derive internal
                                                          priority. */
#define BCM_MPLS_PORT_COLOR_MAP             0x00000200 /* Use specified exp_map
                                                          to derive internal
                                                          color. */
#define BCM_MPLS_PORT_EGRESS_TUNNEL         0x00000400 /* Specified egress
                                                          tunnel interface is
                                                          valid. */
#define BCM_MPLS_PORT_SERVICE_TAGGED        0x00000800 /* Service tag mode. */
#define BCM_MPLS_PORT_SERVICE_VLAN_ADD      0x00001000 /* Add SD-tag. */
#define BCM_MPLS_PORT_SERVICE_VLAN_REPLACE  0x00002000 /* Replace VLAN not TPID. */
#define BCM_MPLS_PORT_SERVICE_VLAN_DELETE   0x00004000 /* Delete VLAN tag. */
#define BCM_MPLS_PORT_SERVICE_VLAN_TPID_REPLACE 0x00008000 /* Replace VLAN and TPID. */
#define BCM_MPLS_PORT_INNER_VLAN_PRESERVE   0x00010000 /* Preserve the inner or
                                                          customer VLAN tag */

/* MPLS port type. */
typedef struct bcm_mpls_port_s {
    bcm_gport_t mpls_port_id;           /* GPORT identifier. */
    uint32 flags;                       /* BCM_MPLS_PORT_xxx. */
    int if_class;                       /* Interface class ID. */
    int exp_map;                        /* Incoming EXP map ID. */
    int int_pri;                        /* Internal priority. */
    uint16 service_tpid;                /* Service VLAN TPID value. */
    bcm_gport_t port;                   /* Match port and/or egress port. */
    bcm_mpls_port_match_t criteria;     /* Match criteria. */
    bcm_vlan_t match_vlan;              /* Outer VLAN ID to match. */
    bcm_vlan_t match_inner_vlan;        /* Inner VLAN ID to match. */
    bcm_mpls_label_t match_label;       /* VC label to match. */
    bcm_if_t egress_tunnel_if;          /* MPLS tunnel egress object. */
    bcm_mpls_egress_label_t egress_label; /* Outgoing VC label. */
    bcm_vlan_t egress_service_vlan;     /* Service VLAN to Add/Replace. */
    bcm_if_t encap_id;                  /* Encap Identifier. */
    bcm_failover_t failover_id;         /* Failover Object Identifier. */
    bcm_gport_t failover_port_id;       /* Failover MPLS Port Identifier. */
    bcm_policer_t policer_id;           /* Policer ID to be associated with the
                                           MPLS gport */
} bcm_mpls_port_t;

/* MPLS label actions. */
typedef enum bcm_mpls_switch_action_e {
    BCM_MPLS_SWITCH_ACTION_SWAP, 
    BCM_MPLS_SWITCH_ACTION_PHP, 
    BCM_MPLS_SWITCH_ACTION_POP, 
    BCM_MPLS_SWITCH_ACTION_POP_DIRECT 
} bcm_mpls_switch_action_t;

/* MPLS tunnel switch flags. */
#define BCM_MPLS_SWITCH_LOOKUP_INNER_LABEL  0x00000001 /* Key contains label and
                                                          inner_label. */
#define BCM_MPLS_SWITCH_COUNTED             0x00000002 /* Maintain packet/byte
                                                          counts. */
#define BCM_MPLS_SWITCH_INT_PRI_SET         0x00000004 /* Use specified int_pri
                                                          value for internal
                                                          priority. */
#define BCM_MPLS_SWITCH_INT_PRI_MAP         0x00000008 /* Use specified exp_map
                                                          to derive internal
                                                          priority. */
#define BCM_MPLS_SWITCH_COLOR_MAP           0x00000010 /* Use specified exp_map
                                                          to derive internal
                                                          color. */
#define BCM_MPLS_SWITCH_OUTER_EXP           0x00000020 /* Get EXP from
                                                          popped/swapped label. */
#define BCM_MPLS_SWITCH_OUTER_TTL           0x00000040 /* Get TTL from
                                                          popped/swapped label. */
#define BCM_MPLS_SWITCH_INNER_EXP           0x00000080 /* (POP/PHP) Get EXP from
                                                          header following
                                                          popped label. */
#define BCM_MPLS_SWITCH_INNER_TTL           0x00000100 /* (POP/PHP) Get TTL from
                                                          header following
                                                          popped label. */
#define BCM_MPLS_SWITCH_TTL_DECREMENT       0x00000200 /* Decrement the TTL
                                                          value by 1. */

/* MPLS tunnel switch structure. */
typedef struct bcm_mpls_tunnel_switch_s {
    uint32 flags;                       /* BCM_MPLS_SWITCH_xxx. */
    bcm_mpls_label_t label;             /* Incoming label value. */
    bcm_mpls_label_t inner_label;       /* Incoming inner label (for two-label
                                           lookup keys). */
    bcm_gport_t port;                   /* Incoming port. */
    bcm_mpls_switch_action_t action;    /* MPLS label action. */
    int exp_map;                        /* EXP-map ID. */
    int int_pri;                        /* Internal priority. */
    bcm_vpn_t vpn;                      /* L3 VPN used if action is POP. */
    bcm_mpls_egress_label_t egress_label; /* Outgoing label information. */
    bcm_if_t egress_if;                 /* Outgoing egress object. */
} bcm_mpls_tunnel_switch_t;

/* Initialize the MPLS port structure. */
extern void bcm_mpls_port_t_init(
    bcm_mpls_port_t *mpls_port);

/* Initialize the MPLS egress label structure. */
extern void bcm_mpls_egress_label_t_init(
    bcm_mpls_egress_label_t *label);

/* Initialize the MPLS tunnel switch structure. */
extern void bcm_mpls_tunnel_switch_t_init(
    bcm_mpls_tunnel_switch_t *info);

/* Initialize a MPLS EXP map structure. */
extern void bcm_mpls_exp_map_t_init(
    bcm_mpls_exp_map_t *exp_map);

/* Initialize the BCM MPLS subsystem. */
extern int bcm_mpls_init(
    int unit);

/* Detach the MPLS software module. */
extern int bcm_mpls_cleanup(
    int unit);

/* Flags for bcm_mpls_vpn_id_create. */
#define BCM_MPLS_VPN_L3         0x00000001 
#define BCM_MPLS_VPN_VPWS       0x00000002 
#define BCM_MPLS_VPN_VPLS       0x00000004 
#define BCM_MPLS_VPN_REPLACE    0x00000008 
#define BCM_MPLS_VPN_WITH_ID    0x00000010 

/* MPLS VPN Config Structure. */
typedef struct bcm_mpls_vpn_config_s {
    uint32 flags;                       /* BCM_MPLS_VPN_xxx. */
    bcm_vpn_t vpn; 
    int lookup_id; 
    bcm_multicast_t broadcast_group; 
    bcm_multicast_t unknown_unicast_group; 
    bcm_multicast_t unknown_multicast_group; 
} bcm_mpls_vpn_config_t;

/* Initialize an MPLS VPN config structure. */
extern void bcm_mpls_vpn_config_t_init(
    bcm_mpls_vpn_config_t *info);

/* bcm_mpls_vpn_id_create */
extern int bcm_mpls_vpn_id_create(
    int unit, 
    bcm_mpls_vpn_config_t *info);

/* bcm_mpls_vpn_id_destroy */
extern int bcm_mpls_vpn_id_destroy(
    int unit, 
    bcm_vpn_t vpn);

/* bcm_mpls_vpn_id_destroy_all */
extern int bcm_mpls_vpn_id_destroy_all(
    int unit);

/* bcm_mpls_vpn_id_get */
extern int bcm_mpls_vpn_id_get(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_mpls_vpn_config_t *info);

/* bcm_mpls_port_add */
extern int bcm_mpls_port_add(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_mpls_port_t *mpls_port);

/* bcm_mpls_port_delete */
extern int bcm_mpls_port_delete(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t mpls_port_id);

/* bcm_mpls_port_delete_all */
extern int bcm_mpls_port_delete_all(
    int unit, 
    bcm_vpn_t vpn);

/* bcm_mpls_port_get */
extern int bcm_mpls_port_get(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_mpls_port_t *mpls_port);

/* bcm_mpls_port_get_all */
extern int bcm_mpls_port_get_all(
    int unit, 
    bcm_vpn_t vpn, 
    int port_max, 
    bcm_mpls_port_t *port_array, 
    int *port_count);

/* bcm_mpls_tunnel_initiator_set */
extern int bcm_mpls_tunnel_initiator_set(
    int unit, 
    bcm_if_t intf, 
    int num_labels, 
    bcm_mpls_egress_label_t *label_array);

/* bcm_mpls_tunnel_initiator_clear */
extern int bcm_mpls_tunnel_initiator_clear(
    int unit, 
    bcm_if_t intf);

/* bcm_mpls_tunnel_initiator_clear_all */
extern int bcm_mpls_tunnel_initiator_clear_all(
    int unit);

/* bcm_mpls_tunnel_initiator_get */
extern int bcm_mpls_tunnel_initiator_get(
    int unit, 
    bcm_if_t intf, 
    int label_max, 
    bcm_mpls_egress_label_t *label_array, 
    int *label_count);

/* bcm_mpls_tunnel_switch_add */
extern int bcm_mpls_tunnel_switch_add(
    int unit, 
    bcm_mpls_tunnel_switch_t *info);

/* bcm_mpls_tunnel_switch_delete */
extern int bcm_mpls_tunnel_switch_delete(
    int unit, 
    bcm_mpls_tunnel_switch_t *info);

/* bcm_mpls_tunnel_switch_delete_all */
extern int bcm_mpls_tunnel_switch_delete_all(
    int unit);

/* bcm_mpls_tunnel_switch_get */
extern int bcm_mpls_tunnel_switch_get(
    int unit, 
    bcm_mpls_tunnel_switch_t *info);

/* MPLS tunnel callback function prototype. */
typedef int (*bcm_mpls_tunnel_switch_traverse_cb)(
    int unit, 
    bcm_mpls_tunnel_switch_t *info, 
    void *user_data);

/* bcm_mpls_tunnel_switch_traverse */
extern int bcm_mpls_tunnel_switch_traverse(
    int unit, 
    bcm_mpls_tunnel_switch_traverse_cb cb, 
    void *user_data);

/* MPLS EXP map modes. */
#define BCM_MPLS_EXP_MAP_WITH_ID    0x01       
#define BCM_MPLS_EXP_MAP_INGRESS    0x02       
#define BCM_MPLS_EXP_MAP_EGRESS     0x04       

/* Create an MPLS EXP map instance. */
extern int bcm_mpls_exp_map_create(
    int unit, 
    uint32 flags, 
    int *exp_map_id);

/* Destroy an MPLS EXP map instance. */
extern int bcm_mpls_exp_map_destroy(
    int unit, 
    int exp_map_id);

/* 
 * Set the { internal priority, color }-to-EXP mapping in the specified
 * EXP map.
 */
extern int bcm_mpls_exp_map_set(
    int unit, 
    int exp_map_id, 
    bcm_mpls_exp_map_t *exp_map);

/* 
 * Get the { internal priority, color }-to-EXP mapping in the specified
 * EXP map.
 */
extern int bcm_mpls_exp_map_get(
    int unit, 
    int exp_map_id, 
    bcm_mpls_exp_map_t *exp_map);

/* MPLS statistics counters. */
typedef enum bcm_mpls_stat_e {
    bcmMplsInBytes, 
    bcmMplsOutBytes, 
    bcmMplsInPkts, 
    bcmMplsOutPkts 
} bcm_mpls_stat_t;

/* bcm_mpls_label_stat_get */
extern int bcm_mpls_label_stat_get(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint64 *val);

/* bcm_mpls_label_stat_get32 */
extern int bcm_mpls_label_stat_get32(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 *val);

/* bcm_mpls_port_stat_enable_set */
extern int bcm_mpls_port_stat_enable_set(
    int unit, 
    bcm_gport_t mpls_port, 
    int enable);

/* Types of statistics that are maintained per MPLS gport. */
typedef enum bcm_mpls_port_stat_e {
    bcmMplsPortStatUnicastPackets, 
    bcmMplsPortStatUnicastBytes, 
    bcmMplsPortStatNonUnicastPackets, 
    bcmMplsPortStatNonUnicastBytes, 
    bcmMplsPortStatDropPackets, 
    bcmMplsPortStatDropBytes, 
    bcmMplsPortStatFloodPackets, 
    bcmMplsPortStatFloodBytes, 
    bcmMplsPortStatFloodDropPackets, 
    bcmMplsPortStatFloodDropBytes, 
    bcmMplsPortStatGreenPackets, 
    bcmMplsPortStatGreenBytes, 
    bcmMplsPortStatYellowPackets, 
    bcmMplsPortStatYellowBytes, 
    bcmMplsPortStatRedPackets, 
    bcmMplsPortStatRedBytes 
} bcm_mpls_port_stat_t;

/* bcm_mpls_port_stat_set */
extern int bcm_mpls_port_stat_set(
    int unit, 
    bcm_gport_t mpls_port, 
    bcm_cos_t cos, 
    bcm_mpls_port_stat_t stat, 
    uint64 val);

/* bcm_mpls_port_stat_set32 */
extern int bcm_mpls_port_stat_set32(
    int unit, 
    bcm_gport_t mpls_port, 
    bcm_cos_t cos, 
    bcm_mpls_port_stat_t stat, 
    uint32 val);

/* bcm_mpls_port_stat_get */
extern int bcm_mpls_port_stat_get(
    int unit, 
    bcm_gport_t mpls_port, 
    bcm_cos_t cos, 
    bcm_mpls_port_stat_t stat, 
    uint64 *val);

/* bcm_mpls_port_stat_get32 */
extern int bcm_mpls_port_stat_get32(
    int unit, 
    bcm_gport_t mpls_port, 
    bcm_cos_t cos, 
    bcm_mpls_port_stat_t stat, 
    uint32 *val);

#define BCM_MPLS_ORIGINAL_PKT           (1 << 0)   /* Do not change MPLS packet. */
#define BCM_MPLS_INSERT_LABEL1          (1 << 1)   /* Insert outer label
                                                      indicator. */
#define BCM_MPLS_INSERT_LABEL2          (1 << 2)   /* Insert inner label
                                                      indicator. */
#define BCM_MPLS_ONE_LABEL_LOOKUP       (1 << 3)   /* Only interior label is
                                                      used. */
#define BCM_MPLS_USE_OUTER_TTL          (1 << 4)   /* Use outer label TTL. */
#define BCM_MPLS_USE_OUTER_EXP          (1 << 5)   /* Use outer label EXP bits. */
#define BCM_MPLS_NO_CHANGE_INNER_EXP    (1 << 6)   /* Do not change inner label
                                                      EXP bits. */
#define BCM_MPLS_USE_PRI                (1 << 7)   /* Set to use MPLS_LABEL_PRI
                                                      as priority instead of
                                                      getting priority from
                                                      MPLS_EXP table lookup. */
#define BCM_MPLS_NO_CHANGE_INNER_L2     (1 << 8)   /* Do not change inner L2
                                                      packet after MPLS tunnel
                                                      decapsulation. */
#define BCM_MPLS_NO_MPLS_DECAP          (1 << 9)   /* Do not do MPLS tunnel
                                                      decap. */
#define BCM_MPLS_L2_LEARN               (1 << 10)  /* No hardware learning if
                                                      not set. */
#define BCM_MPLS_L2_VPN                 (1 << 11)  /* VPN is L2 VPN. */
#define BCM_MPLS_L3_VPN                 (1 << 12)  /* VPN is L3 VPN. */
#define BCM_MPLS_LSR_SWITCH             (1 << 13)  /* Not used. */
#define BCM_MPLS_SRC_TRUNK              (1 << 14)  /* Source port is trunk. */
#define BCM_MPLS_NEXT_TRUNK             (1 << 15)  /* Next (MPLS) port is trunk. */
#define BCM_MPLS_DST_TRUNK              (1 << 16)  /* Destination (termination)
                                                      port is a trunk. */
#define BCM_MPLS_UPDATE                 (1 << 17)  /* Update existing entry. */
#define BCM_MPLS_HIT                    (1 << 18)  /* Entry was hit. */
#define BCM_MPLS_WITH_ID                (1 << 19)  /* ID is provided. */
#define BCM_MPLS_TTL_DO_NOT_DECREMENT   (1 << 20)  /* Valid only with
                                                      BCM_MPLS_ACTION_PHP
                                                      action. */
#define BCM_MPLS_USE_INNER_EXP          (1 << 21)  /* Use inner label EXP. */
#define BCM_MPLS_COUNTED                (1 << 22)  /* Maintain packet/byte
                                                      count. */

/* MPLS actions. */
typedef enum bcm_mpls_action_e {
    BCM_MPLS_ACTION_SWAP,               /* Label swap and forward to nexthop. */
    BCM_MPLS_ACTION_SWAP_PUSH,          /* Label swap, push new label and
                                           forward to nexthop. */
    BCM_MPLS_ACTION_SWAP_NEW_DOMAIN,    /* Label swap, switch to next hop and
                                           may add 1 or 2 new labels. */
    BCM_MPLS_ACTION_PHP,                /* Penultimate hop pop and may add 1
                                           label. */
    BCM_MPLS_ACTION_POP_L2_SWITCH,      /* Pop 1 or 2 labels, L2 switch packet. */
    BCM_MPLS_ACTION_POP_DST_MOD_PORT,   /* Pop 1 or 2 labels, forward packet to
                                           module ID/port. */
    BCM_MPLS_ACTION_POP_L3_SWITCH,      /* Pop 1 or 2 labels, L3 switch packet. */
    BCM_MPLS_ACTION_POP_L3_NEXTHOP,     /* Pop 1 or 2 labels, forward packet to
                                           nexthop. */
    BCM_MPLS_ACTION_POP_SEARCH,         /* Pop 1 or 2 labels, repeat MPLS
                                           actions. */
    BCM_MPLS_ACTION_COUNT               /* Must be last. */
} bcm_mpls_action_t;

#define BCM_MPLS_USER_LABEL(a)  ((a) > 15) 

/* 
 * Information for mapping incoming packets to VPN instance for L3 MPLS
 * VPN Routing/Forwarding Instance (VRF) or L2 MPLS Virtual Forwarding
 * Instance (VFI).
 * 
 * Note: Only supported on BCM5660x devices.
 */
typedef struct bcm_mpls_vpn_s {
    uint32 flags;           /* VRF/VFI select, i.e. L3 or L2; Trunk. */
    bcm_vpn_t vpn;          /* VRF/VFI index - remove. */
    bcm_if_t l3_intf;       /* L3 interface for RPF check, L3 VPN only. */
    bcm_trunk_t trunk;      /* Source trunk Group ID. */
    bcm_port_t port;        /* Source Port. */
    bcm_module_t module;    /* Source MODID. */
    bcm_vlan_t vlan;        /* Source VLAN ID. */
} bcm_mpls_vpn_t;

/* 
 * Virtual Circuit structure.
 * 
 * A VPN can have one or more VCs associated with it. For point-to-point
 * MPLS tunneling, there is one VC for the VPN; for VPLS
 * point-to-multipoint VPN, there can be more the one VCs for a VPN.
 * 
 * A Virtual Circuit is marked by MPLS VC label and header properties,
 * i.e. it contains information for encapsulating incoming Ethernet
 * packets (with no MPLS label) with MPLS headers, happens at L2 MPLS
 * tunnel initiation PE..
 * 
 * Note: Only supported on BCM5660x devices and only point-to-point mode.
 */
typedef struct bcm_mpls_circuit_s {
    uint32 flags;           /* BCM_MPLS_ORIGINAL_PKT? */
    bcm_vpn_t vpn;          /* The VPN this VC belongs to. */
    bcm_vlan_t vlan;        /* New VID in MPLS header. */
    bcm_mpls_label_t label; /* L2 MPLS VC label. */
    bcm_if_t l3_intf;       /* "L3 interface" (source MAC address, labels). */
    bcm_mac_t dst_mac;      /* MPLS packet's egress destination MAC. */
    bcm_port_t dst_port;    /* MPLS packet's egress port. */
    bcm_module_t dst_mod;   /* MPLS packet's egress module ID. */
    bcm_trunk_t dst_trunk;  /* MPLS packet's egress trunk. */
} bcm_mpls_circuit_t;

/* 
 * MPLS L3 initiator structure.
 * 
 * Contains information for Forwarding Equivalence Class (FEC) to MPLS
 * label mapping, FEC can be, all packets using the same route, or all
 * packets egressing at the same L3 interface etc. This is used to map
 * unlabeled IP packet into MPLS labeled packet at the L3 LSP initiation
 * point. This is used at the L3 MPLS initiator edge, The packet will go
 * through the normal L3 host/route lookup, to determine the outgoing
 * interface, and MPLS labels are inserted if the interface is marked as
 * MPLS enabled.
 * 
 * Note: Only supported on BCM5660x devices
 */
typedef struct bcm_mpls_l3_initiator_s {
    uint32 flags;               /* BCM_MPLS_xxx flags. */
    bcm_mpls_label_t label1;    /* First MPLS label. */
    bcm_mpls_label_t label2;    /* Second MPLS label. */
    int ttl1;                   /* TTL value for first MPLS label. */
    int ttl2;                   /* TTL value for second MPLS label. */
    int priority1;              /* EXP-map id for first MPLS label. */
    int priority2;              /* EXP-map id for second MPLS label. */
    uint8 exp1;                 /* EXP value for first MPLS label. */
    uint8 exp2;                 /* EXP value for second MPLS label. */
    uint8 pkt_prio;             /* Packet priority value. */
    uint8 pkt_cfi;              /* Packet CFI value. */
    bcm_mac_t dmac;             /* The MPLS header destination MAC. */
} bcm_mpls_l3_initiator_t;

/* 
 * MPLS switch structure.
 * 
 * The MPLS switch, i.e. incoming label mapping (ILM), structure contains
 * information for for label swapping and forwarding to next hop; label
 * popping at the penultimate switch, as well as information for
 * terminating L2/L3 MPLS tunnels.
 * 
 * Note: Only supported on BCM5660x devices
 */
typedef struct bcm_mpls_switch_s {
    uint32 flags;                   /* BCM_MPLS_ONE_LABEL_LOOKUP etc. etc. */
    bcm_mpls_label_t src_label1;    /* Lookup key: outer label. */
    bcm_mpls_label_t src_label2;    /* Lookup key: inner label if applicable. */
    bcm_port_t src_port;            /* Lookup key: Source port. */
    bcm_module_t src_mod;           /* Lookup key: Source module ID. */
    bcm_trunk_t src_trunk;          /* Lookup key: Source trunk ID. */
    bcm_mpls_action_t action;       /* MPLS action type. */
    bcm_if_t src_l3_intf;           /* Ingress L3 interface for the tunnel. */
    int label_pri;                  /* Priority for the associated label. */
    bcm_mpls_label_t swap_label;    /* New label for label swapping. */
    bcm_mpls_label_t push_label1;   /* New label for label pushing. */
    bcm_mpls_label_t push_label2;   /* New label for label pushing. */
    bcm_if_t next_intf;             /* Egress L3 interface for the tunnel. */
    bcm_mac_t next_mac;             /* Next hop MAC to get NH index. */
    bcm_vlan_t next_vlan;           /* VLAN ID to get NH index. */
    bcm_module_t next_mod;          /* Module ID to get NH index. */
    bcm_port_t next_port;           /* Port to get NH index. */
    bcm_trunk_t next_trunk;         /* Trunk to get NH index. */
    bcm_vpn_t vpn;                  /* VRF for L3 forwarding of IP payload; VFI
                                       ID used for VC table lookup. */
    bcm_port_t dst_port;            /* Port L2 payload is sent to. */
    bcm_module_t dst_mod;           /* Module ID L2 payload is sent to. */
    bcm_trunk_t dst_trunk;          /* Trunk L2 payload is sent to. */
    bcm_vlan_t dst_vlan;            /* New VLAN for overriding in L2 payload. */
} bcm_mpls_switch_t;

/* 
 * MPLS Information Structure
 * 
 * Contains information about MPLS hardware capacity and utilization.
 * 
 * Note: Only supported on BCM5660x devices
 */
typedef struct bcm_mpls_info_s {
    int vpn_max;            /* Maximum number of VPNs supported. */
    int vpn_used;           /* Used number of VPNs. */
    int label_table_max;    /* Maximum number of entries in MPLS label table. */
    int label_table_used;   /* Used number of entries in MPLS label table. */
    int circuit_max;        /* Maximum number of Virtual Circuits supported. */
    int circuit_used;       /* Used number of Virtual Circuits. */
} bcm_mpls_info_t;

/* Get the status of hardware tables. */
extern int bcm_mpls_info(
    int unit, 
    bcm_mpls_info_t *info);

/* Initialize the VPN struct. */
extern void bcm_mpls_vpn_t_init(
    bcm_mpls_vpn_t *vpn_info);

/* Initialize the initiator struct. */
extern void bcm_mpls_l3_initiator_t_init(
    bcm_mpls_l3_initiator_t *ftn);

/* Initialize the ILM structure. */
extern void bcm_mpls_switch_t_init(
    bcm_mpls_switch_t *switch_t);

/* Initialize a MPLS virtual circuit structure. */
extern void bcm_mpls_circuit_t_init(
    bcm_mpls_circuit_t *mpls_vc);

/* Initialize a MPLS information structure. */
extern void bcm_mpls_info_t_init(
    bcm_mpls_info_t *mpls_info);

/* Prevent or allow L2 MPLS packets from egressing a port. */
extern int bcm_mpls_port_block_set(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_port_t port, 
    int enable);

/* Get the L2 MPLS packet blocking state on a port. */
extern int bcm_mpls_port_block_get(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_port_t port, 
    int *enable);

/* Create a VPN instance. */
extern int bcm_mpls_vpn_create(
    int unit, 
    bcm_vpn_t vpn, 
    uint32 flags);

/* Delete a VPN instance. */
extern int bcm_mpls_vpn_destroy(
    int unit, 
    bcm_vpn_t vpn);

/* Bind interface/port/VLAN to VPN instance. */
extern int bcm_mpls_vpn_add(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_mpls_vpn_t *vpn_info);

/* Unbind interface/port/VLAN to VPN instance. */
extern int bcm_mpls_vpn_delete(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_mpls_vpn_t *key);

/* Unbind all interface/port/VLAN to the VPN instance. */
extern int bcm_mpls_vpn_delete_all(
    int unit, 
    bcm_vpn_t vpn);

/* Get the binding of interface/port/VLAN to VPN instance. */
extern int bcm_mpls_vpn_get(
    int unit, 
    bcm_vpn_t vpn, 
    int max_out, 
    bcm_mpls_vpn_t *vpn_info, 
    int *real_count);

/* Add a Virtual Circuit to an L2 MPLS VPN. */
extern int bcm_mpls_vpn_circuit_add(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_mpls_circuit_t *vc_info);

/* Delete a Virtual Circuit from an L2 MPLS VPN. */
extern int bcm_mpls_vpn_circuit_delete(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_mpls_circuit_t *vc_info);

/* Delete all Virtual Circuits associated with an L2 MPLS VPN. */
extern int bcm_mpls_vpn_circuit_delete_all(
    int unit, 
    bcm_vpn_t vpn);

/* Retrieve Virtual Circuit information for an L2 MPLS VPN. */
extern int bcm_mpls_vpn_circuit_get(
    int unit, 
    bcm_vpn_t vpn, 
    int vc_array, 
    bcm_mpls_circuit_t *vc_info, 
    int *vc_count);

/* Set the FEC to MPLS label mapping. */
extern int bcm_mpls_l3_initiator_set(
    int unit, 
    bcm_l3_intf_t *intf, 
    bcm_mpls_l3_initiator_t *mpls_label);

/* Clear the FEC to MPLS label mapping. */
extern int bcm_mpls_l3_initiator_clear(
    int unit, 
    bcm_l3_intf_t *intf);

/* Get the FEC to MPLS label mapping info. */
extern int bcm_mpls_l3_initiator_get(
    int unit, 
    bcm_l3_intf_t *intf, 
    bcm_mpls_l3_initiator_t *mpls_label);

/* Clear all the FEC to MPLS label mappings. */
extern int bcm_mpls_l3_initiator_clear_all(
    int unit);

/* 
 * Add MPLS label swapping, label popping, and packet forwarding
 * information.
 */
extern int bcm_mpls_switch_add(
    int unit, 
    bcm_mpls_switch_t *mswitch_info);

/* Delete MPLS label swapping and packet forwarding information. */
extern int bcm_mpls_switch_delete(
    int unit, 
    bcm_mpls_switch_t *mswitch_info);

/* Get MPLS label swapping and packet forwarding information. */
extern int bcm_mpls_switch_get(
    int unit, 
    bcm_mpls_switch_t *mswitch_info);

/* Delete all MPLS label swapping and packet forwarding information. */
extern int bcm_mpls_switch_delete_all(
    int unit, 
    int flag);

/* MPLS callback function prototype. */
typedef int (*bcm_mpls_switch_traverse_cb)(
    int unit, 
    int index, 
    bcm_mpls_switch_t *info, 
    void *user_data);

/* Find MPLS switch entries. */
extern int bcm_mpls_switch_traverse(
    int unit, 
    uint32 flags, 
    uint32 start, 
    uint32 end, 
    bcm_mpls_switch_traverse_cb trav_fn, 
    void *user_data);

#endif /* defined(INCLUDE_L3) */

#endif /* __BCM_MPLS_H__ */
