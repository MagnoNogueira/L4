/*
 * $Id: rx.h,v 1.64.6.4 Broadcom SDK $
 * 
 * $Copyright: Copyright 2008 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#ifndef __BCM_RX_H__
#define __BCM_RX_H__

#include <bcm/types.h>
#include <bcm/pkt.h>
#include <bcm/tx.h>

#define BCM_RX_COS              48         /* Number of COS supported. */
#define BCM_RX_COS_ALL          -1         /* Affect all COS. */
#define BCM_RX_CHANNELS         4          /* Max. number of RX channels. */

/* 
 * This is the default time between minimum token refreshes. It is also
 * the maximum time between RX thread wake-ups.
 */
#define BCM_RX_TOKEN_CHECK_US_DEFAULT   100000     /* 10 times/sec. */

/* bcm_rx_token_check_us */
extern int bcm_rx_token_check_us;

/* 
 * RX Callback Flags
 * 
 * The lower eight bits of the flag value are used to indicate which
 * COS(es) a callback should look at.
 * 
 *   BCM_RX_F_INTERRUPT_SET(flags)	Add the interrupt flags
 *   BCM_RX_F_COS_ADD(flags, cos)	Add COS to flags
 * 
 *   BCM_RCO_F_COS_ACCEPT_MASK		Bits used for COS
 *   BCM_RCO_F_COS_ACCEPT(cos)		Generate bit for given COS
 *   BCM_RCO_F_INTR			Interrupt level callback
 */
#define BCM_RCO_F_COS_ACCEPT_MASK   0xc0ff     
#define BCM_RCO_F_ALL_COS           0xc0ff     
#define BCM_RCO_F_COS_ACCEPT(cos)   (1 << (cos)) 
#define BCM_RCO_F_INTR              0x80000000 

#define BCM_RX_F_INTERRUPT_SET(flags)  ((flags) |= BCM_RCO_F_INTR) 
#define BCM_RX_F_COS_ADD(flags, cos)  ((flags) |= BCM_RCO_F_COS_ACCEPT(cos)) 

#define BCM_RX_RATE_NOLIMIT         0          
#define BCM_RX_SCHED_ALL_PACKETS    -1         

/* Return values from PKT RX callout routines. */
typedef enum bcm_rx_e {
    BCM_RX_INVALID,         /* Invalid return value. */
    BCM_RX_NOT_HANDLED,     /* Packet not processed. */
    BCM_RX_HANDLED,         /* Packet handled, not owned. */
    BCM_RX_HANDLED_OWNED    /* Packet handled and owned. */
} bcm_rx_t;

/* Max. allowed packets per chain. */
#define BCM_RX_PPC_MAX                     

/* Callback function type for applications using bcm RX facility. */
typedef bcm_rx_t (*bcm_rx_cb_f)(
    int unit, 
    bcm_pkt_t *pkt, 
    void *cookie);

/* Callback function type for applications implementing RX scheduling. */
typedef int (*bcm_rx_sched_cb)(
    int unit, 
    int *sched_unit, 
    bcm_cos_queue_t *sched_cosq, 
    int *sched_count);

/* RX packet buffer allocation function. */
typedef int (*bcm_rx_alloc_f)(
    int unit, 
    int size, 
    uint32 flags, 
    void **pkt_buf);

/* RX packet buffer free function. */
typedef int (*bcm_rx_free_f)(
    int unit, 
    void *pkt_buf);

#define bcm_data_alloc_f        bcm_rx_alloc_f 
#define bcm_data_free_f         bcm_rx_free_f 

/* RX registration function. */
typedef int (*bcm_rx_reg_f)(
    int unit, 
    const char *name, 
    bcm_rx_cb_f callback, 
    uint8 priority, 
    void *cookie, 
    uint32 flags);

/* RX unregistration function. */
typedef int (*bcm_rx_unreg_f)(
    int unit, 
    bcm_rx_cb_f callback, 
    uint8 priority);

/* 
 * Channel-specific RX data.
 * 
 * The number of chains allowed for the channel controls the burst size
 * that the channel accepts.
 * 
 * The 'rate_pps' field is DEPRECATED. The rate may be set on a per-COS
 * basis using bcm_rx_rate_set/get.
 * 
 * IMPORTANT: If BCM_RX_F_MULTI_DCB is NOT used (single DCB per packet)
 * then the rx_free routine must be given the allocation pointer
 * (pkt->alloc_ptr) rather than the packet data pointer
 * (pkt->_pkt_data.data or pkt->pkt_data[0].data).
 */
typedef struct bcm_rx_chan_cfg_s {
    int chains;     /* Number of chains (DVs) set up. 0 means channel not used. */
    int rate_pps;   /* Deprecated: Use bcm_rx_cos_rate_set/get. */
    int flags;      /* See BCM_RX_F_* definitions. */
    uint32 cos_bmp; /* COS bitmap, if supported. */
} bcm_rx_chan_cfg_t;

/* Flags for bcm_rx_chan_cfg_t. */
#define BCM_RX_F_CRC_STRIP      0x1        /* Strip CRC from packets. */
#define BCM_RX_F_VTAG_STRIP     0x2        /* Strip VLAN tag from packets. */
#define BCM_RX_F_RATE_STALL     0x4        /* Use "stall" (vs discard). */
#define BCM_RX_F_MULTI_DCB      0x8        /* Scatter data with multiple DCBs. */
#define BCM_RX_F_OVERSIZED_OK   0x10       /* Accept packets larger than
                                              bufsize. */

/* User-configurable, per-unit RX configuration. */
typedef struct bcm_rx_cfg_s {
    int pkt_size;                       /* Default packet size. */
    int pkts_per_chain;                 /* Packets per DMA chain. */
    int global_pps;                     /* Global rate limiting as packets per
                                           second. */
    int max_burst;                      /* Max. packets to be received in a
                                           single burst. */
    bcm_rx_chan_cfg_t chan_cfg[BCM_RX_CHANNELS]; /* RX channel configuration. */
    bcm_rx_alloc_f rx_alloc;            /* RX packet allocation function. */
    bcm_rx_free_f rx_free;              /* RX packet free function. */
    int32 flags;                        /* See BCM_RX_F_* definitions. */
} bcm_rx_cfg_t;

/* Flags for bcm_rx_cfg_t. */
#define BCM_RX_F_IGNORE_HGHDR   0x1        /* Force HiGig Header into packet for
                                              fabric device. */
#define BCM_RX_F_IGNORE_SLTAG   0x2        /* Force SL tag into packet on SL
                                              stacking. */

/* Structure of transport related function pointers. */
typedef struct bcm_trans_ptr_s {
    bcm_rx_alloc_f tp_data_alloc;   /* Packet data allocation function. */
    bcm_rx_free_f tp_data_free;     /* Packet data free function. */
    bcm_pkt_alloc_f tp_pkt_alloc;   /* Packet structure (bcm_pkt_t) allocation
                                       function. */
    bcm_pkt_free_f tp_pkt_free;     /* Packet structure (bcm_pkt_t) free
                                       function. */
    bcm_rx_reg_f tp_rx_reg;         /* RX registration function. */
    bcm_rx_unreg_f tp_rx_unreg;     /* RX unregistration function. */
    bcm_tx_pkt_setup_f tp_setup_tx; /* TX packet setup function. */
    bcm_tx_f tp_tx;                 /* TX single packet transmit function. */
    bcm_tx_list_f tp_tx_list;       /* TX function for sending a list of
                                       packets. */
    bcm_tx_array_f tp_tx_array;     /* TX function for sending an array of
                                       packets. */
    bcm_pkt_l2_map_f tp_l2_map;     /* Map a packet's L2 information into a port
                                       bitmap. */
    int tp_unit;                    /* Default unit to use for allocation/free
                                       functions. */
} bcm_trans_ptr_t;

/* bcm_rx_chan_t */
typedef int bcm_rx_chan_t;

/* Standard BCM transport pointer structure. */
extern bcm_trans_ptr_t bcm_trans_ptr;

#define BCM_RX_REASON_NAMES_INITIALIZER _SHR_RX_REASON_NAMES_INITIALIZER 

/* 
 * PKT RX Packet Reasons; reason CPU received the packet.
 * 
 * It is possible no reasons are set (directed to CPU from ARL for
 * example), or multiple reasons may be set.
 */
typedef enum bcm_rx_reason_e {
    bcmRxReasonInvalid = _SHR_RX_INVALID, 
    bcmRxReasonArp = _SHR_RX_ARP, 
    bcmRxReasonBpdu = _SHR_RX_BPDU, 
    bcmRxReasonBroadcast = _SHR_RX_BROADCAST, 
    bcmRxReasonClassBasedMove = _SHR_RX_CLASS_BASED_MOVE, 
    bcmRxReasonClassTagPackets = _SHR_RX_CLASS_TAG_PACKETS, 
    bcmRxReasonControl = _SHR_RX_CONTROL, 
    bcmRxReasonCpuLearn = _SHR_RX_CPU_LEARN, 
    bcmRxReasonDestLookupFail = _SHR_RX_DEST_LOOKUP_FAIL, 
    bcmRxReasonDhcp = _SHR_RX_DHCP, 
    bcmRxReasonDosAttack = _SHR_RX_DOS_ATTACK, 
    bcmRxReasonE2eHolIbp = _SHR_RX_E2E_HOL_IBP, 
    bcmRxReasonFilterMatch = _SHR_RX_FILTER_MATCH, 
    bcmRxReasonGreChecksum = _SHR_RX_GRE_CHECKSUM, 
    bcmRxReasonGreSourceRoute = _SHR_RX_GRE_SOURCE_ROUTE, 
    bcmRxReasonHigigControl = _SHR_RX_HIGIG_CONTROL, 
    bcmRxReasonHigigHdrError = _SHR_RX_HIGIG_HDR_ERROR, 
    bcmRxReasonIcmpRedirect = _SHR_RX_ICMP_REDIRECT, 
    bcmRxReasonIgmp = _SHR_RX_IGMP, 
    bcmRxReasonIngressFilter = _SHR_RX_INGRESS_FILTER, 
    bcmRxReasonIp = _SHR_RX_IP, 
    bcmRxReasonIpMcastMiss = _SHR_RX_IP_MCAST_MISS, 
    bcmRxReasonIpmcReserved = _SHR_RX_IPMC_RSVD, 
    bcmRxReasonIpOptionVersion = _SHR_RX_IP_OPTION_VERSION, 
    bcmRxReasonIpmc = _SHR_RX_IPMC, 
    bcmRxReasonL2Cpu = _SHR_RX_L2_CPU, 
    bcmRxReasonL2DestMiss = _SHR_RX_L2_DEST_MISS, 
    bcmRxReasonL2LearnLimit = _SHR_RX_L2_LEARN_LIMIT, 
    bcmRxReasonL2Move = _SHR_RX_L2_MOVE, 
    bcmRxReasonL2MtuFail = _SHR_RX_L2_MTU_FAIL, 
    bcmRxReasonL2NonUnicastMiss = _SHR_RX_L2_NON_UNICAST_MISS, 
    bcmRxReasonL2SourceMiss = _SHR_RX_L2_SOURCE_MISS, 
    bcmRxReasonL3DestMiss = _SHR_RX_L3_DEST_MISS, 
    bcmRxReasonL3HeaderError = _SHR_RX_L3_HEADER_ERROR, 
    bcmRxReasonL3MtuFail = _SHR_RX_L3_MTU_FAIL, 
    bcmRxReasonL3Slowpath = _SHR_RX_L3_SLOW_PATH, 
    bcmRxReasonL3SourceMiss = _SHR_RX_L3_SOURCE_MISS, 
    bcmRxReasonL3SourceMove = _SHR_RX_L3_SOUCE_MOVE, 
    bcmRxReasonMartianAddr = _SHR_RX_MARTIAN_ADDR, 
    bcmRxReasonMcastIdxError = _SHR_RX_MCAST_IDX_ERROR, 
    bcmRxReasonMcastMiss = _SHR_RX_MCAST_MISS, 
    bcmRxReasonMplsError = _SHR_RX_MPLS_ERROR, 
    bcmRxReasonMplsInvalidAction = _SHR_RX_MPLS_INVALID_ACTION, 
    bcmRxReasonMplsInvalidPayload = _SHR_RX_MPLS_INVALID_PAYLOAD, 
    bcmRxReasonMplsLabelMiss = _SHR_RX_MPLS_LABEL_MISS, 
    bcmRxReasonMplsSequenceNumber = _SHR_RX_MPLS_SEQUENCE_NUMBER, 
    bcmRxReasonMplsTtl = _SHR_RX_MPLS_TTL, 
    bcmRxReasonMulticast = _SHR_RX_MULTICAST, 
    bcmRxReasonNhop = _SHR_RX_NHOP, 
    bcmRxReasonParityError = _SHR_RX_PARITY_ERROR, 
    bcmRxReasonProtocol = _SHR_RX_PROTOCOL, 
    bcmRxReasonSampleDest = _SHR_RX_SAMPLE_DEST, 
    bcmRxReasonSampleSource = _SHR_RX_SAMPLE_SOURCE, 
    bcmRxReasonSharedVlanMismatch = _SHR_RX_SHARED_VLAN_MISMATCH, 
    bcmRxReasonSourceRoute = _SHR_RX_SOURCE_ROUTE, 
    bcmRxReasonTtl = _SHR_RX_TTL, 
    bcmRxReasonTtl1 = _SHR_RX_TTL1, 
    bcmRxReasonTunnelError = _SHR_RX_TUNNEL_ERROR, 
    bcmRxReasonUdpChecksum = _SHR_RX_UDP_CHECKSUM, 
    bcmRxReasonUnknownVlan = _SHR_RX_UNKNOWN_VLAN, 
    bcmRxReasonUrpfFail = _SHR_RX_URPF_FAIL, 
    bcmRxReasonVcLabelMiss = _SHR_RX_VC_LABEL_MISS, 
    bcmRxReasonVlanFilterMatch = _SHR_RX_VLAN_FILTER_MATCH, 
    bcmRxReasonExceptionFlood = _SHR_RX_EXCEPTION_FLOOD, 
    bcmRxReasonTimsSync = _SHR_RX_TIMESYNC, 
    bcmRxReasonEAVData = _SHR_RX_EAV_DATA, 
    bcmRxReasonSamePortBridge = _SHR_RX_SAME_PORT_BRIDGE, 
    bcmRxReasonSplitHorizon = _SHR_RX_SPLIT_HORIZON, 
    bcmRxReasonL4Error = _SHR_RX_L4_ERROR, 
    bcmRxReasonStp = _SHR_RX_STP, 
    bcmRxReasonCount = _SHR_RX_REASON_COUNT 
} bcm_rx_reason_t;

/* 
 * Macro to check if a reason (bcmRxReason*) is included in a set of
 * reasons (bcm_rx_reasons_t).
 * 
 * Returns:
 *   zero     => reason is not included in the set
 *   non-zero => reason is included in the set
 */
#define BCM_RX_REASON_GET(_reasons, _reason)  \
   _SHR_RX_REASON_GET(_reasons, _reason) 

/* 
 * Macro to add a reason (bcmRxReason*) to a set of reasons
 * (bcm_rx_reasons_t).
 */
#define BCM_RX_REASON_SET(_reasons, _reason)  \
   _SHR_RX_REASON_SET(_reasons, _reason) 

/* 
 * Macro to add all reasons (bcmRxReason*) to a set of reasons
 * (bcm_rx_reasons_t).
 */
#define BCM_RX_REASON_SET_ALL(_reasons)  \
   _SHR_RX_REASON_SET_ALL(_reasons) 

/* 
 * Macro to clear a reason (bcmRxReason*) from a set of reasons
 * (bcm_rx_reasons_t).
 */
#define BCM_RX_REASON_CLEAR(_reasons, _reason)  \
   _SHR_RX_REASON_CLEAR(_reasons, _reason) 

/* Macro to clear a set of reasons (bcm_rx_reasons_t). */
#define BCM_RX_REASON_CLEAR_ALL(_reasons)  \
   _SHR_RX_REASON_CLEAR_ALL(_reasons) 

/* Associate a policer to the specified set of reason codes. */
extern int bcm_rx_reasons_policer_set(
    int unit, 
    bcm_rx_reasons_t rx_reasons, 
    bcm_policer_t polid);

/* 
 * Defines for priorities of registered PKT RX handlers. PKT RX handlers
 * are always called from highest priority to lowest priority until one
 * of the handlers returns rx_handled or rx_handled_owned.
 * 
 * When started, a default PKT RX handler is installed at PKT_RX_PRIO_MIN
 * that discards the packets.
 */
#define BCM_RX_PRIO_MIN         ((uint8)0) 
#define BCM_RX_PRIO_MAX         ((uint8)255) 

#define BCM_RX_INIT_DONE(unit)  (bcm_rx_cfg_get(unit, NULL) == 0) 

/* Initialize the RX software module for the given device. */
extern int bcm_rx_init(
    int unit);

/* Re-initialize the user level configuration for the RX module. */
extern int bcm_rx_cfg_init(
    int unit);

/* Start packet reception for the given device. */
extern int bcm_rx_start(
    int unit, 
    bcm_rx_cfg_t *cfg);

/* Stop the RX software module. */
extern int bcm_rx_stop(
    int unit, 
    bcm_rx_cfg_t *cfg);

/* Get the current configuration for the given device. */
extern int bcm_rx_cfg_get(
    int unit, 
    bcm_rx_cfg_t *cfg);

/* Boolean indication of whether RX is running on this device. */
extern int bcm_rx_active(
    int unit);

/* Register CPU bound packets scheduler. */
extern int bcm_rx_sched_register(
    int unit, 
    bcm_rx_sched_cb sched_cb);

/* Unregister CPU bound packets scheduler. */
extern int bcm_rx_sched_unregister(
    int unit);

/* Get next unit with cpu rx enabled. */
extern int bcm_rx_unit_next_get(
    int unit, 
    int *next_unit);

/* Get maximum cos queue number for the device. */
extern int bcm_rx_queue_max_get(
    int unit, 
    bcm_cos_queue_t *cosq);

/* 
 * Get number of packet takens available for the specific device/queue
 *                 BCM_RX_SCHED_ALL_PACKETS - queue doesn't limit number
 * of packets.
 */
extern int bcm_rx_queue_rate_limit_status_get(
    int unit, 
    bcm_cos_queue_t cosq, 
    int *packet_tokens);

/* 
 * Get number of packets awaiting processing in the specific device,
 * queue.
 */
extern int bcm_rx_queue_packet_count_get(
    int unit, 
    bcm_cos_queue_t cosq, 
    int *packet_count);

/* Register or unregister to receive callbacks for received packets. */
extern int bcm_rx_register(
    int unit, 
    const char *name, 
    bcm_rx_cb_f callback, 
    uint8 priority, 
    void *cookie, 
    uint32 flags);

/* Register or unregister to receive callbacks for received packets. */
extern int bcm_rx_unregister(
    int unit, 
    bcm_rx_cb_f callback, 
    uint8 priority);

/* 
 * Register a callback function to be called when a packet is received on
 * the specified CPU COS queue.
 */
extern int bcm_rx_queue_register(
    int unit, 
    const char *name, 
    bcm_cos_queue_t cosq, 
    bcm_rx_cb_f callback, 
    uint8 priority, 
    void *cookie, 
    uint32 flags);

/* Unregister CPU COS callback function. */
extern int bcm_rx_queue_unregister(
    int unit, 
    bcm_cos_queue_t cosq, 
    bcm_rx_cb_f callback, 
    uint8 priority);

#define BCM_RX_COSQ_PACKET_TYPE_SWITCHED    0x1        
#define BCM_RX_COSQ_PACKET_TYPE_NON_UNICAST 0x2        
#define BCM_RX_COSQ_PACKET_TYPE_MIRROR      0x4        

/* Get number of packet to CPU COS queue mappings. */
extern int bcm_rx_cosq_mapping_size_get(
    int unit, 
    int *size);

/* Map packets to a CPU COS queue. */
extern int bcm_rx_cosq_mapping_set(
    int unit, 
    int index, 
    bcm_rx_reasons_t reasons, 
    bcm_rx_reasons_t reasons_mask, 
    uint8 int_prio, 
    uint8 int_prio_mask, 
    uint32 packet_type, 
    uint32 packet_type_mask, 
    bcm_cos_queue_t cosq);

/* Get packets to CPU COS queue mappings. */
extern int bcm_rx_cosq_mapping_get(
    int unit, 
    int index, 
    bcm_rx_reasons_t *reasons, 
    bcm_rx_reasons_t *reasons_mask, 
    uint8 *int_prio, 
    uint8 *int_prio_mask, 
    uint32 *packet_type, 
    uint32 *packet_type_mask, 
    bcm_cos_queue_t *cosq);

/* Unmap packets to a CPU COS queue. */
extern int bcm_rx_cosq_mapping_delete(
    int unit, 
    int index);

/* Get all supported reasons for CPU COS queue mapping. */
extern int bcm_rx_cosq_mapping_reasons_get(
    int unit, 
    bcm_rx_reasons_t *reasons);

/* Get all supported reasons for rx packets. */
extern int bcm_rx_reasons_get(
    int unit, 
    bcm_rx_reasons_t *reasons);

/* Assign a RX channel to a cosq. */
extern int bcm_rx_queue_channel_set(
    int unit, 
    bcm_cos_queue_t queue_id, 
    bcm_rx_chan_t chan_id);

/* Get the RX channel assigned to the given cosq. */
extern int bcm_rx_queue_channel_get(
    int unit, 
    bcm_cos_queue_t queue_id, 
    bcm_rx_chan_t *chan_id);

/* bcm_rx_channels_running */
extern int bcm_rx_channels_running(
    int unit, 
    uint32 *channels);

/* Allocate or deallocate a packet buffer as configured. */
extern int bcm_rx_alloc(
    int unit, 
    int pkt_size, 
    uint32 flags, 
    void **buf);

/* Allocate or deallocate a packet buffer as configured. */
extern int bcm_rx_free(
    int unit, 
    void *pkt_data);

/* Enqueue a data buffer to be freed later. */
extern int bcm_rx_free_enqueue(
    int unit, 
    void *pkt_data);

/* Set/get the overall packet rate for the given device. */
extern int bcm_rx_rate_set(
    int unit, 
    int pps);

/* Set/get the overall packet rate for the given device. */
extern int bcm_rx_rate_get(
    int unit, 
    int *pps);

/* 
 * Set/get the overall packet rate for the CPU that given device is
 * attached to.
 */
extern int bcm_rx_cpu_rate_set(
    int unit, 
    int pps);

/* 
 * Set/get the overall packet rate for the CPU that given device is
 * attached to.
 */
extern int bcm_rx_cpu_rate_get(
    int unit, 
    int *pps);

/* Set/get the burst size for the given device. */
extern int bcm_rx_burst_set(
    int unit, 
    int burst);

/* Set/get the burst size for the given device. */
extern int bcm_rx_burst_get(
    int unit, 
    int *burst);

/* Set/get the RX per-COS rate limiting value. */
extern int bcm_rx_cos_rate_set(
    int unit, 
    int cos, 
    int pps);

/* Set/get the RX per-COS rate limiting value. */
extern int bcm_rx_cos_rate_get(
    int unit, 
    int cos, 
    int *pps);

/* Set/get the per-COS burst setting. */
extern int bcm_rx_cos_burst_set(
    int unit, 
    int cos, 
    int burst);

/* Set/get the per-COS burst setting. */
extern int bcm_rx_cos_burst_get(
    int unit, 
    int cos, 
    int *burst);

/* Set/get the per-COS max queue length. */
extern int bcm_rx_cos_max_len_set(
    int unit, 
    int cos, 
    int max_q_len);

/* Set/get the per-COS max queue length. */
extern int bcm_rx_cos_max_len_get(
    int unit, 
    int cos, 
    int *max_q_len);

/* Clear all the RX configuration. */
extern int bcm_rx_clear(
    int unit);

/* Initialize a BCM RX configuration structure. */
extern void bcm_rx_cfg_t_init(
    bcm_rx_cfg_t *rx_cfg);

#if defined(BCM_RPC_SUPPORT)
#define BCM_RX_PKTLIST_COUNT_DEFAULT    64         
#endif

#if defined(BCM_RPC_SUPPORT)
/* bcm_rx_pktlist_count */
extern int bcm_rx_pktlist_count;
#endif

#if defined(BCM_RPC_SUPPORT)
/* bcm_rx_remote_pkt_alloc */
extern int bcm_rx_remote_pkt_alloc(
    int len, 
    bcm_pkt_t **pkt);
#endif

#if defined(BCM_RPC_SUPPORT)
/* bcm_rx_remote_pkt_free */
extern int bcm_rx_remote_pkt_free(
    bcm_pkt_t *pkt);
#endif

/* bcm_rx_remote_pkt_enqueue */
extern int bcm_rx_remote_pkt_enqueue(
    int unit, 
    bcm_pkt_t *pkt);

#if defined(BROADCOM_DEBUG)
/* bcm_rx_show */
extern int bcm_rx_show(
    int unit);
#endif

/* 
 * RX Pool
 * 
 * RX Pool is not really a true API, but an implementation of an
 * efficient buffer management scheme. RX uses the RX Pool allocation and
 * free routines as the default, and the application is free to change
 * them.
 */

/* Set up the RX pool software module. */
extern int bcm_rx_pool_setup(
    int pkt_count, 
    int bytes_per_pkt);

/* Boolean indication of whether the RX pool module is currently set up. */
extern int bcm_rx_pool_setup_done(
    void );

/* Deallocate RX pool structures. */
extern int bcm_rx_pool_cleanup(
    void );

/* Allocate a buffer from RX pool. */
extern int bcm_rx_pool_alloc(
    int unit, 
    int size, 
    uint32 flags, 
    void **pool);

/* Deallocate a buffer allocated with =bcm_rx_pool_alloc. */
extern int bcm_rx_pool_free(
    int unit, 
    void *buf);

#if defined(BCM_RXP_DEBUG)
/* Display information on RX pool buffer status. */
extern void bcm_rx_pool_dump(
    int min, 
    int max);
#endif

#if defined(BCM_RXP_DEBUG)
/* Verify the RX pool free buffer list. */
extern void bcm_rx_pool_free_verify(void);
#endif

#if defined(BCM_RXP_DEBUG)
/* Indicate ownership of an RX pool buffer. */
extern void bcm_rx_pool_own(
    void *buf, 
    void *owner);
#endif

#if defined(BCM_RXP_DEBUG)
/* Send RX pool debugging information to an output stream. */
extern void bcm_rx_pool_report(
    int min, 
    int max);
#endif

#endif /* __BCM_RX_H__ */
