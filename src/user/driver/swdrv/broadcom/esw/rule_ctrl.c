/* FUNCTION NAME: RULE_CTRL.H
 * PURPOSE:
 *   manage Logical Rule(om) and Physical Rule(Chip) mapping
 *
 * NOTES:
 *
 * REASON:
 *    DESCRIPTION:
 *    CREATOR:       pttch
 *    Date 2005/5/1
 *
 * Copyright(C)      Accton Corporation, 2005
 */

// FIXME: Add test case for counter on time-range aged out.

/* INCLUDE FILE DECLARATIONS
 */
#include <memory.h>
#include <bcm/field.h>

#include "sys_type.h"
#include "leaf_es3626a.h"
#include "sys_module.h"
#include "sys_bld.h"

#include "sys_cpnt.h"
#include "sys_dflt.h"
#include "sys_adpt.h"

#include "l_mm.h"
#include "l_inet.h"
#include "l_cvrt.h"
#include "l_pt.h"
#include "l_stdlib.h"

#include "sysfun.h"

#include "backdoor_mgr.h"

#include "rule_type.h"
#include "rule_ctrl.h"
#include "rule_om.h"
#include "cos_om.h"

#if (SYS_CPNT_TIME_BASED_ACL == TRUE)
#include "time_range_type.h"
#include "time_range_om.h"
#endif /* SYS_CPNT_TIME_BASED_ACL */

#include "fp_config.h"

#include "dev_swdrv_pmgr.h"
#include "esw/dev_rm.h"
#include "dev_rm_pmgr.h"
#include "stktplg_om.h"
#include "stktplg_pom.h" /* to avoid include swctrl.h */
#include "swctrl.h"
#include "swctrl_pom.h"

#include "isc.h"

/**************************************************

 NAMING CONSTANT DECLARATIONS

 **************************************************/

#define RULE_CTRL_MAX_NBR_OF_LINK_LOCAL_TO_CPU          30

#define RULE_CTRL_RT_GLOBAL_RULE                        1
#define RULE_CTRL_RT_SHARED_PORT_RULE                   2
#define RULE_CTRL_RT_PORT_RULE                          3

#define RULE_CTRL_PARAM_MAX_TAG                         4
#define RULE_CTRL_PARAM_MAX_TAG_NAME_STR_LEN            31

#define RULE_CTRL_PROT_IP           0                   /* Dummy for IP. */
#define RULE_CTRL_PROT_ICMP         1                   /* Internet Control Message Protocol. */
#define RULE_CTRL_PROT_IGMP         2                   /* Internet Group Management Protocol. */
#define RULE_CTRL_PROT_DVMRP        RULE_CTRL_PROT_IGMP /* DVMRP Protocol. */
#define RULE_CTRL_PROT_IPIP         4                   /* IPv4 inside IPv4. */
#define RULE_CTRL_PROT_IPV4         4
#define RULE_CTRL_PROT_TCP          6                   /* Transmisstion Control Protocol */
#define RULE_CTRL_PROT_UDP          17                  /* User Datagram Protocol */
#define RULE_CTRL_PROT_IPV6         41                  /* IPv6 inside IPv4 */
#define RULE_CTRL_PROT_RSVP         46                  /* Reservation Protocol */
#define RULE_CTRL_PROT_GRE          47                  /* Cisco GRE tunnels (RFC 1701, 1702) */
#define RULE_CTRL_PROT_ESP          50                  /* Encap. Security Payload. */
#define RULE_CTRL_PROT_AH           51                  /* Authentication header. */
#define RULE_CTRL_PROT_ICMPV6       58                  /* Internet Control Message Protocol version 6 */
#define RULE_CTRL_PROT_OSPFIGP      89                  /* Open Shortest Path First protocol */
#define RULE_CTRL_PROT_PIM          103                 /* Protocol Independent Multicast */
#define RULE_CTRL_PROT_VRRP         112                 /* Support VRRP pro */
#define RULE_CTRL_PROT_RAW          255                 /* Raw IP datagram. */
#define RULE_CTRL_PROT_MAX          256

/* IngressStpState */
#define STG_FORWORDING              4                   /* BCM_STG_STP_FORWARD */

#define DHCP_CLIENT_PORT            68
#define DHCP_SERVER_PORT            67
#define DHCP6_CLIENT_PORT           546
#define DHCP6_SERVER_PORT           547

/*delete MACRO :defined (ES4626H) || defined (ECN430_FB2),michael.wang 2008-6-25*/
#define RULE_CTRL_PORT_BITMAP_TO_CPU_ONLY       SYS_ADPT_RULE_CTRL_PORT_BITMAP_TO_CPU_ONLY
#define RULE_CTRL_PORT_BITMAP_TO_ALL_PORTS      SYS_ADPT_RULE_CTRL_PORT_BITMAP_TO_ALL_PORTS
#define RULE_CTRL_PORT_BITMAP_EXCLUDE_CPU       SYS_ADPT_RULE_CTRL_PORT_BITMAP_EXCLUDE_CPU

#define CHECK_MAC_IS_NULL(mac) ((mac[0]|mac[1]|mac[2]|mac[3]|mac[4]|mac[5])==0)

/* use bcmFieldActionCount to indicate the action_p is empty action */
#define RULE_CTRL_NO_ACTION                     bcmFieldActionCount

/* by BCM FPF2 definition, DSCP[23:16] has 8 bits */
#define RULE_CTRL_PRECEDENCE_OFFSET_IN_TOS_FIELD    5   /* IP Precedence start bit is 5 */
#define RULE_CTRL_PRECEDENCE_MASK                   7
#define RULE_CTRL_TOS_OFFSET_IN_TOS_FIELD           1   /* TOS start bit is 1 */
#define RULE_CTRL_TOS_MASK                          15
#define RULE_CTRL_DSCP_OFFSET_IN_TOS_FIELD          2   /* DSCP start bit is 2 */
#define RULE_CTRL_DSCP_MASK                         63

#define RULE_CTRL_IS_USER_RULE(func_type)               \
    (func_type == RULE_TYPE_INGRESS_IP_ACL              \
    || func_type == RULE_TYPE_INGRESS_MAC_ACL           \
    || func_type == RULE_TYPE_IP_DIFFSERV               \
    || func_type == RULE_TYPE_MAC_DIFFSERV              \
    || func_type == RULE_TYPE_INGRESS_IPV6_STD_ACL      \
    || func_type == RULE_TYPE_INGRESS_IPV6_EXT_ACL      \
    || func_type == RULE_TYPE_INGRESS_IPV6_STD_DIFFSERV \
    || func_type == RULE_TYPE_INGRESS_IPV6_EXT_DIFFSERV \
    )

#define RULE_CTRL_USER_TCAM_CAPABILITY_LIST(_)  \
    _(RULE_TYPE_TCAM_CAP_MAC_ACL)               \
    _(RULE_TYPE_TCAM_CAP_IPV4_ACL)              \
    _(RULE_TYPE_TCAM_CAP_IPV6_STD_ACL)          \
    _(RULE_TYPE_TCAM_CAP_IPV6_EXT_ACL)          \
    _(RULE_TYPE_TCAM_CAP_MAC_DS)                \
    _(RULE_TYPE_TCAM_CAP_IPV4_DS)               \
    _(RULE_TYPE_TCAM_CAP_IPV6_STD_DS)           \
    _(RULE_TYPE_TCAM_CAP_IPV6_EXT_DS)           \
    _(RULE_TYPE_TCAM_CAP_EGRESS_MAC_DS)         \
    _(RULE_TYPE_TCAM_CAP_EGRESS_IPV4_DS)        \
    _(RULE_TYPE_TCAM_CAP_EGRESS_IPV6_STD_DS)    \
    _(RULE_TYPE_TCAM_CAP_EGRESS_IPV6_EXT_DS)    \
    _(RULE_TYPE_TCAM_CAP_EGRESS_MAC_ACL)        \
    _(RULE_TYPE_TCAM_CAP_EGRESS_IPV4_ACL)       \
    _(RULE_TYPE_TCAM_CAP_EGRESS_IPV6_STD_ACL)   \
    _(RULE_TYPE_TCAM_CAP_EGRESS_IPV6_EXT_ACL)   \
    _(RULE_TYPE_TCAM_CAP_MAC_VLAN)              \
    _(RULE_TYPE_TCAM_CAP_PROTOCOL_VLAN)         \
    _(RULE_TYPE_TCAM_CAP_VOICE_VLAN)            \
    _(RULE_TYPE_TCAM_CAP_IP_SOURCE_GUSRD)       \
    _(RULE_TYPE_TCAM_CAP_IPV6_SOURCE_GUSRD)

#define RULE_CTRL_TIME_OUT                  1000 /* 10 sec */  /* time to wait for ISC reply */
#define RULE_CTRL_TRY_TIMES                 3
#define RULE_CTRL_ISC_MAX_NBR_OF_ACTION     10 /* in-action(2), out-action(2), meter-action(1) */

#define RULE_CTRL_NO_SHARE_METER_ENTRY_ID   0xFFFFFFFF /* an in-valid rule id to share meter */

/* option flag
 */
#define RULE_CTRL_OPT_INSTALL           0x00000001      /* 1: Install rule;
                                                         * 0: uninstall.
                                                         */
#define RULE_CTRL_OPT_FORCE_INSTALL     0x00000002      /* 1: Reinstall rule if it
                                                         * always bound
                                                         */
#define RULE_CTRL_OPT_ALL_DEVICES       0x00000004      /* 1: Install/uninstall/reinstall
                                                         * to all devices.
                                                         * unit/port will be ignored.
                                                         * sys_rule_storage_p will be
                                                         * used to save all rule ID.
                                                         */
#define RULE_CTRL_OPT_SINGLETON         0x00000008      /* 1: One logic rule corresponds
                                                         * one phy rule on device.
                                                         * rule_storage_p will be used
                                                         * to save device rule ID.
                                                         */
#define RULE_CTRL_OPT_ABORT             0x00000010      /* 1: Abort process
                                                         */
#define RULE_CTRL_OPT_RES_SUCCEEDED     0x00000020      /* 1: Set rule suceeded;
                                                         * 0: set rule failed
                                                         */
#define RULE_CTRL_OPT_QUERY             0x00000040      /* 1: query by explicit input
                                                         */
#define RULE_CTRL_OPT_QUERY_BY_RULE_ID  0x00000100      /* 1: query by rule ID
                                                         */

/**************************************************

 MACRO FUNCTION DECLARATIONS

 **************************************************/

#define RULE_CTRL_IS_BAD_POLICY_MAP_IDX(idx)                ((0 >= idx) || (idx > SYS_ADPT_DIFFSERV_MAX_NBR_OF_POLICY_MAP))
#define RULE_CTRL_IS_BAD_UPORT(port)                        ((0 >= port) || (port > SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT))

/* whether bno-th bit in bmp is 1 or 0 (bmp is an UI8_T array, bno is a zero-based bit index) */
#define RULE_CTRL_IS_BIT_ON(bmp, bno)                       RULE_TYPE_IS_BIT_ON(bmp, bno)
#define RULE_CTRL_IS_BIT_OFF(bmp, bno)                      RULE_TYPE_IS_BIT_OFF(bmp, bno)
#define RULE_CTRL_SET_BIT_ON(bmp, bno)                      RULE_TYPE_SET_BIT_ON(bmp, bno)
#define RULE_CTRL_SET_BIT_OFF(bmp, bno)                     RULE_TYPE_SET_BIT_OFF(bmp, bno)

#define RULE_CTRL_IS_ACL_TYPE()    (RULE_TYPE_MAC_ACL      == acl_type || RULE_TYPE_IP_ACL       == acl_type || \
                                    RULE_TYPE_IP_STD_ACL   == acl_type || RULE_TYPE_IP_EXT_ACL   == acl_type || \
                                    RULE_TYPE_IPV6_ACL     == acl_type || RULE_TYPE_IPV6_STD_ACL == acl_type || \
                                    RULE_TYPE_IPV6_EXT_ACL == acl_type)

#define RULE_CTRL_IS_CONTAINER_TYPE(type)                   \
    (                                                       \
        RULE_TYPE_INST_CONTAINER == type                    \
    )

#define RULE_CTRL_IS_CLASS_INSTANCE_TYPE(type)              \
    (                                                       \
        RULE_TYPE_INST_POLICY_MAP == type ||                \
        RULE_TYPE_INST_CLASS_MAP == type ||                 \
        RULE_TYPE_INST_ACL == type ||                       \
        RULE_TYPE_INST_MF_ACE == type ||                    \
        RULE_TYPE_INST_ACE == type ||                       \
        RULE_TYPE_INST_CPU_IF == type                       \
    )

#define RULE_CTRL_IS_RULE_INSTANCE_TYPE(type)               \
    (                                                       \
        RULE_TYPE_INST_RULE == type                         \
    )

#ifdef RULE_CTRL_INSTANCE_DEBUG_ON
    #define RULE_CTRL_IN_VALIDATE_PTR(in)                   \
        ( RULE_CTRL_IN_Priv_ValidatePtr((RULE_TYPE_INSTANCE_T *)in) )

    #define RULE_CTRL_IN_VALIDATE_RULE_INST(in)             \
        ( RULE_CTRL_IN_Priv_ValidateRuleInstance(in) )

    #define RULE_CTRL_IN_VALIDATE_CLASS_INST(in)            \
        ( RULE_CTRL_IN_Priv_ValidateClassInstance(in) )
#else
    #define RULE_CTRL_IN_VALIDATE_PTR(in_p)
    #define RULE_CTRL_IN_VALIDATE_RULE_INST(in)
    #define RULE_CTRL_IN_VALIDATE_CLASS_INST(in)
#endif /* RULE_CTRL_INSTANCE_DEBUG_ON */

#define RULE_CTRL_SET_FILTER_IPBM(ace_entry, ipbm) \
    { \
        DEVRM_PBMP_ASSIGN(ace_entry.inports_data, ipbm); \
        DEVRM_PBMP_ASSIGN(ace_entry.inports_mask, shmem_data_p->dev_info[0].port_bit_map.all_ports); \
    }

    #define RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry) \
    { \
        DEVRM_PBMP_ASSIGN(ace_entry.inports_data, shmem_data_p->dev_info[0].port_bit_map.all_ports); \
        DEVRM_PBMP_ASSIGN(ace_entry.inports_mask, shmem_data_p->dev_info[0].port_bit_map.all_ports); \
    }

#define RULE_CTRL_SET_FILTER_SRCPORTTGID(ace_entry, phy_port) \
    { \
        ace_entry.srcporttgid_data = phy_port; \
        memset(&ace_entry.srcporttgid_mask, 0xff, sizeof(ace_entry.srcporttgid_mask)); \
    }

#define RULE_CTRL_SET_FILTER_DSTPORTTGID(ace_entry, phy_port) \
    { \
        ace_entry.dstporttgid_data = phy_port; \
        memset(&ace_entry.dstporttgid_mask, 0xff, sizeof(ace_entry.dstporttgid_mask)); \
    }

#define RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, eth) \
    { \
        ace_entry.ethertype_data = (UI16_T)eth; \
        memset(&ace_entry.ethertype_mask, 0xff, sizeof(ace_entry.ethertype_mask)); \
    }

#define RULE_CTRL_SET_FILTER_DA(ace_entry, da)                              \
    {                                                                       \
        memcpy(ace_entry.dstmac_data, da, SYS_ADPT_MAC_ADDR_LEN);           \
        memset(ace_entry.dstmac_mask, 0xff, SYS_ADPT_MAC_ADDR_LEN);         \
    }

#define RULE_CTRL_SET_FILTER_DA_MASK(ace_entry, da, mask)                   \
    {                                                                       \
        memcpy(ace_entry.dstmac_data, da, SYS_ADPT_MAC_ADDR_LEN);           \
        memcpy(ace_entry.dstmac_mask, mask, SYS_ADPT_MAC_ADDR_LEN);         \
    }

#define RULE_CTRL_SET_FILTER_SA(ace_entry, sa)                              \
    {                                                                       \
        memcpy(ace_entry.srcmac_data, sa, SYS_ADPT_MAC_ADDR_LEN);           \
        memset(ace_entry.srcmac_mask, 0xff, SYS_ADPT_MAC_ADDR_LEN);         \
    }

#define RULE_CTRL_SET_FILTER_SIP(ace_entry, sip) \
    { \
        ace_entry.srcip_data = sip; \
        memset(&ace_entry.srcip_mask, 0xff, sizeof(ace_entry.srcip_mask)); \
    }

#define RULE_CTRL_SET_FILTER_OUTERVLAN(ace_entry, vlanid) \
    { \
        ace_entry.outvlan_data = (UI16_T)vlanid; \
        ace_entry.outvlan_mask = (UI16_T)0xfff; \
    }

#define RULE_CTRL_SET_FILTER_DIP(ace_entry, dip)                            \
    {                                                                       \
        ace_entry.dstip_data = dip;                                         \
        memset(&ace_entry.dstip_mask, 0xff, sizeof(ace_entry.dstip_mask));  \
    }

#define RULE_CTRL_SET_FILTER_DIP_MASK(ace_entry, dip, mask) \
    { \
        ace_entry.dstip_data = dip; \
        ace_entry.dstip_mask = mask; \
    }

#define RULE_CTRL_SET_FILTER_SPORT(ace_entry, sport) \
    { \
        ace_entry.l4_srcport_data = sport; \
        memset(&ace_entry.l4_srcport_mask, 0xff, sizeof(ace_entry.l4_srcport_mask)); \
    }

#define RULE_CTRL_SET_FILTER_DPORT(ace_entry, dport)                        \
    {                                                                       \
        ace_entry.l4_dstport_data = dport;                                  \
        memset(&ace_entry.l4_dstport_mask, 0xff, sizeof(ace_entry.l4_dstport_data)); \
    }

/* Make a patch for SDK 5.7.0. In this version bcmFieldQualifyIpProtocol is the
 * same as bcmFieldQualifyIp6NextHeader.
 */
#define RULE_CTRL_SET_FILTER_IPPROTOCOL(ace_entry, ip_protocol)         \
    {                                                                   \
        ace_entry.ipprotocol_data = ip_protocol;                        \
        memset(&ace_entry.ipprotocol_mask, 0xff, sizeof(ace_entry.ipprotocol_mask));\
        if (DEVRM_FIELD_QUALIFY_IpProtocol == DEVRM_FIELD_QUALIFY_Ip6NextHeader) \
        {                                                               \
            ace_entry.ip6nextheader_data = ip_protocol;                 \
            memset(&ace_entry.ip6nextheader_mask, 0xff, sizeof(ace_entry.ip6nextheader_mask)); \
        }                                                               \
    }

#define RULE_CTRL_SET_FILTER_SIPV6(ace_entry, sipv6) \
    { \
        memcpy(ace_entry.srcip6_data, sipv6, sizeof(ace_entry.srcip6_data)); \
        memset(ace_entry.srcip6_mask, 0xff,  sizeof(ace_entry.srcip6_mask)); \
    }

/* Make a patch for SDK 5.7.0. In this version bcmFieldQualifyIpProtocol is the
 * same as bcmFieldQualifyIp6NextHeader.
 */
#define RULE_CTRL_SET_FILTER_IP6_NEXTHEADER(ace_entry, ip6_nextheader)  \
    {                                                                   \
        ace_entry.ip6nextheader_data = ip6_nextheader;                  \
        memset(&ace_entry.ip6nextheader_mask, 0xff, sizeof(ace_entry.ip6nextheader_mask)); \
        if (DEVRM_FIELD_QUALIFY_IpProtocol == DEVRM_FIELD_QUALIFY_Ip6NextHeader)\
        {                                                               \
            ace_entry.ipprotocol_data = ip6_nextheader;                 \
            memset(&ace_entry.ipprotocol_mask, 0xff, sizeof(ace_entry.ipprotocol_mask)); \
        }                                                               \
    }

/* Make a patch for SDK 5.7.0. In this version bcmFieldQualifyTtl is the
 * same as bcmFieldQualifyIp6HopLimit.
 */
#define RULE_CTRL_SET_FILTER_TTL(ace_entry, ttl)                        \
    {                                                                   \
        ace_entry.ttl_data = ttl;                                       \
        memset(&ace_entry.ttl_mask, 0xff, sizeof(ace_entry.ttl_mask));  \
        if (DEVRM_FIELD_QUALIFY_Ttl == DEVRM_FIELD_QUALIFY_Ip6HopLimit) \
        {                                                               \
            ace_entry.ip6hoplimit_data = ttl;                           \
            memset(&ace_entry.ip6hoplimit_mask, 0xff, sizeof(ace_entry.ip6hoplimit_mask)); \
        }                                                               \
    }

/* Make a patch for SDK 5.7.0. In this version bcmFieldQualifyTtl is the
 * same as bcmFieldQualifyIp6HopLimit.
 */
#define RULE_CTRL_SET_FILTER_IP6_HOPLIMIT(ace_entry, hoplimit)          \
    {                                                                   \
        ace_entry.ip6hoplimit_data = hoplimit;                          \
        memset(&ace_entry.ip6hoplimit_mask, 0xff, sizeof(ace_entry.ip6hoplimit_mask)); \
        if (DEVRM_FIELD_QUALIFY_Ttl == DEVRM_FIELD_QUALIFY_Ip6HopLimit) \
        {                                                               \
            ace_entry.ttl_data = hoplimit;                              \
            memset(&ace_entry.ttl_mask, 0xff, sizeof(ace_entry.ttl_mask));  \
        }                                                               \
    }

#define RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, value, mask) \
    { \
        ace_entry.higpacket_data = value; \
        ace_entry.higpacket_mask = mask;    \
    }

/* because BCM driver code has a bug, can't use 0xff to stand for exactly match */
#define RULE_CTRL_SET_FILTER_MHOPCODE(ace_entry, mh_opcode) \
    { \
        ace_entry.mhopcode_data = mh_opcode; \
        ace_entry.mhopcode_mask = 0x7; \
    }

#define RULE_CTRL_SET_FILTER_IPTYPE(ace_entry, iptype_value) \
    { \
        ace_entry.iptype = iptype_value; \
    }

#define RULE_CTRL_SET_FILTER_L2FORMAT(ace_entry, l2format_value) \
    { \
        ace_entry.l2format = l2format_value; \
    }

#define RULE_CTRL_SET_FILTER_VLANFORMAT(ace_entry, data, mask) \
    { \
        ace_entry.vlanformat_data = data; \
        ace_entry.vlanformat_mask = mask; \
    }

#define RULE_CTRL_SET_FILTER_L4_SRCPORT(ace_entry, l4srcport) \
    { \
        ace_entry.l4_srcport_data = l4srcport; \
        ace_entry.l4_srcport_mask = -1; \
    }

#define RULE_CTRL_SET_FILTER_ING_STP_STATE(ace_entry, stpstate_value) \
    { \
        ace_entry.stpstate = stpstate_value; \
    }

#define RULE_CTRL_SET_FILTER_L2_SRC_HIT(ace_entry, data, mask) \
    { \
        ace_entry.l2srchit_data = data; \
        ace_entry.l2srchit_mask = mask; \
    }

#define RULE_CTRL_SET_FILTER_L2_DST_HIT(ace_entry, data, mask) \
    { \
        ace_entry.l2dsthit_data = data; \
        ace_entry.l2dsthit_mask = mask; \
    }

#define RULE_CTRL_SET_FILTER_L3_ROUTABLE(ace_entry, data, mask) \
    { \
        ace_entry.l3routable_data = data; \
        ace_entry.l3routable_mask = mask; \
    }

#define RULE_CTRL_SET_FILTER_L3_DSTHOST_HIT(ace_entry, data, mask) \
    { \
        ace_entry.l3dsthosthit_data = data; \
        ace_entry.l3dsthosthit_mask = mask; \
    }

/* ICMP6 type use the same position with TCP source port
 */
#define RULE_CTRL_ADD_FILTER_ICMP6_TYPE(ace_entry, data, mask) \
    { \
        DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_L4SrcPort); \
        ace_entry.l4_srcport_data = ((UI8_T)data << 8) & 0xff00; \
        ace_entry.l4_srcport_mask = ((UI8_T)mask << 8) & 0xff00; \
    }

#define RULE_CTRL_ADD_FILTER_IPTYPE(dev_ace, iptype_value) \
    { \
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_IpType);\
        dev_ace->iptype = iptype_value; \
    }

#define RULE_CTRL_ADD_FILTER_L2FORMAT(dev_ace, l2format_value) \
    { \
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_L2Format);\
        dev_ace->l2format = l2format_value; \
    }

#define RULE_CTRL_ADD_FILTER_VLANFORMAT(dev_ace, data, mask) \
    { \
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_VlanFormat);\
        dev_ace->vlanformat_data = data; \
        dev_ace->vlanformat_mask = mask; \
    }

/* Make a patch for SDK 5.7.0. In this version bcmFieldQualifyDSCP is the
 * same as bcmFieldQualifyIp6TrafficClass.
 */
#define RULE_CTRL_ADD_FILTER_DSCP(dev_ace, data, mask, offset)  \
    {                                                           \
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_DSCP); \
        dev_ace->dscp_data |= data << offset;                   \
        dev_ace->dscp_mask |= mask << offset;                   \
        if (DEVRM_FIELD_QUALIFY_DSCP == DEVRM_FIELD_QUALIFY_Ip6TrafficClass)\
        {                                                       \
            dev_ace->ip6trafficclass_data |= data << offset;    \
            dev_ace->ip6trafficclass_mask |= mask << offset;    \
        }                                                       \
    }

/* Make a patch for SDK 5.7.0. In this version bcmFieldQualifyDSCP is the
 * same as bcmFieldQualifyIp6TrafficClass.
 */
#define RULE_CTRL_ADD_FILTER_TC(dev_ace, data, mask, offset)    \
    {                                                           \
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_Ip6TrafficClass);  \
        dev_ace->ip6trafficclass_data = data << offset;         \
        dev_ace->ip6trafficclass_mask = mask << offset;         \
        if (DEVRM_FIELD_QUALIFY_DSCP == DEVRM_FIELD_QUALIFY_Ip6TrafficClass)\
        {                                                       \
            dev_ace->dscp_data |= data << offset;               \
            dev_ace->dscp_mask |= mask << offset;               \
        }                                                       \
    }

#define RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry) \
    { \
        memset(&action_entry, 0, sizeof(DEVRM_ActionEntry_T)); \
        action_entry.action = bcmFieldActionCopyToCpu; \
    }

#define RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(action_entry)          \
    {                                                               \
        memset(&action_entry, 0, sizeof(DEVRM_ActionEntry_T));      \
        action_entry.action = bcmFieldActionRedirectPbmp;           \
        action_entry.param0 = shmem_data_p->dev_info[0].port_bit_map.cpu_port.pbits[0]; \
        action_entry.param1 = shmem_data_p->dev_info[0].port_bit_map.cpu_port.pbits[1]; \
        DEVRM_PBMP_ASSIGN(action_entry.pbmp, shmem_data_p->dev_info[0].port_bit_map.cpu_port); \
    }

/* Add two action. One is CopyToCPU, other one is Drop.
 */
#define RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU2(action_entry1, action_entry2) \
    {                                                                       \
        memset(&action_entry1, 0, sizeof(DEVRM_ActionEntry_T));             \
        memset(&action_entry2, 0, sizeof(DEVRM_ActionEntry_T));             \
        RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry1);                    \
        action_entry1.next_action = &action_entry2;                         \
        RULE_CTRL_SET_ACTION_DROP(action_entry2);                           \
        action_entry2.next_action = NULL;                                   \
    }

#define RULE_CTRL_SET_ACTION_REDIRECT_TO_PORT_BITMAP(action_entry, dst_pbmp)\
    {                                                                       \
        memset(&action_entry, 0, sizeof(DEVRM_ActionEntry_T));              \
        action_entry.action = bcmFieldActionRedirectPbmp;                   \
        action_entry.param0 = dst_pbmp.pbits[0];                            \
        action_entry.param1 = dst_pbmp.pbits[1];                            \
        action_entry.pbmp.pbits[0] = dst_pbmp.pbits[0];                     \
        action_entry.pbmp.pbits[1] = dst_pbmp.pbits[1];                     \
    }

#define RULE_CTRL_SET_ACTION_COPY_TO_CPU_CANCEL(action_entry) \
    { \
        memset(&action_entry, 0, sizeof(DEVRM_ActionEntry_T)); \
        action_entry.action = bcmFieldActionCopyToCpuCancel; \
    }


#define RULE_CTRL_SET_ACTION_SWITCH_TO_CPU_CANCEL(action_entry) \
    { \
        memset(&action_entry, 0, sizeof(DEVRM_ActionEntry_T)); \
        action_entry.action = bcmFieldActionSwitchToCpuCancel; \
    }

#define RULE_CTRL_SET_ACTION_EGRESS_MASK(action_entry, port_bmp) \
    { \
        memset(&action_entry, 0, sizeof(DEVRM_ActionEntry_T)); \
        action_entry.action = bcmFieldActionEgressMask; \
        action_entry.param0 = port_bmp; \
        action_entry.pbmp.pbits[0] = port_bmp;\
    }

/* remapping: change COS queue only
 */
#define RULE_CTRL_SET_ACTION_REMARK_INNER_PRIORITY(action_entry, pri) \
    { \
        memset(&action_entry, 0, sizeof(DEVRM_ActionEntry_T)); \
        action_entry.action = bcmFieldActionPrioIntNew; \
        action_entry.param0 = pri; \
    }

/* remarking: change priority in packet only
 */
#define RULE_CTRL_SET_ACTION_REMARK_PACKET_PRIORITY(action_entry, pri) \
    { \
        memset(&action_entry, 0, sizeof(DEVRM_ActionEntry_T)); \
        action_entry.action = bcmFieldActionPrioPktNew; \
        action_entry.param0 = pri; \
    }

/* remapping + remarking: change priority in packet and COS queue
 */
#define RULE_CTRL_SET_ACTION_REMARK_PACKET_AND_INNER_PRIORITY(action_entry, pri) \
    { \
        memset(&action_entry, 0, sizeof(DEVRM_ActionEntry_T)); \
        action_entry.action = bcmFieldActionPrioPktAndIntNew; \
        action_entry.param0 = pri; \
    }

#define RULE_CTRL_SET_ACTION_REMARK_DROP_PRECEDENCE(action_entry, color) \
    { \
        memset(&action_entry, 0, sizeof(DEVRM_ActionEntry_T)); \
        action_entry.action = bcmFieldActionDropPrecedence; \
        action_entry.param0 = color; \
    }

#define RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry, qid) \
    { \
        memset(&action_entry, 0, sizeof(DEVRM_ActionEntry_T)); \
        action_entry.action = bcmFieldActionCosQCpuNew; \
        action_entry.param0 = qid; \
    }

#define RULE_CTRL_SET_ACTION_CHANGE_DSCP(action_entry, dscp) \
    { \
        memset(&action_entry, 0, sizeof(DEVRM_ActionEntry_T)); \
        action_entry.action = bcmFieldActionDscpNew; \
        action_entry.param0 = dscp; \
    }

#define RULE_CTRL_SET_ACTION_RED_DROP(action_entry) \
    { \
        memset(&action_entry, 0, sizeof(DEVRM_ActionEntry_T)); \
        action_entry.action = bcmFieldActionRpDrop; \
    }

#define RULE_CTRL_SET_ACTION_METER_CONFIG(action_entry) \
    { \
        memset(&action_entry, 0, sizeof(DEVRM_ActionEntry_T)); \
        action_entry.action = bcmFieldActionMeterConfig; \
        action_entry.param0 = BCM_FIELD_METER_MODE_FLOW; \
    }

#define RULE_CTRL_SET_ACTION_LOOPBACK(action_entry) \
    { \
        memset(&action_entry, 0, sizeof(DEVRM_ActionEntry_T)); \
        action_entry.action = bcmFieldActionRedirectPbmp; \
    }

/* need to user bcm sdk 550
 */
#if 0
#define RULE_CTRL_SET_ACTION_LOOPBACK(action_entry) \
    { \
        memset(&action_entry, 0, sizeof(DEVRM_ActionEntry_T)); \
        action_entry.action = bcmFieldActionLoopback; \
    }
#endif

#define RULE_CTRL_SET_ACTION_DROP(action_entry) \
    { \
        memset(&action_entry, 0, sizeof(DEVRM_ActionEntry_T)); \
        action_entry.action = bcmFieldActionDrop; \
    }

#define RULE_CTRL_SET_ACTION_DROP_CANCEL(action_entry) \
    { \
        memset(&action_entry, 0, sizeof(DEVRM_ActionEntry_T)); \
        action_entry.action = bcmFieldActionDropCancel; \
    }

#define RULE_CTRL_SET_ACTION_TIME_STAMP_TO_CPU(action_entry)    \
    {                                                           \
        memset(&action_entry, 0, sizeof(DEVRM_ActionEntry_T));  \
        action_entry.action = bcmFieldActionTimeStampToCpu;     \
    }

/* because 0 is meaningful, can not just use memset() to initialize action_p here */
#define RULE_CTRL_INITIALIZE_ACTION_ENTRY(action_p)                         \
    {                                                                       \
        memset(action_p, 0, sizeof(DEVRM_ActionEntry_T));                   \
        (action_p)->action = RULE_CTRL_NO_ACTION;                           \
    }

/* this macro function will check the contain of action_p.
 * if action_p is no action, re-assign action_p to NULL (to tell dev_rm no action)
 */
#define RULE_CTRL_CHECK_THEN_SET_NO_ACTION(action_p)                        \
    {                                                                       \
        if (NULL != action_p)                                               \
        {                                                                   \
            if (RULE_CTRL_NO_ACTION == action_p->action)                    \
                action_p = NULL;                                            \
        }                                                                   \
    }

#define RULE_CTRL_IS_DEBUG_ERROR_ON(flag)       (flag & RULE_OM_DEBUG_CTRL_ERR)

#if (1400 <= _MSC_VER /* VC2005 */)
    #define RULE_CTRL_PRINT(fmt, ...)                                       \
    {                                                                       \
        printf("[%s:%d] ", __FUNCTION__, __LINE__);                         \
        printf(fmt, __VA_ARGS__);                                           \
        printf("\r\n");                                                     \
    }
#else
    #define RULE_CTRL_PRINT(fmt, args...)                                   \
        {                                                                   \
            BACKDOOR_MGR_Printf("[%s:%d] ", __FUNCTION__, __LINE__);        \
            BACKDOOR_MGR_Printf(fmt, ##args);                               \
            BACKDOOR_MGR_Printf("\r\n");                                    \
        }
#endif /* RULE_CTRL_PRINT */

#if (1400 <= _MSC_VER /* VC2005 */)
    #define RULE_CTRL_LOG                       RULE_CTRL_PRINT
#else
    #define RULE_CTRL_LOG(fmt, args...)                                     \
        {                                                                   \
            if (RULE_CTRL_IS_DEBUG_ERROR_ON(RULE_OM_GetDebugFlag()))        \
            {                                                               \
                RULE_CTRL_PRINT(fmt, ##args)                                \
            }                                                               \
        }
#endif /* RULE_CTRL_LOG */

#define PRINTF(fmt, ...)                                                    \
    {                                                                       \
        BACKDOOR_MGR_Printf(fmt, ##__VA_ARGS__);                            \
    }

#define LOG(fmt, ...)                                                       \
    {                                                                       \
        UI32_T flag = RULE_OM_GetDebugFlag();                               \
        RULE_TYPE_LOG(flag & RULE_OM_DEBUG_CTRL_ERR, fmt, ##__VA_ARGS__);   \
    }

#define LOG_IF(interface, fmt, ...)                                         \
    {                                                                       \
        switch ((interface).type)                                           \
        {                                                                   \
            case RULE_TYPE_INTERFACE_UPORT:                                 \
                LOG("direction = %s, iftype = %s, uport = %lu/%lu, "        \
                    fmt,                                                    \
                    RULE_TYPE_DIRECTION_STR((interface).direction),         \
                    RULE_TYPE_INTERFACE_TYPE_STR((interface).type),         \
                    (interface).uport.unit, (interface).uport.port,         \
                    ##__VA_ARGS__);                                         \
                break;                                                      \
            case RULE_TYPE_INTERFACE_TRUNK:                                 \
                LOG("direction = %s, iftype = %s, trunkId = %lu, "          \
                    fmt,                                                    \
                    RULE_TYPE_DIRECTION_STR((interface).direction),         \
                    RULE_TYPE_INTERFACE_TYPE_STR((interface).type),         \
                    (interface).trunk_id,                                   \
                    ##__VA_ARGS__);                                         \
                break;                                                      \
            case RULE_TYPE_INTERFACE_UNIT:                                  \
                LOG("direction = %s, iftype = %s, unit = %lu/%lu, "         \
                    fmt,                                                    \
                    RULE_TYPE_DIRECTION_STR((interface).direction),         \
                    RULE_TYPE_INTERFACE_TYPE_STR((interface).type),         \
                    (interface).unit,                                       \
                    ##__VA_ARGS__);                                         \
                break;                                                      \
            default:                                                        \
                LOG("direction = %s, iftype = %s, " fmt,                    \
                    RULE_TYPE_DIRECTION_STR((interface).direction),         \
                    RULE_TYPE_INTERFACE_TYPE_STR((interface).type),         \
                    ##__VA_ARGS__);                                         \
                break;                                                      \
        }                                                                   \
    }

#ifndef _countof
#define _countof(_Array) (sizeof(_Array)/sizeof(_Array[0]))
#endif

#ifndef ASSERT
#define ASSERT(eq)
#endif

/**************************************************

 DATA TYPE DECLARATIONS

 **************************************************/

typedef enum
{
    RULE_CTRL_REQUEST_RESOURCE_ALLOCATE,
    RULE_CTRL_REQUEST_RESOURCE_ALLOCATE_TEST,
    RULE_CTRL_REQUEST_RESOURCE_FREE
} RULE_CTRL_RequestResourceType_T;

enum
{
    RULE_CTRL_UNIT_1_INDEX = 0,

    RULE_CTRL_UPORT_1_INDEX = RULE_CTRL_UNIT_1_INDEX + 1,
    RULE_CTRL_TOTAL_NBR_OF_UPORT = (SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK *
                                    SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT),

    RULE_CTRL_TRUNK_PORT_1_INDEX = (RULE_CTRL_UPORT_1_INDEX +
                                    RULE_CTRL_TOTAL_NBR_OF_UPORT),
    RULE_CTRL_TOTAL_NBR_OF_TRUNK_PORT = SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM,

    RULE_CTRL_CRAFT_PORT_1_INDEX = (RULE_CTRL_TRUNK_PORT_1_INDEX +
                                    RULE_CTRL_TOTAL_NBR_OF_TRUNK_PORT),
    RULE_CTRL_TOTAL_NBR_OF_CRAFT_PORT = 1,

    RULE_CTRL_CPU_PORT_1_INDEX = (RULE_CTRL_CRAFT_PORT_1_INDEX +
                                  RULE_CTRL_TOTAL_NBR_OF_CRAFT_PORT),
    RULE_CTRL_TOTAL_NBR_OF_CPU_PORT = 1,

    /** Each direction have
     *   global(1) + uport + trunk port + cpu port(1) + craft port(1)
     *
     * If #ifEntryPerDirection == 10 Then
     *   index of global = 0, 10
     *   first index of uport = 1, 11
     */
    RULE_CTRL_TOTAL_NBR_OF_IF_ENTRY_PER_DIRECTION = (1 +
                                                     RULE_CTRL_TOTAL_NBR_OF_UPORT +
                                                     RULE_CTRL_TOTAL_NBR_OF_TRUNK_PORT +
                                                     RULE_CTRL_TOTAL_NBR_OF_CPU_PORT +
                                                     RULE_CTRL_TOTAL_NBR_OF_CRAFT_PORT),
};

typedef struct
{
    RULE_TYPE_SHM_POINTER_T     class_inst_ptr;
} RULE_CTRL_IF_ENTRY_T, *RULE_CTRL_IF_ENTRY_PTR_T;

typedef struct
{
    DEVRM_AceEntry_T            rule_pattern;
    DEVRM_ACTION_T              action;
} RULE_CTRL_RULE_ENTRY_T, *RULE_CTRL_RULE_ENTRY_PTR_T;

typedef struct
{
    BOOL_T  is_enable;                      /* occupty flag, set 1 if all succeeded */
    UI32_T  rule_id;
} RULE_CTRL_RULE_STORAGE, *RULE_CTRL_RULE_STORAGE_PTR;

typedef struct
{
    BOOL_T  is_enable;                      /* occupty flag, set 1 if all succeeded */
    UI32_T  rule_id[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                   [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
} RULE_CTRL_SYS_RULE_STORAGE, *RULE_CTRL_SYS_RULE_STORAGE_PTR;

typedef struct
{
    UI32_T unit;
    UI32_T device_id;
} RULE_CTRL_UNIT_DEVICE_T, *RULE_CTRL_UNIT_DEVICE_PTR_T;

typedef struct
{
    union
    {
        struct
        {
            RULE_TYPE_INSTANCE_TYPE_T   type;
            UI32_T                      id;
        };

        void *ptr;
    };
} RULE_CTRL_INSTANCE_TYPE_ID_T, *RULE_CTRL_INSTANCE_TYPE_ID_PTR_T;

typedef struct
{
    UI32_T                      indent;
} RULE_CTRL_DUMP_CLASS_INSTANCE_PARAM_T, *RULE_CTRL_DUMP_CLASS_INSTANCE_PARAM_PTR_T;

typedef BOOL_T (*RULE_CTRL_CALLBACK_PTR)(void *param_p);
typedef void*  (*RULE_CTRL_SPR_GET_OM_HANDLER)(void *param_p);
typedef BOOL_T (*RULE_CTRL_SPR_SET_RULE_HANDLER)(void *param_p, DEVRM_PBMP_T new_pbmp);

typedef struct
{
    RULE_TYPE_FunctionType_T        func_type;
    UI32_T                          unit;
    UI32_T                          port;
    UI32_T                          flags;
    RULE_CTRL_CALLBACK_PTR          callback;   /* callback after set rule succeeded of failed */

    /* Shared Port Rule
     * SPR means single rule can be bound to multi ports.
     * Record which port was bound by a port bitmap.
     */
    struct
    {
        UI32_T                          om_offset;
        RULE_CTRL_SPR_GET_OM_HANDLER    get_om_handler;
        RULE_CTRL_SPR_SET_RULE_HANDLER  cfg_rule_handler;
    } SPR;

    RULE_CTRL_RULE_STORAGE_PTR      rule_storage_p;     /* !(flags | RULE_CTRL_OPT_ALL_DEVICES) */
    RULE_CTRL_SYS_RULE_STORAGE_PTR  sys_rule_storage_p; /* flags | RULE_CTRL_OPT_ALL_DEVICES */

    struct
    {
        char                        tag[RULE_CTRL_PARAM_MAX_TAG][RULE_CTRL_PARAM_MAX_TAG_NAME_STR_LEN + 1];
    } name;

    DEVRM_AceEntry_T                ace_entry;
    BOOL_T                          meter_enabled;
    DEVRM_MeterEntry_T              meter_entry;
    DEVRM_ActionEntry_T             action_entries[RULE_CTRL_ISC_MAX_NBR_OF_ACTION];
    RULE_TYPE_COUNTER_ENABLE_T      counter_enabled;

    struct
    {
        UI32_T unit;
        UI32_T port;
        UI32_T device_id;
        UI32_T group_id;
        UI32_T rule_id;
    } query;                                            /* flags|RULE_CTRL_OPT_QUERY_BY_RULE_ID */

    /* by-pass data
     */
    union
    {
        /* L4 Port to CoS
         */
        struct
        {
            UI16_T                  dst_port;
            UI8_T                   cos;
        } L4_PORT_COS_MAP;

        /* L4 Port to Internal Priority
         */
        struct
        {
            BOOL_T                  is_tcp;
            UI16_T                  dst_port;
            UI8_T                   phb;
            UI8_T                   color;
        } l4_port_to_int_pri;

        /* IPv6 Link Local Address
         */
        struct
        {
            UI32_T                  vlan_id;
            UI8_T                   addr[SYS_ADPT_IPV6_ADDR_LEN];
        } LINK_LOCAL_ADDRESS;

        /* Dot1x UC
         */
        struct
        {
            UI8_T                   cpu_mac[SYS_ADPT_MAC_ADDR_LEN];
        } DOT1X_UC;

        /* IP Source Guard
         */
        struct
        {
            UI32_T                  len;
            UI32_T                  vlan_id;

            union
            {
                union
                {
                    UI32_T          un_w;
                    UI8_T           un_b[SYS_TYPE_IPV4_ADDR_LEN];
                } src_ipv4_addr;

                union
                {
                    UI32_T          un_w[4];
                    UI8_T           un_b[SYS_TYPE_IPV6_ADDR_LEN];
                } src_ipv6_addr;
            };

            UI8_T                   src_mac_addr[SYS_ADPT_MAC_ADDR_LEN];
        } IPSG;

        /* Web Authentication
         */
        struct
        {
            union
            {
                UI32_T              un_w;
                UI8_T               un_b[4];
            } src_ipv4_addr;
        } WA;

#if (SYS_CPNT_QINQ_L2PT_CUSTOM_PDU == TRUE)
        /* L2PT custom PDU
         */
        struct
        {
            UI16_T                  ethertype;
            UI8_T                   dstmac[SYS_ADPT_MAC_ADDR_LEN];
        } L2PT_CUSTOM_PDU;
#endif

        /* CPU rule control
         */
        struct
        {
            BOOL_T to_cpu;
            BOOL_T flood;
        } CPU_CTRL;

        /* igmp control rule
        */
        struct
        {
            BOOL_T to_cpu;
        } igmp;

        struct
        {
            UI32_T rate; /* packet/second */
        } arp;
    };

} RULE_CTRL_PARAM, *RULE_CTRL_PARAM_PTR;

typedef BOOL_T (*RULE_CTRL_HANDLER)(RULE_CTRL_PARAM_PTR param_p);

typedef struct
{
    struct RULE_CTRL_FunctionCode
    {
        unsigned int  valid      : 1;
        unsigned int  type       : 7;
        unsigned int  padding    : 24;
    } code;

    UI32_T      rule_id;

    union
    {
        struct
        {
            RULE_CTRL_HANDLER               do_handler;

            UI16_T                          unit;
            UI16_T                          device;
        } GR;

        struct
        {
            RULE_CTRL_SPR_GET_OM_HANDLER    get_om_handler;
            RULE_CTRL_SPR_SET_RULE_HANDLER  set_rule_handler;

            UI16_T                          unit;
            UI16_T                          port;
        } SPR;

        struct
        {
            RULE_CTRL_HANDLER               do_handler;

            UI16_T                          unit;
            UI16_T                          port;
        } PR;
    };

} RULE_CTRL_RuleLookupEntry_T;

typedef struct RULE_CTRL_CpuInterfaceStatus_S
{
    UI32_T  dot1x               :1;
    UI32_T  cdp                 :1;
    UI32_T  nbx_sa              :1;
    UI32_T  nbx_eth             :1;
    UI32_T  nbx_da              :1;

    UI32_T  arp_reply           :1;
    UI32_T  arp_request         :1;
    UI32_T  rip_v1              :1;
    UI32_T  igmp                :1;
    UI32_T  dhcp_client_bc      :1;

    UI32_T  dhcp_server_bc      :1;
    UI32_T  rip                 :1;
    UI32_T  ospf_v2_mc5         :1;
    UI32_T  ospf_v2_mc6         :1;
    UI32_T  dvmrp               :1;

    UI32_T  pim                 :1;
    UI32_T  vrrp                :1;
    UI32_T  ripng               :1;
    UI32_T  ipmc_data           :1;
    UI32_T  ipv6_mc             :1;

    UI32_T  org_specific        :1;
    UI32_T  ipv6_data           :1;

    UI32_T  dhcp_client_bc_type :3; /* delete/permit/redirect/copy/drop */
    UI32_T  dhcp_server_bc_type :3; /* delete/permit/redirect/copy/drop */

    UI32_T  reserved_bits       :4;

} RULE_CTRL_CpuInterfaceStatus_T;

typedef struct RULE_CTRL_PortConfigStatus_S
{
    BOOL_T  rate_limit_install_flag;    /* TRUE implies instaled */
    UI32_T  dev_rule_id;

} RULE_CTRL_PortConfigStatus_T;

typedef struct RULE_CTRL_AllocatedRule_S
{
    UI32_T   dev_rule_id;
} RULE_CTRL_AllocatedRule_T;

typedef struct
{
    RULE_TYPE_FunctionType_T        fun_type;
    UI32_T                          group_id;           /* device group ID */
    UI32_T                          total_rule;         /* 0 means no limitation */
    UI32_T                          free_rule;
    UI32_T                          rule_cnt;
    BOOL_T                          used;
} RULE_CTRL_RuleQuota_T;

typedef struct
{
    RULE_CTRL_RuleQuota_T           rq[RULE_TYPE_FUNCTION_TYPE_MAX];
} RULE_CTRL_RuleQuotaVector_T;

typedef struct
{
    RULE_CTRL_RuleQuotaVector_T     vec[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                       [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
} RULE_CTRL_RuleQuotaDescriptor_T;

typedef struct
{
    RULE_TYPE_FunctionType_T        func_type;          /* BAD FIELD !! */
    UI8_T                           func_type_bmp[RULE_TYPE_GET_BITMAP_ARRAY_SIZE(RULE_TYPE_FUNCTION_TYPE_MAX)];
    UI32_T                          total_rule;
    UI32_T                          free_rule;
} RULE_CTRL_ResourceInfo_T;

#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)
typedef struct
{
    RULE_TYPE_FunctionType_T        fun_type;           /* key
                                                         */
    RULE_TYPE_FunctionType_T        used_by_fun_type;   /* if this field is
                                                         * RULE_TYPE_FUNCTION_TYPE_MAX
                                                         * means fun_type is free
                                                         */
} RULE_CTRL_FunTypeFreeEntry_T;

static RULE_TYPE_FunctionType_T rule_ctrl_av_fun_type_list[] =
{
    RULE_TYPE_INGRESS_MAC_ACL,
    RULE_TYPE_INGRESS_IP_ACL,
    RULE_TYPE_INGRESS_IPV6_STD_ACL,
    RULE_TYPE_INGRESS_IPV6_EXT_ACL
};

#define RULE_CTRL_TOTAL_NBR_OF_AV_REMAP_FUN_TYPE  (_countof(rule_ctrl_av_fun_type_list))

typedef struct
{
    RULE_CTRL_FunTypeFreeEntry_T    av_vector[RULE_CTRL_TOTAL_NBR_OF_AV_REMAP_FUN_TYPE];
} RULE_CTRL_FunTypeFreeTable_T;

typedef struct
{
    RULE_CTRL_ResourceInfo_T        resource_info[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                 [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT]
                                                 [SYS_ADPT_FP_MAX_NBR_OF_GROUP_PER_CHIP];
    RULE_CTRL_RuleQuotaDescriptor_T quota_desc;

    RULE_CTRL_FunTypeFreeTable_T    av_fun_type_tbl;

    RULE_TYPE_CONTAINER_T           container_pool_buf[SYS_ADPT_TOTAL_NBR_OF_LPORT * (2)];
    RULE_TYPE_CLASS_INSTANCE_T      class_inst_pool_buf[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK *
                                                        SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT *
                                                        SYS_ADPT_FP_MAX_NBR_OF_GROUP_PER_CHIP *
                                                        SYS_ADPT_FP_MAX_NBR_OF_RULE_PER_SELECTOR +
                                                        SYS_ADPT_TOTAL_NBR_OF_LPORT];
    RULE_TYPE_RULE_INSTANCE_T       rule_inst_pool_buf[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK *
                                                       SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT *
                                                       SYS_ADPT_FP_MAX_NBR_OF_GROUP_PER_CHIP *
                                                       SYS_ADPT_FP_MAX_NBR_OF_RULE_PER_SELECTOR];

    RULE_CTRL_IF_ENTRY_T            if_table[RULE_CTRL_TOTAL_NBR_OF_IF_ENTRY_PER_DIRECTION * 2];
    RULE_OM_Snapshot_T              om_part;

    BOOL_T                          valid;
} RULE_CTRL_Snapshot_T;

typedef struct
{
    BOOL_T is_ingress;
    UI32_T unit;
    UI32_T port;
    UI32_T acl_id;
    BOOL_T is_trunk;
    BOOL_T is_add;
    UI32_T time_range_index;
    RULE_TYPE_COUNTER_ENABLE_T counter_enable;
} RULE_CTRL_WRAP_FN_PARAM_T;

#endif /* SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT */

typedef struct RULE_CTRL_CpuRule_S
{
    BOOL_T   is_enabled;
    UI32_T   dev_rule_id;
} RULE_CTRL_CpuRule_T;


typedef struct RULE_CTRL_SlfRule_S
{
    BOOL_T   is_enabled;
    UI8_T    slf_action;
    UI32_T   dev_rule_id;
} RULE_CTRL_SlfRule_T;

typedef struct
{
    DEVRM_PBMP_T  pbmp;
    UI32_T      rule_id;
} RULE_CTRL_RuleIdPair_T;

#if (SYS_CPNT_IP_SOURCE_GUARD == TRUE)
typedef struct
{
    struct RULE_CTRL_IpSrcGrdPortInfoElem {
        RULE_CTRL_RuleIdPair_T  permit_rule;
        UI32_T                  permit_sip;
        UI8_T                   permit_sa[SYS_ADPT_MAC_ADDR_LEN];
    }record[SYS_ADPT_DHCPSNP_MAX_NBR_OF_CLIENT_PER_PORT];
}RULE_CTRL_IpSrcGrdPortInfo_T;

typedef struct
{
    struct RULE_CTRL_IpSrcGrdGlobalInfo
    {
        RULE_CTRL_RuleIdPair_T  deny_ip;
    }global[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK][SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];

    RULE_CTRL_IpSrcGrdPortInfo_T port[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK][SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT];
} RULE_CTRL_IpSrcGrdInfo_T;
#endif /* #if (SYS_CPNT_IP_SOURCE_GUARD == TRUE) */

typedef struct
{
    RULE_CTRL_SYS_RULE_STORAGE      rule_storage;
    UI16_T                          dst_port;
    UI8_T                           cos;
} RULE_CTRL_L4PortCosRuleStorage_T;

typedef struct
{
    RULE_CTRL_SYS_RULE_STORAGE      rule_storage;
    UI32_T                          vlan_id;
    UI8_T                           addr[SYS_ADPT_IPV6_ADDR_LEN];
} RULE_CTRL_LinkLocalRuleStorage_T;

#if (SYS_CPNT_IPV6_DENY_LINK_LOCAL_ROUTING_BY_RULE_AS_TEMPORARY_SOLUTION == TRUE)
typedef struct
{
    RULE_CTRL_SYS_RULE_STORAGE      rule_storage;
} RULE_CTRL_RS_IP6_DenyLinkLocalL3Routable_T;
#endif /* #if (SYS_CPNT_IPV6_DENY_LINK_LOCAL_ROUTING_BY_RULE_AS_TEMPORARY_SOLUTION == TRUE) */

typedef struct
{
    RULE_CTRL_RULE_STORAGE          rule_storage;
    DEVRM_PBMP_T                    pbmp;
} RULE_CTRL_SPRRuleStorage_T;

/* For 802.1X MAC-based mode. Trap my MAC + 802.1x ether type to CPU.
 */
typedef struct
{
    RULE_CTRL_RULE_STORAGE          rule_storage;
    DEVRM_PBMP_T                    pbmp;
    UI8_T                           cpu_mac[SYS_ADPT_MAC_ADDR_LEN];
} RULE_CTRL_Dot1xUCRuleStorage_T;

typedef struct
{
    RULE_CTRL_SYS_RULE_STORAGE      rule_storage;
} RULE_CTRL_Dot1xEapolPassThroughStorage_T;

typedef struct
{
    RULE_CTRL_RULE_STORAGE          rule_storage;
    DEVRM_PBMP_T                      pbmp;
} RULE_CTRL_IPSGDenyAnyIPRuleStorage_T;

typedef struct
{
    RULE_CTRL_RULE_STORAGE          rule_storage;
    UI8_T                           src_ipv4_addr[4];
} RULE_CTRL_WebAuthPermitIPRuleStorage_T;

typedef struct
{
    RULE_CTRL_RULE_STORAGE          rule_storage;
    UI32_T                          vlan_id;
    UI8_T                           ipv4_addr[SYS_TYPE_IPV4_ADDR_LEN];
    UI8_T                           mac_addr[SYS_TYPE_MAC_ADDR_LEN];
} RULE_CTRL_IPSGPermitIPRuleStorage_T;

#if (SYS_CPNT_IPV6_SOURCE_GUARD == TRUE)
typedef struct
{
    RULE_CTRL_RULE_STORAGE          rule_storage;
    DEVRM_PBMP_T                      pbmp;
} RULE_CTRL_IPV6SGDenyAnyIPRuleStorage_T;

typedef struct
{
    RULE_CTRL_RULE_STORAGE          rule_storage;
    UI32_T                          vlan_id;
    UI8_T                           ipv6_addr[SYS_TYPE_IPV6_ADDR_LEN];
} RULE_CTRL_IPV6SGPermitIP6RuleStorage_T;
#endif /* #if (SYS_CPNT_IPV6_SOURCE_GUARD == TRUE) */

#if (SYS_CPNT_DAI == TRUE)
typedef struct
{
    RULE_CTRL_RULE_STORAGE          rule_storage;
    UI32_T                          meter_rate; /* packet/sec */
} RULE_CTRL_RS_ARP_T;
#endif /* SYS_CPNT_DAI */

typedef struct
{
    RULE_CTRL_SYS_RULE_STORAGE      rule_storage;
} RULE_CTRL_RS_PTP_T;

#if (SYS_CPNT_MLD == TRUE || SYS_CPNT_MLDSNP == TRUE || SYS_CPNT_MVR6 == TRUE)
typedef struct
{
    RULE_CTRL_SYS_RULE_STORAGE      rule_storage;
} RULE_CTRL_RS_MLD_T;
#endif /* SYS_CPNT_MLD || SYS_CPNT_MLDSNP || SYS_CPNT_MVR6 */

#if (SYS_CPNT_IGMPSNP == TRUE && SYS_CPNT_IGMPSNP_RESERVE_ADDRESS_PACKET_CHIP_TRAP_TO_CPU_BUT_NOT_FORWARD == FALSE)
typedef struct
{
    RULE_CTRL_SYS_RULE_STORAGE      rule_storage;
} RULE_CTRL_RS_IGMPSNP_RESERVED_T;
#endif /* SYS_CPNT_IGMPSNP && !SYS_CPNT_IGMPSNP_RESERVE_ADDRESS_PACKET_CHIP_TRAP_TO_CPU_BUT_NOT_FORWARD */

typedef struct
{
    RULE_CTRL_SYS_RULE_STORAGE      rule_storage;
}RULE_CTRL_RS_IGMPSNP_T;

typedef struct
{
    RULE_CTRL_SYS_RULE_STORAGE      rule_storage;
    BOOL_T                          to_cpu;
    BOOL_T                          flood;
}RULE_CTRL_RS_ORG_SPEC1_T;

#if (SYS_CPNT_UDLD == TRUE)
typedef struct
{
    RULE_CTRL_SYS_RULE_STORAGE      rule_storage;
    BOOL_T                          to_cpu;
    BOOL_T                          flood;
}RULE_CTRL_RS_UDLD_T;
#endif /* SYS_CPNT_UDLD */

typedef struct
{
    RULE_CTRL_SYS_RULE_STORAGE      rule_storage;
    BOOL_T                          to_cpu;
    BOOL_T                          flood;
}RULE_CTRL_RS_ORG_SPEC3_T;

typedef struct
{
    RULE_CTRL_SYS_RULE_STORAGE      rule_storage;
    BOOL_T                          to_cpu;
    BOOL_T                          flood;
} RULE_CTRL_RS_DHCPV6_T;

#if (SYS_CPNT_QINQ_L2PT_CUSTOM_PDU == TRUE)
typedef struct
{
    RULE_CTRL_SPRRuleStorage_T      spr_rs;
    UI8_T                           dstmac[SYS_ADPT_MAC_ADDR_LEN];
} RULE_CTRL_L2PTCustomPduRuleStorage_T;
#endif

typedef RULE_CTRL_SPRRuleStorage_T RULE_CTRL_RS_IP6_RA_Guard_T;

typedef struct
{
    RULE_CTRL_SPRRuleStorage_T      spr_rs;
    BOOL_T                          is_tcp; /* TRUE: TCP, FALSE: UDP */
    UI16_T                          dst_port;
    UI8_T                           phb;
    UI8_T                           color;
} RULE_CTRL_L4PortDscpRuleStorage_T;


typedef enum
{
    RULE_CTRL_SID_DEVRM_ALLOCATERULE      = 0,
    RULE_CTRL_SID_DEVRM_SETRULE           ,
    RULE_CTRL_SID_DEVRM_DESTROYRULE       ,
    RULE_CTRL_SID_DEVRM_CREATEMETER       ,
    RULE_CTRL_SID_DEVRM_UPDATEMETER       ,
    RULE_CTRL_SID_DEVRM_SHAREMETER        ,
    RULE_CTRL_SID_DEVRM_DESTROYMETER      ,
    RULE_CTRL_SID_DEVRM_SETACTION         ,
    RULE_CTRL_SID_DEVRM_DESTROYACTION     ,
    RULE_CTRL_SID_DEVRM_UPDATERULE        ,
    RULE_CTRL_SID_DEVRM_SETALLOCATEDRULE  ,/* service id for slave to tell master a allocated rule id. */
    RULE_CTRL_SID_TRAPPACKET2CPU          ,
    RULE_CTRL_SID_GET_DEV_INFO            ,
    RULE_CTRL_SID_SET_GROUP_QUALIFY_SET   ,
    RULE_CTRL_SID_SET_GROUP_PRIORITY      ,
    RULE_CTRL_SID_GET_RULE_COUNTER        ,
    RULE_CTRL_SID_CLEAR_RULE_COUNTER      ,
    RULE_CTRL_NBR_OF_SERVICE_ID           ,
}RULE_CTRL_ServicesID_T;

#define RULECTRLINFO info.rule_ctrl_info
#define CPUINFO      info.cpu_interface_info
#define L4PORTINFO   info.l4_port_info

typedef struct
{
    UI32_T              ServiceID;      /* Service ID  */
    UI32_T              unit;           /* stack id (unit number) */
    UI32_T              port;           /* port number */
    UI32_T              option_module;  /* option module */
    UI32_T              option_num_port;
    union
    {
        /*rule ctrl info*/
        struct
        {
            UI32_T                      device_id;
            UI32_T                      src_dev_rule_id;
            UI32_T                      group_id;
            UI32_T                      fun_type;
            int                         rule_pri;
            UI32_T                      dev_rule_id;
            UI32_T                      meter_id;
            UI32_T                      action_id;
            DEVRM_AceEntry_T            ace_entry;
            BOOL_T                      is_meter_exist;
            DEVRM_MeterEntry_T          meter_entry;
            UI8_T                       action_nbr;
            DEVRM_ActionEntry_T         action_entry[RULE_CTRL_ISC_MAX_NBR_OF_ACTION];
            DEVRM_GroupEntry_T          group_entry;
            RULE_TYPE_COUNTER_ENABLE_T  counter_enable;
        }rule_ctrl_info;
        /*cpu interface*/
        struct
        {
            BOOL_T                      enable_flag;
            RULE_TYPE_PacketType_T      packet_type;
            RULE_TYPE_CpuRuleInfo_T     rule_info;
        }cpu_interface_info;
        /*l4 port*/
        struct
        {
            UI16_T              dest_port;
            UI8_T               is_tcp;
            UI8_T               phb;
            UI8_T               color;
            UI8_T               is_update;
        }l4_port_info;

        /* device information */
        DEVRM_DevInfo_T         dev_info;
    }info;
} RULE_CTRL_IscBuf_T;

typedef struct
{
    union
    {
        BOOL_T b_result;
    } return_value;

    union
    {
        RULE_TYPE_CounterRec_T counter;
        DEVRM_DevInfo_T device_info;
    } data;
} RULE_CTRL_IscReplyBuf_T;

typedef struct RULE_CTRL_TcpUdpPortMapping_S
{
    BOOL_T   is_enabled;
    UI32_T   dev_rule_id;
    UI8_T    protocol;
    UI16_T   dport;
} RULE_CTRL_TcpUdpPortMapping_T;

#if (SYS_CPNT_EFM_OAM == TRUE)
    typedef struct RULE_CTRL_EfmOamInfo_S
    {
    #if 1
        DEVRM_PBMP_T  oampdu_pbmp;
        DEVRM_PBMP_T  loopbk_pbmp;
        UI32_T      oam_rule_id;
        UI32_T      loopbk_rule_id;
    #else
        UI32_T      oampdu_pbmp;
        UI32_T      loopbk_pbmp;
    #endif
    } RULE_CTRL_EfmOamInfo_T;
#endif

#pragma mark -
#pragma mark Shared memory data definition
#pragma mark typedef struct {

typedef struct
{
    SYSFUN_DECLARE_CSC_ON_SHMEM

    RULE_CTRL_AllocatedRule_T           allocated_rule[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                      [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
    RULE_CTRL_CpuRule_T                 cpu_rule[SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT]
                                                [RULE_TYPE_Pkt2CpuRule_MAX];

    RULE_CTRL_SlfRule_T                 slf_rule[SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT]
                                                [SYS_ADPT_MAX_NBR_OF_VLAN];

    /* local unit management only */
    RULE_CTRL_PortConfigStatus_T        port_config_status_table[SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT];

    L_PT_ShMem_Descriptor_T     _container_pool;
    L_PT_ShMem_Descriptor_T     _class_inst_pool;
    L_PT_ShMem_Descriptor_T     _rule_inst_pool;

    /* ACL (ingress and egress)
     */
    RULE_TYPE_CONTAINER_T       _container_pool_buf[SYS_ADPT_TOTAL_NBR_OF_LPORT * (2)];
    RULE_TYPE_CLASS_INSTANCE_T  _class_inst_pool_buf[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK *
                                                     SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT *
                                                     SYS_ADPT_FP_MAX_NBR_OF_GROUP_PER_CHIP *
                                                     SYS_ADPT_FP_MAX_NBR_OF_RULE_PER_SELECTOR +
                                                     SYS_ADPT_TOTAL_NBR_OF_LPORT];
    RULE_TYPE_RULE_INSTANCE_T   _rule_inst_pool_buf[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK *
                                                    SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT *
                                                    SYS_ADPT_FP_MAX_NBR_OF_GROUP_PER_CHIP *
                                                    SYS_ADPT_FP_MAX_NBR_OF_RULE_PER_SELECTOR];

    /*store all unit group information*/
    RULE_CTRL_ResourceInfo_T                resource_info[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                         [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT]
                                                         [SYS_ADPT_FP_MAX_NBR_OF_GROUP_PER_CHIP];
    RULE_CTRL_RuleQuotaDescriptor_T         quota_desc;

#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)
    RULE_CTRL_FunTypeFreeTable_T            av_fun_type_tbl;
#endif /* SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT */

    DEVRM_DevInfo_T                         dev_info[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK];

    RULE_CTRL_RuleLookupEntry_T             rule_lookup_tbl[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                           [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT]
                                                           [SYS_ADPT_FP_MAX_NBR_OF_GROUP_PER_CHIP]
                                                           [SYS_ADPT_FP_MAX_NBR_OF_RULE_PER_SELECTOR];

    RULE_CTRL_IF_ENTRY_T        if_table[RULE_CTRL_TOTAL_NBR_OF_IF_ENTRY_PER_DIRECTION * 2];

    //
    // FIXME: 1-to-1 map from _rule_inst_pool_buf
    //
    RULE_CTRL_RULE_ENTRY_T      rule_table[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK *
                                           SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT *
                                           SYS_ADPT_FP_MAX_NBR_OF_GROUP_PER_CHIP *
                                           SYS_ADPT_FP_MAX_NBR_OF_RULE_PER_SELECTOR];

    /*******************************************
     * Share port rule storage
     *******************************************
     */
    RULE_CTRL_L4PortDscpRuleStorage_T       l4_port_internal_pri[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                                [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT]
                                                                [SYS_ADPT_MAX_NBRS_OF_TCPUDP_ACE];

#if (SYS_CPNT_WEBAUTH == TRUE)
    RULE_CTRL_SPRRuleStorage_T              web_auth_trap_httpc[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                               [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
    RULE_CTRL_SPRRuleStorage_T              web_auth_permit_dns[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                               [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
    RULE_CTRL_SPRRuleStorage_T              web_auth_permit_dhcpc[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                                 [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
    RULE_CTRL_SPRRuleStorage_T              web_auth_deny_any_ip[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                                [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
    RULE_CTRL_WebAuthPermitIPRuleStorage_T  web_auth_permit_ip[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                              [SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT]
                                                              [SYS_ADPT_WEBAUTH_MAX_NBR_OF_HOSTS_PER_PORT];
#endif /* SYS_CPNT_WEBAUTH */

#if (SYS_CPNT_ERPS == TRUE)
    RULE_CTRL_SPRRuleStorage_T              erps_raps[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                     [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
#endif /* SYS_CPNT_ERPS */

#if (SYS_CPNT_DOT1X == TRUE)
    RULE_CTRL_Dot1xUCRuleStorage_T          dot1xuc[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                   [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
#endif /* SYS_CPNT_DOT1X */

#if (SYS_CPNT_IPV6_RA_GUARD == TRUE)
    RULE_CTRL_RS_IP6_RA_Guard_T             ip6_ra_guard_deny_ra[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                                [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
    RULE_CTRL_RS_IP6_RA_Guard_T             ip6_ra_guard_deny_rr[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                                [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
#endif /* SYS_CPNT_IPV6_RA_GUARD */

#if (SYS_CPNT_EFM_OAM_REMOTE_LB_PASSIVELY == TRUE)
    RULE_CTRL_SPRRuleStorage_T              cpe_oampdu[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                      [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];

    RULE_CTRL_SPRRuleStorage_T              cpe_oamloopback[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                           [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
#endif /* SYS_CPNT_EFM_OAM_REMOTE_LB_PASSIVELY */

#if (SYS_CPNT_EFM_OAM_REMOTE_LB_ACTIVELY == TRUE)
    RULE_CTRL_SPRRuleStorage_T              co_oamloopback[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                          [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
#endif /* SYS_CPNT_EFM_OAM_REMOTE_LB_ACTIVELY */

#if (SYS_CPNT_IP_MULTICAST_DATA_DROP== TRUE) || (SYS_CPNT_MVR == TRUE)
    RULE_CTRL_SPRRuleStorage_T              igmpsnp_denymcdata[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                              [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
#endif /* SYS_CPNT_IP_MULTICAST_DATA_DROP || SYS_CPNT_MVR */

#if (SYS_CPNT_IPV6_MULTICAST_DATA_DROP == TRUE) || (SYS_CPNT_MVR6 == TRUE)
    RULE_CTRL_SPRRuleStorage_T              ip6_deny_ipmc_data[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                              [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
#endif /* SYS_CPNT_IPV6_MULTICAST_DATA_DROP || SYS_CPNT_MVR6 */

#if (SYS_CPNT_QINQ_L2PT_CUSTOM_PDU == TRUE)
    RULE_CTRL_L2PTCustomPduRuleStorage_T    l2pt_custom_pdu[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                           [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT]
                                                           [SYS_ADPT_QINQ_L2PT_MAX_NBR_OF_CUSTOM_PDU_CONFIG];
#endif /* SYS_CPNT_QINQ_L2PT_CUSTOM_PDU */

#if (SYS_CPNT_PPPOE_IA == TRUE)
    RULE_CTRL_SPRRuleStorage_T              pppoe_discovery[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                           [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
#endif /* SYS_CPNT_PPPOE_IA */

#if (SYS_CPNT_APP_FILTER == TRUE)
    RULE_CTRL_SPRRuleStorage_T              af_discard_cdp[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                          [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
    RULE_CTRL_SPRRuleStorage_T              af_discard_pvst[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                           [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
#endif /* SYS_CPNT_APP_FILTER */

    /*******************************************
     * Normal rule (global) storage
     *******************************************
     */
    RULE_CTRL_L4PortCosRuleStorage_T        l4_port_cos_map[SYS_ADPT_MAX_NBRS_OF_TCPUDP_ACE];

#if (SYS_CPNT_IPV6 == TRUE)
    RULE_CTRL_LinkLocalRuleStorage_T        ip6_link_local_addr_map[RULE_CTRL_MAX_NBR_OF_LINK_LOCAL_TO_CPU];
#endif /* SYS_CPNT_IPV6 */

#if (SYS_CPNT_IPV6_DENY_LINK_LOCAL_ROUTING_BY_RULE_AS_TEMPORARY_SOLUTION == TRUE)
    RULE_CTRL_RS_IP6_DenyLinkLocalL3Routable_T  ip6_deny_link_local_l3_routable;
#endif /* SYS_CPNT_IPV6_DENY_LINK_LOCAL_ROUTING_BY_RULE_AS_TEMPORARY_SOLUTION */

#if (SYS_CPNT_DOT1X == TRUE) && (SYS_CPNT_DOT1X_EAPOL_PASS_THROUGH_BY_RULE == TRUE)
    RULE_CTRL_Dot1xEapolPassThroughStorage_T     dot1x_eapol_pass_through;
#endif /* SYS_CPNT_DOT1X_EAPOL_PASS_THROUGH_BY_RULE && SYS_CPNT_DOT1X */

#if (SYS_CPNT_IPV6_SOURCE_GUARD == TRUE)
    RULE_CTRL_IPV6SGPermitIP6RuleStorage_T  ipv6sg_permit_ip6[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                             [SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT]
                                                             [SYS_ADPT_DHCPSNP_MAX_NBR_OF_CLIENT_PER_PORT];

    RULE_CTRL_IPV6SGDenyAnyIPRuleStorage_T  ipv6sg_deny_any_ip6[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                               [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
#endif /* SYS_CPNT_IPV6_SOURCE_GUARD */

#if (SYS_CPNT_PTP == TRUE)
    RULE_CTRL_RS_PTP_T                      ptp_event_eth;
    RULE_CTRL_RS_PTP_T                      ptp_event_udp;
    RULE_CTRL_RS_PTP_T                      ptp_general_udp;
#endif /* SYS_CPNT_PTP */

#if (SYS_CPNT_MLD == TRUE || SYS_CPNT_MLDSNP == TRUE || SYS_CPNT_MVR6 == TRUE)
    RULE_CTRL_RS_MLD_T                      mld_query;
    RULE_CTRL_RS_MLD_T                      mld_report;
    RULE_CTRL_RS_MLD_T                      mld_done;
    RULE_CTRL_RS_MLD_T                      mldv2_reports;
#endif /* SYS_CPNT_MLD || SYS_CPNT_MLDSNP || SYS_CPNT_MVR6 */

#if (SYS_CPNT_DHCPV6 == TRUE)
    RULE_CTRL_RS_DHCPV6_T                   dhcpv6_client_cpu_rule;
    RULE_CTRL_RS_DHCPV6_T                   dhcpv6_server_cpu_rule;
#endif /* SYS_CPNT_DHCPV6 */

#if (SYS_CPNT_IGMPSNP == TRUE && SYS_CPNT_IGMPSNP_RESERVE_ADDRESS_PACKET_CHIP_TRAP_TO_CPU_BUT_NOT_FORWARD == FALSE)
    RULE_CTRL_RS_IGMPSNP_RESERVED_T         igmpsnp_reserved;
#endif /* SYS_CPNT_IGMPSNP && !SYS_CPNT_IGMPSNP_RESERVE_ADDRESS_PACKET_CHIP_TRAP_TO_CPU_BUT_NOT_FORWARD */

    RULE_CTRL_RS_IGMPSNP_T                  igmpsnp_control;
    RULE_CTRL_RS_ORG_SPEC1_T                org_spec1;

#if (SYS_CPNT_UDLD == TRUE)
    RULE_CTRL_RS_UDLD_T                     udld;
#endif /* SYS_CPNT_UDLD */

    RULE_CTRL_RS_ORG_SPEC3_T                org_spec3;

    /*******************************************
     * Normal rule (per-port) storage
     *******************************************
     */
#if (SYS_CPNT_IP_SOURCE_GUARD == TRUE)
    RULE_CTRL_IPSGPermitIPRuleStorage_T     ipsg_permit_ip[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                          [SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT]
                                                          [SYS_ADPT_DHCPSNP_MAX_NBR_OF_CLIENT_PER_PORT];
    RULE_CTRL_IPSGDenyAnyIPRuleStorage_T    ipsg_deny_any_ip[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                                            [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT];
#endif /* SYS_CPNT_IP_SOURCE_GUARD */

#if (SYS_CPNT_DAI_RATE_LIMIT_BY_RULE == TRUE)
    RULE_CTRL_RS_ARP_T                      arp[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                                               [SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT];
#endif /* SYS_CPNT_DAI_RATE_LIMIT_BY_RULE */

} RULE_CTRL_ShmemData_T;

#pragma mark }RULE_CTRL_ShmemData_T;
#pragma mark -

#define RULE_CTRL_FIND_EXISTED_RULE_ENTRY       0x00000001
#define RULE_CTRL_FIND_NEXT_EXISTED_RULE_ENTRY  0x00000002
#define RULE_CTRL_FIND_FIRST_FREE_RULE_ENTRY    0x00000004

typedef struct
{
    UI32_T                      flag;
    UI32_T                      unit;
    UI32_T                      device_id;
    UI32_T                      group_id;
    UI32_T                      rule_id;

    UI32_T                      _last_index;

    RULE_CTRL_RuleLookupEntry_T *existed_p;
    RULE_CTRL_RuleLookupEntry_T *first_free_p;
} RULE_CTRL_FindRuleLookupTable_T;

typedef BOOL_T (*RULE_CTRL_ServiceFunc_t)(ISC_Key_T *key, RULE_CTRL_IscBuf_T *ptr);

/**************************************************

 LOCAL SUBPROGRAM DECLARATIONS

 **************************************************/
#include "rule_ctrl_priv.h"


/**************************************************

 STATIC VARIABLE DECLARATIONS

 **************************************************/
/* service function table
 */

static BOOL_T RULE_CTRL_TrapDhcpClientPacketToCPU(BOOL_T enable, BOOL_T to_cpu, BOOL_T flood);
static BOOL_T RULE_CTRL_TrapDhcpServerPacketToCPU(BOOL_T enable, BOOL_T to_cpu, BOOL_T flood);

#if (SYS_CPNT_STACKING == TRUE)
static RULE_CTRL_ServiceFunc_t RULE_CTRL_func_tab[] =
{
    RULE_CTRL_Slave_Allocate_Rule,          /* RULE_CTRL_SID_DEVRM_ALLOCATERULE     */
    RULE_CTRL_Slave_Set_Rule,               /* RULE_CTRL_SID_DEVRM_SETRULE          */
    RULE_CTRL_Slave_Destroy_Rule,           /* RULE_CTRL_SID_DEVRM_DESTROYRULE      */
    RULE_CTRL_Slave_Create_Meter,           /* RULE_CTRL_SID_DEVRM_CREATEMETER      */
    RULE_CTRL_Slave_Update_Meter,           /* RULE_CTRL_SID_DEVRM_UPDATEMETER      */
    RULE_CTRL_Slave_Share_Meter,            /* RULE_CTRL_SID_DEVRM_SHAREMETER       */
    RULE_CTRL_Slave_Destroy_Meter,          /* RULE_CTRL_SID_DEVRM_DESTROYMETER     */
    RULE_CTRL_Slave_Set_Action,             /* RULE_CTRL_SID_DEVRM_SETACTION        */
    RULE_CTRL_Slave_Destroy_Action,         /* RULE_CTRL_SID_DEVRM_DESTROYACTION    */
    RULE_CTRL_Slave_Update_Rule,            /* RULE_CTRL_SID_DEVRM_UPDATERULE       */
    RULE_CTRL_Master_Set_Allocated_Rule,    /* RULE_CTRL_SID_DEVRM_SETALLOCATEDRULE */
    RULE_CTRL_Slave_TrapPacket2Cpu,         /* RULE_CTRL_SID_TRAPPACKET2CPU         */
    RULE_CTRL_Slave_GetDevInfo,             /* RULE_CTRL_SID_GET_DEV_INFO           */
    RULE_CTRL_Slave_Set_Group_Qualify_Set,  /* RULE_CTRL_SID_SET_GROUP_QUALIFY_SET  */
    RULE_CTRL_Slave_Set_Group_Priority,     /* RULE_CTRL_SID_SET_GROUP_PRIORITY     */
    RULE_CTRL_Slave_GetRuleCounter,         /* RULE_CTRL_SID_GET_RULE_COUNTER       */
    RULE_CTRL_Slave_ClearRuleCounter,       /* RULE_CTRL_SID_CLEAR_RULE_COUNTER     */
};
#endif /* #if (SYS_CPNT_STACKING == TRUE) */

static RULE_CTRL_ShmemData_T   *shmem_data_p;
static UI32_T rule_ctrl_sem_id;

#define RULE_CTRL_EnterCriticalSection() SYSFUN_TakeSem(rule_ctrl_sem_id, SYSFUN_TIMEOUT_WAIT_FOREVER)
#define RULE_CTRL_LeaveCriticalSection() SYSFUN_GiveSem(rule_ctrl_sem_id)
#define RULE_CTRL_LeaveCriticalSectionReturnState(value)        \
    {                                                           \
        RULE_CTRL_LeaveCriticalSection();                       \
        return value;                                           \
    }

#pragma mark -
#pragma mark dynamic selector assignment
typedef struct
{
    BOOL_T
    (*fn_allocate_rule)(
        UI32_T unit,
        UI32_T port,
        UI32_T device_id,
        UI32_T group_id,
        UI32_T fun_type,
        int rule_pri,
        UI32_T *dev_rule_id);

    BOOL_T
    (*fn_destroy_rule)(
        UI32_T unit,
        UI32_T port,
        UI32_T device_id,
        UI32_T group_id,
        UI32_T fun_type,
        UI32_T dev_rule_id);

    BOOL_T (*fn_set_rule)(
        UI32_T unit,
        UI32_T port,
        UI32_T device_id,
        UI32_T group_id,
        UI32_T dev_rule_id,
        DEVRM_AceEntry_T *ace_entry,
        DEVRM_MeterEntry_T *meter_entry,
        DEVRM_ActionEntry_T *action_entry,
        RULE_TYPE_COUNTER_ENABLE_T counter_enable);

    BOOL_T
    (*fn_update_rule)(
        UI32_T unit,
        UI32_T port,
        UI32_T device_id,
        UI32_T dev_rule_id,
        DEVRM_AceEntry_T *ace_entry,
        DEVRM_MeterEntry_T *meter_entry,
        DEVRM_ActionEntry_T *action_entry);

    BOOL_T
    (*fn_create_meter)(
        UI32_T unit,
        UI32_T port,
        UI32_T device_id,
        UI32_T dev_rule_id,
        DEVRM_MeterEntry_T *meter_entry);

    BOOL_T
    (*fn_destroy_meter)(
        UI32_T unit,
        UI32_T port,
        UI32_T device_id,
        UI32_T dev_rule_id);

    BOOL_T
    (*fn_share_meter)(
        UI32_T unit,
        UI32_T port,
        UI32_T device_id,
        UI32_T src_dev_rule_id,
        UI32_T dev_rule_id);

    BOOL_T
    (*fn_update_meter)(
        UI32_T unit,
        UI32_T port,
        UI32_T device_id,
        UI32_T dev_rule_id,
        DEVRM_MeterEntry_T *meter_entry);

    BOOL_T
    (*fn_set_action)(
        UI32_T unit,
        UI32_T port,
        UI32_T device_id,
        UI32_T rule_id,
        DEVRM_ActionEntry_T *action_entry);

    BOOL_T
    (*fn_set_group_qset)(
        DEVRM_GroupEntry_T *group_p);

    BOOL_T
    (*fn_set_group_priority)(
        UI32_T group_id,
        int priority);

} RULE_CTRL_OpTable_T;

static RULE_CTRL_OpTable_T rule_ctrl_dflt_optable =
{
    .fn_allocate_rule           = RULE_CTRL_Allocate_Rule,
    .fn_destroy_rule            = RULE_CTRL_Destroy_Rule,
    .fn_set_rule                = RULE_CTRL_Set_Rule,
    .fn_update_rule             = RULE_CTRL_Update_Rule,

    .fn_create_meter            = RULE_CTRL_Create_Meter,
    .fn_destroy_meter           = RULE_CTRL_Destroy_Meter,
    .fn_share_meter             = RULE_CTRL_Share_Meter,
    .fn_update_meter            = RULE_CTRL_Update_Meter,

    .fn_set_action              = RULE_CTRL_Set_Action,

    .fn_set_group_qset          = RULE_CTRL_Set_Group_Qualify_Set,
    .fn_set_group_priority      = RULE_CTRL_Set_Group_Priority,
};

static RULE_CTRL_OpTable_T          *rule_ctrl_optable_ptr = &rule_ctrl_dflt_optable;

#define RULE_CTRL_OPTABLE()                 (rule_ctrl_optable_ptr)

#define RULE_CTRL_ALLOCATE_RULE             RULE_CTRL_OPTABLE()->fn_allocate_rule
#define RULE_CTRL_DESTROY_RULE              RULE_CTRL_OPTABLE()->fn_destroy_rule
#define RULE_CTRL_SET_RULE                  RULE_CTRL_OPTABLE()->fn_set_rule
#define RULE_CTRL_UPDATE_RULE               RULE_CTRL_OPTABLE()->fn_update_rule

#define RULE_CTRL_CREATE_METER              RULE_CTRL_OPTABLE()->fn_create_meter
#define RULE_CTRL_DESTROY_METER             RULE_CTRL_OPTABLE()->fn_destroy_meter
#define RULE_CTRL_SHARE_METER               RULE_CTRL_OPTABLE()->fn_share_meter
#define RULE_CTRL_UPDATE_METER              RULE_CTRL_OPTABLE()->fn_update_meter

#define RULE_CTRL_SET_ACTION(unit, port, device_id, rule_id, action_entry_ptr) \
    RULE_CTRL_OPTABLE()->fn_set_action(unit, port, device_id, rule_id, action_entry_ptr)

#define RULE_CTRL_SET_GROUP_QUALIFY_SET     RULE_CTRL_OPTABLE()->fn_set_group_qset
#define RULE_CTRL_SET_GROUP_PRIORITY        RULE_CTRL_OPTABLE()->fn_set_group_priority
#pragma mark -

/*------------------------------------------------------------------------------
 * FUNCTION NAME: RULE_CTRL_AttachSystemResources
 *------------------------------------------------------------------------------
 * PURPOSE: Attach system resource for RULE_CTRL in the context of the calling
 *          process.
 * INPUT:   None
 * OUTPUT:  None
 * RETUEN:  None
 * NOTES:
 *------------------------------------------------------------------------------
 */
void RULE_CTRL_AttachSystemResources(void)
{
    shmem_data_p = (RULE_CTRL_ShmemData_T*)SYSRSC_MGR_GetShMem(SYSRSC_MGR_RULE_CTRL_SHMEM_SEGID);
    SYSFUN_GetSem(SYS_BLD_SYS_SEMAPHORE_KEY_RULE_CTRL, &rule_ctrl_sem_id);

    FP_CONFIG_AttachSystemResources((UI8_T*)shmem_data_p + sizeof(RULE_CTRL_ShmemData_T));
}

/* FUNCTION NAME: RULE_CTRL_GetShMemInfo
 *------------------------------------------------------------------------------
 * PURPOSE: Get share memory info
 *------------------------------------------------------------------------------
 * INPUT:   None
 * OUTPUT:  None
 * RETUEN:  None
 * NOTES:
 *------------------------------------------------------------------------------
 */
void RULE_CTRL_GetShMemInfo(SYSRSC_MGR_SEGID_T *segid_p, UI32_T *seglen_p)
{
    *segid_p = SYSRSC_MGR_RULE_CTRL_SHMEM_SEGID;
    *seglen_p = sizeof(RULE_CTRL_ShmemData_T) + FP_CONFIG_GetShMemDataSize();
}

/* EXPORTED SUBPROGRAM SPECIFICATIONS
 */
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_InitiateSystemResources
 *------------------------------------------------------------------------------
 * PURPOSE  : Initial resource
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_InitiateSystemResources()
{
    BOOL_T  ret = TRUE;

    /* ES4626H-38-00062
       MUST configure fp before stacking complete
       to avoid HBT go through wrong queue
    */
    shmem_data_p = (RULE_CTRL_ShmemData_T *)SYSRSC_MGR_GetShMem(SYSRSC_MGR_RULE_CTRL_SHMEM_SEGID);
    SYSFUN_INITIATE_CSC_ON_SHMEM(shmem_data_p);

    // ret &= RULE_CTRL_LocalInitialize();
    // ret &= RULE_CTRL_TrapHbtWorkAroundToCPU();

    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Create_InterCSC_Relation
 *------------------------------------------------------------------------------
 * PURPOSE  : This function initializes all function pointer registration operations.
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
void RULE_CTRL_Create_InterCSC_Relation()
{

}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_EnterMasterMode
 *------------------------------------------------------------------------------
 * PURPOSE  : This function will make the rule ctrl enter the master mode.
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
void RULE_CTRL_EnterMasterMode()
{
    BOOL_T  ret = TRUE;

    /* once TCN, all fp MUST be re-configured */
    ret &= RULE_CTRL_LocalInitialize();

    ret &= RULE_CTRL_UpdateDevInfo();

#if 0/* fix bug ES3628BT-FLF-ZZ-000715, ISC packet enqueue 7 by TC in HG header, FP rule is not needed. */
    ret &= RULE_CTRL_TrapHbtWorkAroundToCPU(TRUE);
#endif
    if (FALSE == ret)
        PRINTF("\r\n[RULE_CTRL_EnterMasterMode] initialize error");

    SYSFUN_ENTER_MASTER_MODE_ON_SHMEM(shmem_data_p);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_EnterSlaveMode
 *------------------------------------------------------------------------------
 * PURPOSE  : This function will make the rule ctrl enter the slave mode.
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
void RULE_CTRL_EnterSlaveMode()
{
    BOOL_T  ret = TRUE;

    /* once TCN, all fp MUST be re-configured */
    ret &= RULE_CTRL_LocalInitialize();
#if 0/* fix bug ES3628BT-FLF-ZZ-000715, ISC packet enqueue 7 by TC in HG header, FP rule is not needed. */
    ret &= RULE_CTRL_TrapHbtWorkAroundToCPU(TRUE);
#endif
    if (FALSE == ret)
        PRINTF("\r\n[RULE_CTRL_EnterSlaveMode] initialize error");

    SYSFUN_ENTER_SLAVE_MODE_ON_SHMEM(shmem_data_p);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetTransitionMode
 *------------------------------------------------------------------------------
 * PURPOSE:  Set transition mode
 * INPUT:    None
 * OUTPUT:   None
 * RETURN:   None
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
void RULE_CTRL_SetTransitionMode()
{
    SYSFUN_SET_TRANSITION_MODE_ON_SHMEM(shmem_data_p);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_EnterTransitionMode
 *------------------------------------------------------------------------------
 * PURPOSE:  This function will make the rule ctrl enter the transition mode.
 * INPUT:    None
 * OUTPUT:   None
 * RETURN:   None
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
void RULE_CTRL_EnterTransitionMode()
{
    SYSFUN_ENTER_TRANSITION_MODE_ON_SHMEM(shmem_data_p);

    FP_CONFIG_Init();
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_HandleHotInsertion
 *------------------------------------------------------------------------------
 * PURPOSE:  .
 * INPUT:    None
 * OUTPUT:   None
 * RETURN:   None
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
void RULE_CTRL_HandleHotInsertion(UI32_T starting_port_ifindex, UI32_T number_of_port)
{
    UI32_T unit, port, trunk_id;

    RULE_CTRL_UpdateDevInfo();
    RULE_CTRL_Priv_SyncGroupPropertyToSlaverUnit();

    (void)number_of_port;

    if(SWCTRL_LPORT_NORMAL_PORT !=
        SWCTRL_POM_LogicalPortToUserPort(starting_port_ifindex, &unit, &port, &trunk_id))
        return;

#if (SYS_CPNT_QOS_V2 == TRUE)
    /* the following packets
     * Always configure to chip to trap to CPU
     */
    if (FALSE == RULE_CTRL_TrapPacket2CpuByUnit(unit, TRUE, RULE_TYPE_PacketType_ARP_REQUEST, NULL))
        PRINTF("\r\n[L4_MGR_EnterMasterMode] RULE_TYPE_PacketType_ARP_REQUEST failed");
    if (FALSE == RULE_CTRL_TrapPacket2CpuByUnit(unit, TRUE, RULE_TYPE_PacketType_ARP_REPLY, NULL))
        PRINTF("\r\n[L4_MGR_EnterMasterMode] RULE_TYPE_PacketType_ARP_REPLY failed");
    if (FALSE == RULE_CTRL_TrapPacket2CpuByUnit(unit, TRUE, RULE_TYPE_PacketType_RIP, NULL))
        PRINTF("\r\n[L4_MGR_EnterMasterMode] RULE_TYPE_PacketType_RIP failed");
    if (FALSE == RULE_CTRL_TrapPacket2CpuByUnit(unit, TRUE, RULE_TYPE_PacketType_OSPF, NULL))
        PRINTF("\r\n[L4_MGR_EnterMasterMode] RULE_TYPE_PacketType_OSPF failed");
#if (SYS_CPNT_OSPF6 == TRUE)
    /* added by steven.gao for OSPFv3 */
    if (FALSE == RULE_CTRL_TrapPacket2CpuByUnit(unit, TRUE, RULE_TYPE_PacketType_OSPF6, NULL))
        PRINTF("\r\n[L4_MGR_EnterMasterMode] RULE_TYPE_PacketType_OSPF6 failed");
#endif
    if (FALSE == RULE_CTRL_TrapPacket2CpuByUnit(unit, TRUE, RULE_TYPE_PacketType_DVMRP, NULL))
        PRINTF("\r\n[L4_MGR_EnterMasterMode] RULE_TYPE_PacketType_DVMRP failed");

    if (FALSE == RULE_CTRL_TrapPacket2CpuByUnit(unit, TRUE, RULE_TYPE_PacketType_PIM, NULL))
        PRINTF("\r\n[L4_MGR_EnterMasterMode] RULE_TYPE_PacketType_PIM failed");
    if (FALSE == RULE_CTRL_TrapPacket2CpuByUnit(unit, TRUE, RULE_TYPE_PacketType_VRRP, NULL))
        PRINTF("\r\n[L4_MGR_EnterMasterMode] RULE_TYPE_PacketType_VRRP failed");

    if (FALSE == RULE_CTRL_TrapPacket2CpuByUnit(unit, TRUE, RULE_TYPE_PacketType_L2_SLF, NULL))
        PRINTF("\r\n[L4_MGR_EnterMasterMode] RULE_TYPE_PacketType_L2_SLF failed");
    if (FALSE == RULE_CTRL_TrapPacket2CpuByUnit(unit, TRUE, RULE_TYPE_PacketType_IP_BCAST, NULL))
        PRINTF("\r\n[L4_MGR_EnterMasterMode] RULE_TYPE_PacketType_IP_BCAST failed");
    if (FALSE == RULE_CTRL_TrapPacket2CpuByUnit(unit, TRUE, RULE_TYPE_PacketType_ALL_HOST, NULL))
        PRINTF("\r\n[L4_MGR_EnterMasterMode] RULE_TYPE_PacketType_ALL_HOST failed");
    if (FALSE == RULE_CTRL_TrapPacket2CpuByUnit(unit, TRUE, RULE_TYPE_PacketType_ALL_ROUTER, NULL))
        PRINTF("\r\n[L4_MGR_EnterMasterMode] RULE_TYPE_PacketType_ALL_ROUTER failed");
    if (FALSE == RULE_CTRL_TrapPacket2CpuByUnit(unit, TRUE, RULE_TYPE_PacketType_MY_MAC_MY_IP, NULL))
        PRINTF("\r\n[L4_MGR_EnterMasterMode] RULE_TYPE_PacketType_MY_MAC_MY_IP failed");
    if (FALSE == RULE_CTRL_TrapPacket2CpuByUnit(unit, TRUE, RULE_TYPE_PacketType_IP_OPTION, NULL))
        PRINTF("\r\n[L4_MGR_EnterMasterMode] RULE_TYPE_PacketType_IP_OPTION failed");
    if (FALSE == RULE_CTRL_TrapPacket2CpuByUnit(unit, TRUE, RULE_TYPE_PacketType_BPDU, NULL))
        PRINTF("\r\n[L4_MGR_EnterMasterMode] RULE_TYPE_PacketType_BPDU failed");
    if (FALSE == RULE_CTRL_TrapPacket2CpuByUnit(unit, TRUE, RULE_TYPE_PacketType_L2CP, NULL))
        PRINTF("\r\n[L4_MGR_EnterMasterMode] RULE_TYPE_PacketType_L2CP failed");

#if (SYS_CPNT_IPV6 == TRUE)
    if (FALSE == RULE_CTRL_TrapPacket2CpuByUnit(unit, TRUE, RULE_TYPE_PacketType_IPV6_ALL_NODES, NULL))
        PRINTF("\r\n[L4_MGR_EnterMasterMode] RULE_TYPE_PacketType_IPV6_ALL_NODES failed");
    if (FALSE == RULE_CTRL_TrapPacket2CpuByUnit(unit, TRUE, RULE_TYPE_PacketType_IPV6_ALL_ROUTERS, NULL))
        PRINTF("\r\n[L4_MGR_EnterMasterMode] RULE_TYPE_PacketType_IPV6_ALL_ROUTERS failed");
#endif /* SYS_CPNT_IPV6 */
#endif /* SYS_CPNT_QOS_V2 */
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_HandleHotRemoval
 *------------------------------------------------------------------------------
 * PURPOSE:  .
 * INPUT:    None
 * OUTPUT:   None
 * RETURN:   None
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
void RULE_CTRL_HandleHotRemoval(
    UI32_T starting_port_ifindex,
    UI32_T number_of_port)
{
#define RULE_CTRL_UNIT_DEVICE_ID_TO_INDEX(unit, device)  \
    ( ((unit)-1) * SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT + (device) )

    UI32_T                          end_port_ifindex;

    UI32_T                          starting_unit, starting_device_id, starting_port;
    UI32_T                          end_unit, end_device_id, end_port;
    UI32_T                          starting_device_index, end_device_index;

    UI32_T                          module_id, device_id, phy_port;
    RULE_CTRL_FindRuleLookupTable_T find;

    RULE_CTRL_LOG("Hot Removal starting_ifindex=%lu, #port=%lu", starting_port_ifindex, number_of_port);

    RULE_CTRL_UpdateDevInfo();

    if (0 == number_of_port)
    {
        return;
    }

    end_port_ifindex = starting_port_ifindex + (number_of_port-1);

    starting_unit = STKTPLG_OM_IFINDEX_TO_UNIT(starting_port_ifindex);
    starting_port = STKTPLG_OM_IFINDEX_TO_PORT(starting_port_ifindex);

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(starting_unit, starting_port,
                                                        &module_id, &starting_device_id, &phy_port))
    {
        RULE_CTRL_LOG("Invalid starting_port_ifindex(%lu) [unit(%lu), port(%lu)]",
                      starting_port_ifindex,
                      starting_unit,
                      starting_port);
        return;
    }

    end_unit = STKTPLG_OM_IFINDEX_TO_UNIT(end_port_ifindex);
    end_port = STKTPLG_OM_IFINDEX_TO_PORT(end_port_ifindex);

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(end_unit, end_port,
                                                        &module_id, &end_device_id, &phy_port))
    {
        RULE_CTRL_LOG("Invalid number_of_port(%lu) [unit(%lu), port(%lu)]",
                      number_of_port,
                      end_unit,
                      end_port);
        return;
    }

    starting_device_index = RULE_CTRL_UNIT_DEVICE_ID_TO_INDEX(starting_unit, starting_device_id);
    end_device_index      = RULE_CTRL_UNIT_DEVICE_ID_TO_INDEX(end_unit, end_device_id);

    RULE_CTRL_LOG("From uport=%lu/%lu to %lu/%lu, device=%lu to %lu",
                  starting_unit, starting_port,
                  end_unit, end_port,
                  starting_device_index, end_device_index);

    find.flag       = RULE_CTRL_FIND_NEXT_EXISTED_RULE_ENTRY;
    find.unit       = RULE_CTRL_INVALID;
    find.device_id  = RULE_CTRL_INVALID;
    find.group_id   = RULE_CTRL_INVALID;
    find.rule_id    = RULE_CTRL_INVALID;

    while (TRUE == RULE_CTRL_GetNextRuleEntryInLookupTable(&find))
    {
        switch (find.existed_p->code.type)
        {
        case RULE_CTRL_RT_GLOBAL_RULE:
            {
                UI32_T  index = RULE_CTRL_UNIT_DEVICE_ID_TO_INDEX(find.existed_p->GR.unit,
                                                                  find.existed_p->GR.device);

                if (starting_device_index <= index && index <= end_device_index)
                {
                    UI32_T                          unit;
                    UI32_T                          dummy_port = 1;
                    UI32_T                          device_id;
                    UI32_T                          group_id;
                    int                             rule_pri;
                    UI32_T                          rule_id;
                    RULE_CTRL_SYS_RULE_STORAGE_PTR  rs_p;
                    RULE_CTRL_PARAM                 param;

                    if (FALSE == RULE_CTRL_GetParamFromLookupEntry(find.existed_p, &param))
                    {
                        break;
                    }

                    rs_p = param.sys_rule_storage_p;

                    unit = find.existed_p->GR.unit;
                    device_id = find.existed_p->GR.device;

                    rule_id = rs_p->rule_id[unit-1][device_id];

                    if (FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(param.func_type, &group_id, &rule_pri))
                    {
                        RULE_CTRL_LOG("RULE_CTRL_GetFunctionInfoByFunctionType(func_type = %d)",
                                      param.func_type);
                    }
                    else
                    {
                        /* TODO: RULE_CTRL_Destroy_Rule must need to check port is exist
                         */
                        RULE_CTRL_DESTROY_RULE(unit,
                                               dummy_port,
                                               device_id,
                                               group_id,
                                               param.func_type,
                                               rule_id);

                        RULE_CTRL_RemoveRuleFromLookupTable(unit,
                                                            dummy_port,
                                                            device_id,
                                                            group_id,
                                                            rule_id);
                    }

                    rs_p->rule_id[unit-1][device_id] = 0;

                    /* clean rs_p->is_enable flag if no any rule on it
                     */
                    {
                        UI32_T __unit, __device;
                        BOOL_T zero = TRUE;

                        for (__unit=0; __unit<SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; __unit++)
                        {
                            for (__device=0; __device<SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT; __device++)
                            {
                                if (rs_p->rule_id[__unit][__device] != 0)
                                {
                                    zero = FALSE;
                                    break;
                                }
                            }

                            if (!zero)
                            {
                                break;
                            }
                        }

                        if (zero)
                        {
                            rs_p->is_enable = FALSE;

                            if (FALSE == RULE_CTRL_RequestRuleByQuota(__unit+1, __device, param.func_type,
                                                                      RULE_CTRL_REQUEST_RESOURCE_FREE,
                                                                      1))
                            {
                                RULE_CTRL_LOG("RULE_CTRL_RequestRuleByQuota(func_type=%d) failed", param.func_type);
                            }
                        }
                    }
                }
            }

            break;

        case RULE_CTRL_RT_PORT_RULE:
            {
                UI32_T ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(find.existed_p->PR.unit,
                                                             find.existed_p->PR.port);

                if (starting_port_ifindex <= ifindex && ifindex <= end_port_ifindex)
                {
                    UI32_T                      group_id;
                    int                         rule_pri;
                    RULE_CTRL_RULE_STORAGE_PTR  rs_p;
                    RULE_CTRL_PARAM             param;

                    if (FALSE == RULE_CTRL_GetParamFromLookupEntry(find.existed_p, &param))
                    {
                        break;
                    }

                    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param.unit, param.port,
                                                                        &module_id, &device_id, &phy_port))
                    {
                        RULE_CTRL_LOG("Invalid unit(%lu) and port(%lu)", param.unit,
                                                                         param.port);
                        break;
                    }

                    rs_p = param.rule_storage_p;

                    /* TODO: need to call RULE_CTRL_Destroy_Rule for accounting rule number
                     */
                    /* TODO: move RULE_CTRL_RemoveRuleFromLookupTable into RULE_CTRL_Destroy_Rule
                     */
                    if (FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(param.func_type, &group_id, &rule_pri))
                    {
                        RULE_CTRL_LOG("RULE_CTRL_GetFunctionInfoByFunctionType(func_type = %d)",
                                      param.func_type);
                    }
                    else
                    {
                        /* TODO: RULE_CTRL_Destroy_Rule must need to check port is exist
                         */
                        RULE_CTRL_DESTROY_RULE(param.unit,
                                               param.port,
                                               device_id,
                                               group_id,
                                               param.func_type,
                                               rs_p->rule_id);

                        RULE_CTRL_RemoveRuleFromLookupTable(param.unit,
                                                            param.port,
                                                            device_id,
                                                            group_id,
                                                            rs_p->rule_id);
                    }

                    rs_p->is_enable = FALSE;
                    rs_p->rule_id = 0;

                    if (FALSE == RULE_CTRL_RequestRuleByQuota(param.unit, device_id, param.func_type,
                                                              RULE_CTRL_REQUEST_RESOURCE_FREE,
                                                              1))
                    {
                        RULE_CTRL_LOG("RULE_CTRL_RequestRuleByQuota(func_type=%d) failed", param.func_type);
                    }
                }
            }

            break;

        case RULE_CTRL_RT_SHARED_PORT_RULE:
            {
                UI32_T ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(find.existed_p->SPR.unit,
                                                             find.existed_p->SPR.port);

                if (starting_port_ifindex <= ifindex && ifindex <= end_port_ifindex)
                {
                    UI32_T                      group_id;
                    int                         rule_pri;
                    RULE_CTRL_SPRRuleStorage_T  *rs_p;
                    RULE_CTRL_PARAM             param;

                    if (FALSE == RULE_CTRL_GetParamFromLookupEntry(find.existed_p, &param))
                    {
                        break;
                    }

                    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param.unit, param.port,
                                                                        &module_id, &device_id, &phy_port))
                    {
                        RULE_CTRL_LOG("Invalid unit(%lu) and port(%lu)", param.unit,
                                                                         param.port);
                        break;
                    }

                    rs_p = (RULE_CTRL_SPRRuleStorage_T*)param.rule_storage_p;

                    DEVRM_PBMP_CLEAR(rs_p->pbmp);

                    if (FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(param.func_type, &group_id, &rule_pri))
                    {
                        RULE_CTRL_LOG("RULE_CTRL_GetFunctionInfoByFunctionType(func_type = %d)",
                                      param.func_type);
                    }
                    else
                    {
                        /* TODO: RULE_CTRL_Destroy_Rule must need to check port is exist
                         */
                        RULE_CTRL_DESTROY_RULE(param.unit,
                                               param.port,
                                               device_id,
                                               group_id,
                                               param.func_type,
                                               rs_p->rule_storage.rule_id);

                        RULE_CTRL_RemoveRuleFromLookupTable(param.unit,
                                                            param.port,
                                                            device_id,
                                                            group_id,
                                                            rs_p->rule_storage.rule_id);
                    }


                    rs_p->rule_storage.is_enable = FALSE;
                    rs_p->rule_storage.rule_id = 0;

                    if (FALSE == RULE_CTRL_RequestRuleByQuota(param.unit, device_id,
                                                              param.func_type,
                                                              RULE_CTRL_REQUEST_RESOURCE_FREE,
                                                              1))
                    {
                        RULE_CTRL_LOG("RULE_CTRL_RequestRuleByQuota(func_type=%d) failed", param.func_type);
                    }
                }
            }

            break;
        }
    }

    /* TODO: Now we clean the user port interface when received hot removal event.
     * But, we also need to clean the rule instance for 'all-ports' or 'trunk'
     * interface.
     */
    {
        UI32_T _ifindex;

        for (_ifindex = starting_port_ifindex; _ifindex < end_port_ifindex; ++ _ifindex)
        {
            RULE_TYPE_INTERFACE_INFO_T interface;

            RULE_CTRL_Ifindex_To_Interface(_ifindex, &interface);

            for (interface.direction = RULE_TYPE_INBOUND; interface.direction <= RULE_TYPE_OUTBOUND; ++ interface.direction)
            {
                RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;
                RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;
                RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T iter;

                if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
                if (NULL == if_entry_p)
                {
                    continue;
                }

                RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                          &if_class_obj);

                if_class_obj.get_element_iterator(&if_class_obj, &iter);

                for (iter.last(&iter); NULL != iter.get_instance(&iter); iter.last(&iter))
                {
                    RULE_TYPE_SHM_POINTER_T child = iter.get_ptr(&iter);

                    if_class_obj.remove(&if_class_obj, RULE_CTRL_IN_Ptr2Instance(child));

                    if (TRUE == RULE_CTRL_IS_CONTAINER_TYPE(child.type))
                    {
                        RULE_CTRL_IN_Priv_DestroyContainer(child);
                    }
                    else if (TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(child.type))
                    {
                        RULE_CTRL_IN_Priv_DestroyClassInstance(child);
                    }
                    else if (TRUE == RULE_CTRL_IS_RULE_INSTANCE_TYPE(child.type))
                    {
                        RULE_CTRL_IN_Priv_DestroyRuleInstance(child);
                    }
                }
            }
        }
    }

    {
        UI32_T _unit;
        UI32_T _device_id;
        UI32_T _group_id;

        for (_unit = starting_unit; _unit <= end_unit; ++_unit)
        {
            for (_device_id = starting_device_id; _device_id <= end_device_id; ++_device_id)
            {
                for (_group_id = 0; _group_id < SYS_ADPT_FP_MAX_NBR_OF_GROUP_PER_CHIP; ++_group_id)
                {
                    RULE_CTRL_ResourceInfo_T *res_p = RULE_CTRL_GetResourceInfo(_unit, _device_id, _group_id);

                    ASSERT(NULL != res_p);

                    res_p->free_rule = res_p->total_rule;
                }
            }
        }
    }

#undef RULE_CTRL_UNIT_DEVICE_TO_INDEX
}

void
RULE_CTRL_HotRemoval_FreeRuleGroup(
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p)
{
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T   class_inst_obj;

    if (NULL != class_inst_p &&
        RULE_TYPE_NIL != class_inst_p->super.type)
    {
        ASSERT(RULE_TYPE_INST_ACL == class_inst_p->super.type ||
               RULE_TYPE_INST_POLICY_MAP == class_inst_p->super.type);

        RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_inst_p, &class_inst_obj);

        RULE_CTRL_IN_Priv_DestroyClassInstanceObject(&class_inst_obj);
    }
}

/* Handle Timer Event */
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_ProcessTimerEvent
 *------------------------------------------------------------------------------
 * PURPOSE: Process timer alarm event from timer
 * INPUT:  None
 * OUTPUT: None
 * RETURN: TRUE/FALSE
 * NOTES:  None
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_ProcessTimerEvent()
{
    if (SYSFUN_GET_CSC_OPERATING_MODE_ON_SHMEM(shmem_data_p) != SYS_TYPE_STACKING_MASTER_MODE)
    {
        return TRUE;
    }

#if (SYS_CPNT_QOS_V2_SOFTWARE_BUNDLE_RATE_CONTROL == TRUE)
    {
        UI32_T port;

        for (port = 1; port <= SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT; ++port)
        {
            RULE_CTRL_LocalBundleRateControlProcessTimerEvent(port);
        }
    }
#endif /* #if (SYS_CPNT_QOS_V2_SOFTWARE_BUNDLE_RATE_CONTROL == TRUE) */

    return TRUE;
} /* END FUNCTION - BOOL_T RULE_CTRL_ProcessTimerEvent() */

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_FieldInit
 *------------------------------------------------------------------------------
 * PURPOSE:  This function will make the rule ctrl clear the chip of the slave.
 * INPUT:    None
 * OUTPUT:   None
 * RETURN:   None
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
void RULE_CTRL_FieldInit()
{
    DEVRM_PMGR_FieldInit();
}

#pragma mark -
#pragma mark ACL / Diffserv Functions

/** ACL / Diffserv Functions
 */

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_AddClassMapConfig
 *------------------------------------------------------------------------------
 * PURPOSE  : add class-map config on chip for every ports bound with specific policy-map and class-map
 * INPUT    : policy_map_index, class_map_index
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : 1, if there is nothing to config, return TRUE (do nothing)
 *            2, this func used when a policy-map already config to chip and dynamically add a class-map
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_AddClassMapConfig(UI32_T policy_map_index, UI32_T class_map_index)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CTRL_EnterCriticalSection();

    result = RULE_CTRL_LocalSyncClassMap2DEV(policy_map_index, class_map_index);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Failed to update meter");
        RULE_CTRL_LeaveCriticalSectionReturnState(result);
    }

    RULE_CTRL_LeaveCriticalSection();

    result = RULE_OM_AddCosReference(policy_map_index, class_map_index);
    if (RULE_TYPE_OK != result)
        return result;

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_AddClassMapElementConfig
 *------------------------------------------------------------------------------
 * PURPOSE  : add class-map element config on chip for every ports bound
 *            with specific class-map
 * INPUT    : class_map_index, class_type, class_index
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : if there is nothing to config, return TRUE (do nothing)
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_AddClassMapElementConfig(UI32_T class_map_index, RULE_TYPE_ClassType_T class_type, UI32_T class_index)
{
    RULE_TYPE_RETURN_TYPE_T result;
    UI32_T i;

#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
    if(class_type == RULE_TYPE_CLASS_ACL)
    {
        RULE_TYPE_Acl_T acl_entry;

        result = RULE_OM_GetAclByIndex(class_index, &acl_entry);
        if (RULE_TYPE_OK != result)
        {
            return result;
        }
        if (TRUE == acl_entry.flag_aggregate_done)
        {
            class_index = acl_entry.aggregate_acl_index;
        }
    }
#endif

    RULE_CTRL_EnterCriticalSection();

    for (i = 0; i < _countof(shmem_data_p->if_table); ++ i)
    {
        RULE_TYPE_INTERFACE_INFO_T interface;
        //
        // --== Duplicated code start
        //
        RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

        RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

        RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;
        RULE_CTRL_INSTANCE_TYPE_ID_T find_param;
        //
        // --== End of duplicated code
        //

        RULE_CTRL_Priv_IfEntry_Index_To_Interface(i, &interface);

        //
        // --== Duplicated code start
        //
        if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
        ASSERT(NULL != if_entry_p);

        RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                  &if_class_obj);

        memset(&find_param, 0, sizeof(find_param));

        find_param.type = RULE_TYPE_INST_POLICY_MAP;

        policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                           RULE_CTRL_Priv_IsClassInstanceMatchType,
                                                                                           &find_param);
        //
        // --== End of duplicated code
        //

        while (NULL != policy_map_inst_p)
        {
            RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p;
            RULE_CTRL_INSTANCE_TYPE_ID_T class_map_find_param;

            memset(&class_map_find_param, 0, sizeof(class_map_find_param));

            class_map_find_param.type = RULE_TYPE_INST_CLASS_MAP;
            class_map_find_param.id = class_map_index;

            /** assumption: a class-map can not bind in a policy-map twice
             */
            class_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_IN_Priv_FindIf((RULE_TYPE_INSTANCE_PTR_T)policy_map_inst_p,
                                                                                        RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                        &class_map_find_param);
            if (NULL != class_map_inst_p)
            {
                RULE_TYPE_PolicyElement_T policy_element;

                ASSERT(class_map_inst_p->id == class_map_index);

                result = RULE_OM_GetPolicyMapElementEntry(policy_map_inst_p->id, class_map_inst_p->id, &policy_element);
                ASSERT(RULE_TYPE_OK == result);

                if (RULE_TYPE_OK != result)
                {
                    RULE_CTRL_LeaveCriticalSection();
                    goto undo;
                }

                ASSERT(policy_element.class_map_index == class_map_index);

                if (RULE_TYPE_CLASS_MF == class_type)
                {
                    result = RULE_CTRL_LocalSetMF2DEV(&interface, policy_map_inst_p->id, class_map_inst_p->id,
                                                      class_index, policy_element.meter_index, policy_element.action_index);
                    if (RULE_TYPE_OK != result)
                    {
                        RULE_CTRL_LeaveCriticalSection();
                        goto undo;
                    }
                }
                else if (RULE_TYPE_CLASS_ACL == class_type)
                {
                    result = RULE_CTRL_LocalSetQoSACL2DEV(&interface, policy_map_inst_p->id, class_map_inst_p->id,
                                                          class_index, policy_element.meter_index, policy_element.action_index);
                    if (RULE_TYPE_OK != result)
                    {
                        RULE_CTRL_LeaveCriticalSection();
                        goto undo;
                    }
                }
                else
                {
                    RULE_CTRL_LeaveCriticalSection();
                    ASSERT(0);
                    goto undo;
                }
            }

            policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetNextSiblingIf((RULE_TYPE_INSTANCE_PTR_T)policy_map_inst_p,
                                                                                                RULE_CTRL_Priv_IsClassInstanceMatchType,
                                                                                                &find_param);
        }
    }

    RULE_CTRL_LeaveCriticalSection();

    return RULE_TYPE_OK;

undo:
    {
        RULE_TYPE_RETURN_TYPE_T temp_result;

        temp_result = RULE_CTRL_RemoveClassMapElementConfig(class_map_index, class_type, class_index);
        ASSERT(RULE_TYPE_OK == temp_result);
    }

    ASSERT(RULE_TYPE_OK != result);

    return result;
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_AddMeterConfig
 *------------------------------------------------------------------------------
 * PURPOSE  : add meter config on chip for every ports bound with specific policy-map and class-map
 * INPUT    : policy_map_index, class_map_index
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : if there is nothing to config, return TRUE (do nothing)
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_AddMeterConfig(UI32_T policy_map_index, UI32_T class_map_index)
{
    RULE_TYPE_RETURN_TYPE_T     result;

    RULE_CTRL_EnterCriticalSection();

    result = RULE_CTRL_LocalSyncClassMap2DEV(policy_map_index, class_map_index);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Failed to update meter");
        RULE_CTRL_LeaveCriticalSectionReturnState(result);
    }

    RULE_CTRL_LeaveCriticalSectionReturnState(RULE_TYPE_OK);
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_UpdateMeterConfig
 *------------------------------------------------------------------------------
 * PURPOSE  : update meter config on chip for every ports bound with specific policy-map and class-map
 * INPUT    : policy_map_index, class_map_index
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : if there is nothing to config, return TRUE (do nothing)
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_UpdateMeterConfig(UI32_T policy_map_index, UI32_T class_map_index)
{
    RULE_TYPE_RETURN_TYPE_T     result;

    RULE_CTRL_EnterCriticalSection();

    result = RULE_CTRL_LocalSyncClassMap2DEV(policy_map_index, class_map_index);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Failed to update meter");
        RULE_CTRL_LeaveCriticalSectionReturnState(result);
    }

    RULE_CTRL_LeaveCriticalSectionReturnState(RULE_TYPE_OK);
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_UpdateActionConfig
 *------------------------------------------------------------------------------
 * PURPOSE  : update action config on chip for every ports bound with specific policy-map and class-map
 * INPUT    : policy_map_index, class_map_index
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : if there is nothing to config, return TRUE (do nothing)
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_UpdateActionConfig(UI32_T policy_map_index, UI32_T class_map_index)
{
    RULE_TYPE_RETURN_TYPE_T     result;

    RULE_CTRL_EnterCriticalSection();

    result = RULE_CTRL_LocalSyncClassMap2DEV(policy_map_index, class_map_index);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Failed to update action");
        RULE_CTRL_LeaveCriticalSectionReturnState(result);
    }

    RULE_CTRL_LeaveCriticalSection();

    /* remove cos reference first because action may reference COS no more */
    RULE_OM_RemoveCosReference(policy_map_index, class_map_index);

    result = RULE_OM_AddCosReference(policy_map_index, class_map_index);
    if (RULE_TYPE_OK != result)
        return result;

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_RemoveClassMapConfig
 *------------------------------------------------------------------------------
 * PURPOSE  : remove class-map config on chip for every ports bound with specific policy-map and class-map
 * INPUT    : policy_map_index, class_map_index
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : if there is nothing to free, return TRUE (do nothing)
 *            free_cos_reference = TRUE implies need to free CoS reference
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_RemoveClassMapConfig(UI32_T policy_map_index, UI32_T class_map_index, BOOL_T free_cos_reference)
{
    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T i;
    //
    // --== Duplicated code start
    //
    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;
    RULE_CTRL_INSTANCE_TYPE_ID_T param;
    //
    // --== End of duplicated code
    //

    RULE_TYPE_PolicyMap_T       policy_map;

    RULE_TYPE_ClassMap_T        class_map;
    RULE_TYPE_PolicyElement_T   policy_element;

    result = RULE_OM_GetPolicyMap(policy_map_index, &policy_map);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    result = RULE_OM_GetClassMap(class_map_index, &class_map);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    result = RULE_OM_GetPolicyMapElementFromPolicyMapByClassMap(policy_map_index, class_map_index, &policy_element);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    RULE_CTRL_EnterCriticalSection();

    for (i = 0; i < _countof(shmem_data_p->if_table); ++ i)
    {
        RULE_TYPE_INTERFACE_INFO_T interface;

        RULE_CTRL_Priv_IfEntry_Index_To_Interface(i, &interface);

        //
        // --== Duplicated code start
        //
        if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
        ASSERT(NULL != if_entry_p);

        RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                  &if_class_obj);

        memset(&param, 0, sizeof(param));

        param.type = RULE_TYPE_INST_POLICY_MAP;
        param.id = policy_map_index;

        policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                           RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                           &param);
        //
        // --== End of duplicated code
        //
        if (NULL == policy_map_inst_p)
        {
            continue;
        }

        result = RULE_CTRL_LocalRemoveClassMap2DEV(&interface, policy_map_index, &policy_map,
                                                   policy_map_inst_p,
                                                   policy_element.class_map_index,
                                                   policy_element.meter_index,
                                                   policy_element.action_index);
        ASSERT(RULE_TYPE_OK == result);
        if (RULE_TYPE_OK != result)
        {
            continue;
        }
    }

    RULE_CTRL_LeaveCriticalSection();

    if (TRUE == free_cos_reference)
        RULE_OM_RemoveCosReference(policy_map_index, class_map_index);

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_RemoveClassMapElementConfig
 *------------------------------------------------------------------------------
 * PURPOSE  : remove class-map element config on chip for every ports bound with specific class-map
 * INPUT    : class_map_index, class_type, class_index
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : if there is nothing to free, return TRUE (do nothing)
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_RemoveClassMapElementConfig(UI32_T class_map_index, RULE_TYPE_ClassType_T class_type, UI32_T class_index)
{
    RULE_TYPE_RETURN_TYPE_T result;
    UI32_T i;

#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
    if(class_type == RULE_TYPE_CLASS_ACL)
    {
        RULE_TYPE_Acl_T acl_entry;

        result = RULE_OM_GetAclByIndex(class_index, &acl_entry);
        if (RULE_TYPE_OK != result)
        {
            return result;
        }
        if (TRUE == acl_entry.flag_aggregate_done)
        {
            class_index = acl_entry.aggregate_acl_index;
        }
    }
#endif

    RULE_CTRL_EnterCriticalSection();

    for (i = 0; i < _countof(shmem_data_p->if_table); ++ i)
    {
        RULE_TYPE_INTERFACE_INFO_T interface;
        //
        // --== Duplicated code start
        //
        RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

        RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

        RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;
        RULE_CTRL_INSTANCE_TYPE_ID_T find_param;
        //
        // --== End of duplicated code
        //

        RULE_CTRL_Priv_IfEntry_Index_To_Interface(i, &interface);

        //
        // --== Duplicated code start
        //
        if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
        ASSERT(NULL != if_entry_p);

        RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                  &if_class_obj);

        memset(&find_param, 0, sizeof(find_param));

        find_param.type = RULE_TYPE_INST_POLICY_MAP;

        policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                           RULE_CTRL_Priv_IsClassInstanceMatchType,
                                                                                           &find_param);
        //
        // --== End of duplicated code
        //

        while (NULL != policy_map_inst_p)
        {
            RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p;
            RULE_CTRL_INSTANCE_TYPE_ID_T class_map_find_param;

            memset(&class_map_find_param, 0, sizeof(class_map_find_param));

            class_map_find_param.type = RULE_TYPE_INST_CLASS_MAP;
            class_map_find_param.id = class_map_index;

            /** assumption: a class-map can not bind in a policy-map twice
             */
            class_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_IN_Priv_FindIf((RULE_TYPE_INSTANCE_PTR_T)policy_map_inst_p,
                                                                                        RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                        &class_map_find_param);
            if (NULL != class_map_inst_p)
            {
                RULE_TYPE_PolicyElement_T policy_element;

                ASSERT(class_map_inst_p->id == class_map_index);

                result = RULE_OM_GetPolicyMapElementEntry(policy_map_inst_p->id, class_map_inst_p->id, &policy_element);
                ASSERT(RULE_TYPE_OK == result);

                if (RULE_TYPE_OK != result)
                {
                    continue;
                }

                ASSERT(policy_element.class_map_index == class_map_index);

                if (RULE_TYPE_CLASS_MF == class_type)
                {
                    result = RULE_CTRL_LocalRemoveMF2DEV(&interface, policy_map_inst_p->id, class_map_inst_p->id,
                                                      class_index, policy_element.meter_index, policy_element.action_index);
                    ASSERT(RULE_TYPE_OK == result);
                }
                else if (RULE_TYPE_CLASS_ACL == class_type)
                {
                    result = RULE_CTRL_LocalRemoveQoSACL2DEV(&interface, policy_map_inst_p->id, class_map_inst_p->id,
                                                             class_index, policy_element.meter_index, policy_element.action_index);
                    ASSERT(RULE_TYPE_OK == result);
                }
                else
                {
                    ASSERT(0);
                }
            }

            policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetNextSiblingIf((RULE_TYPE_INSTANCE_PTR_T)policy_map_inst_p,
                                                                                                RULE_CTRL_Priv_IsClassInstanceMatchType,
                                                                                                &find_param);
        }
    }

    RULE_CTRL_LeaveCriticalSection();

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_RemoveMeterConfig
 *------------------------------------------------------------------------------
 * PURPOSE  : remove meter config on chip for every ports bound with specific policy-map and class-map
 * INPUT    : policy_map_index, class_map_index
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : if there is nothing to free, return TRUE (do nothing)
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_RemoveMeterConfig(UI32_T policy_map_index, UI32_T class_map_index)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_CTRL_EnterCriticalSection();

    result = RULE_CTRL_LocalSyncClassMap2DEV(policy_map_index, class_map_index);
    if (RULE_TYPE_OK != result)
    {
        RULE_CTRL_LeaveCriticalSectionReturnState(result);
    }

    RULE_CTRL_LeaveCriticalSectionReturnState(RULE_TYPE_OK);
}

/* rule */
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetAce
 *------------------------------------------------------------------------------
 * PURPOSE:  Set a ACE entry.
 * INPUT:    acl_id, rule_entry
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_SetAce(
    UI32_T acl_id,
    const RULE_TYPE_Ace_Entry_T *ace_entry_p,
    BOOL_T is_add)
{
    RULE_TYPE_RETURN_TYPE_T result;
    RULE_TYPE_Acl_T         acl_entry;

    result = RULE_OM_GetAclByIndex(acl_id, &acl_entry);
    if (RULE_TYPE_OK != result)
        return result;

    RULE_CTRL_EnterCriticalSection();

    if (is_add == TRUE)
    {
        result = RULE_CTRL_LocalAddAce2DEV(acl_id, &acl_entry, ace_entry_p);
    }
    else
    {
        result = RULE_CTRL_LocalRemoveAceFromDEV(acl_id, &acl_entry, ace_entry_p);
    }

#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)
    if (RULE_TYPE_INSUFFICIENT_RESOURCE == result)
    {
        RULE_TYPE_InOutDirection_T direction = RULE_TYPE_BOTH_DIRECTION;

        result = RULE_CTRL_Priv_DefragRule(direction, acl_id, NULL, NULL, NULL);
    }
#endif /* SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT */

    RULE_CTRL_LeaveCriticalSectionReturnState(result);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetQoSAcl
 *------------------------------------------------------------------------------
 * PURPOSE:  Set a rule entry.
 * INPUT:    unit, port, acl_id, meter_id, action_id, is_add
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_SetQoSAcl(
    UI32_T ifindex,
    RULE_TYPE_InOutDirection_T direction,
    UI32_T policy_map_index,
    UI32_T class_map_index,
    UI32_T acl_id,
    UI32_T meter_id,
    UI32_T action_id,
    BOOL_T is_add)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_INTERFACE_INFO_T interface;

    memset(&interface, 0, sizeof(interface));

    result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    interface.direction = direction;

    if (RULE_TYPE_INTERFACE_UPORT != interface.type &&
        RULE_TYPE_INTERFACE_CPU_PORT != interface.type)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    if (RULE_TYPE_INBOUND != interface.direction &&
        RULE_TYPE_OUTBOUND != interface.direction)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    if (RULE_TYPE_INTERFACE_UPORT == interface.type)
    {
        UI32_T module_id;
        UI32_T device_id;
        UI32_T phy_port;

        module_id = 0;
        device_id = 0;
        phy_port  = 0;

        if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(interface.uport.unit,
                                                            interface.uport.port,
                                                            &module_id,
                                                            &device_id,
                                                            &phy_port))
        {
            LOG("<Error> Invalid parameter");
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }
    else if (RULE_TYPE_INTERFACE_CPU_PORT == interface.type)
    {
        if (RULE_TYPE_OUTBOUND != interface.direction)
        {
            LOG("<Error> Invalid parameter");
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }

#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
    {
        RULE_TYPE_Acl_T acl_entry;

        result = RULE_OM_GetAclByIndex(acl_id, &acl_entry);
        if (RULE_TYPE_OK != result)
        {
            return result;
        }
        if (TRUE == acl_entry.flag_aggregate_done)
        {
            acl_id = acl_entry.aggregate_acl_index;
        }
    }
#endif

    RULE_CTRL_EnterCriticalSection();

    if (TRUE == is_add)
    {
        result = RULE_CTRL_LocalSetQoSACL2DEV(&interface,
                                              policy_map_index,
                                              class_map_index,
                                              acl_id,
                                              meter_id,
                                              action_id);
    }
    else
    {
        result = RULE_CTRL_LocalRemoveQoSACL2DEV(&interface,
                                                 policy_map_index,
                                                 class_map_index,
                                                 acl_id,
                                                 meter_id,
                                                 action_id);
    }

    RULE_CTRL_LeaveCriticalSectionReturnState(result);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetAcl
 *------------------------------------------------------------------------------
 * PURPOSE:  Set a rule entry.
 * INPUT:    is_ingress, unit, port, acl_id, is_trunk, is_add, time_range_index
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_SetAcl(
    UI32_T ifindex,
    RULE_TYPE_InOutDirection_T direction,
    UI32_T acl_id,
    BOOL_T is_add,
    UI32_T time_range_index,
    RULE_TYPE_COUNTER_ENABLE_T counter_enable)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_INTERFACE_INFO_T interface;

    RULE_TYPE_Acl_T acl_entry;

    memset(&interface, 0, sizeof(interface));

    result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    interface.direction = direction;

    if (RULE_TYPE_INTERFACE_UPORT != interface.type)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    if (RULE_TYPE_INBOUND != interface.direction &&
        RULE_TYPE_OUTBOUND != interface.direction)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    if (RULE_TYPE_INTERFACE_UPORT == interface.type)
    {
        UI32_T module_id;
        UI32_T device_id;
        UI32_T phy_port;

        module_id = 0;
        device_id = 0;
        phy_port  = 0;

        if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(interface.uport.unit,
                                                            interface.uport.port,
                                                            &module_id,
                                                            &device_id,
                                                            &phy_port))
        {
            LOG("<Error> Invalid parameter");
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }
    else if (RULE_TYPE_INTERFACE_CPU_PORT == interface.type)
    {
        if (RULE_TYPE_OUTBOUND != interface.direction)
        {
            LOG("<Error> Invalid parameter");
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }

    RULE_CTRL_EnterCriticalSection();

    result = RULE_OM_GetAclByIndex(acl_id, &acl_entry);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Invalid parameter");
        RULE_CTRL_LeaveCriticalSectionReturnState(result);
    }

    if (TRUE == is_add)
    {
        result = RULE_CTRL_LocalSetACL2DEV(&interface,
                                           acl_id,
                                           &acl_entry,
                                           time_range_index,
                                           counter_enable);
    }
    else
    {
        result = RULE_CTRL_LocalRemoveACLFromDEV(&interface,
                                                 acl_id,
                                                 &acl_entry);
    }

#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)
    if (RULE_TYPE_INSUFFICIENT_RESOURCE == result)
    {
        RULE_CTRL_WRAP_FN_PARAM_T param;

        //
        // FIXME: Use ifindex + direction instead
        //
        param.is_ingress = interface.direction == RULE_TYPE_INBOUND ? TRUE : FALSE;
        param.unit = interface.uport.unit;
        param.port = interface.uport.port;
        param.acl_id = acl_id;
        param.is_trunk = FALSE;
        param.is_add = is_add;
        param.time_range_index = time_range_index;
        param.counter_enable = counter_enable;

        result = RULE_CTRL_Priv_DefragRule(interface.direction,
                                           acl_id,
                                           RULE_CTRL_Priv_Wrap_SetACL2DEV,
                                           RULE_CTRL_Priv_Wrap_RemoveACLFromDEV,
                                           &param);
    }
#endif /* SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT */

    RULE_CTRL_LeaveCriticalSectionReturnState(result);
}

#if (SYS_CPNT_QOS_V2_COUNTER == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_GetQosCounter
 *------------------------------------------------------------------------------
 * PURPOSE:  Get diffserv counter
 * INPUT:    ifindex - port index
 *           direction - ingress or egress
 *           policy_id - policy-map id
 *           class_id - class-map id
 * OUTPUT:   counter
 * RETURN:   Error code
 * NOTE: None
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_GetQosCounter(
    UI32_T ifindex,
    RULE_TYPE_InOutDirection_T direction,
    UI32_T policy_id,
    UI32_T class_id,
    RULE_TYPE_CounterRec_T *counter)
{

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_ClearQosCounter
 *------------------------------------------------------------------------------
 * PURPOSE:  Clear diffserv counter
 * INPUT:    ifindex - port index
 *           direction - ingress or egress
 *           policy_id - policy-map id
 *           class_id - class-map id
 * OUTPUT:   None
 * RETURN:   Error code
 * NOTE: None
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_ClearQosCounter(
    UI32_T ifindex,
    RULE_TYPE_InOutDirection_T direction,
    UI32_T policy_id,
    UI32_T class_id)
{

    return RULE_TYPE_OK;
}
#endif /*#if (SYS_CPNT_QOS_V2_COUNTER == TRUE)*/

#if (SYS_CPNT_ACL_COUNTER == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_GetAclRuleCounter
 *------------------------------------------------------------------------------
 * PURPOSE:  Get counter for ACE of ACL
 * INPUT:    acl_id     - ACL ID
 *           ace_id     - ACE ID
 * OUTPUT:   ace_entry  - ACE object
 * RETURN:   TRUE/FALSE.
 * NOTE:     NONE
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_GetAclRuleCounter(
    UI32_T ifindex,
    RULE_TYPE_InOutDirection_T direction,
    UI32_T acl_index,
    UI32_T ace_index,
    RULE_TYPE_Ace_Entry_T *ace_entry)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_INTERFACE_INFO_T interface;

    RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;
    RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T ace_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T rule_inst_iter;

    RULE_CTRL_INSTANCE_TYPE_ID_T param;

    BOOL_T b_result;

    memset(&interface, 0, sizeof(interface));

    result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    interface.direction = direction;

    LOG_IF(interface, "AclId = %lu, AceId = %lu",
           acl_index,
           ace_index);

    if (RULE_TYPE_INTERFACE_UPORT != interface.type)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    if (RULE_TYPE_INBOUND != interface.direction &&
        RULE_TYPE_OUTBOUND != interface.direction)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    if (RULE_TYPE_INTERFACE_UPORT == interface.type)
    {
        UI32_T module_id;
        UI32_T device_id;
        UI32_T phy_port;

        module_id = 0;
        device_id = 0;
        phy_port  = 0;

        if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(interface.uport.unit,
                                                            interface.uport.port,
                                                            &module_id,
                                                            &device_id,
                                                            &phy_port))
        {
            LOG("<Error> Invalid parameter");
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }
    else if (RULE_TYPE_INTERFACE_CPU_PORT == interface.type)
    {
        if (RULE_TYPE_OUTBOUND != interface.direction)
        {
            LOG("<Error> Invalid parameter");
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }
    else if (RULE_TYPE_INTERFACE_TRUNK == interface.type)
    {
        if (RULE_TYPE_INBOUND != interface.direction)
        {
            LOG("<Error> Invalid parameter");
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }
    else if (RULE_TYPE_INTERFACE_ALL_UNIT == interface.type)
    {
        if (RULE_TYPE_INBOUND != interface.direction)
        {
            LOG("<Error> Invalid parameter");
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }

    RULE_CTRL_EnterCriticalSection();

    acl_inst_p = RULE_CTRL_Priv_GetAclInstanceById(&interface, acl_index);

    if (NULL == acl_inst_p ||
        RULE_TYPE_COUNTER_ENABLE != acl_inst_p->counter_enable)
    {
        RULE_CTRL_LeaveCriticalSectionReturnState(RULE_TYPE_OK);
    }

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_ACE;
    param.id = ace_index;

    ace_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) acl_inst_p,
                                                                                RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                &param);
    if (NULL == ace_inst_p)
    {
        LOG("<Error> Invalid parameter: ace_index = %lu", ace_index);
        RULE_CTRL_LeaveCriticalSectionReturnState(RULE_TYPE_INVALID_PARAMETER);
    }

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(ace_inst_p, &ace_inst_obj);
    ace_inst_obj.get_element_iterator(&ace_inst_obj, &rule_inst_iter);

    memset(&ace_entry->counter, 0, sizeof(ace_entry->counter));

    for (rule_inst_iter.first(&rule_inst_iter);
         NULL != rule_inst_iter.get_instance(&rule_inst_iter);
         rule_inst_iter.next(&rule_inst_iter))
    {
        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_TYPE_CounterRec_T *counter_p;

        rule_inst_p = (RULE_TYPE_RULE_INSTANCE_PTR_T) rule_inst_iter.get_instance(&rule_inst_iter);

        ASSERT(rule_inst_p->current_counter_index < _countof(rule_inst_p->counter));

        counter_p = &rule_inst_p->counter[(rule_inst_p->current_counter_index + 1)
                                          % _countof(rule_inst_p->counter)];

        if (rule_inst_p->active == FALSE)
        {
            continue;
        }

        /*
         * FIXME: For stacking, we need find the correct unit, port before call
         * DEVRM_PMGR_GetCounter().
         */

        b_result = DEVRM_PMGR_GetCounter(rule_inst_p->dev_rule_info.device,
                                         rule_inst_p->dev_rule_info.rule_id,
                                         &counter_p->total_packets);
        if (FALSE == b_result)
        {
            LOG("GetCounter failed: aclId=%lu, aceId=%lu, ruleId=%lu",
                acl_index, ace_index, rule_inst_p->dev_rule_info.rule_id);
            RULE_CTRL_LeaveCriticalSectionReturnState(RULE_TYPE_FAIL);
        }

        rule_inst_p->current_counter_index = (rule_inst_p->current_counter_index + 1)
                                                % _countof(rule_inst_p->counter);

        ASSERT(rule_inst_p->current_counter_index < _countof(rule_inst_p->counter));
        ASSERT(counter_p == &rule_inst_p->counter[rule_inst_p->current_counter_index]);

        counter_p->last_update_tick = SYSFUN_GetSysTick();
        ace_entry->counter.total_packets += counter_p->total_packets;
    }

    ace_entry->counter.last_update_tick = SYSFUN_GetSysTick();

    RULE_CTRL_LeaveCriticalSectionReturnState(RULE_TYPE_OK);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_ClearAclRuleCounter
 *------------------------------------------------------------------------------
 * PURPOSE:  Clear counter for ACE of ACL
 * INPUT:    interface  - The interface.
 *                        The type of this parameter should be
 *                        RULE_TYPE_INTERFACE_UPORT
 *                        The direction of this parameter should be one of the
 *                        values:
 *                        RULE_TYPE_INBOUND     - Ingress direction
 *                        RULE_TYPE_OUTBOUND    - Egress direction
 *           acl_id     - ACL ID
 *           ace_id     - ACE ID
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_ClearAclRuleCounter(
    UI32_T ifindex,
    RULE_TYPE_InOutDirection_T direction,
    UI32_T acl_index,
    UI32_T ace_index)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_INTERFACE_INFO_T interface;

    RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;
    RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T ace_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T rule_inst_iter;

    RULE_CTRL_INSTANCE_TYPE_ID_T param;

    BOOL_T b_result;

    memset(&interface, 0, sizeof(interface));

    result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    interface.direction = direction;

    LOG_IF(interface, "AclId = %lu, AceId = %lu",
           acl_index,
           ace_index);

    if (RULE_TYPE_INTERFACE_UPORT != interface.type)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    if (RULE_TYPE_INBOUND != interface.direction &&
        RULE_TYPE_OUTBOUND != interface.direction)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    if (RULE_TYPE_INTERFACE_UPORT == interface.type)
    {
        UI32_T module_id;
        UI32_T device_id;
        UI32_T phy_port;

        module_id = 0;
        device_id = 0;
        phy_port  = 0;

        if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(interface.uport.unit,
                                                            interface.uport.port,
                                                            &module_id,
                                                            &device_id,
                                                            &phy_port))
        {
            LOG("<Error> Invalid parameter");
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }
    else if (RULE_TYPE_INTERFACE_CPU_PORT == interface.type)
    {
        if (RULE_TYPE_OUTBOUND != interface.direction)
        {
            LOG("<Error> Invalid parameter");
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }
    else if (RULE_TYPE_INTERFACE_TRUNK == interface.type)
    {
        if (RULE_TYPE_INBOUND != interface.direction)
        {
            LOG("<Error> Invalid parameter");
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }
    else if (RULE_TYPE_INTERFACE_ALL_UNIT == interface.type)
    {
        if (RULE_TYPE_INBOUND != interface.direction)
        {
            LOG("<Error> Invalid parameter");
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }

    RULE_CTRL_EnterCriticalSection();

    acl_inst_p = RULE_CTRL_Priv_GetAclInstanceById(&interface, acl_index);

    if (NULL == acl_inst_p ||
        RULE_TYPE_COUNTER_ENABLE != acl_inst_p->counter_enable)
    {
        RULE_CTRL_LeaveCriticalSectionReturnState(RULE_TYPE_OK);
    }

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_ACE;
    param.id = ace_index;

    ace_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) acl_inst_p,
                                                                                RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                &param);
    if (NULL == ace_inst_p)
    {
        LOG("<Error> Invalid parameter: ace_index = %lu", ace_index);
        RULE_CTRL_LeaveCriticalSectionReturnState(RULE_TYPE_INVALID_PARAMETER);
    }

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(ace_inst_p, &ace_inst_obj);
    ace_inst_obj.get_element_iterator(&ace_inst_obj, &rule_inst_iter);

    for (rule_inst_iter.first(&rule_inst_iter);
         NULL != rule_inst_iter.get_instance(&rule_inst_iter);
         rule_inst_iter.next(&rule_inst_iter))
    {
        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;

        rule_inst_p = (RULE_TYPE_RULE_INSTANCE_PTR_T) rule_inst_iter.get_instance(&rule_inst_iter);

        if (rule_inst_p->active == FALSE)
        {
            continue;
        }

        /*
         * FIXME: For stacking, we need find the correct unit, port before call
         * DEVRM_PMGR_ClearCounter().
         */

        b_result = DEVRM_PMGR_ClearCounter(rule_inst_p->dev_rule_info.device,
                                           rule_inst_p->dev_rule_info.rule_id);
        if (FALSE == b_result)
        {
            LOG("ClearCounter failed: aclId=%lu, aceId=%lu, ruleId=%lu",
                acl_index,
                rule_inst_p->ace_id,
                rule_inst_p->dev_rule_info.rule_id);

            RULE_CTRL_LeaveCriticalSectionReturnState(RULE_TYPE_FAIL);
        }
    }

    RULE_CTRL_LeaveCriticalSectionReturnState(RULE_TYPE_OK);
}
#endif /* #if (SYS_CPNT_ACL_COUNTER == TRUE) */

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetMf
 *------------------------------------------------------------------------------
 * PURPOSE  : Set a MF entry.
 * INPUT    : class_map_index, mf_index, is_add
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : is_add == FALSE implies remove MF
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_SetMf(
    UI32_T ifindex,
    RULE_TYPE_InOutDirection_T direction,
    UI32_T policy_map_index,
    UI32_T class_map_index,
    UI32_T mf_index,
    UI32_T meter_id,
    UI32_T action_id,
    BOOL_T is_add)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_INTERFACE_INFO_T interface;

    memset(&interface, 0, sizeof(interface));

    result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    interface.direction = direction;

    if (RULE_TYPE_INTERFACE_UPORT != interface.type &&
        RULE_TYPE_INTERFACE_CPU_PORT != interface.type)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    if (RULE_TYPE_INBOUND != interface.direction &&
        RULE_TYPE_OUTBOUND != interface.direction)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    if (RULE_TYPE_INTERFACE_UPORT == interface.type)
    {
        UI32_T module_id;
        UI32_T device_id;
        UI32_T phy_port;

        module_id = 0;
        device_id = 0;
        phy_port  = 0;

        if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(interface.uport.unit,
                                                            interface.uport.port,
                                                            &module_id,
                                                            &device_id,
                                                            &phy_port))
        {
            LOG("<Error> Invalid parameter");
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }
    else if (RULE_TYPE_INTERFACE_CPU_PORT == interface.type)
    {
        if (RULE_TYPE_OUTBOUND != interface.direction)
        {
            LOG("<Error> Invalid parameter");
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }

    RULE_CTRL_EnterCriticalSection();

    if (TRUE == is_add)
    {
        result = RULE_CTRL_LocalSetMF2DEV(&interface,
                                          policy_map_index,
                                          class_map_index,
                                          mf_index,
                                          meter_id,
                                          action_id);
    }
    else
    {
        result = RULE_CTRL_LocalRemoveMF2DEV(&interface,
                                             policy_map_index,
                                             class_map_index,
                                             mf_index, meter_id, action_id);
    }

    RULE_CTRL_LeaveCriticalSectionReturnState(result);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetPolicyMap
 *------------------------------------------------------------------------------
 * PURPOSE  : Set rule for a policy-map.
 * INPUT    : unit              - unit
 *            port              - port
 *            inout_profile     - direction
 *            policy_map_index  - policy-map index
 *            is_add            - TRUE, set rule to chip; FALSE, remove rule
 * OUTPUT   : none
 * RETURN   : TRUE/FALSE.
 * NOTE     : none
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_SetPolicyMap(
    UI32_T ifindex,
    RULE_TYPE_InOutDirection_T direction,
    UI32_T policy_map_index,
    BOOL_T is_add)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_INTERFACE_INFO_T interface;

    RULE_TYPE_PolicyMap_T policy_map;

    memset(&interface, 0, sizeof(interface));

    result = RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    interface.direction = direction;

    if (RULE_TYPE_INTERFACE_UPORT != interface.type &&
        RULE_TYPE_INTERFACE_CPU_PORT != interface.type)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    if (RULE_TYPE_INBOUND != interface.direction &&
        RULE_TYPE_OUTBOUND != interface.direction)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    if (RULE_TYPE_INTERFACE_UPORT == interface.type)
    {
        UI32_T module_id;
        UI32_T device_id;
        UI32_T phy_port;

        module_id = 0;
        device_id = 0;
        phy_port  = 0;

        if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(interface.uport.unit,
                                                            interface.uport.port,
                                                            &module_id,
                                                            &device_id,
                                                            &phy_port))
        {
            LOG("<Error> Invalid parameter");
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }
    else if (RULE_TYPE_INTERFACE_CPU_PORT == interface.type)
    {
        if (RULE_TYPE_OUTBOUND != interface.direction)
        {
            LOG("<Error> Invalid parameter");
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }
    else if (RULE_TYPE_INTERFACE_TRUNK == interface.type)
    {
        if (RULE_TYPE_INBOUND != interface.direction)
        {
            LOG("<Error> Invalid parameter");
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }
    else if (RULE_TYPE_INTERFACE_ALL_UNIT == interface.type)
    {
        if (RULE_TYPE_INBOUND != interface.direction)
        {
            LOG("<Error> Invalid parameter");
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }

    RULE_CTRL_EnterCriticalSection();

    result = RULE_OM_GetPolicyMap(policy_map_index, &policy_map);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Invalid parameter");
        RULE_CTRL_LeaveCriticalSectionReturnState(result);
    }

    if (TRUE == is_add)
    {
        result = RULE_CTRL_LocalSetPolicyMap2DEV(&interface,
                                                 policy_map_index,
                                                 &policy_map);
    }
    else
    {
        result = RULE_CTRL_LocalRemovePolicyMap2DEV(&interface,
                                                    policy_map_index,
                                                    &policy_map);
    }

    RULE_CTRL_LeaveCriticalSectionReturnState(result);
}

#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_ReserveResourceOnCreateAcl
 *------------------------------------------------------------------------------
 * PURPOSE:  Reserve resource on createing ACL
 * INPUT:    acl_index  -   ACL index
 * OUTPUT:   None
 * RETURN:   RULE_TYPE_OK ; Error code
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_ReserveResourceOnCreateAcl(
    UI32_T acl_index)
{
    RULE_TYPE_Acl_T acl_entry;
    RULE_TYPE_FunctionType_T my_fun_type;

    RULE_TYPE_FunctionType_T fun_stats[ RULE_CTRL_TOTAL_NBR_OF_AV_REMAP_FUN_TYPE ];
    UI32_T number_of_entries_written;

    RULE_TYPE_RETURN_TYPE_T result;

    result = RULE_OM_GetAclByIndex(acl_index, &acl_entry);
    if (RULE_TYPE_OK != result)
    {
        ASSERT(0);
        return result;
    }

    /* We need to check direction ingress and egress both.
     * But we have not implement egress yet. So just need to check ingress only.
     */
    if (FALSE == RULE_CTRL_GetFunctionTypeForACLAndQoS(TRUE, TRUE,
                                                       acl_entry.acl_type,
                                                       &my_fun_type))
    {
        /* If failed to get funtype, suppose the ACL is not need to bind into
         * hardware. E.g., ARP
         */
        return RULE_TYPE_OK;
    }

    result = RULE_CTRL_Priv_GetAvailableFunctionTypeList(RULE_TYPE_INBOUND,
                                                          &acl_entry, fun_stats,
                                                            _countof(fun_stats),
                                                    &number_of_entries_written);
    if (RULE_TYPE_OK != result)
    {
        return result;
    }

    if (0 == number_of_entries_written)
    {
        return RULE_TYPE_E_HW_INSUFFICIENT_SELECTOR;
    }

    ASSERT(number_of_entries_written <= _countof(fun_stats));

    {
        RULE_CTRL_FunTypeFreeEntry_T *free_entry_p;

        free_entry_p = RULE_CTRL_Priv_GetFunTypeFreeEntry(fun_stats[0]);

        ASSERT(NULL != free_entry_p);

        if (RULE_TYPE_FUNCTION_TYPE_MAX != free_entry_p->used_by_fun_type)
        {
            ASSERT(my_fun_type == free_entry_p->used_by_fun_type);

            return RULE_TYPE_OK;
        }
    }

    result = RULE_CTRL_Priv_ChangeGroupQualifySet(my_fun_type, fun_stats[0]);

    ASSERT(RULE_TYPE_OK == result);

    if (RULE_TYPE_OK != result)
    {
        return result;
    }

    result = RULE_CTRL_Priv_ChangeGroupPriority(my_fun_type, fun_stats[0]);

    ASSERT(RULE_TYPE_OK == result);

    if (RULE_TYPE_OK != result)
    {
        return result;
    }

    result = RULE_CTRL_Priv_EnableFuncTypeRemap(my_fun_type, fun_stats[0]);

    ASSERT(RULE_TYPE_OK == result);

    if (RULE_TYPE_OK != result)
    {
        return result;
    }

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_ReleaseResourceOnDeleteAcl
 *------------------------------------------------------------------------------
 * PURPOSE:  Release resource on deleting ACL
 * INPUT:    acl_index  - ACL index
 * OUTPUT:   None
 * RETURN:   RULE_TYPE_OK ; Error code
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_ReleaseResourceOnDeleteAcl()
{
    return RULE_CTRL_Priv_RecycleGroup();
}
#endif /* SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT */

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_TrapPacket2Cpu
 *------------------------------------------------------------------------------
 * PURPOSE:  trap specified packet to CPU
 * INPUT:    enable_flag, packet_type, rule_info
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:     1. dip is used as do_action for DHCPS_BC & DHCPC_BC (DHCPSNP)
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_TrapPacket2Cpu(
    BOOL_T enable_flag, RULE_TYPE_PacketType_T packet_type, RULE_TYPE_CpuRuleInfo_T *rule_info)
{
#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    RULE_CTRL_IscBuf_T  *isc_buf_p;
    L_MM_Mref_Handle_T  *mref_handle_p;
    UI32_T              pdu_len;
    UI32_T              unit_index, my_drv_unit;
    UI16_T              dst_bmp = 0, isc_ret_val;
#endif
    BOOL_T               ret = TRUE;

    /*
     * Use new arch for trap packet to CPU
     */
    switch (packet_type)
    {
#if (SYS_CPNT_DOT1X == TRUE)
        case RULE_TYPE_PacketType_DOT1X:
        {
            UI32_T  unit;
            UI32_T  port;

            if (NULL == rule_info)
            {
                RULE_CTRL_LOG("rule_info is NULL");
                return FALSE;
            }

            unit = STKTPLG_OM_IFINDEX_TO_UNIT(rule_info->dot1x.ifindex);
            port = STKTPLG_OM_IFINDEX_TO_PORT(rule_info->dot1x.ifindex);

            return RULE_CTRL_1X_TrapDot1xUCToCPU(enable_flag,
                                                 unit,
                                                 port,
                                                 rule_info->dot1x.cpu_mac);
        }

#endif /* SYS_CPNT_DOT1X */

#if (SYS_CPNT_IPV6 == TRUE)
        case RULE_TYPE_PacketType_LinkLocal:
        {
            if (NULL == rule_info)
            {
                RULE_CTRL_LOG("rule_info is NULL");
                return FALSE;
            }

            return RULE_CTRL_IP6_TrapLinkLocalToCPU(enable_flag,
                                                    rule_info->linklocal.addr,
                                                    rule_info->linklocal.vlan_id);
        }
#endif /* SYS_CPNT_IPV6 */

#if (SYS_CPNT_PTP == TRUE)
        case RULE_TYPE_PacketType_PTP_EVENT_ETH:
            return RULE_CTRL_PTP_TrapPtpEventEthToCPU(enable_flag);

        case RULE_TYPE_PacketType_PTP_EVENT_UDP:
           return RULE_CTRL_PTP_TrapPtpEventUdpToCPU(enable_flag);

        case RULE_TYPE_PacketType_PTP_GENERAL_UDP:
            return RULE_CTRL_PTP_TrapPtpGeneralUdpToCPU(enable_flag);
#endif /* SYS_CPNT_PTP */

#if (SYS_CPNT_DHCPV6 == TRUE)
        case RULE_TYPE_PacketType_DHCP6_CLIENT:
        {
            if(NULL == rule_info)
            {
                RULE_CTRL_LOG("rule_info is NULL");
                return FALSE;
            }

            return RULE_CTRL_DHCP6_TrapDHCP6ClientPacketToCPU(enable_flag,
                                                    rule_info->common.to_cpu,
                                                    rule_info->common.flood);
        }
        case RULE_TYPE_PacketType_DHCP6_SERVER:
        {
            if(NULL == rule_info)
            {
                RULE_CTRL_LOG("rule_info is NULL");
                return FALSE;
            }

            return RULE_CTRL_DHCP6_TrapDHCP6ServerPacketToCPU(enable_flag,
                                                    rule_info->common.to_cpu,
                                                    rule_info->common.flood);
        }
#endif

#if (SYS_CPNT_MLD == TRUE || SYS_CPNT_MLDSNP == TRUE || SYS_CPNT_MVR6 == TRUE)
        case RULE_TYPE_PacketType_MLD_Query:
            return RULE_CTRL_IP6_SetMldQueryRule(enable_flag);

        case RULE_TYPE_PacketType_MLD_Report:
            return RULE_CTRL_IP6_SetMldReportRule(enable_flag);

        case RULE_TYPE_PacketType_MLD_Done:
            return RULE_CTRL_IP6_SetMldDoneRule(enable_flag);

        case RULE_TYPE_PacketType_MLDV2_Reports:
            return RULE_CTRL_IP6_SetMldv2ReportsRule(enable_flag);
#endif /* SYS_CPNT_MLD || SYS_CPNT_MLDSNP || SYS_CPNT_MVR6 */

#if (SYS_CPNT_IGMPSNP == TRUE && SYS_CPNT_IGMPSNP_RESERVE_ADDRESS_PACKET_CHIP_TRAP_TO_CPU_BUT_NOT_FORWARD == FALSE)
        case RULE_TYPE_PacketType_RESERVED_UDP:
            return RULE_CTRL_IGMPSNP_CancelReservedMulticastToCPU(enable_flag);
#endif /* SYS_CPNT_IGMPSNP && !SYS_CPNT_IGMPSNP_RESERVE_ADDRESS_PACKET_CHIP_TRAP_TO_CPU_BUT_NOT_FORWARD */

        case RULE_TYPE_PacketType_IGMP:
        case RULE_TYPE_PacketType_DVMRP:
            return RULE_CTRL_IGMPSNP_SetIgmpRule(enable_flag, rule_info->common.to_cpu);

        case RULE_TYPE_PacketType_ORG_SPECIFIC1:
            if (NULL == rule_info)
            {
                RULE_CTRL_LOG("rule_info is NULL");
                return FALSE;
            }

            return RULE_CTRL_SetOrgSpecific1Packet(enable_flag,
                        rule_info->common.to_cpu, rule_info->common.flood);

#if (SYS_CPNT_UDLD == TRUE)
        case RULE_TYPE_PacketType_ORG_SPECIFIC2:
            if (NULL == rule_info)
            {
                RULE_CTRL_LOG("rule_info is NULL");
                return FALSE;
            }

            return RULE_CTRL_UDLD_SetUdldPacket(enable_flag,
                                                rule_info->common.to_cpu,
                                                rule_info->common.flood);
#endif /* SYS_CPNT_UDLD */

        case RULE_TYPE_PacketType_ORG_SPECIFIC3:
            if (NULL == rule_info)
            {
                RULE_CTRL_LOG("rule_info is NULL");
                return FALSE;
            }

            return RULE_CTRL_SetOrgSpecific3Packet(enable_flag,
                        rule_info->common.to_cpu, rule_info->common.flood);

        default:
        break;
    }


    if (FALSE == RULE_CTRL_LocalIsNeedToConfigCpuRule(enable_flag, packet_type))
        return TRUE;

    /* config local chip. */
    ret = RULE_CTRL_LocalTrapPacket2Cpu(enable_flag, packet_type, rule_info);

#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))

    if (FALSE == STKTPLG_POM_GetMyDriverUnit(&my_drv_unit))
    {
        return FALSE;
    }

    unit_index = 0;
    while(STKTPLG_POM_GetNextDriverUnit(&unit_index))
    {
        if(my_drv_unit != unit_index)
        {
            dst_bmp |= BIT_VALUE(unit_index - 1);
        }
    }
    if(dst_bmp!=0)
    {
        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(RULE_CTRL_IscBuf_T), L_MM_USER_ID2(SYS_MODULE_RULE_CTRL, RULE_CTRL_SID_TRAPPACKET2CPU));
        isc_buf_p = (RULE_CTRL_IscBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
        if(isc_buf_p==NULL)
        {
            SYSFUN_Debug_Printf("\r\n%s():L_MM_Mref_GetPdu() fails", __FUNCTION__);
            return FALSE;
        }

        isc_buf_p->ServiceID = RULE_CTRL_SID_TRAPPACKET2CPU;
        isc_buf_p->unit = my_drv_unit;
        isc_buf_p->CPUINFO.enable_flag = enable_flag;
        isc_buf_p->CPUINFO.packet_type = packet_type;
        if (NULL != rule_info)/* rule_info may be null, for some kind of rules */
        {
            memcpy(&isc_buf_p->CPUINFO.rule_info, rule_info, sizeof(RULE_TYPE_CpuRuleInfo_T));
        }

        isc_ret_val=ISC_SendMcastReliable(dst_bmp, ISC_RULE_CTRL_SID,
                              mref_handle_p, SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                              RULE_CTRL_TRY_TIMES, RULE_CTRL_TIME_OUT, FALSE);
        if(isc_ret_val!=0)
        {
            SYSFUN_Debug_Printf("\r\n%s():ISC_SendMcastReliable() fails(ret_val=0x%x)", __FUNCTION__, isc_ret_val);
            return FALSE;   /* can't control remote unit */
        }
    }
    else
    {
#endif

        //ret = RULE_CTRL_LocalTrapPacket2Cpu(enable_flag, packet_type, rule_info);

#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    }
#endif
    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_TrapPacket2Cpu
 *------------------------------------------------------------------------------
 * PURPOSE:  This function is used to Copy frame to CPU.
 *           The packet is still forwarded by bridge mechenism.
 * INPUT:    enable_flag, packet_type, rule_info
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:     Not implement
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_MirrorPacket2Cpu(BOOL_T enable_flag, RULE_TYPE_PacketType_T packet_type, RULE_TYPE_CpuRuleInfo_T *rule_info)
{
    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_TrapPacket2CpuForSwdrv
 *------------------------------------------------------------------------------
 * PURPOSE:  trap specified packet to CPU
 * INPUT:    enable_flag, packet_type, rule_info
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:     1. dip is used as do_action for DHCPS_BC & DHCPC_BC (DHCPSNP)
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_TrapPacket2CpuForSwdrv(
    BOOL_T enable_flag, RULE_TYPE_PacketType_T packet_type, RULE_TYPE_CpuRuleInfo_T *rule_info)
{
    BOOL_T               ret = TRUE;

    if (FALSE == RULE_CTRL_LocalIsNeedToConfigCpuRule(enable_flag, packet_type))
        return TRUE;

    /* config local chip. */
    ret = RULE_CTRL_LocalTrapPacket2Cpu(enable_flag, packet_type, rule_info);

    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_TrapPacket2CpuByUnit
 *------------------------------------------------------------------------------
 * PURPOSE:  trap specified packet to CPU
 * INPUT:    enable_flag, packet_type, rule_info
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:     1. dip is used as do_action for DHCPS_BC & DHCPC_BC (DHCPSNP)
 *              It should only be call to set slave unit.
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapPacket2CpuByUnit(UI32_T unit,
    BOOL_T enable_flag, RULE_TYPE_PacketType_T packet_type, RULE_TYPE_CpuRuleInfo_T *rule_info)
{
    RULE_CTRL_IscBuf_T  *isc_buf_p;
    L_MM_Mref_Handle_T  *mref_handle_p;
    UI32_T              pdu_len;
    UI32_T              my_drv_unit;
    UI16_T              dst_bmp = 0, isc_ret_val;

    if(0 == unit)
        return FALSE;

#if 0
    if (FALSE == RULE_CTRL_LocalIsNeedToConfigCpuRule(enable_flag, packet_type))
        return TRUE;
#endif

    if (FALSE == STKTPLG_POM_GetMyDriverUnit(&my_drv_unit))
        return FALSE;

    if(unit == my_drv_unit)
        return FALSE;

    dst_bmp |= BIT_VALUE(unit - 1);
    if(dst_bmp!=0)
    {
        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(RULE_CTRL_IscBuf_T), L_MM_USER_ID2(SYS_MODULE_RULE_CTRL, RULE_CTRL_SID_TRAPPACKET2CPU));
        isc_buf_p = (RULE_CTRL_IscBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
        if(isc_buf_p==NULL)
        {
            SYSFUN_Debug_Printf("\r\n%s():L_MM_Mref_GetPdu() fails", __FUNCTION__);
            return FALSE;
        }

        isc_buf_p->ServiceID = RULE_CTRL_SID_TRAPPACKET2CPU;
        isc_buf_p->unit = my_drv_unit;
        isc_buf_p->CPUINFO.enable_flag = enable_flag;
        isc_buf_p->CPUINFO.packet_type = packet_type;
        if (NULL != rule_info)/* rule_info may be null, for some kind of rules */
        {
            memcpy(&isc_buf_p->CPUINFO.rule_info, rule_info, sizeof(RULE_TYPE_CpuRuleInfo_T));
        }

        isc_ret_val=ISC_SendMcastReliable(dst_bmp, ISC_RULE_CTRL_SID,
                              mref_handle_p, SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                              RULE_CTRL_TRY_TIMES, RULE_CTRL_TIME_OUT, FALSE);
        if(isc_ret_val!=0)
        {
            SYSFUN_Debug_Printf("\r\n%s():ISC_SendMcastReliable() fails(ret_val=0x%x)", __FUNCTION__, isc_ret_val);
            return FALSE;   /* can't control remote unit */
        }
    }

    return TRUE;
}

static void *
RULE_CTRL_COS_GETOM_L4PortToInternalPri(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T module_id, device_id, phy_port;
    RULE_CTRL_L4PortDscpRuleStorage_T *rule_storage_p;
    int index, first_empty_index = -1;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit,
                     param_p->port, &module_id, &device_id, &phy_port))
    {
        return NULL;
    }

    for (index = 0; index < SYS_ADPT_MAX_NBRS_OF_TCPUDP_ACE; ++index)
    {
        rule_storage_p = &shmem_data_p->l4_port_internal_pri[param_p->unit - 1][device_id][index];

        if (TRUE == rule_storage_p->spr_rs.rule_storage.is_enable)
        {
            if (rule_storage_p->is_tcp == param_p->l4_port_to_int_pri.is_tcp &&
                rule_storage_p->dst_port == param_p->l4_port_to_int_pri.dst_port &&
                rule_storage_p->phb == param_p->l4_port_to_int_pri.phb &&
                rule_storage_p->color == param_p->l4_port_to_int_pri.color)
            {
                return &rule_storage_p->spr_rs;
            }
        }
        else
        {
            if (first_empty_index == -1)
            {
                first_empty_index = index;
            }
        }
    }

    if (first_empty_index == -1)
    {
        return NULL;
    }

    rule_storage_p = &shmem_data_p->l4_port_internal_pri[param_p->unit - 1][device_id][first_empty_index];

    rule_storage_p->is_tcp   = param_p->l4_port_to_int_pri.is_tcp;
    rule_storage_p->dst_port = param_p->l4_port_to_int_pri.dst_port;
    rule_storage_p->phb      = param_p->l4_port_to_int_pri.phb;
    rule_storage_p->color    = param_p->l4_port_to_int_pri.color;

    return &rule_storage_p->spr_rs;
}

static BOOL_T
RULE_CTRL_COS_L4PortToInternalPri(
    RULE_CTRL_PARAM_PTR param_p,
    DEVRM_PBMP_T new_pbmp)
{
    param_p->func_type = RULE_TYPE_TCP_UDP_PORT_MAPPING;
    RULE_CTRL_MakeParamTag(param_p, "cos", "l4-port", "dscp", "cos-l4-port-dscp");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(param_p->ace_entry,
        (param_p->l4_port_to_int_pri.is_tcp ? RULE_CTRL_PROT_TCP : RULE_CTRL_PROT_UDP));

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpType);
    RULE_CTRL_SET_FILTER_IPTYPE(param_p->ace_entry, bcmFieldIpTypeIpv4Any);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_L4DstPort);
    RULE_CTRL_SET_FILTER_DPORT(param_p->ace_entry,
        param_p->l4_port_to_int_pri.dst_port);

    /* setup action
     */
    RULE_CTRL_SET_ACTION_REMARK_PACKET_AND_INNER_PRIORITY(param_p->action_entries[0],
        param_p->l4_port_to_int_pri.phb);
    param_p->action_entries[0].next_action = &param_p->action_entries[1];

    RULE_CTRL_SET_ACTION_REMARK_DROP_PRECEDENCE(param_p->action_entries[1],
        param_p->l4_port_to_int_pri.color);
    param_p->action_entries[1].next_action = NULL;

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalSetTcpUdpPortCosMap
 *------------------------------------------------------------------------------
 * PURPOSE:  set local unit tcp/udp port to cos mapping
 * INPUT:    unit, port, is_tcp, dest_port, phb, color
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_LocalSetTcpUdpPortCosMap(
    BOOL_T enable,
    UI32_T unit,
    UI32_T port,
    BOOL_T is_tcp,
    UI16_T dest_port,
    UI8_T phb,
    UI8_T color)
{
    RULE_CTRL_PARAM param;

    LOG("%s unit=%lu, port=%lu, %s:dest_port=%u to (phb=%hu, color=%hu)",
        enable? "Enable":"Disable", unit, port, is_tcp ? "TCP" : "UDP",
        dest_port, phb, color);

    RULE_CTRL_InitParam(&param);

    param.unit = unit;
    param.port = port;
    param.l4_port_to_int_pri.is_tcp    = is_tcp;
    param.l4_port_to_int_pri.dst_port  = dest_port;
    param.l4_port_to_int_pri.phb       = phb;
    param.l4_port_to_int_pri.color     = color;

    if (enable)
    {
        param.flags |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return RULE_CTRL_SetSharedPortRule(&param,
            (RULE_CTRL_SPR_GET_OM_HANDLER)RULE_CTRL_COS_GETOM_L4PortToInternalPri,
            (RULE_CTRL_SPR_SET_RULE_HANDLER)RULE_CTRL_COS_L4PortToInternalPri);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetTcpUdpPortCosMap
 *------------------------------------------------------------------------------
 * PURPOSE:  set tcp/udp destination port mapped to cos by unit and port
 * INPUT:    unit, port, is_tcp, dest_port, phb, color
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_SetTcpUdpPortCosMap(UI32_T unit, UI32_T port, BOOL_T is_tcp, UI16_T dest_port, UI8_T phb, UI8_T color, BOOL_T is_update)
{
    return RULE_CTRL_LocalSetTcpUdpPortCosMap(TRUE, unit, port, is_tcp, dest_port, phb, color);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_DeleteTcpUdpPortCosMap
 *------------------------------------------------------------------------------
 * PURPOSE:  delete tcp/udp destination port mapped to cos by unit and port
 * INPUT:    unit, port, is_tcp, dest_port, phb, color
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_DeleteTcpUdpPortCosMap(UI32_T unit, UI32_T port, BOOL_T is_tcp, UI16_T dest_port, UI8_T phb, UI8_T color)
{
    return RULE_CTRL_LocalSetTcpUdpPortCosMap(FALSE, unit, port, is_tcp, dest_port, phb, color);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_GetL4PortCosMapEntry
 *------------------------------------------------------------------------------
 * PURPOSE:  Get l4 port to COS mapping entry
 * INPUT:    dst_port
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static RULE_CTRL_L4PortCosRuleStorage_T* RULE_CTRL_GetL4PortCosMapEntry(
    UI32_T dst_port)
{
    UI32_T i;

    for (i=0; i<SYS_ADPT_MAX_NBRS_OF_TCPUDP_ACE; i++)
    {
        if (shmem_data_p->l4_port_cos_map[i].rule_storage.is_enable)
        {
            if (shmem_data_p->l4_port_cos_map[i].dst_port == dst_port)
            {
                return &shmem_data_p->l4_port_cos_map[i];
            }
        }
    }

    return NULL;
}

static RULE_CTRL_L4PortCosRuleStorage_T* RULE_CTRL_GetL4PortCosMapEntryByRuleId(
    UI32_T unit,
    UI32_T device_id,
    UI32_T rule_id)
{
    UI32_T  i;

    if (0 == unit)
    {
        return NULL;
    }

    unit -= 1;

    if (SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK <= unit ||
        SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT <= device_id)
    {
        return NULL;
    }

    for (i=0; i<SYS_ADPT_MAX_NBRS_OF_TCPUDP_ACE; i++)
    {
        RULE_CTRL_L4PortCosRuleStorage_T  *rs_p = &shmem_data_p->l4_port_cos_map[i];

        if (rs_p->rule_storage.is_enable)
        {
            if (rs_p->rule_storage.rule_id[unit][device_id] == rule_id)
            {
                return rs_p;
            }
        }
    }

    return NULL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_AllocL4PortCosMapEntry
 *------------------------------------------------------------------------------
 * PURPOSE:  Allocate l4 port to COS mapping entry
 * INPUT:    dst_port
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static RULE_CTRL_L4PortCosRuleStorage_T* RULE_CTRL_AllocL4PortCosMapEntry(
    UI32_T dst_port,
    UI32_T cos)
{
    UI32_T i;

    for (i=0; i<SYS_ADPT_MAX_NBRS_OF_TCPUDP_ACE; i++)
    {
        RULE_CTRL_L4PortCosRuleStorage_T  *rs_p = &shmem_data_p->l4_port_cos_map[i];

        if (!rs_p->rule_storage.is_enable)
        {
            rs_p->dst_port  = (UI16_T)dst_port;
            rs_p->cos       = (UI8_T)cos;

            memset(rs_p->rule_storage.rule_id, 0, sizeof(rs_p->rule_storage.rule_id));
            return rs_p;
        }
    }

    return NULL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetL4PortCosMap
 *------------------------------------------------------------------------------
 * PURPOSE:  set tcp/udp destination port mapped to cos
 * INPUT:    param_p
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_DO_L4PortCosMap(RULE_CTRL_PARAM_PTR param_p)
{
    RULE_CTRL_L4PortCosRuleStorage_T    *rs_p;

    if (param_p->flags & RULE_CTRL_OPT_INSTALL)
    {
        rs_p = RULE_CTRL_GetL4PortCosMapEntry(param_p->L4_PORT_COS_MAP.dst_port);
        if (NULL == rs_p)
        {
            rs_p = RULE_CTRL_AllocL4PortCosMapEntry(param_p->L4_PORT_COS_MAP.dst_port,
                                                    param_p->L4_PORT_COS_MAP.cos);
        }
    }
    else if (param_p->flags & RULE_CTRL_OPT_QUERY_BY_RULE_ID)
    {
        rs_p = RULE_CTRL_GetL4PortCosMapEntryByRuleId(param_p->query.unit,
                                                      param_p->query.device_id,
                                                      param_p->query.rule_id);
        if (rs_p)
        {
            param_p->L4_PORT_COS_MAP.dst_port = rs_p->dst_port;
            param_p->L4_PORT_COS_MAP.cos = rs_p->cos;
        }
    }
    else
    {
        rs_p = RULE_CTRL_GetL4PortCosMapEntry(param_p->L4_PORT_COS_MAP.dst_port);
    }

    if (rs_p)
    {
        param_p->sys_rule_storage_p = &rs_p->rule_storage;
    }

    param_p->func_type = RULE_TYPE_TCP_UDP_PORT_MAPPING;
    RULE_CTRL_MakeParamTag(param_p, "l4-dport", "dport", "cos", "l4-dport-cos");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_L4DstPort);
    RULE_CTRL_SET_FILTER_DPORT(param_p->ace_entry, param_p->L4_PORT_COS_MAP.dst_port);

    RULE_CTRL_SET_ACTION_REMARK_INNER_PRIORITY(param_p->action_entries[0],
                                               param_p->L4_PORT_COS_MAP.cos);
    param_p->action_entries[0].next_action = NULL;

    return TRUE;
}

#if (SYS_CPNT_IPV6 == TRUE)
static RULE_CTRL_LinkLocalRuleStorage_T* RULE_CTRL_IP6_GetLinkLocalRuleStorage(
    UI8_T   addr[SYS_ADPT_IPV6_ADDR_LEN],
    UI32_T  vlan_id)
{
    UI32_T  i;
    RULE_CTRL_LinkLocalRuleStorage_T  *link_local_addr_map_p =
        &shmem_data_p->ip6_link_local_addr_map[0];

    for (i=0; i<RULE_CTRL_MAX_NBR_OF_LINK_LOCAL_TO_CPU; i++)
    {
        if (link_local_addr_map_p[i].rule_storage.is_enable)
        {
            if (0 == memcmp(link_local_addr_map_p[i].addr, addr, SYS_ADPT_IPV6_ADDR_LEN)
                && link_local_addr_map_p[i].vlan_id == vlan_id)
            {
                return &link_local_addr_map_p[i];
            }
        }
    }

    return NULL;
}

static RULE_CTRL_LinkLocalRuleStorage_T* RULE_CTRL_IP6_GetLinkLocalRuleStorageByRuleId(
    UI32_T unit,
    UI32_T device_id,
    UI32_T rule_id)
{
    UI32_T  i;

    if (0 == unit)
    {
        return NULL;
    }

    unit -= 1;

    if (SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK <= unit ||
        SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT <= device_id)
    {
        return NULL;
    }

    for (i=0; i<RULE_CTRL_MAX_NBR_OF_LINK_LOCAL_TO_CPU; i++)
    {
        RULE_CTRL_LinkLocalRuleStorage_T  *rs_p = &shmem_data_p->ip6_link_local_addr_map[i];

        if (rs_p->rule_storage.is_enable)
        {
            if (rs_p->rule_storage.rule_id[unit][device_id] == rule_id)
            {
                return rs_p;
            }
        }
    }

    return NULL;
}

static RULE_CTRL_LinkLocalRuleStorage_T* RULE_CTRL_IP6_AllocateLinkLocalRuleStorage(
    UI8_T   addr[SYS_ADPT_IPV6_ADDR_LEN],
    UI32_T  vlan_id)
{
    UI32_T  i;
    RULE_CTRL_LinkLocalRuleStorage_T  *link_local_addr_map_p =
        &shmem_data_p->ip6_link_local_addr_map[0];

    for (i=0; i<RULE_CTRL_MAX_NBR_OF_LINK_LOCAL_TO_CPU; i++)
    {
        if (!link_local_addr_map_p[i].rule_storage.is_enable)
        {
            memcpy(link_local_addr_map_p[i].addr, addr, SYS_ADPT_IPV6_ADDR_LEN);
            link_local_addr_map_p[i].vlan_id = vlan_id;

            /* clear all rule ID
             */
            memset(link_local_addr_map_p[i].rule_storage.rule_id, 0, sizeof(link_local_addr_map_p[i].rule_storage.rule_id));
            return &link_local_addr_map_p[i];
        }
    }

    return NULL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IP6_DO_TrapLinkLocalToCPU
 *------------------------------------------------------------------------------
 * PURPOSE:  Trap IPv6 link local address to CPU
 * INPUT:    param_p - General parameter
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_IP6_DO_TrapLinkLocalToCPU(
    RULE_CTRL_PARAM_PTR param_p)
{
    RULE_CTRL_LinkLocalRuleStorage_T    *rs_p;

    if (param_p->flags & RULE_CTRL_OPT_INSTALL)
    {
        rs_p = RULE_CTRL_IP6_GetLinkLocalRuleStorage(param_p->LINK_LOCAL_ADDRESS.addr,
                                                     param_p->LINK_LOCAL_ADDRESS.vlan_id);
        if (NULL == rs_p)
        {
            rs_p = RULE_CTRL_IP6_AllocateLinkLocalRuleStorage(param_p->LINK_LOCAL_ADDRESS.addr,
                                                              param_p->LINK_LOCAL_ADDRESS.vlan_id);
        }
    }
    else if (param_p->flags & RULE_CTRL_OPT_QUERY_BY_RULE_ID)
    {
        rs_p = RULE_CTRL_IP6_GetLinkLocalRuleStorageByRuleId(param_p->query.unit,
                                                             param_p->query.device_id,
                                                             param_p->query.rule_id);

        if (rs_p)
        {
            memcpy(param_p->LINK_LOCAL_ADDRESS.addr, rs_p->addr, SYS_ADPT_IPV6_ADDR_LEN);
            param_p->LINK_LOCAL_ADDRESS.vlan_id = rs_p->vlan_id;
        }
    }
    else /* Uninstall || RULE_CTRL_OPT_QUERY */
    {
        rs_p = RULE_CTRL_IP6_GetLinkLocalRuleStorage(param_p->LINK_LOCAL_ADDRESS.addr,
                                                     param_p->LINK_LOCAL_ADDRESS.vlan_id);
    }

    if (rs_p)
    {
        param_p->sys_rule_storage_p = &rs_p->rule_storage;
    }

    param_p->func_type  = RULE_TYPE_PACKET_TO_CPU_LINK_LOCAL_ADDR;
    RULE_CTRL_MakeParamTag(param_p, "ip6", "ipv6", "link-local", "ip6-link-local");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstIp6);
    memcpy(param_p->ace_entry.dstip6_data, param_p->LINK_LOCAL_ADDRESS.addr, SYS_ADPT_IPV6_ADDR_LEN);
    memset(param_p->ace_entry.dstip6_mask, 0xFF, SYS_ADPT_IPV6_ADDR_LEN);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_OuterVlan);
    RULE_CTRL_SET_FILTER_OUTERVLAN(param_p->ace_entry, param_p->LINK_LOCAL_ADDRESS.vlan_id);

    /* Use copy to CPU + drip to replace redirect CPU, becuase CPU
     * port does not join to all VLAN, so the action
     * bcmFieldActionRedirectPbmp was not working
     * (RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU).
     */
    RULE_CTRL_SET_ACTION_COPY_TO_CPU(param_p->action_entries[0]);
    param_p->action_entries[0].next_action = &param_p->action_entries[1];
    RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[1]);
    param_p->action_entries[1].next_action = NULL;

    return TRUE;
}
#endif /* SYS_CPNT_IPV6 */

#if (SYS_CPNT_IPV6_DENY_LINK_LOCAL_ROUTING_BY_RULE_AS_TEMPORARY_SOLUTION == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_IP6_DO_DenyLinkLocalL3RoutablePkt
 *------------------------------------------------------------------------------
 * PURPOSE  : Deny IPv6 link local address and L3 routable enabled
 * INPUT    : param_p - General parameter
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IP6_DO_DenyLinkLocalL3RoutablePkt(RULE_CTRL_PARAM_PTR param_p)
{
    UI8_T addr[SYS_ADPT_IPV6_ADDR_LEN] =
        {
            0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        };
    UI8_T mask[SYS_ADPT_IPV6_ADDR_LEN] =
        {
            0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        };

    param_p->sys_rule_storage_p = &shmem_data_p->ip6_deny_link_local_l3_routable.rule_storage;

    param_p->func_type  = RULE_TYPE_LINK_LOCAL_ADDR_L3_ROUTABLE;
    RULE_CTRL_MakeParamTag(param_p, "ip6", "ipv6", "link-local-l3-routable", "ip6-link-local-l3-routable");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstIp6High);
    memcpy(param_p->ace_entry.dstip6high_data, addr, sizeof(param_p->ace_entry.dstip6high_data));
    memcpy(param_p->ace_entry.dstip6high_mask, mask, sizeof(param_p->ace_entry.dstip6high_mask));

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_L3Routable);
    RULE_CTRL_SET_FILTER_L3_ROUTABLE(param_p->ace_entry, 1, 1);

    RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[0]);
    param_p->action_entries[0].next_action = &param_p->action_entries[1];

    return TRUE;
}
#endif /* #if (SYS_CPNT_IPV6_DENY_LINK_LOCAL_ROUTING_BY_RULE_AS_TEMPORARY_SOLUTION == TRUE) */


#if (SYS_CPNT_WEBAUTH == TRUE)
static void* RULE_CTRL_WA_GETOM_TrapHttpToCPU(RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T  module_id, device_id, phy_port;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit, param_p->port,
        &module_id, &device_id, &phy_port))
    {
        return NULL;
    }

    return &shmem_data_p->web_auth_trap_httpc[param_p->unit-1][device_id];
}

static void* RULE_CTRL_WA_GETOM_PermitDhcp(RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T  module_id, device_id, phy_port;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit, param_p->port,
        &module_id, &device_id, &phy_port))
    {
        return NULL;
    }

    return &shmem_data_p->web_auth_permit_dhcpc[param_p->unit-1][device_id];
}

static void* RULE_CTRL_WA_GETOM_PermitDns(RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T  module_id, device_id, phy_port;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit, param_p->port,
        &module_id, &device_id, &phy_port))
    {
        return NULL;
    }

    return &shmem_data_p->web_auth_permit_dns[param_p->unit-1][device_id];
}

static void* RULE_CTRL_WA_GETOM_DenyAnyIpPacket(RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T  module_id, device_id, phy_port;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit, param_p->port,
        &module_id, &device_id, &phy_port))
    {
        return NULL;
    }

    return &shmem_data_p->web_auth_deny_any_ip[param_p->unit-1][device_id];
}

static BOOL_T RULE_CTRL_WA_SETRULE_TrapHttpToCPU(RULE_CTRL_PARAM_PTR param_p, DEVRM_PBMP_T new_pbmp)
{
    param_p->func_type  = RULE_TYPE_WEBAUTH_PRIO_MED;
    RULE_CTRL_MakeParamTag(param_p, "wa", "trap", "http", "wa-trap-http");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(param_p->ace_entry, RULE_CTRL_PROT_TCP);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_L4DstPort);
    RULE_CTRL_SET_FILTER_DPORT(param_p->ace_entry, 80);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpType);
    RULE_CTRL_SET_FILTER_IPTYPE(param_p->ace_entry, bcmFieldIpTypeIpv4Any);

    /* Use copy to CPU + drip to replace redirect CPU, becuase CPU
     * port does not join to all VLAN, so the action
     * bcmFieldActionRedirectPbmp was not working
     * (RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU).
     */
    RULE_CTRL_SET_ACTION_COPY_TO_CPU(param_p->action_entries[0]);
    param_p->action_entries[0].next_action = &param_p->action_entries[1];
    RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[1]);
    param_p->action_entries[1].next_action = NULL;

    return TRUE;
}

static BOOL_T RULE_CTRL_WA_SETRULE_PermitDhcp(RULE_CTRL_PARAM_PTR param_p, DEVRM_PBMP_T new_pbmp)
{
    param_p->func_type  = RULE_TYPE_WEBAUTH_PRIO_MED;
    RULE_CTRL_MakeParamTag(param_p, "wa", "permit", "dhcp", "wa-permit-dhcp");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_L4DstPort);
    RULE_CTRL_SET_FILTER_SPORT(param_p->ace_entry, 68);
    RULE_CTRL_SET_FILTER_DPORT(param_p->ace_entry, 67);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpType);
    RULE_CTRL_SET_FILTER_IPTYPE(param_p->ace_entry, bcmFieldIpTypeIpv4Any);

    RULE_CTRL_SET_ACTION_DROP_CANCEL(param_p->action_entries[0]);
    param_p->action_entries[0].next_action = NULL;

    return TRUE;
}

static BOOL_T RULE_CTRL_WA_SETRULE_PermitDns(RULE_CTRL_PARAM_PTR param_p, DEVRM_PBMP_T new_pbmp)
{
    param_p->func_type  = RULE_TYPE_WEBAUTH_PRIO_MED;
    RULE_CTRL_MakeParamTag(param_p, "wa", "permit", "dns", "wa-permit-dns");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_L4DstPort);
    RULE_CTRL_SET_FILTER_DPORT(param_p->ace_entry, 53);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpType);
    RULE_CTRL_SET_FILTER_IPTYPE(param_p->ace_entry, bcmFieldIpTypeIpv4Any);

    RULE_CTRL_SET_ACTION_DROP_CANCEL(param_p->action_entries[0]);
    param_p->action_entries[0].next_action = NULL;

    return TRUE;
}

static BOOL_T RULE_CTRL_WA_SETRULE_DenyAnyIpPacket(RULE_CTRL_PARAM_PTR param_p, DEVRM_PBMP_T new_pbmp)
{
    param_p->func_type  = RULE_TYPE_WEBAUTH_PRIO_LOW;
    RULE_CTRL_MakeParamTag(param_p, "wa", "deny", "ip", "wa-deny-ip");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpType);
    RULE_CTRL_SET_FILTER_IPTYPE(param_p->ace_entry, bcmFieldIpTypeIpv4Any);

    RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[0]);
    param_p->action_entries[0].next_action = NULL;

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_WA_GetPermitIpRuleStorage
 *------------------------------------------------------------------------------
 * PURPOSE:  Get rule storage of Web Authentication by specified input
 * INPUT:    unit           - unit
 *           port           - port
 *           src_ipv4_addr  - source IPv4 address
 * OUTPUT:   None
 * RETURN:   rule storage pointer / NULL
 * NOTE:
 *------------------------------------------------------------------------------
 */
static RULE_CTRL_WebAuthPermitIPRuleStorage_T* RULE_CTRL_WA_GetPermitIpRuleStorage(
    UI32_T  unit,
    UI32_T  port,
    UI8_T   *src_ipv4_addr)
{
    RULE_CTRL_WebAuthPermitIPRuleStorage_T *rs_p   = NULL;
    UI32_T                                  i;

    if (unit == 0
        || port == 0
        || SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK < unit
        || SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT < port)
    {
        return NULL;
    }

    rs_p = &shmem_data_p->web_auth_permit_ip[unit-1][port-1][0];

    for (i=0; i<SYS_ADPT_WEBAUTH_MAX_NBR_OF_HOSTS_PER_PORT; i++)
    {
        if (rs_p[i].rule_storage.is_enable)
        {
            if (0 == memcmp(rs_p[i].src_ipv4_addr, src_ipv4_addr, sizeof(rs_p[i].src_ipv4_addr)))
            {
                return &rs_p[i];
            }
        }
    }

    return NULL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_WA_GetPermitIpRuleStorageByRuleId
 *------------------------------------------------------------------------------
 * PURPOSE:  Get rule storage of Web Authentication by specified input
 * INPUT:    unit           - unit
 *           port           - port
 *           src_ipv4_addr  - source IPv4 address
 * OUTPUT:   None
 * RETURN:   rule storage pointer / NULL
 * NOTE:
 *------------------------------------------------------------------------------
 */
static RULE_CTRL_WebAuthPermitIPRuleStorage_T* RULE_CTRL_WA_GetPermitIpRuleStorageByRuleId(
    UI32_T  unit,
    UI32_T  port,
    UI32_T  rule_id)
{
    RULE_CTRL_WebAuthPermitIPRuleStorage_T *rs_p   = NULL;
    UI32_T                                  i;

    if (unit == 0
        || port == 0
        || SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK < unit
        || SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT < port)
    {
        return NULL;
    }

    unit -= 1;
    port -= 1;

    for (i=0; i<SYS_ADPT_WEBAUTH_MAX_NBR_OF_HOSTS_PER_PORT; i++)
    {
        rs_p = &shmem_data_p->web_auth_permit_ip[unit][port][i];

        if (rs_p->rule_storage.is_enable)
        {
            if (rs_p->rule_storage.rule_id == rule_id)
            {
                return rs_p;
            }
        }
    }

    return NULL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_WA_AllocatePermitIPRuleStorage
 *------------------------------------------------------------------------------
 * PURPOSE:  Find empty rule storage of Web Authentication by specified input
 * INPUT:    unit           - unit
 *           port           - port
 *           src_ipv4_addr  - source IPv4 address
 * OUTPUT:   None
 * RETURN:   rule storage pointer / NULL
 * NOTE:
 *------------------------------------------------------------------------------
 */
static RULE_CTRL_WebAuthPermitIPRuleStorage_T* RULE_CTRL_WA_AllocatePermitIPRuleStorage(
    UI32_T  unit,
    UI32_T  port,
    UI8_T   *src_ipv4_addr)
{
    RULE_CTRL_WebAuthPermitIPRuleStorage_T  *rs_p = NULL;
    UI32_T                                  i;

    if (unit == 0
        || port == 0
        || SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK < unit
        || SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT < port)
    {
        return NULL;
    }

    rs_p = &shmem_data_p->web_auth_permit_ip[unit-1][port-1][0];

    for (i=0; i<SYS_ADPT_WEBAUTH_MAX_NBR_OF_HOSTS_PER_PORT; i++)
    {
        if (!rs_p[i].rule_storage.is_enable)
        {
            memcpy(rs_p[i].src_ipv4_addr, src_ipv4_addr, sizeof(rs_p[i].src_ipv4_addr));

            /* clear all rule ID
             */
            rs_p[i].rule_storage.rule_id = 0;
            return &rs_p[i];
        }
    }

    return NULL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_WA_DO_PermitIpPacket
 *------------------------------------------------------------------------------
 * PURPOSE:  Permit IP packet for Web Authentication
 * INPUT:    param_p - General parameter
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_WA_DO_PermitIpPacket(RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T                                  module_id, device_id, phy_port;
    RULE_CTRL_WebAuthPermitIPRuleStorage_T  *rs_p;
    DEVRM_PBMP_T                            new_pbmp;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit, param_p->port,
                                                        &module_id, &device_id, &phy_port))
    {
        return FALSE;
    }

    if (param_p->flags & RULE_CTRL_OPT_INSTALL)
    {
        rs_p = RULE_CTRL_WA_GetPermitIpRuleStorage(param_p->unit,
                                                   param_p->port,
                                                   param_p->WA.src_ipv4_addr.un_b);
        if (NULL == rs_p)
        {
            rs_p = RULE_CTRL_WA_AllocatePermitIPRuleStorage(param_p->unit,
                                                            param_p->port,
                                                            param_p->WA.src_ipv4_addr.un_b);
        }

    }
    else if (param_p->flags & RULE_CTRL_OPT_QUERY_BY_RULE_ID)
    {
        rs_p = RULE_CTRL_WA_GetPermitIpRuleStorageByRuleId(param_p->query.unit,
                                                           param_p->query.port,
                                                           param_p->query.rule_id);

        if (rs_p)
        {
            memcpy(&param_p->WA.src_ipv4_addr, rs_p->src_ipv4_addr, sizeof(param_p->WA.src_ipv4_addr));
        }
    }
    else /* for UnInstall and OPT_QUERY */
    {
        rs_p = RULE_CTRL_WA_GetPermitIpRuleStorage(param_p->unit,
                                                   param_p->port,
                                                   param_p->WA.src_ipv4_addr.un_b);
    }

    if (rs_p)
    {
        param_p->rule_storage_p = &rs_p->rule_storage;
    }

    param_p->func_type = RULE_TYPE_WEBAUTH_PRIO_HIGH;
    RULE_CTRL_MakeParamTag(param_p, "wa", "permit", "ip", "wa-permit-ip");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_PBMP_CLEAR(new_pbmp);
    DEVRM_PBMP_PORT_ADD(new_pbmp, phy_port);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_SrcIp);
    RULE_CTRL_SET_FILTER_SIP(param_p->ace_entry, param_p->WA.src_ipv4_addr.un_w);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpType);
    RULE_CTRL_SET_FILTER_IPTYPE(param_p->ace_entry, bcmFieldIpTypeIpv4Any);

    RULE_CTRL_SET_ACTION_DROP_CANCEL(param_p->action_entries[0]);
    param_p->action_entries[0].next_action = NULL;

    return TRUE;
}

#endif /* #if (SYS_CPNT_WEBAUTH == TRUE) */

#if (SYS_CPNT_DOT1X == TRUE)
static void* RULE_CTRL_1X_GETOM_TrapDot1xUCToCPU(RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T  module_id, device_id, phy_port;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit, param_p->port,
                                                        &module_id, &device_id, &phy_port))
    {
        return NULL;
    }

    return &shmem_data_p->dot1xuc[param_p->unit-1][device_id];
}

static BOOL_T RULE_CTRL_1X_SETRULE_TrapDot1xUCToCPU(RULE_CTRL_PARAM_PTR param_p, DEVRM_PBMP_T new_pbmp)
{
    RULE_CTRL_Dot1xUCRuleStorage_T         *rs_p;

    rs_p = (RULE_CTRL_Dot1xUCRuleStorage_T*)param_p->rule_storage_p;

    if (rs_p)
    {
        if (param_p->flags & RULE_CTRL_OPT_QUERY ||
            param_p->flags & RULE_CTRL_OPT_QUERY_BY_RULE_ID)
        {
            if (TRUE == param_p->rule_storage_p->is_enable)
            {
                memcpy(param_p->DOT1X_UC.cpu_mac, rs_p->cpu_mac, sizeof(rs_p->cpu_mac));
            }
        }
        else if (param_p->flags & RULE_CTRL_OPT_INSTALL)
        {
            if (TRUE == param_p->rule_storage_p->is_enable)
            {
                if (0 != memcmp(param_p->DOT1X_UC.cpu_mac, rs_p->cpu_mac, sizeof(rs_p->cpu_mac)))
                {
                    RULE_CTRL_LOG("CPU MAC changed");
                    return FALSE;
                }
            }
            else
            {
                memcpy(rs_p->cpu_mac, param_p->DOT1X_UC.cpu_mac, sizeof(rs_p->cpu_mac));
            }
        }
    }

    param_p->func_type  = RULE_TYPE_PACKET_TO_CPU_DEFAULT;
    RULE_CTRL_MakeParamTag(param_p, "dot1x", "1x", "trap", "1x-uc-trap");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(param_p->ace_entry, RULE_CTRL_ETHER_TYPE_EAP);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    RULE_CTRL_SET_FILTER_DA(param_p->ace_entry, param_p->DOT1X_UC.cpu_mac);

    /* Use copy to CPU + drip to replace redirect CPU, becuase CPU
     * port does not join to all VLAN, so the action
     * bcmFieldActionRedirectPbmp was not working
     * (RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU).
     */
    RULE_CTRL_SET_ACTION_COPY_TO_CPU(param_p->action_entries[0]);
    param_p->action_entries[0].next_action = &param_p->action_entries[1];
    RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[1]);
    param_p->action_entries[1].next_action = &param_p->action_entries[2];

    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[2], SYS_ADPT_CPU_QUEUE_DOT1X);
    param_p->action_entries[2].next_action = NULL;

    return TRUE;
}

#if (SYS_CPNT_DOT1X_EAPOL_PASS_THROUGH_BY_RULE == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_1X_DO_SetEapolPassThrough
 *------------------------------------------------------------------------------
 * PURPOSE  : Fill rule for eapol-pass-through
 * INPUT    : param_p
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_1X_DO_SetEapolPassThrough(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI8_T eapol_mac_addr[] = {0x01, 0x80, 0xC2, 0x00, 0x00, 0x03};
    UI8_T eapol_mac_mask[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_PRIO_2;
    param_p->sys_rule_storage_p = &shmem_data_p->dot1x_eapol_pass_through.rule_storage;

    RULE_CTRL_MakeParamTag(param_p, "dot1x", "1x", "permit", "1x-permit-eapol");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(param_p->ace_entry);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(param_p->ace_entry, RULE_CTRL_ETHER_TYPE_EAP);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    RULE_CTRL_SET_FILTER_DA_MASK(param_p->ace_entry, eapol_mac_addr, eapol_mac_mask);

    RULE_CTRL_SET_ACTION_DROP_CANCEL(param_p->action_entries[0]);
    param_p->action_entries[0].next_action = NULL;

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_1X_SetEapolPassThrough
 *------------------------------------------------------------------------------
 * PURPOSE:  Add/Delete rule for eapol-pass-through
 * INPUT:    is_enable: TRUE - add rule.
 *                      FALSE - delete rule.
 * OUTPUT:   none
 * RETURN:   TRUE/FALSE
 * NOTE:     ethertype = 0x888e, DA = 0x0180c2000003
 *------------------------------------------------------------------------------
 */
BOOL_T
RULE_CTRL_1X_SetEapolPassThrough(
    BOOL_T is_enable)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s", is_enable ? "enable" : "disable");

    RULE_CTRL_InitParam(&param);

    if (is_enable == TRUE)
    {
        param.flags |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    param.flags |= RULE_CTRL_OPT_ALL_DEVICES;

    return _rule_ctrl_set_rule(&param, RULE_CTRL_1X_DO_SetEapolPassThrough);
}
#endif /* SYS_CPNT_DOT1X_EAPOL_PASS_THROUGH_BY_RULE */
#endif /* #if (SYS_CPNT_DOT1X == TRUE) */

#if (SYS_CPNT_ERPS == TRUE)
/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_ERPS_GETOM_TrapRapsPduToCPU
 *------------------------------------------------------------------------------
 * PURPOSE : This function will enable R-APS PDU redirect to CPU rule
 *           for specified unit and port
 * INPUT:    param_p - General parameter
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
static void* RULE_CTRL_ERPS_GETOM_TrapRapsPduToCPU(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T  module_id, device_id, phy_port;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit,
                                                        param_p->port,
                                                        &module_id,
                                                        &device_id,
                                                        &phy_port))
    {
        return NULL;
    }

    return &shmem_data_p->erps_raps[param_p->unit-1][device_id];
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_ERPS_SETRULE_TrapRapsPduToCPU
 *------------------------------------------------------------------------------
 * PURPOSE : This function will enable R-APS PDU redirect to CPU rule
 *           for specified unit and port
 * INPUT:    param_p - General parameter
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_ERPS_SETRULE_TrapRapsPduToCPU(
    RULE_CTRL_PARAM_PTR param_p,
    DEVRM_PBMP_T new_pbmp)
{
    /* packet format:   ETH: 0x8902
     *                  DA : 0x0119a7-000001
     */
    UI32_T  ethtype = 0X8902;
    UI8_T   da[]    = {0x01, 0x19, 0xA7, 0x00, 0x00, 0x01};

    param_p->func_type  = RULE_TYPE_PACKET_TO_CPU_DEFAULT;
    RULE_CTRL_MakeParamTag(param_p, "erps", NULL, NULL, NULL);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(param_p->ace_entry, ethtype);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    RULE_CTRL_SET_FILTER_DA(param_p->ace_entry, da);
    /*  modify for v2, the last byte may be ring-id, ignored by rule
     */
    param_p->ace_entry.dstmac_mask[5] = 0x0;

    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(param_p->action_entries[0]);

    return TRUE;
}
#endif /* #if (SYS_CPNT_ERPS == TRUE) */

#if (SYS_CPNT_EFM_OAM_REMOTE_LB_PASSIVELY == TRUE)
/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_OAM_CPE_GETOM_TrapOamPduToCPU
 *------------------------------------------------------------------------------
 * PURPOSE : For CPE, redirect EFM OAM PDU to CPU rule.
 * INPUT:    param_p - General parameter
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
static void* RULE_CTRL_OAM_CPE_GETOM_TrapOamPduToCPU(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T  module_id, device_id, phy_port;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit,
                                                        param_p->port,
                                                        &module_id,
                                                        &device_id,
                                                        &phy_port))
    {
        return NULL;
    }

    return &shmem_data_p->cpe_oampdu[param_p->unit-1][device_id];
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_OAM_CPE_SETRULE_TrapOamPduToCPU
 *------------------------------------------------------------------------------
 * PURPOSE : For CPE, redirect EFM OAM PDU to CPU rule.
 * INPUT:    param_p - General parameter
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_OAM_CPE_SETRULE_TrapOamPduToCPU(
    RULE_CTRL_PARAM_PTR param_p,
    DEVRM_PBMP_T new_pbmp)
{
    /* packet format:   ETH: 0x8809
     *                  DA : 0x0180c2-000002
     */
    UI32_T  ethtype = RULE_CTRL_ETHER_TYPE_CPE_OAM_PDU;
    UI8_T   da[]    = {0x01, 0x80, 0xC2, 0x00, 0x00, 0x02};

    param_p->func_type  = RULE_TYPE_PACKET_TO_CPU_DEFAULT;
    RULE_CTRL_MakeParamTag(param_p, "oam", "cpe", "oam-pdu", "oam-cpe-oam-pdu");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(param_p->ace_entry, ethtype);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    RULE_CTRL_SET_FILTER_DA(param_p->ace_entry, da);

    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(param_p->action_entries[0]);
    param_p->action_entries[0].next_action = &param_p->action_entries[1];

    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[1], SYS_ADPT_CPU_QUEUE_OAM);
    param_p->action_entries[1].next_action = NULL;

    return TRUE;
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_GETOM_TrapOAMLoopbackToCPUForCPE
 *------------------------------------------------------------------------------
 * PURPOSE : For CPE, redirect EFM OAM loopback packet to receiving port.
 * INPUT:    param_p - General parameter
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
static void* RULE_CTRL_OAM_CPE_GETOM_RedirOamLoopbackToRecvPort(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T  module_id, device_id, phy_port;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit,
                                                        param_p->port,
                                                        &module_id,
                                                        &device_id,
                                                        &phy_port))
    {
        return NULL;
    }

    return &shmem_data_p->cpe_oamloopback[param_p->unit-1][device_id];
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_SETRULE_TrapOAMLoopbackToCPUForCPE
 *------------------------------------------------------------------------------
 * PURPOSE : For CPE, redirect EFM OAM loopback packet to receiving port.
 * INPUT:    param_p - General parameter
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_OAM_CPE_SETRULE_RedirOamLoopbackToRecvPort(
    RULE_CTRL_PARAM_PTR param_p,
    DEVRM_PBMP_T new_pbmp)
{
    param_p->func_type  = RULE_TYPE_PACKET_TO_CPU_LOW;
    RULE_CTRL_MakeParamTag(param_p, "oam", "cpe", "loopback", "oam-cpe-oam-loopback");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);
    RULE_CTRL_SET_ACTION_REDIRECT_TO_PORT_BITMAP(param_p->action_entries[0], new_pbmp);
    return TRUE;
}
#endif /* #if (SYS_CPNT_EFM_OAM_REMOTE_LB_PASSIVELY == TRUE) */

#if (SYS_CPNT_EFM_OAM_REMOTE_LB_ACTIVELY == TRUE)
/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_GETOM_TrapOAMLoopbackToCPU
 *------------------------------------------------------------------------------
 * FUNCTION : For CO side, trap EFM OAM loopback packet to CPU.
 * INPUT:    param_p - General parameter
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
static void* RULE_CTRL_OAM_CO_GETOM_TrapOamLoopbackToCPU(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T  module_id, device_id, phy_port;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit,
                                                        param_p->port,
                                                        &module_id,
                                                        &device_id,
                                                        &phy_port))
    {
        return NULL;
    }

    return &shmem_data_p->co_oamloopback[param_p->unit-1][device_id];
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_SETRULE_TrapOAMLoopbackToCPU
 *------------------------------------------------------------------------------
 * FUNCTION : For CO side, trap EFM OAM loopback packet to CPU.
 * INPUT:    param_p - General parameter
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_OAM_CO_SETRULE_TrapOamLoopbackToCPU(
    RULE_CTRL_PARAM_PTR param_p,
    DEVRM_PBMP_T new_pbmp)
{
    /* packet format:   ETH: 0x9000
     *                  DA : 0xffffff-ffffff
     */
    UI32_T  ethtype = RULE_CTRL_ETHER_TYPE_CO_OAM_LOOPBACK;
    UI8_T   da[]    = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

    param_p->func_type  = RULE_TYPE_PACKET_TO_CPU_DEFAULT;
    RULE_CTRL_MakeParamTag(param_p, "oam", "co", "loopback", "oam-co-oam-loopback");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(param_p->ace_entry, ethtype);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    RULE_CTRL_SET_FILTER_DA(param_p->ace_entry, da);

    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(param_p->action_entries[0]);
    param_p->action_entries[0].next_action = &param_p->action_entries[1];

    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[1], SYS_ADPT_CPU_QUEUE_OAM);
    param_p->action_entries[1].next_action = NULL;

    return TRUE;
}
#endif /* #if (SYS_CPNT_EFM_OAM_REMOTE_LB_ACTIVELY == TRUE) */

#if (SYS_CPNT_QINQ_L2PT_CUSTOM_PDU == TRUE)
/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_L2PT_GETOM_SetCustomPduTrapStatusForL2PT
 *------------------------------------------------------------------------------
 * FUNCTION : Trap customo PDU for L2PT to CPU.
 * INPUT:    param_p - General parameter
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
static void* RULE_CTRL_L2PT_GETOM_SetCustomPduTrapStatusForL2PT(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T  module_id, device_id, phy_port;
    RULE_CTRL_L2PTCustomPduRuleStorage_T *l2pt_rs_p;
    RULE_CTRL_SPRRuleStorage_T *rs_p;
    int i;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit,
                                                        param_p->port,
                                                        &module_id,
                                                        &device_id,
                                                        &phy_port))
    {
        return NULL;
    }

    l2pt_rs_p = shmem_data_p->l2pt_custom_pdu[param_p->unit-1][device_id];
    rs_p = NULL;

    for (i = 0; i < SYS_ADPT_QINQ_L2PT_MAX_NBR_OF_CUSTOM_PDU_CONFIG; i++)
    {
        if (l2pt_rs_p[i].spr_rs.rule_storage.is_enable)
        {
            if (0 == memcmp(l2pt_rs_p[i].dstmac, param_p->L2PT_CUSTOM_PDU.dstmac, sizeof(l2pt_rs_p[i].dstmac)))
            {
                rs_p = &l2pt_rs_p[i].spr_rs;
                break;
            }
        }
        else if (rs_p == NULL)
        {
            rs_p = &l2pt_rs_p[i].spr_rs;
            memcpy(l2pt_rs_p[i].dstmac, param_p->L2PT_CUSTOM_PDU.dstmac, sizeof(l2pt_rs_p[i].dstmac));
        }
    }

    return rs_p;
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_L2PT_SETRULE_SetCustomPduTrapStatusForL2PT
 *------------------------------------------------------------------------------
 * FUNCTION : Trap customo PDU for L2PT to CPU.
 * INPUT:    param_p - General parameter
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_L2PT_SETRULE_SetCustomPduTrapStatusForL2PT(
    RULE_CTRL_PARAM_PTR param_p,
    DEVRM_PBMP_T new_pbmp)
{
    param_p->func_type  = RULE_TYPE_PACKET_TO_CPU_DEFAULT;
    RULE_CTRL_MakeParamTag(param_p, "l2pt", "custom-pdu", NULL, NULL);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    if (param_p->L2PT_CUSTOM_PDU.ethertype != 0)
    {
        DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
        RULE_CTRL_SET_FILTER_ETHER_TYPE(param_p->ace_entry, param_p->L2PT_CUSTOM_PDU.ethertype);
    }

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    RULE_CTRL_SET_FILTER_DA(param_p->ace_entry, param_p->L2PT_CUSTOM_PDU.dstmac);

    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(param_p->action_entries[0]);
    param_p->action_entries[0].next_action = &param_p->action_entries[1];

    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[1], SYS_ADPT_CPU_QUEUE_L2CP);
    param_p->action_entries[1].next_action = NULL;

    return TRUE;
}
#endif /* (SYS_CPNT_QINQ_L2PT_CUSTOM_PDU == TRUE) */

#define RULE_CTRL_IS_ZEOR_MAC_ADDR(mac) (mac[0]==0&&mac[1]==0&&mac[2]==0&&mac[3]==0&&mac[4]==0&&mac[5]==0)

#if (SYS_CPNT_IP_SOURCE_GUARD == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IPSG_GetPermitIPRuleStorage
 *------------------------------------------------------------------------------
 * PURPOSE:  Get rule storage of IPSG by specified input
 * INPUT:    unit           - unit
 *           port           - port
 *           vlan_id        - VLAN ID
 *           src_ipv4_addr  - source IPv4 address
 *           src_mac_addr   - source MAC address
 * OUTPUT:   None
 * RETURN:   rule storage pointer / NULL
 * NOTE:
 *------------------------------------------------------------------------------
 */
static RULE_CTRL_IPSGPermitIPRuleStorage_T*
RULE_CTRL_IPSG_GetPermitIPRuleStorage(
    UI32_T  unit,
    UI32_T  port,
    UI32_T  vlan_id,
    UI8_T   *src_ipv4_addr,
    UI8_T   *src_mac_addr)
{
    RULE_CTRL_IPSGPermitIPRuleStorage_T *rs_p   = NULL;
    UI32_T                              i;
    UI8_T                               wk_mac_addr[SYS_ADPT_MAC_ADDR_LEN] = {0};

    if (unit == 0
        || port == 0
        || SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK < unit
        || SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT < port)
    {
        return NULL;
    }

    rs_p = &shmem_data_p->ipsg_permit_ip[unit-1][port-1][0];

    if (src_mac_addr)
    {
        if (RULE_CTRL_IS_ZEOR_MAC_ADDR(src_mac_addr))
            return NULL;

        memcpy(wk_mac_addr, src_mac_addr, sizeof(wk_mac_addr));
    }

    for (i=0; i<SYS_ADPT_DHCPSNP_MAX_NBR_OF_CLIENT_PER_PORT; i++)
    {
        if (rs_p[i].rule_storage.is_enable)
        {
            if (rs_p[i].vlan_id == vlan_id
                && 0 == memcmp(rs_p[i].ipv4_addr, src_ipv4_addr, sizeof(rs_p[i].ipv4_addr))
                && 0 == memcmp(rs_p[i].mac_addr, wk_mac_addr, sizeof(rs_p[i].mac_addr)))
            {
                return &rs_p[i];
            }
        }
    }

    return NULL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IPSG_GetPermitIpRuleStorageByRuleId
 *------------------------------------------------------------------------------
 * PURPOSE:  Get rule storage of IPSG by the specified rule ID
 * INPUT:    unit           - unit
 *           port           - port
 *           rule_id        - rule ID
 * OUTPUT:   None
 * RETURN:   rule storage pointer / NULL
 * NOTE:
 *------------------------------------------------------------------------------
 */
static RULE_CTRL_IPSGPermitIPRuleStorage_T*
RULE_CTRL_IPSG_GetPermitIpRuleStorageByRuleId(
    UI32_T  unit,
    UI32_T  port,
    UI32_T  rule_id)
{
    RULE_CTRL_IPSGPermitIPRuleStorage_T *rs_p   = NULL;
    UI32_T                              i;

    if (unit == 0
        || port == 0
        || SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK < unit
        || SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT < port)
    {
        return NULL;
    }

    rs_p = &shmem_data_p->ipsg_permit_ip[unit-1][port-1][0];

    for (i=0; i<SYS_ADPT_DHCPSNP_MAX_NBR_OF_CLIENT_PER_PORT; i++)
    {
        if (rs_p[i].rule_storage.is_enable)
        {
            if (rs_p[i].rule_storage.rule_id == rule_id)
            {
                return &rs_p[i];
            }
        }
    }

    return NULL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IPSG_AllocatePermitIPRuleStorage
 *------------------------------------------------------------------------------
 * PURPOSE:  Find empty rule storage of IPSG by specified input
 * INPUT:    unit           - unit
 *           port           - port
 *           vlan_id        - VLAN ID
 *           src_ipv4_addr  - source IPv4 address
 *           src_mac_addr   - source MAC address
 * OUTPUT:   None
 * RETURN:   rule storage pointer / NULL
 * NOTE:
 *------------------------------------------------------------------------------
 */
static RULE_CTRL_IPSGPermitIPRuleStorage_T*
RULE_CTRL_IPSG_AllocatePermitIPRuleStorage(
    UI32_T  unit,
    UI32_T  port,
    UI32_T  vlan_id,
    UI8_T   *src_ipv4_addr,
    UI8_T   *src_mac_addr)
{
    RULE_CTRL_IPSGPermitIPRuleStorage_T *rs_p = NULL;
    UI32_T                              i;
    UI8_T                               wk_mac_addr[SYS_ADPT_MAC_ADDR_LEN] = {0};

    if (unit == 0
        || port == 0
        || SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK < unit
        || SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT < port)
    {
        return NULL;
    }

    rs_p = &shmem_data_p->ipsg_permit_ip[unit-1][port-1][0];

    if (src_mac_addr)
    {
        if (RULE_CTRL_IS_ZEOR_MAC_ADDR(src_mac_addr))
            return NULL;

        memcpy(wk_mac_addr, src_mac_addr, sizeof(wk_mac_addr));
    }

    for (i=0; i<SYS_ADPT_DHCPSNP_MAX_NBR_OF_CLIENT_PER_PORT; i++)
    {
        if (!rs_p[i].rule_storage.is_enable)
        {
            rs_p[i].vlan_id = vlan_id;
            memcpy(rs_p[i].ipv4_addr, src_ipv4_addr, sizeof(rs_p[i].ipv4_addr));
            memcpy(rs_p[i].mac_addr, wk_mac_addr, sizeof(rs_p[i].mac_addr));

            /* clear all rule ID
             */
            rs_p[i].rule_storage.rule_id = 0;
            return &rs_p[i];
        }
    }

    return NULL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IPSG_DO_PermitIpPacket
 *------------------------------------------------------------------------------
 * PURPOSE:  Permit IP packet for IPSG
 * INPUT:    param_p - General parameter
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_IPSG_DO_PermitIpPacket(RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T                              module_id, device_id, phy_port;
    RULE_CTRL_IPSGPermitIPRuleStorage_T *rs_p;
    UI32_T                              have_mac_addr;
    DEVRM_PBMP_T                          new_pbmp;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit, param_p->port,
        &module_id, &device_id, &phy_port))
    {
        RULE_CTRL_LOG("Invalid unit(%lu) port(%lu)", param_p->unit, param_p->port);
        return FALSE;
    }

    if (param_p->IPSG.len == sizeof(param_p->IPSG.vlan_id) + sizeof(param_p->IPSG.src_ipv4_addr))
    {
        have_mac_addr = 0;
    }
    else
    {
        have_mac_addr = 1;
    }

    if (param_p->flags & RULE_CTRL_OPT_INSTALL)
    {
        rs_p = RULE_CTRL_IPSG_GetPermitIPRuleStorage(param_p->unit,
                                                     param_p->port,
                                                     param_p->IPSG.vlan_id,
                                                     param_p->IPSG.src_ipv4_addr.un_b,
                                                     (have_mac_addr) ? param_p->IPSG.src_mac_addr : NULL);
        if (NULL == rs_p)
        {
            rs_p = RULE_CTRL_IPSG_AllocatePermitIPRuleStorage(param_p->unit,
                                                              param_p->port,
                                                              param_p->IPSG.vlan_id,
                                                              param_p->IPSG.src_ipv4_addr.un_b,
                                                              (have_mac_addr) ? param_p->IPSG.src_mac_addr : NULL);
        }
    }
    else if (param_p->flags & RULE_CTRL_OPT_QUERY_BY_RULE_ID)
    {
        rs_p = RULE_CTRL_IPSG_GetPermitIpRuleStorageByRuleId(param_p->unit,
                                                             param_p->port,
                                                             param_p->query.rule_id);
        if (rs_p)
        {
            param_p->IPSG.vlan_id = rs_p->vlan_id;
            memcpy(&param_p->IPSG.src_ipv4_addr, rs_p->ipv4_addr, sizeof(param_p->IPSG.src_ipv4_addr));
            param_p->IPSG.len = sizeof(param_p->IPSG.vlan_id) + sizeof(param_p->IPSG.src_ipv4_addr);

            memcpy(&param_p->IPSG.src_mac_addr, rs_p->mac_addr, sizeof(param_p->IPSG.src_mac_addr));

            if (RULE_CTRL_IS_ZEOR_MAC_ADDR(rs_p->mac_addr))
            {
                have_mac_addr = 0;
            }
            else
            {
                have_mac_addr = 1;
                param_p->IPSG.len += sizeof(param_p->IPSG.src_mac_addr);
            }
        }
    }
    else /* Uninstall || RULE_CTRL_OPT_QUERY */
    {
        rs_p = RULE_CTRL_IPSG_GetPermitIPRuleStorage(param_p->unit,
                                                    param_p->port,
                                                    param_p->IPSG.vlan_id,
                                                    param_p->IPSG.src_ipv4_addr.un_b,
                                                    (have_mac_addr) ? param_p->IPSG.src_mac_addr : NULL);
    }

    if (rs_p)
    {
        param_p->rule_storage_p = &rs_p->rule_storage;
    }

    param_p->func_type  = RULE_TYPE_IP_SOURCE_GUARD_PRIO_HIGH;
    RULE_CTRL_MakeParamTag(param_p, "ipsg", "permit", "ip", "ipsg-permit-ip");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_PBMP_CLEAR(new_pbmp);
    DEVRM_PBMP_PORT_ADD(new_pbmp, phy_port);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_OuterVlan);
    RULE_CTRL_SET_FILTER_OUTERVLAN(param_p->ace_entry, param_p->IPSG.vlan_id)

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_SrcIp);
    RULE_CTRL_SET_FILTER_SIP(param_p->ace_entry, param_p->IPSG.src_ipv4_addr.un_w);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpType);
    RULE_CTRL_SET_FILTER_IPTYPE(param_p->ace_entry, bcmFieldIpTypeIpv4Any);

    if (have_mac_addr == 1)
    {
        DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_SrcMac);
        RULE_CTRL_SET_FILTER_SA(param_p->ace_entry, param_p->IPSG.src_mac_addr);
    }

    RULE_CTRL_INITIALIZE_ACTION_ENTRY(param_p->action_entries);

    /* Not set permit action, for working with ACL
     */
    /*
     * RULE_CTRL_SET_ACTION_DROP_CANCEL(param_p->action_entries[0]);
     * param_p->action_entries[0].next_action = NULL;
     */

    return TRUE;
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_IPSG_GETOM_DenyAnyIpPacket
 *------------------------------------------------------------------------------
 * PURPOSE:  Get rule storage
 * INPUT:    param_p - General parameter
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static void*
RULE_CTRL_IPSG_GETOM_DenyAnyIpPacket(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T  module_id, device_id, phy_port;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit,
                                                        param_p->port,
                                                        &module_id,
                                                        &device_id,
                                                        &phy_port))
    {
        return NULL;
    }

    return &shmem_data_p->ipsg_deny_any_ip[param_p->unit-1][device_id];
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_IPSG_SETRULE_DenyAnyIpPacket
 *------------------------------------------------------------------------------
 * PURPOSE:  Deny any IP packet for IPSG
 * INPUT:    param_p - General parameter
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IPSG_SETRULE_DenyAnyIpPacket(
    RULE_CTRL_PARAM_PTR param_p,
    DEVRM_PBMP_T new_pbmp)
{
    param_p->func_type      = RULE_TYPE_IP_SOURCE_GUARD_PRIO_LOW;
    RULE_CTRL_MakeParamTag(param_p, "ipsg", "deny", "ip", "ipsg-deny-ip");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpType);
    RULE_CTRL_SET_FILTER_IPTYPE(param_p->ace_entry, bcmFieldIpTypeIpv4Any);

    RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[0]);
    RULE_CTRL_SET_ACTION_SWITCH_TO_CPU_CANCEL(param_p->action_entries[1]);
    param_p->action_entries[0].next_action = &param_p->action_entries[1];
    param_p->action_entries[1].next_action = NULL;

    return TRUE;
}
#endif /* #if (SYS_CPNT_IP_SOURCE_GUARD == TRUE) */

#if (SYS_CPNT_IPV6_SOURCE_GUARD == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IPV6SG_GetPermitIPv6RuleStorages
 *------------------------------------------------------------------------------
 * PURPOSE:  Get rule storage of IPV6SG by specified input
 * INPUT:    unit           - unit
 *           port           - port
 *           vlan_id        - VLAN ID
 *           src_ipv6_addr  - source IPv6 address
 * OUTPUT:   None
 * RETURN:   rule storage pointer / NULL
 * NOTE:
 *------------------------------------------------------------------------------
 */
static RULE_CTRL_IPV6SGPermitIP6RuleStorage_T*
RULE_CTRL_IPV6SG_GetPermitIPv6RuleStorage(
    UI32_T  unit,
    UI32_T  port,
    UI32_T  vlan_id,
    UI8_T   *src_ipv6_addr)
{
    RULE_CTRL_IPV6SGPermitIP6RuleStorage_T  *rs_p   = NULL;
    UI32_T                                  i;

    if (unit == 0
        || port == 0
        || SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK < unit
        || SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT < port)
    {
        return NULL;
    }

    rs_p = &shmem_data_p->ipv6sg_permit_ip6[unit-1][port-1][0];

    for (i=0; i<SYS_ADPT_DHCPSNP_MAX_NBR_OF_CLIENT_PER_PORT; i++)
    {
        if (rs_p[i].rule_storage.is_enable)
        {
            if (rs_p[i].vlan_id == vlan_id
                && 0 == memcmp(rs_p[i].ipv6_addr, src_ipv6_addr, sizeof(rs_p[i].ipv6_addr)))
            {
                return &rs_p[i];
            }
        }
    }

    return NULL;
}

static RULE_CTRL_IPV6SGPermitIP6RuleStorage_T*
RULE_CTRL_IPV6SG_GetPermitIpv6RuleStorageByRuleId(
    UI32_T  unit,
    UI32_T  port,
    UI32_T  rule_id)
{
    RULE_CTRL_IPV6SGPermitIP6RuleStorage_T  *rs_p   = NULL;
    UI32_T                                  i;

    if (unit == 0
        || port == 0
        || SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK < unit
        || SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT < port)
    {
        return NULL;
    }

    rs_p = &shmem_data_p->ipv6sg_permit_ip6[unit-1][port-1][0];

    for (i=0; i<SYS_ADPT_DHCPSNP_MAX_NBR_OF_CLIENT_PER_PORT; i++)
    {
        if (rs_p[i].rule_storage.is_enable)
        {
            if (rs_p[i].rule_storage.rule_id == rule_id)
            {
                return &rs_p[i];
            }
        }
    }

    return NULL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IPV6SG_AllocatePermitIPv6RuleStorage
 *------------------------------------------------------------------------------
 * PURPOSE:  Find empty rule storage of IPSG by specified input
 * INPUT:    unit           - unit
 *           port           - port
 *           vlan_id        - VLAN ID
 *           src_ipv6_addr  - source IPv6 address
 * OUTPUT:   None
 * RETURN:   rule storage pointer / NULL
 * NOTE:
 *------------------------------------------------------------------------------
 */
static RULE_CTRL_IPV6SGPermitIP6RuleStorage_T*
RULE_CTRL_IPV6SG_AllocatePermitIPv6RuleStorage(
    UI32_T  unit,
    UI32_T  port,
    UI32_T  vlan_id,
    UI8_T   *src_ipv6_addr)
{
    RULE_CTRL_IPV6SGPermitIP6RuleStorage_T  *rs_p = NULL;
    UI32_T                                  i;

    if (unit == 0
        || port == 0
        || SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK < unit
        || SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT < port)
    {
        return NULL;
    }

    rs_p = &shmem_data_p->ipv6sg_permit_ip6[unit-1][port-1][0];

    for (i=0; i<SYS_ADPT_DHCPSNP_MAX_NBR_OF_CLIENT_PER_PORT; i++)
    {
        if (!rs_p[i].rule_storage.is_enable)
        {
            rs_p[i].vlan_id = vlan_id;
            memcpy(rs_p[i].ipv6_addr, src_ipv6_addr, sizeof(rs_p[i].ipv6_addr));

            /* clear all rule ID
             */
            rs_p[i].rule_storage.rule_id = 0;
            return &rs_p[i];
        }
    }

    return NULL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IPV6SG_DO_PermitIpv6Packet
 *------------------------------------------------------------------------------
 * PURPOSE:  Permit IPv6 packet for IPV6SG
 * INPUT:    param_p - General parameter
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_IPV6SG_DO_PermitIpv6Packet(RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T                                  module_id, device_id, phy_port;
    RULE_CTRL_IPV6SGPermitIP6RuleStorage_T  *rs_p;
    DEVRM_PBMP_T                              new_pbmp;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit, param_p->port,
        &module_id, &device_id, &phy_port))
    {
        RULE_CTRL_LOG("Invalid unit(%lu) port(%lu)", param_p->unit, param_p->port);
        return FALSE;
    }

    if (param_p->flags & RULE_CTRL_OPT_INSTALL)
    {
        rs_p = RULE_CTRL_IPV6SG_GetPermitIPv6RuleStorage(param_p->unit,
                                                     param_p->port,
                                                     param_p->IPSG.vlan_id,
                                                     param_p->IPSG.src_ipv6_addr.un_b);
        if (NULL == rs_p)
        {
            rs_p = RULE_CTRL_IPV6SG_AllocatePermitIPv6RuleStorage(param_p->unit,
                                                              param_p->port,
                                                              param_p->IPSG.vlan_id,
                                                              param_p->IPSG.src_ipv6_addr.un_b);
        }
    }
    else if (param_p->flags & RULE_CTRL_OPT_QUERY_BY_RULE_ID)
    {
        rs_p = RULE_CTRL_IPV6SG_GetPermitIpv6RuleStorageByRuleId(param_p->unit,
                                                             param_p->port,
                                                             param_p->query.rule_id);
        if (rs_p)
        {
            param_p->IPSG.vlan_id = rs_p->vlan_id;
            memcpy(&param_p->IPSG.src_ipv6_addr, rs_p->ipv6_addr, sizeof(param_p->IPSG.src_ipv6_addr));
            param_p->IPSG.len = sizeof(param_p->IPSG.vlan_id) + sizeof(param_p->IPSG.src_ipv6_addr);
        }
    }
    else /* Uninstall || RULE_CTRL_OPT_QUERY */
    {
        rs_p = RULE_CTRL_IPV6SG_GetPermitIPv6RuleStorage(param_p->unit,
                                                    param_p->port,
                                                    param_p->IPSG.vlan_id,
                                                    param_p->IPSG.src_ipv6_addr.un_b);
    }

    if (rs_p)
    {
        param_p->rule_storage_p = &rs_p->rule_storage;
    }

    param_p->func_type  = RULE_TYPE_IPV6_SG_PERMIT_HOST;
    RULE_CTRL_MakeParamTag(param_p, "ipv6sg", "permit", "ip6", "ipv6sg-permit-ip");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_PBMP_CLEAR(new_pbmp);
    DEVRM_PBMP_PORT_ADD(new_pbmp, phy_port);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_OuterVlan);
    RULE_CTRL_SET_FILTER_OUTERVLAN(param_p->ace_entry, param_p->IPSG.vlan_id)

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_SrcIp6);
    RULE_CTRL_SET_FILTER_SIPV6(param_p->ace_entry, param_p->IPSG.src_ipv6_addr.un_b);

    RULE_CTRL_ADD_FILTER_IPTYPE((&param_p->ace_entry), bcmFieldIpTypeIpv6);

    RULE_CTRL_INITIALIZE_ACTION_ENTRY(param_p->action_entries);

    return TRUE;
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_IPV6SG_GETOM_DenyAnyIp6Packet
 *------------------------------------------------------------------------------
 * PURPOSE:  Get rule storage
 * INPUT:    param_p - General parameter
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static void*
RULE_CTRL_IPV6SG_GETOM_DenyAnyIp6Packet(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T  module_id, device_id, phy_port;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit,
                                                        param_p->port,
                                                        &module_id,
                                                        &device_id,
                                                        &phy_port))
    {
        ASSERT(0);
        return NULL;
    }

    return &shmem_data_p->ipv6sg_deny_any_ip6[param_p->unit-1][device_id];
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_IPV6SG_SETRULE_DenyAnyIp6Packet
 *------------------------------------------------------------------------------
 * PURPOSE:  Deny any IP6 packet for IPSG6
 * INPUT:    param_p - General parameter
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IPV6SG_SETRULE_DenyAnyIp6Packet(
    RULE_CTRL_PARAM_PTR param_p,
    DEVRM_PBMP_T new_pbmp)
{
    param_p->func_type      = RULE_TYPE_IPV6_SG_DENY_ALL;
    RULE_CTRL_MakeParamTag(param_p, "ipv6sg", "deny", "ip6", "ipv6sg-deny-ip6");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    RULE_CTRL_ADD_FILTER_IPTYPE((&param_p->ace_entry), bcmFieldIpTypeIpv6);

    RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[0]);
    RULE_CTRL_SET_ACTION_SWITCH_TO_CPU_CANCEL(param_p->action_entries[1]);
    param_p->action_entries[0].next_action = &param_p->action_entries[1];
    param_p->action_entries[1].next_action = NULL;

    return TRUE;
}
#endif /* #if (SYS_CPNT_IPV6_SOURCE_GUARD == TRUE) */

#if (SYS_CPNT_IP_MULTICAST_DATA_DROP == TRUE) || (SYS_CPNT_MVR == TRUE)
/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_IGMPSNP_GETOM_DenyMulticastData
 *------------------------------------------------------------------------------
 * PURPOSE : This function will enable R-APS PDU redirect to CPU rule
 *           for specified unit and port
 * INPUT:    param_p - General parameter
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
static void*
RULE_CTRL_IGMPSNP_GETOM_DenyMulticastData(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T  module_id, device_id, phy_port;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit,
                                                        param_p->port,
                                                        &module_id,
                                                        &device_id,
                                                        &phy_port))
    {
        return NULL;
    }

    return &shmem_data_p->igmpsnp_denymcdata[param_p->unit-1][device_id];
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_IGMPSNP_SETRULE_DenyMulticastData
 *------------------------------------------------------------------------------
 * PURPOSE : This function will enable R-APS PDU redirect to CPU rule
 *           for specified unit and port
 * INPUT:    param_p - General parameter
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IGMPSNP_SETRULE_DenyMulticastData(
    RULE_CTRL_PARAM_PTR param_p,
    DEVRM_PBMP_T new_pbmp)
{
    UI8_T multicast_mac_addr[] = {0x01, 0x00, 0x5E, 0x00, 0x00, 0x00};
    UI8_T multicast_mac_mask[] = {0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00};

    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_PRIO_5;

    RULE_CTRL_MakeParamTag(param_p, "igmp", "igmp-snp", "mvr", "igmp-snp-deny-multicast-data");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(param_p->ace_entry, RULE_CTRL_ETHER_TYPE_IPV4);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(param_p->ace_entry, RULE_CTRL_PROT_UDP);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    RULE_CTRL_SET_FILTER_DA_MASK(param_p->ace_entry, multicast_mac_addr, multicast_mac_mask);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);
    RULE_CTRL_SET_FILTER_HIG_PACKET(param_p->ace_entry, 0, 0xff);

    /* setup action */
    RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[0]);

    return TRUE;
}
#endif /* SYS_CPNT_IP_MULTICAST_DATA_DROP || SYS_CPNT_MVR */

#if (SYS_CPNT_IPV6_MULTICAST_DATA_DROP == TRUE) || (SYS_CPNT_MVR6 == TRUE)
/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_IGMPSNP_GETOM_DenyMulticastData
 *------------------------------------------------------------------------------
 * PURPOSE : This function will enable R-APS PDU redirect to CPU rule
 *           for specified unit and port
 * INPUT:    param_p - General parameter
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
static void*
RULE_CTRL_IP6_GETOM_DenyMulticastData(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T  module_id, device_id, phy_port;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit,
                                                        param_p->port,
                                                        &module_id,
                                                        &device_id,
                                                        &phy_port))
    {
        return NULL;
    }

    return &shmem_data_p->ip6_deny_ipmc_data[param_p->unit-1][device_id];
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_IGMPSNP_SETRULE_DenyMulticastData
 *------------------------------------------------------------------------------
 * PURPOSE : This function will enable R-APS PDU redirect to CPU rule
 *           for specified unit and port
 * INPUT:    param_p - General parameter
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IP6_SETRULE_DenyMulticastData(
    RULE_CTRL_PARAM_PTR param_p,
    DEVRM_PBMP_T new_pbmp)
{
    UI8_T multicast_mac_addr[] = {0x33, 0x33, 0x00, 0x00, 0x00, 0x00};
    UI8_T multicast_mac_mask[] = {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00};

    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_PRIO_7;

    RULE_CTRL_MakeParamTag(param_p, "ipv6", "mvr6", "multicast-data", "ipv6-deny-multicast-data");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(param_p->ace_entry, RULE_CTRL_ETHER_TYPE_IPV6);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(param_p->ace_entry, RULE_CTRL_PROT_UDP);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    RULE_CTRL_SET_FILTER_DA_MASK(param_p->ace_entry, multicast_mac_addr, multicast_mac_mask);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);
    RULE_CTRL_SET_FILTER_HIG_PACKET(param_p->ace_entry, 0, 0xff);

    /* setup action */
    RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[0]);

    return TRUE;
}
#endif /* SYS_CPNT_IPV6_MULTICAST_DATA_DROP || SYS_CPNT_MVR6 */

#if (SYS_CPNT_PTP == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_PTP_DO_TrapPtpEventToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap PTP packet to CPU
 * INPUT    : param_p
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_PTP_DO_TrapPtpEventUdpToCPU(
    RULE_CTRL_PARAM_PTR param_p)
{
    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_HIGH;
    param_p->sys_rule_storage_p = &shmem_data_p->ptp_event_udp.rule_storage;

    RULE_CTRL_MakeParamTag(param_p, "ptp", "ptp-event", "ptp-event-udp", NULL);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(param_p->ace_entry);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);
    RULE_CTRL_SET_FILTER_HIG_PACKET(param_p->ace_entry, 0, 0xff);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(param_p->ace_entry, RULE_CTRL_PROT_UDP);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_L4DstPort);
    RULE_CTRL_SET_FILTER_DPORT(param_p->ace_entry, 319);

    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[0], SYS_ADPT_CPU_QUEUE_PTP);
    RULE_CTRL_SET_ACTION_TIME_STAMP_TO_CPU(param_p->action_entries[1]);
    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(param_p->action_entries[2]);
    param_p->action_entries[0].next_action = &param_p->action_entries[1];
    param_p->action_entries[1].next_action = &param_p->action_entries[2];

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_PTP_DO_TrapPtpEventToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap PTP packet to CPU
 * INPUT    : param_p
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_PTP_DO_TrapPtpEventEthToCPU(
    RULE_CTRL_PARAM_PTR param_p)
{
    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_HIGH;
    param_p->sys_rule_storage_p = &shmem_data_p->ptp_event_eth.rule_storage;

    RULE_CTRL_MakeParamTag(param_p, "ptp", "ptp-event", "ptp-event-ethernet", NULL);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(param_p->ace_entry);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);
    RULE_CTRL_SET_FILTER_HIG_PACKET(param_p->ace_entry, 0, 0xff);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(param_p->ace_entry, RULE_CTRL_ETHER_TYPE_PTP);

    RULE_CTRL_SET_ACTION_TIME_STAMP_TO_CPU(param_p->action_entries[0]);
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[1], SYS_ADPT_CPU_QUEUE_PTP);
    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(param_p->action_entries[2]);
    param_p->action_entries[1].next_action = &param_p->action_entries[2];

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_PTP_DO_TrapPtpEventToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap PTP packet to CPU
 * INPUT    : param_p
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_PTP_DO_TrapPtpGeneralUdpToCPU(
    RULE_CTRL_PARAM_PTR param_p)
{
    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_HIGH;
    param_p->sys_rule_storage_p = &shmem_data_p->ptp_general_udp.rule_storage;

    RULE_CTRL_MakeParamTag(param_p, "ptp", "ptp-general", "ptp-general-udp", NULL);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(param_p->ace_entry);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);
    RULE_CTRL_SET_FILTER_HIG_PACKET(param_p->ace_entry, 0, 0xff);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(param_p->ace_entry, RULE_CTRL_PROT_UDP);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_L4DstPort);
    RULE_CTRL_SET_FILTER_DPORT(param_p->ace_entry, 320);

    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[0], SYS_ADPT_CPU_QUEUE_PTP);
    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(param_p->action_entries[1]);
    param_p->action_entries[0].next_action = &param_p->action_entries[1];

    return TRUE;
}
#endif /* SYS_CPNT_PTP */

#if (SYS_CPNT_MLD == TRUE || SYS_CPNT_MLDSNP == TRUE || SYS_CPNT_MVR6 == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_IP6_DO_SetMldQueryRule
 *------------------------------------------------------------------------------
 * PURPOSE  : trap MLD packet to CPU
 * INPUT    : param_p
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IP6_DO_SetMldQueryRule(
    RULE_CTRL_PARAM_PTR param_p)
{
    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_MLD;
    param_p->sys_rule_storage_p = &shmem_data_p->mld_query.rule_storage;

    RULE_CTRL_MakeParamTag(param_p, "ipv6", "mld", "query", "ipv6-mld-query");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(param_p->ace_entry);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);
    RULE_CTRL_SET_FILTER_HIG_PACKET(param_p->ace_entry, 0, 0xff);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(param_p->ace_entry, RULE_CTRL_ETHER_TYPE_IPV6);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(param_p->ace_entry, RULE_CTRL_PROT_ICMPV6);

    RULE_CTRL_ADD_FILTER_ICMP6_TYPE(param_p->ace_entry, 130, 0xff);

    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[0], SYS_ADPT_CPU_QUEUE_MLD);
    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(param_p->action_entries[1]);
    param_p->action_entries[0].next_action = &param_p->action_entries[1];

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_IP6_DO_SetMldReportRule
 *------------------------------------------------------------------------------
 * PURPOSE  : trap MLD packet to CPU
 * INPUT    : param_p
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IP6_DO_SetMldReportRule(
    RULE_CTRL_PARAM_PTR param_p)
{
    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_MLD;
    param_p->sys_rule_storage_p = &shmem_data_p->mld_report.rule_storage;

    RULE_CTRL_MakeParamTag(param_p, "ipv6", "mld", "report", "ipv6-mld-report");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(param_p->ace_entry);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);
    RULE_CTRL_SET_FILTER_HIG_PACKET(param_p->ace_entry, 0, 0xff);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(param_p->ace_entry, RULE_CTRL_ETHER_TYPE_IPV6);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(param_p->ace_entry, RULE_CTRL_PROT_ICMPV6);

    RULE_CTRL_ADD_FILTER_ICMP6_TYPE(param_p->ace_entry, 131, 0xff);

    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[0], SYS_ADPT_CPU_QUEUE_MLD);
    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(param_p->action_entries[1]);
    param_p->action_entries[0].next_action = &param_p->action_entries[1];

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_IP6_DO_SetMldDoneRule
 *------------------------------------------------------------------------------
 * PURPOSE  : trap MLD packet to CPU
 * INPUT    : param_p
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IP6_DO_SetMldDoneRule(
    RULE_CTRL_PARAM_PTR param_p)
{
    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_MLD;
    param_p->sys_rule_storage_p = &shmem_data_p->mld_done.rule_storage;

    RULE_CTRL_MakeParamTag(param_p, "ipv6", "mld", "done", "ipv6-mld-done");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(param_p->ace_entry);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);
    RULE_CTRL_SET_FILTER_HIG_PACKET(param_p->ace_entry, 0, 0xff);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(param_p->ace_entry, RULE_CTRL_ETHER_TYPE_IPV6);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(param_p->ace_entry, RULE_CTRL_PROT_ICMPV6);

    RULE_CTRL_ADD_FILTER_ICMP6_TYPE(param_p->ace_entry, 132, 0xff);

    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[0], SYS_ADPT_CPU_QUEUE_MLD);
    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(param_p->action_entries[1]);
    param_p->action_entries[0].next_action = &param_p->action_entries[1];

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_IP6_DO_SetMldv2ReportsRule
 *------------------------------------------------------------------------------
 * PURPOSE  : trap MLD packet to CPU
 * INPUT    : param_p
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IP6_DO_SetMldv2ReportsRule(
    RULE_CTRL_PARAM_PTR param_p)
{
    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_MLD;
    param_p->sys_rule_storage_p = &shmem_data_p->mldv2_reports.rule_storage;

    RULE_CTRL_MakeParamTag(param_p, "ipv6", "mldv2", "reports", "ipv6-mldv2-reports");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(param_p->ace_entry);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);
    RULE_CTRL_SET_FILTER_HIG_PACKET(param_p->ace_entry, 0, 0xff);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(param_p->ace_entry, RULE_CTRL_ETHER_TYPE_IPV6);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(param_p->ace_entry, RULE_CTRL_PROT_ICMPV6);

    RULE_CTRL_ADD_FILTER_ICMP6_TYPE(param_p->ace_entry, 143, 0xff);

    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[0], SYS_ADPT_CPU_QUEUE_MLD);
    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(param_p->action_entries[1]);
    param_p->action_entries[0].next_action = &param_p->action_entries[1];

    return TRUE;
}
#endif /* SYS_CPNT_MLD || SYS_CPNT_MLDSNP || SYS_CPNT_MVR6 */

#if (SYS_CPNT_IPV6_RA_GUARD == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IP6_RA_Guard_GETOM_DenyRAPacket
 *------------------------------------------------------------------------------
 * PURPOSE:  Deny IPv6 Router-Advertisement packet for RA Guard
 * INPUT:    param_p - General parameter
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static RULE_CTRL_RS_IP6_RA_Guard_T *
RULE_CTRL_IP6_RA_Guard_GETOM_DenyRAPacket(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T  module_id, device_id, phy_port;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit,
                                                        param_p->port,
                                                        &module_id,
                                                        &device_id,
                                                        &phy_port))
    {
        return NULL;
    }

    return &shmem_data_p->ip6_ra_guard_deny_ra[param_p->unit-1][device_id];
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IP6_RA_Guard_GETOM_DenyRRPacket
 *------------------------------------------------------------------------------
 * PURPOSE:  Deny IPv6 Router-Redirect packet for RA Guard
 * INPUT:    param_p - General parameter
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static RULE_CTRL_RS_IP6_RA_Guard_T *
RULE_CTRL_IP6_RA_Guard_GETOM_DenyRRPacket(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T  module_id, device_id, phy_port;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit,
                                                        param_p->port,
                                                        &module_id,
                                                        &device_id,
                                                        &phy_port))
    {
        return NULL;
    }

    return &shmem_data_p->ip6_ra_guard_deny_rr[param_p->unit-1][device_id];
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_IP6_RA_Guard_SETRULE_DenyRAPacket
 *------------------------------------------------------------------------------
 * PURPOSE:  Deny IPv6 Router-Advertisement packet for RA Guard
 * INPUT:    param_p - General parameter
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IP6_RA_Guard_SETRULE_DenyRAPacket(
    RULE_CTRL_PARAM_PTR param_p,
    DEVRM_PBMP_T new_pbmp)
{
    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_PRIO_3;

    RULE_CTRL_MakeParamTag(param_p, "ip6", "ra-guard", "ip6-ra-guard", "ip6-ra-guard-deny-rr");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(param_p->ace_entry, RULE_CTRL_ETHER_TYPE_IPV6);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(param_p->ace_entry, RULE_CTRL_PROT_ICMPV6);

    RULE_CTRL_ADD_FILTER_ICMP6_TYPE(param_p->ace_entry, 134, 0xff);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);
    RULE_CTRL_SET_FILTER_HIG_PACKET(param_p->ace_entry, 0, 0xff);

    /* setup action
     */
    RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[0]);
    param_p->action_entries[0].next_action = NULL;

    return TRUE;
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_IP6_RA_Guard_SETRULE_DenyRAPacket
 *------------------------------------------------------------------------------
 * PURPOSE:  Deny IPv6 Router-Redirect packet for RA Guard
 * INPUT:    param_p - General parameter
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IP6_RA_Guard_SETRULE_DenyRRPacket(
    RULE_CTRL_PARAM_PTR param_p,
    DEVRM_PBMP_T new_pbmp)
{
    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_PRIO_3;

    RULE_CTRL_MakeParamTag(param_p, "ip6", "ra-guard", "ip6-ra-guard", "ip6-ra-guard-deny-ra");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(param_p->ace_entry, RULE_CTRL_ETHER_TYPE_IPV6);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(param_p->ace_entry, RULE_CTRL_PROT_ICMPV6);

    RULE_CTRL_ADD_FILTER_ICMP6_TYPE(param_p->ace_entry, 137, 0xff);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);
    RULE_CTRL_SET_FILTER_HIG_PACKET(param_p->ace_entry, 0, 0xff);

    /* setup action
     */
    RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[0]);
    param_p->action_entries[0].next_action = NULL;

    return TRUE;
}

#endif /* #if (SYS_CPNT_IPV6_RA_GUARD == TRUE) */

#if (SYS_CPNT_APP_FILTER_CDP == TRUE)
static void* RULE_CTRL_AF_GETOM_DenyCdpPacket(RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T  module_id, device_id, phy_port;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit, param_p->port,
        &module_id, &device_id, &phy_port))
    {
        return NULL;
    }

    return &shmem_data_p->af_discard_cdp[param_p->unit-1][device_id];
}

static BOOL_T RULE_CTRL_AF_SETRULE_DenyCdpPacket(RULE_CTRL_PARAM_PTR param_p, DEVRM_PBMP_T new_pbmp)
{
    UI8_T cdp_mac_addr[] = {0x01, 0x00, 0x0C, 0xCC, 0xCC, 0xCC};
    UI8_T cdp_mac_mask[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_LOW;
    RULE_CTRL_MakeParamTag(param_p, "af", "deny", "cdp", "af-deny-cdp");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    RULE_CTRL_SET_FILTER_DA_MASK(param_p->ace_entry, cdp_mac_addr, cdp_mac_mask);

    RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[0]);
    param_p->action_entries[0].next_action = NULL;

    return TRUE;
}
#endif /* #if (SYS_CPNT_APP_FILTER_CDP == TRUE) */

#if (SYS_CPNT_APP_FILTER_PVST == TRUE)
static void* RULE_CTRL_AF_GETOM_DenyPvstPacket(RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T  module_id, device_id, phy_port;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit, param_p->port,
        &module_id, &device_id, &phy_port))
    {
        return NULL;
    }

    return &shmem_data_p->af_discard_pvst[param_p->unit-1][device_id];
}

static BOOL_T RULE_CTRL_AF_SETRULE_DenyPvstPacket(RULE_CTRL_PARAM_PTR param_p, DEVRM_PBMP_T new_pbmp)
{
    UI8_T cdp_mac_addr[] = {0x01, 0x00, 0x0C, 0xCC, 0xCC, 0xCD};
    UI8_T cdp_mac_mask[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_LOW;
    RULE_CTRL_MakeParamTag(param_p, "af", "deny", "pvst", "af-deny-pvst");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    RULE_CTRL_SET_FILTER_DA_MASK(param_p->ace_entry, cdp_mac_addr, cdp_mac_mask);

    RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[0]);
    param_p->action_entries[0].next_action = NULL;

    return TRUE;
}
#endif /* #if (SYS_CPNT_APP_FILTER_PVST == TRUE) */

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetL4PortCosMap
 *------------------------------------------------------------------------------
 * PURPOSE:  set tcp/udp destination port mapped to cos
 * INPUT:    unit, port, dst_port, cos
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:     now this api is for global tcp port to cos not per port
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_SetL4PortCosMap(
    UI32_T  unit,
    UI32_T  port,
    UI16_T  dst_port,
    UI8_T   cos)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("unit=%lu port=%lu dst_port=%hu cos=%u\n", unit, port, dst_port, cos);

    RULE_CTRL_InitParam(&param);

    param.flags        |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    param.flags        |= RULE_CTRL_OPT_ALL_DEVICES;

    param.L4_PORT_COS_MAP.dst_port    = dst_port;
    param.L4_PORT_COS_MAP.cos         = cos;

    return _rule_ctrl_set_rule(&param, RULE_CTRL_DO_L4PortCosMap);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_DelL4PortCosMap
 *------------------------------------------------------------------------------
 * PURPOSE:  set tcp/udp destination port mapped to cos by unit and port
 * INPUT:    unit, port, is_tcp, dst_port, phb, color
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:     now this api is for global tcp port to cos not per port
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_DelL4PortCosMap(
    UI32_T  unit,
    UI32_T  port,
    UI16_T  dst_port,
    UI8_T   cos)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("unit=%lu port=%lu dst_port=%hu cos=%u\n", unit, port, dst_port, cos);

    RULE_CTRL_InitParam(&param);

    param.flags        |= RULE_CTRL_OPT_ALL_DEVICES;

    param.L4_PORT_COS_MAP.dst_port    = dst_port;
    param.L4_PORT_COS_MAP.cos         = cos;

    return _rule_ctrl_set_rule(&param, RULE_CTRL_DO_L4PortCosMap);
}

#if (SYS_CPNT_IPV6 == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IP6_TrapLinkLocalToCPU
 *------------------------------------------------------------------------------
 * PURPOSE:  Trap IPv6 link local address to CPU
 * INPUT:    enable          - TRUE:  trap to CPU
 *                             FALSE: no trap
 *           link_local_addr - IPv6 link local address
 *           vlan_id         - VLAN ID
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_IP6_TrapLinkLocalToCPU(
    BOOL_T enable,
    UI8_T link_local_addr[SYS_ADPT_IPV6_ADDR_LEN],
    UI32_T vlan_id)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s "
                  "addr=%02X%02X%02X%02X%02X%02X%02X%02X %02X%02X%02X%02X%02X%02X%02X%02X"
                  "vid=%lu\n",
                  enable?"enable":"disable",
                  link_local_addr[0], link_local_addr[1], link_local_addr[2], link_local_addr[3],
                  link_local_addr[4], link_local_addr[5], link_local_addr[6], link_local_addr[7],
                  link_local_addr[8], link_local_addr[9], link_local_addr[10], link_local_addr[11],
                  link_local_addr[12], link_local_addr[13], link_local_addr[14], link_local_addr[15],
                  vlan_id);

    RULE_CTRL_InitParam(&param);

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }
    param.flags        |= RULE_CTRL_OPT_ALL_DEVICES;

    memcpy(param.LINK_LOCAL_ADDRESS.addr, link_local_addr, SYS_ADPT_IPV6_ADDR_LEN);
    param.LINK_LOCAL_ADDRESS.vlan_id = vlan_id;

    return _rule_ctrl_set_rule(&param, RULE_CTRL_IP6_DO_TrapLinkLocalToCPU);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_GetTrapLinkLocalRule
 *------------------------------------------------------------------------------
 * PURPOSE:  Get rule of trap IPv6 link local address to CPU
 * INPUT:    rule_printf     - callback function. Use to dump rule
 *                             detail information. Pass NULL if does not want
 *                             to get information.
 *           link_local_addr - IPv6 link local address.
 * OUTPUT:   rule_id         - device rule ID array.
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_GetTrapLinkLocalRule(
    BOOL_T (*rule_printf)(char*, ...),
    UI8_T link_local_addr[SYS_ADPT_IPV6_ADDR_LEN],
    UI32_T vlan_id,
    UI32_T rule_id[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK][SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT])
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_InitParam(&param);

    param.flags |= RULE_CTRL_OPT_QUERY;

    memcpy(param.LINK_LOCAL_ADDRESS.addr, link_local_addr, SYS_ADPT_IPV6_ADDR_LEN);
    param.LINK_LOCAL_ADDRESS.vlan_id = vlan_id;

    if (FALSE == RULE_CTRL_IP6_DO_TrapLinkLocalToCPU(&param))
    {
        return FALSE;
    }

    if (NULL == param.sys_rule_storage_p)
    {
        return FALSE;
    }

    memcpy(rule_id, param.sys_rule_storage_p->rule_id, sizeof(param.sys_rule_storage_p->rule_id));

    if (rule_printf)
    {
        RULE_CTRL_DumpParam(&param, rule_printf);
    }

    return TRUE;
}
#endif /* SYS_CPNT_IPV6 */

#if (SYS_CPNT_IPV6_DENY_LINK_LOCAL_ROUTING_BY_RULE_AS_TEMPORARY_SOLUTION == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_IP6_DenyLinkLocalL3RoutablePkt
 *------------------------------------------------------------------------------
 * PURPOSE  : Deny IPv6 link local address and L3 routable enabled
 * INPUT    : enable    - TRUE: enable, FALSE: disable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_IP6_DenyLinkLocalL3RoutablePkt(
    BOOL_T enable)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s ",
                  enable?"enable":"disable");

    RULE_CTRL_InitParam(&param);

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }
    param.flags        |= RULE_CTRL_OPT_ALL_DEVICES;

    return _rule_ctrl_set_rule(&param, RULE_CTRL_IP6_DO_DenyLinkLocalL3RoutablePkt);
}
#endif /* #if (SYS_CPNT_IPV6_DENY_LINK_LOCAL_ROUTING_BY_RULE_AS_TEMPORARY_SOLUTION == TRUE) */

#if (SYS_CPNT_WEBAUTH == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_WA_TrapHttpToCPU
 *------------------------------------------------------------------------------
 * PURPOSE:  Trap HTTP client packet to CPU for Web authentication
 * INPUT:    enable         - TRUE:  trap to CPU
 *                            FALSE: no trap
 *           unit           - unit
 *           port           - port
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_WA_TrapHttpToCPU(
    BOOL_T  enable,
    UI32_T  unit,
    UI32_T  port)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s unit=%lu port=%lu\n", enable?"enable":"disable", unit, port);

    RULE_CTRL_InitParam(&param);

    param.unit          = unit;
    param.port          = port;
    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return RULE_CTRL_SetSharedPortRule(&param,
            (RULE_CTRL_SPR_GET_OM_HANDLER)RULE_CTRL_WA_GETOM_TrapHttpToCPU,
            (RULE_CTRL_SPR_SET_RULE_HANDLER)RULE_CTRL_WA_SETRULE_TrapHttpToCPU);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_WA_PermitDhcp
 *------------------------------------------------------------------------------
 * PURPOSE:  Permit DHCP client packet for Web authentication
 * INPUT:    enable         - TRUE:  trap to CPU
 *                            FALSE: no trap
 *           unit           - unit
 *           port           - port
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_WA_PermitDhcp(
    BOOL_T  enable,
    UI32_T  unit,
    UI32_T  port)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s unit=%lu port=%lu\n", enable?"enable":"disable", unit, port);

    RULE_CTRL_InitParam(&param);

    param.unit          = unit;
    param.port          = port;
    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return RULE_CTRL_SetSharedPortRule(&param,
            (RULE_CTRL_SPR_GET_OM_HANDLER)RULE_CTRL_WA_GETOM_PermitDhcp,
            (RULE_CTRL_SPR_SET_RULE_HANDLER)RULE_CTRL_WA_SETRULE_PermitDhcp);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_WA_PermitDns
 *------------------------------------------------------------------------------
 * PURPOSE:  Permit DNS packet for Web authentication
 * INPUT:    enable         - TRUE:  trap to CPU
 *                            FALSE: no trap
 *           unit           - unit
 *           port           - port
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_WA_PermitDns(
    BOOL_T  enable,
    UI32_T  unit,
    UI32_T  port)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s unit=%lu port=%lu\n", enable?"enable":"disable", unit, port);

    RULE_CTRL_InitParam(&param);

    param.unit          = unit;
    param.port          = port;
    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return RULE_CTRL_SetSharedPortRule(&param,
            (RULE_CTRL_SPR_GET_OM_HANDLER)RULE_CTRL_WA_GETOM_PermitDns,
            (RULE_CTRL_SPR_SET_RULE_HANDLER)RULE_CTRL_WA_SETRULE_PermitDns);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_WA_PermitIpPacket
 *------------------------------------------------------------------------------
 * PURPOSE:  Permit IP packet for Web Authentication
 * INPUT:    enable          - TRUE:  permit
 *                             FALSE: no permit
 *           unit            - unit
 *           port            - port
 *           src_ipv4_addr   - source IPv4 address
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_WA_PermitIpPacket(
    BOOL_T  enable,
    UI32_T  unit,
    UI32_T  port,
    UI8_T   *src_ipv4_addr)
{
    RULE_CTRL_PARAM param;

    if (NULL == src_ipv4_addr)
    {
        RULE_CTRL_LOG("src_ipv4_addr = NULL");
        return FALSE;
    }

    RULE_CTRL_LOG("%s uport=%lu/%lu sip=%d.%d.%d.%d\n",
                  enable?"enable":"disable", unit, port,
                  src_ipv4_addr[0], src_ipv4_addr[1], src_ipv4_addr[2], src_ipv4_addr[3]);

    RULE_CTRL_InitParam(&param);

    param.unit          = unit;
    param.port          = port;

    memcpy(&param.WA.src_ipv4_addr, src_ipv4_addr, sizeof(param.WA.src_ipv4_addr));

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return _rule_ctrl_set_rule(&param, RULE_CTRL_WA_DO_PermitIpPacket);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_WA_GetPermitIpPacketRule
 *------------------------------------------------------------------------------
 * PURPOSE:  Web Authentication. Get permit IP packet rule
 * INPUT:    unit            - unit
 *           port            - port
 *           rule_printf     - callback function. Use to dump rule
 *                             detail information. Pass NULL if does not want
 *                             to get information.
 *           src_ipv4_addr   - source IPv4 address
 * OUTPUT:   enable          - enable/disable
 *           rule_id         - device rule ID
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_WA_GetPermitIpPacketRule(
    UI32_T unit,
    UI32_T port,
    UI8_T *src_ipv4_addr,
    BOOL_T (*rule_printf)(char*, ...),
    BOOL_T *enable,
    UI32_T *rule_id)
{
    RULE_CTRL_PARAM param;

    if (NULL == enable || NULL == rule_id)
    {
        return FALSE;
    }

    *enable = FALSE;
    *rule_id= 0;

    if (NULL == src_ipv4_addr)
    {
        return FALSE;
    }

    RULE_CTRL_InitParam(&param);

    param.unit          = unit;
    param.port          = port;

    param.flags         |= RULE_CTRL_OPT_QUERY;

    memcpy(&param.WA.src_ipv4_addr, src_ipv4_addr, sizeof(param.WA.src_ipv4_addr));

    if (FALSE == RULE_CTRL_WA_DO_PermitIpPacket(&param))
    {
        return FALSE;
    }

    if (NULL == param.rule_storage_p)
    {
        return FALSE;
    }

    *enable = param.rule_storage_p->is_enable;
    *rule_id= param.rule_storage_p->rule_id;

    if (rule_printf)
    {
        RULE_CTRL_DumpParam(&param, rule_printf);
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_WA_DenyAnyIpPacket
 *------------------------------------------------------------------------------
 * PURPOSE:  Deny any IP packet for Web authentication
 * INPUT:    enable         - TRUE:  trap to CPU
 *                            FALSE: no trap
 *           unit           - unit
 *           port           - port
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_WA_DenyAnyIpPacket(
    BOOL_T  enable,
    UI32_T  unit,
    UI32_T  port)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s unit=%lu port=%lu\n", enable?"enable":"disable", unit, port);

    RULE_CTRL_InitParam(&param);

    param.unit          = unit;
    param.port          = port;
    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return RULE_CTRL_SetSharedPortRule(&param,
            (RULE_CTRL_SPR_GET_OM_HANDLER)RULE_CTRL_WA_GETOM_DenyAnyIpPacket,
            (RULE_CTRL_SPR_SET_RULE_HANDLER)RULE_CTRL_WA_SETRULE_DenyAnyIpPacket);
}
#endif /* #if (SYS_CPNT_WEBAUTH == TRUE) */

#if (SYS_CPNT_DOT1X == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_1X_TrapDot1xUCToCPU
 *------------------------------------------------------------------------------
 * PURPOSE:  Trap 802.1x unticast to CPU
 * INPUT:    enable          - TRUE:  trap to CPU
 *                             FALSE: no trap
 *           unit            - unit
 *           port            - port
 *           cpu_mac         - CPU MAC address. For each port, the cpu_mac
 *                             should set the same.
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_1X_TrapDot1xUCToCPU(
    BOOL_T  enable,
    UI32_T  unit,
    UI32_T  port,
    UI8_T   cpu_mac[SYS_ADPT_MAC_ADDR_LEN])
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s uport=%lu/%lu cpu_mac=%02x%02x%02x-%02x%02x%02x\n",
                  enable?"enable":"disable",
                  unit,
                  port,
                  cpu_mac[0], cpu_mac[1], cpu_mac[2],
                  cpu_mac[3], cpu_mac[4], cpu_mac[5]);

    RULE_CTRL_InitParam(&param);

    param.unit          = unit;
    param.port          = port;

    memcpy(param.DOT1X_UC.cpu_mac, cpu_mac, SYS_ADPT_MAC_ADDR_LEN);

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return RULE_CTRL_SetSharedPortRule(&param,
        (RULE_CTRL_SPR_GET_OM_HANDLER)RULE_CTRL_1X_GETOM_TrapDot1xUCToCPU,
        (RULE_CTRL_SPR_SET_RULE_HANDLER)RULE_CTRL_1X_SETRULE_TrapDot1xUCToCPU);
}
#endif /* #if (SYS_CPNT_DOT1X == TRUE) */

#if (SYS_CPNT_IP_SOURCE_GUARD == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IPSG_PermitIpPacket
 *------------------------------------------------------------------------------
 * PURPOSE:  Permit IP packet for IPSG
 * INPUT:    enable          - TRUE:  permit
 *                             FALSE: no permit
 *           unit            - unit
 *           port            - port
 *           vlan_id         - VLAN ID
 *           src_ipv4_addr   - source IPv4 address
 *           src_mac_addr    - source MAC address
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_IPSG_PermitIpPacket(
    BOOL_T  enable,
    UI32_T  unit,
    UI32_T  port,
    UI32_T  vlan_id,
    UI8_T   *src_ipv4_addr,
    UI8_T   *src_mac_addr)
{
    RULE_CTRL_PARAM param;

    if (NULL == src_ipv4_addr)
    {
        RULE_CTRL_LOG("src_ip_addr is NULL");
        return FALSE;
    }

    if (src_mac_addr)
    {
        if (RULE_CTRL_IS_ZEOR_MAC_ADDR(src_mac_addr))
        {
            RULE_CTRL_LOG("src_mac_addr is all ZERO");
            return FALSE;
        }
    }

    if (src_mac_addr)
    {
        RULE_CTRL_LOG("%s uport=%lu/%lu sip=%u.%u.%u.%u sa=%02x-%02x-%02x-%02x-%02x-%02x\n",
                      enable?"enable":"disable",
                      unit,
                      port,
                      src_ipv4_addr[0], src_ipv4_addr[1], src_ipv4_addr[2], src_ipv4_addr[3],
                      src_mac_addr[0], src_mac_addr[1], src_mac_addr[2], src_mac_addr[3],
                      src_mac_addr[4], src_mac_addr[5]);
    }
    else
    {
        RULE_CTRL_LOG("%s uport=%lu/%lu sip=%u.%u.%u.%u sa=na\n",
                      enable?"enable":"disable",
                      unit,
                      port,
                      src_ipv4_addr[0], src_ipv4_addr[1], src_ipv4_addr[2], src_ipv4_addr[3]);
    }

    RULE_CTRL_InitParam(&param);

    param.unit          = unit;
    param.port          = port;

    param.IPSG.vlan_id  = vlan_id;
    param.IPSG.len      += sizeof(param.IPSG.vlan_id);

    memcpy(&param.IPSG.src_ipv4_addr, src_ipv4_addr, sizeof(param.IPSG.src_ipv4_addr));
    param.IPSG.len      += sizeof(param.IPSG.src_ipv4_addr);

    if (src_mac_addr)
    {
        memcpy(param.IPSG.src_mac_addr, src_mac_addr, sizeof(param.IPSG.src_mac_addr));
        param.IPSG.len += sizeof(param.IPSG.src_mac_addr);
    }

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return _rule_ctrl_set_rule(&param, RULE_CTRL_IPSG_DO_PermitIpPacket);
}

#if 0
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IPSG_GetPermitIpPacketRule
 *------------------------------------------------------------------------------
 * PURPOSE:  Get rule information of IPSG permit IP packet
 * INPUT:    unit            - unit
 *           port            - port
 *           rule_printf     - callback function. Use to dump rule
 *                             detail information. Pass NULL if does not want
 *                             to dump information.
 *           vlan_id         - VLAN ID.
 *           src_ipv4_addr   - source IPv4 address
 *           src_mac_addr    - source MAC address
 * OUTPUT:   rule_id_p       - device rule ID
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_IPSG_GetPermitIpPacketRule(
    UI32_T unit,
    UI32_T port,
    BOOL_T (*rule_printf)(char*, ...),
    UI32_T vlan_id,
    UI8_T  *src_ipv4_addr,
    UI8_T   *src_mac_addr,
    UI32_T *rule_id_p)
{
    RULE_CTRL_PARAM param;

    if (NULL == src_ipv4_addr || NULL == rule_id_p)
    {
        return FALSE;
    }

    RULE_CTRL_InitParam(&param);

    param.unit          = unit;
    param.port          = port;

    param.IPSG.vlan_id  = vlan_id;
    param.IPSG.len      += sizeof(param.IPSG.vlan_id);

    memcpy(&param.IPSG.src_ipv4_addr, src_ipv4_addr, sizeof(param.IPSG.src_ipv4_addr));
    param.IPSG.len      += sizeof(param.IPSG.src_ipv4_addr);

    if (src_mac_addr)
    {
        memcpy(param.IPSG.src_mac_addr, src_mac_addr, sizeof(param.IPSG.src_mac_addr));
        param.IPSG.len += sizeof(param.IPSG.src_mac_addr);
    }

    param.flags         |= RULE_CTRL_OPT_QUERY;

    *rule_id_p          = 0;

    if (FALSE == RULE_CTRL_IPSG_DO_PermitIpPacket(&param))
    {
        return FALSE;
    }

    if (NULL == param.rule_storage_p)
    {
        RULE_CTRL_LOG("No such rule");
        return FALSE;
    }

    *rule_id_p = param.rule_storage_p->rule_id;

    if (rule_printf)
    {
        RULE_CTRL_DumpParam(&param, rule_printf);
    }

    return TRUE;
}
#endif

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IPSG_DenyAnyIpPacket
 *------------------------------------------------------------------------------
 * PURPOSE:  Deny any IP address for IPSG
 * INPUT:    enable          - TRUE:  deny
 *                             FALSE: no deny
 *           unit            - unit
 *           port            - port
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_IPSG_DenyAnyIpPacket(
    BOOL_T  enable,
    UI32_T  unit,
    UI32_T  port)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s unit=%lu port=%lu\n", enable?"enable":"disable", unit, port);

    RULE_CTRL_InitParam(&param);

    param.unit          = unit;
    param.port          = port;

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return RULE_CTRL_SetSharedPortRule(&param,
            (RULE_CTRL_SPR_GET_OM_HANDLER)RULE_CTRL_IPSG_GETOM_DenyAnyIpPacket,
            (RULE_CTRL_SPR_SET_RULE_HANDLER)RULE_CTRL_IPSG_SETRULE_DenyAnyIpPacket);
}
#endif /* #if (SYS_CPNT_IP_SOURCE_GUARD == TRUE) */

#if (SYS_CPNT_IPV6_SOURCE_GUARD == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IPV6SG_PermitIp6Host
 *------------------------------------------------------------------------------
 * PURPOSE:  Permit IPv6 packet for IPv6SG
 * INPUT:    enable          - TRUE:  permit
 *                             FALSE: no permit
 *           interface_p     - pointer to interface info
 *           vlan_id         - VLAN ID
 *           src_ipv6_addr   - source IPv6 address
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
BOOL_T
RULE_CTRL_IPV6SG_PermitIp6Host(
    BOOL_T                      enable,
    RULE_TYPE_INTERFACE_INFO_T  *interface_p,
    UI32_T                      vlan_id,
    const UI8_T                 src_ipv6_addr[SYS_TYPE_IPV6_ADDR_LEN])
{
    RULE_CTRL_PARAM param;

    ASSERT(NULL != interface_p);
    ASSERT(NULL != src_ipv6_addr);

    if (RULE_TYPE_INTERFACE_UPORT != interface_p->type)
    {
        RULE_CTRL_LOG("Invalid interface->type(%d)", interface_p->type);
        return FALSE;
    }

    RULE_CTRL_LOG("%s uport=%lu/%lu "
                  "sip6=%02x%02x%02x%02x:%02x%02x%02x%02x:%02x%02x%02x%02x:%02x%02x%02x%02x",
                  enable?"enable":"disable",
                  interface_p->uport.unit,
                  interface_p->uport.port,
                  src_ipv6_addr[0], src_ipv6_addr[1], src_ipv6_addr[2], src_ipv6_addr[3],
                  src_ipv6_addr[4], src_ipv6_addr[5], src_ipv6_addr[6], src_ipv6_addr[7],
                  src_ipv6_addr[8], src_ipv6_addr[9], src_ipv6_addr[10], src_ipv6_addr[11],
                  src_ipv6_addr[12], src_ipv6_addr[13], src_ipv6_addr[14], src_ipv6_addr[15]);

    RULE_CTRL_InitParam(&param);

    param.unit          = interface_p->uport.unit;
    param.port          = interface_p->uport.port;

    param.IPSG.vlan_id  = vlan_id;
    param.IPSG.len      += sizeof(param.IPSG.vlan_id);

    memcpy(&param.IPSG.src_ipv6_addr, src_ipv6_addr, sizeof(param.IPSG.src_ipv6_addr));
    param.IPSG.len      += sizeof(param.IPSG.src_ipv6_addr);

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return _rule_ctrl_set_rule(&param, RULE_CTRL_IPV6SG_DO_PermitIpv6Packet);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IPV6SG_DenyAnyIp6Packet
 *------------------------------------------------------------------------------
 * PURPOSE:  Deny any IPv6 address for IPv6 SG
 * INPUT:    enable          - TRUE:  deny
 *                             FALSE: no deny
 *           interface_p     - pointer to interface info
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_IPV6SG_DenyAnyIp6Packet(
    BOOL_T                      enable,
    RULE_TYPE_INTERFACE_INFO_T  *interface_p)
{
    RULE_CTRL_PARAM param;

    ASSERT(NULL != interface_p);

    if (RULE_TYPE_INTERFACE_UPORT != interface_p->type)
    {
        RULE_CTRL_LOG("Invalid interface->type(%d)", interface_p->type);
        return FALSE;
    }

    RULE_CTRL_LOG("%s unit=%lu port=%lu\n", enable?"enable":"disable",
                                                          interface_p->uport.unit,
                                                          interface_p->uport.port);

    RULE_CTRL_InitParam(&param);

    param.unit          = interface_p->uport.unit;
    param.port          = interface_p->uport.port;

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return RULE_CTRL_SetSharedPortRule(&param,
            (RULE_CTRL_SPR_GET_OM_HANDLER)RULE_CTRL_IPV6SG_GETOM_DenyAnyIp6Packet,
            (RULE_CTRL_SPR_SET_RULE_HANDLER)RULE_CTRL_IPV6SG_SETRULE_DenyAnyIp6Packet);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IPV6SG_PermitIp6LinkLocal
 *------------------------------------------------------------------------------
 * PURPOSE:  Permit all IPv6 link local packets
 * INPUT:    is_enable - TRUE:  permit
 *                       FALSE: no action
 * OUTPUT:   None
 * RETURN:   RULE_TYPE_OK / RULE_TYPE_FAIL
 * NOTE:
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_IPV6SG_PermitIp6LinkLocal(
    BOOL_T is_enable)
{
    return RULE_TYPE_FAIL;
}
#endif /* #if (SYS_CPNT_IPV6_SOURCE_GUARD == TRUE) */

#if (SYS_CPNT_ERPS == TRUE)
/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_SetRapsPduToCpuByPort
 *------------------------------------------------------------------------------
 * PURPOSE : This function will enable R-APS PDU redirect to CPU rule
 *            for specified unit and port
 * INPUT   : unit      -- which unit.
 *           port      -- which port.
 *           eth_type  -- which EtherType to set (no used)
 *           dmac_p    -- which destination MAC to set  (no used)
 *           is_enable -- enable/disable
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_SetRapsPduToCpuByPort(
    UI32_T  unit,
    UI32_T  port,
    UI16_T  eth_type,
    UI8_T   *dst_mac_p,
    BOOL_T  is_enable)
{
    return RULE_CTRL_ERPS_TrapRapsPduToCPU(is_enable, unit, port);
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_ERPS_TrapRapsPduToCPU
 *------------------------------------------------------------------------------
 * PURPOSE : This function will enable R-APS PDU redirect to CPU rule
 *           for specified unit and port
 * INPUT   : is_enable    -- enable/disable
 *           unit         -- which unit.
 *           port         -- which port.
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_ERPS_TrapRapsPduToCPU(
    BOOL_T  enable,
    UI32_T  unit,
    UI32_T  port)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s unit=%lu port=%lu", enable?"enable":"disable", unit, port);

    RULE_CTRL_InitParam(&param);

    param.unit          = unit;
    param.port          = port;

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return RULE_CTRL_SetSharedPortRule(&param,
            (RULE_CTRL_SPR_GET_OM_HANDLER)RULE_CTRL_ERPS_GETOM_TrapRapsPduToCPU,
            (RULE_CTRL_SPR_SET_RULE_HANDLER)RULE_CTRL_ERPS_SETRULE_TrapRapsPduToCPU);
}
#endif /* #if (SYS_CPNT_ERPS == TRUE) */

#if (SYS_CPNT_EFM_OAM_REMOTE_LB_PASSIVELY == TRUE)
/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_SetOamPduToCpu
 *------------------------------------------------------------------------------
 * PURPOSE : For CPE, redirect EFM OAM PDU to CPU rule.
 * INPUT   : unit       -- which unit
 *           port       -- which port
 *           is_enable  -- enable/disable
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_SetOamPduToCpu(
    UI32_T unit,
    UI32_T port,
    BOOL_T is_enable)
{
    return RULE_CTRL_OAM_CPE_TrapOamPduToCPU(is_enable, unit, port);
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_OAM_CPE_TrapOamPduToCPU
 *------------------------------------------------------------------------------
 * PURPOSE : For CPE, redirect EFM OAM PDU to CPU rule.
 * INPUT   : enable  -- enable/disable
 *           unit    -- which unit.
 *           port    -- which port.
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_OAM_CPE_TrapOamPduToCPU(
    BOOL_T  enable,
    UI32_T  unit,
    UI32_T  port)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s unit=%lu port=%lu", enable?"enable":"disable", unit, port);

    RULE_CTRL_InitParam(&param);

    param.unit          = unit;
    param.port          = port;

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return RULE_CTRL_SetSharedPortRule(&param,
            (RULE_CTRL_SPR_GET_OM_HANDLER)RULE_CTRL_OAM_CPE_GETOM_TrapOamPduToCPU,
            (RULE_CTRL_SPR_SET_RULE_HANDLER)RULE_CTRL_OAM_CPE_SETRULE_TrapOamPduToCPU);
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_SetOamLoopbackToRecPort
 *------------------------------------------------------------------------------
 * PURPOSE : For CPE, redirect EFM OAM loopback packet to receiving port.
 * INPUT   : unit       -- which unit
 *           port       -- which port
 *           is_enable  -- enable/disable
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_SetOamLoopbackToRecPort(
    UI32_T unit,
    UI32_T port,
    BOOL_T is_enable)
{
    return RULE_CTRL_OAM_CPE_RedirOamLoopbackToRecvPort(is_enable, unit, port);
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_OAM_CPE_RedirOamLoopbackToRecvPort
 *------------------------------------------------------------------------------
 * PURPOSE : For CPE, redirect EFM OAM loopback packet to receiving port.
 * INPUT   : enable  -- enable/disable
 *           unit    -- which unit.
 *           port    -- which port.
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_OAM_CPE_RedirOamLoopbackToRecvPort(
    BOOL_T  enable,
    UI32_T  unit,
    UI32_T  port)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s unit=%lu port=%lu", enable?"enable":"disable", unit, port);

    RULE_CTRL_InitParam(&param);

    param.unit          = unit;
    param.port          = port;

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return RULE_CTRL_SetSharedPortRule(&param,
            (RULE_CTRL_SPR_GET_OM_HANDLER)RULE_CTRL_OAM_CPE_GETOM_RedirOamLoopbackToRecvPort,
            (RULE_CTRL_SPR_SET_RULE_HANDLER)RULE_CTRL_OAM_CPE_SETRULE_RedirOamLoopbackToRecvPort);
}
#endif /* #if (SYS_CPNT_EFM_OAM_REMOTE_LB_PASSIVELY == TRUE) */

#if (SYS_CPNT_EFM_OAM_REMOTE_LB_ACTIVELY == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_TrapOAMLoopbackToCPU
 *------------------------------------------------------------------------------
 * FUNCTION : For CO side, trap EFM OAM loopback packet to CPU.
 * INPUT   : enable  -- enable/disable
 *           unit    -- which unit.
 *           port    -- which port.
 * OUTPUT   : None
 * RETURN   : TRUE / FALSE
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_OAM_CO_TrapOamLoopbackToCPU(
    BOOL_T enable,
    UI32_T unit,
    UI32_T port)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s unit=%lu port=%lu", enable?"enable":"disable", unit, port);

    RULE_CTRL_InitParam(&param);

    param.unit          = unit;
    param.port          = port;

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return RULE_CTRL_SetSharedPortRule(&param,
            (RULE_CTRL_SPR_GET_OM_HANDLER)RULE_CTRL_OAM_CO_GETOM_TrapOamLoopbackToCPU,
            (RULE_CTRL_SPR_SET_RULE_HANDLER)RULE_CTRL_OAM_CO_SETRULE_TrapOamLoopbackToCPU);
}
#endif /* #if (SYS_CPNT_EFM_OAM_REMOTE_LB_ACTIVELY == TRUE) */

#if (SYS_CPNT_IP_MULTICAST_DATA_DROP == TRUE) || (SYS_CPNT_MVR == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IGMPSNP_DenyMulticastData
 *------------------------------------------------------------------------------
 * PURPOSE : This function sets internet multicast Entry
 * INPUT   : enable - TRUE to add rule;
 *                    FALSE to remove rule.
 *           unit   - unit
 *           port   - port
 * OUTPUT  : None
 * RETURN  : TRUE   - Success
 *           FALSE  - Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
BOOL_T
RULE_CTRL_IGMPSNP_DenyMulticastData(BOOL_T enable, UI32_T unit, UI32_T port)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s unit=%lu port=%lu", enable?"enable":"disable", unit, port);

    RULE_CTRL_InitParam(&param);

    param.unit          = unit;
    param.port          = port;

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return RULE_CTRL_SetSharedPortRule(&param,
            (RULE_CTRL_SPR_GET_OM_HANDLER)RULE_CTRL_IGMPSNP_GETOM_DenyMulticastData,
            (RULE_CTRL_SPR_SET_RULE_HANDLER)RULE_CTRL_IGMPSNP_SETRULE_DenyMulticastData);
}
#endif  /* SYS_CPNT_IP_MULTICAST_DATA_DROP || SYS_CPNT_MVR */

#if (SYS_CPNT_IPV6_MULTICAST_DATA_DROP == TRUE) || (SYS_CPNT_MVR6 == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IGMPSNP_DenyMulticastData
 *------------------------------------------------------------------------------
 * PURPOSE : This function sets internet multicast Entry
 * INPUT   : enable - TRUE to add rule;
 *                    FALSE to remove rule.
 *           unit   - unit
 *           port   - port
 * OUTPUT  : None
 * RETURN  : TRUE   - Success
 *           FALSE  - Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
BOOL_T
RULE_CTRL_IPV6_DenyMulticastData(
    BOOL_T enable,
    UI32_T unit,
    UI32_T port)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s unit=%lu port=%lu", enable?"enable":"disable", unit, port);

    RULE_CTRL_InitParam(&param);

    param.unit          = unit;
    param.port          = port;

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return RULE_CTRL_SetSharedPortRule(&param,
                                       (RULE_CTRL_SPR_GET_OM_HANDLER)RULE_CTRL_IP6_GETOM_DenyMulticastData,
                                       (RULE_CTRL_SPR_SET_RULE_HANDLER)RULE_CTRL_IP6_SETRULE_DenyMulticastData);
}
#endif /* #if SYS_CPNT_IPV6_MULTICAST_DATA_DROP || SYS_CPNT_MVR6 */


#if (SYS_CPNT_PTP == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_PTP_TrapPtpEventToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap PTP event packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_PTP_TrapPtpEventUdpToCPU(
    BOOL_T enable)
{
    RULE_CTRL_PARAM param;
    BOOL_T ret = FALSE;

    RULE_CTRL_LOG("%s", enable ? "enabled" : "disable");

    RULE_CTRL_InitParam(&param);

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    param.flags        |= RULE_CTRL_OPT_ALL_DEVICES;

   return _rule_ctrl_set_rule(&param, RULE_CTRL_PTP_DO_TrapPtpEventUdpToCPU);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_PTP_TrapPtpEventToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap PTP event packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_PTP_TrapPtpEventEthToCPU(
    BOOL_T enable)
{
    RULE_CTRL_PARAM param;
    BOOL_T ret = FALSE;

    RULE_CTRL_LOG("%s", enable ? "enabled" : "disable");

    RULE_CTRL_InitParam(&param);

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    param.flags        |= RULE_CTRL_OPT_ALL_DEVICES;

   return _rule_ctrl_set_rule(&param, RULE_CTRL_PTP_DO_TrapPtpEventEthToCPU);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_PTP_TrapPtpGeneralUdpToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap PTP event packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_PTP_TrapPtpGeneralUdpToCPU(
    BOOL_T enable)
{
    RULE_CTRL_PARAM param;
    BOOL_T ret = FALSE;

    RULE_CTRL_LOG("%s", enable ? "enabled" : "disable");

    RULE_CTRL_InitParam(&param);

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    param.flags        |= RULE_CTRL_OPT_ALL_DEVICES;

    return _rule_ctrl_set_rule(&param, RULE_CTRL_PTP_DO_TrapPtpGeneralUdpToCPU);
}
#endif  /* #if (SYS_CPNT_PTP == TRUE) */

#if (SYS_CPNT_MLD == TRUE || SYS_CPNT_MLDSNP == TRUE || SYS_CPNT_MVR6 == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IP6_SetMldQueryRule
 *------------------------------------------------------------------------------
 * PURPOSE  : trap MLD event packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IP6_SetMldQueryRule(
    BOOL_T enable)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s", enable ? "enabled" : "disable");

    RULE_CTRL_InitParam(&param);

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    param.flags        |= RULE_CTRL_OPT_ALL_DEVICES;

   return _rule_ctrl_set_rule(&param, RULE_CTRL_IP6_DO_SetMldQueryRule);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IP6_SetMldReportRule
 *------------------------------------------------------------------------------
 * PURPOSE  : trap MLD event packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IP6_SetMldReportRule(
    BOOL_T enable)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s", enable ? "enabled" : "disable");

    RULE_CTRL_InitParam(&param);

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    param.flags        |= RULE_CTRL_OPT_ALL_DEVICES;

   return _rule_ctrl_set_rule(&param, RULE_CTRL_IP6_DO_SetMldReportRule);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IP6_SetMldDoneRule
 *------------------------------------------------------------------------------
 * PURPOSE  : trap MLD event packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IP6_SetMldDoneRule(
    BOOL_T enable)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s", enable ? "enabled" : "disable");

    RULE_CTRL_InitParam(&param);

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    param.flags        |= RULE_CTRL_OPT_ALL_DEVICES;

   return _rule_ctrl_set_rule(&param, RULE_CTRL_IP6_DO_SetMldDoneRule);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IP6_SetMldv2ReportsRule
 *------------------------------------------------------------------------------
 * PURPOSE  : trap MLD event packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IP6_SetMldv2ReportsRule(
    BOOL_T enable)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s", enable ? "enabled" : "disable");

    RULE_CTRL_InitParam(&param);

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    param.flags        |= RULE_CTRL_OPT_ALL_DEVICES;

   return _rule_ctrl_set_rule(&param, RULE_CTRL_IP6_DO_SetMldv2ReportsRule);
}
#endif /* SYS_CPNT_MLD || SYS_CPNT_MLDSNP || SYS_CPNT_MVR6 */

#if (SYS_CPNT_IPV6_RA_GUARD == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IP6_RA_Guard_Deny_RA_Packet
 *------------------------------------------------------------------------------
 * PURPOSE:  Deny IPv6 Router-Advertisement packet for RA Guard
 * INPUT:    enable          - TRUE:  deny
 *                             FALSE: no deny
 *           interface_p     - pointer to interface info
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
BOOL_T
RULE_CTRL_IP6_RA_Guard_DenyRAPacket(
    BOOL_T                      enable,
    RULE_TYPE_INTERFACE_INFO_T  *interface_p)
{
    RULE_CTRL_PARAM param;

    ASSERT(NULL != interface_p);

    if (RULE_TYPE_INTERFACE_UPORT != interface_p->type)
    {
        RULE_CTRL_LOG("Invalid interface->type(%d)", interface_p->type);
        return FALSE;
    }

    RULE_CTRL_LOG("%s unit=%lu port=%lu\n", enable?"enable":"disable",
                  interface_p->uport.unit,
                  interface_p->uport.port);

    RULE_CTRL_InitParam(&param);

    param.unit          = interface_p->uport.unit;
    param.port          = interface_p->uport.port;

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return RULE_CTRL_SetSharedPortRule(&param,
                                       (RULE_CTRL_SPR_GET_OM_HANDLER)RULE_CTRL_IP6_RA_Guard_GETOM_DenyRAPacket,
                                       (RULE_CTRL_SPR_SET_RULE_HANDLER)RULE_CTRL_IP6_RA_Guard_SETRULE_DenyRAPacket);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IP6_RA_Guard_Deny_RR_Packet
 *------------------------------------------------------------------------------
 * PURPOSE:  Deny IPv6 Router-Redirect packet for RA Guard
 * INPUT:    enable          - TRUE:  deny
 *                             FALSE: no deny
 *           interface_p     - pointer to interface info
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
BOOL_T
RULE_CTRL_IP6_RA_Guard_DenyRRPacket(
    BOOL_T                      enable,
    RULE_TYPE_INTERFACE_INFO_T  *interface_p)
{
    RULE_CTRL_PARAM param;

    ASSERT(NULL != interface_p);

    if (RULE_TYPE_INTERFACE_UPORT != interface_p->type)
    {
        RULE_CTRL_LOG("Invalid interface->type(%d)", interface_p->type);
        return FALSE;
    }

    RULE_CTRL_LOG("%s unit=%lu port=%lu\n", enable?"enable":"disable",
                  interface_p->uport.unit,
                  interface_p->uport.port);

    RULE_CTRL_InitParam(&param);

    param.unit          = interface_p->uport.unit;
    param.port          = interface_p->uport.port;

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return RULE_CTRL_SetSharedPortRule(&param,
                                       (RULE_CTRL_SPR_GET_OM_HANDLER)RULE_CTRL_IP6_RA_Guard_GETOM_DenyRRPacket,
                                       (RULE_CTRL_SPR_SET_RULE_HANDLER)RULE_CTRL_IP6_RA_Guard_SETRULE_DenyRRPacket);
}
#endif /* #if (SYS_CPNT_IPV6_RA_GUARD == TRUE) */

#if (SYS_CPNT_APP_FILTER_CDP == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_AF_DenyCdpPacket
 *------------------------------------------------------------------------------
 * PURPOSE : This function enables/disables drop CDP packeage
 * INPUT   : enable - TRUE:  Enable
 *                    FALSE: Disable
 *           unit   - unit
 *           port   - port
 * OUTPUT  : None
 * RETURN  : RULE_TYPE_RETURN_TYPE_T
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_AF_DenyCdpPacket(
    BOOL_T enable,
    UI32_T unit,
    UI32_T port)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s unit=%lu port=%lu\n", enable?"enable":"disable", unit, port);

    RULE_CTRL_InitParam(&param);

    param.unit          = unit;
    param.port          = port;
    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return (TRUE == RULE_CTRL_SetSharedPortRule(&param,
               (RULE_CTRL_SPR_GET_OM_HANDLER)RULE_CTRL_AF_GETOM_DenyCdpPacket,
               (RULE_CTRL_SPR_SET_RULE_HANDLER)RULE_CTRL_AF_SETRULE_DenyCdpPacket))
               ? RULE_TYPE_OK : RULE_TYPE_FAIL;
}
#endif /* #if (SYS_CPNT_APP_FILTER_CDP == TRUE) */

#if (SYS_CPNT_APP_FILTER_PVST == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_AF_DenyPvstPacket
 *------------------------------------------------------------------------------
 * PURPOSE : This function enables/disables drop CDP packeage
 * INPUT   : enable - TRUE:  Enable
 *                    FALSE: Disable
 *           unit   - unit
 *           port   - port
 * OUTPUT  : None
 * RETURN  : RULE_TYPE_RETURN_TYPE_T
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_AF_DenyPvstPacket(
    BOOL_T enable,
    UI32_T unit,
    UI32_T port)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s unit=%lu port=%lu\n", enable?"enable":"disable", unit, port);

    RULE_CTRL_InitParam(&param);

    param.unit          = unit;
    param.port          = port;
    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return (TRUE == RULE_CTRL_SetSharedPortRule(&param,
               (RULE_CTRL_SPR_GET_OM_HANDLER)RULE_CTRL_AF_GETOM_DenyPvstPacket,
               (RULE_CTRL_SPR_SET_RULE_HANDLER)RULE_CTRL_AF_SETRULE_DenyPvstPacket))
               ? RULE_TYPE_OK : RULE_TYPE_FAIL;
}
#endif /* #if (SYS_CPNT_APP_FILTER_PVST == TRUE) */

#if ((SYS_CPNT_INGRESS_RATE_LIMIT_VIA_FILTER_ENGINE == TRUE) && (SYS_CPNT_QOS_V2 == TRUE))
/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_GetPortConfigStatus
 *------------------------------------------------------------------------------
 * PURPOSE  : get port config status by port
 * INPUT    : port
 * OUTPUT   : None
 * RETURN   : NULL -- failed
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static RULE_CTRL_PortConfigStatus_T* RULE_CTRL_GetPortRatelimimtStatus(UI32_T port)
{
    if (RULE_CTRL_IS_BAD_UPORT(port))
        return NULL;

    return &shmem_data_p->port_config_status_table[port - 1]; /* to zero-based */
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalSetRateLimit
 *------------------------------------------------------------------------------
 * PURPOSE  : set up rate limit on specified (unit, port)
 * INPUT    : unit, port, k_bps, trunk_id (0 means the port didn't join any trunk)
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : if already set, MUST be deleted before modification
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_LocalSetRateLimit(UI32_T unit, UI32_T port, UI32_T k_bps)
{
#define RULE_CTRL_TGID_TRUNK_INDICATOR         0x40 /*BCM_TGID_TRUNK_INDICATOR*/

    DEVRM_PBMP_T                        port_pbmp;
    BOOL_T                              ret = TRUE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_MeterEntry_T                  meter_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    RULE_CTRL_PortConfigStatus_T        *port_config_status_p;
    UI32_T                              module_id, device_id, phy_port;
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_INGRESS_PPORT_RATELIMIT;


    /* setup rule/filter */
    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(unit, port, &module_id, &device_id, &phy_port))
    {
        return FALSE;
    }

    RULE_CTRL_EnterCriticalSection();
    port_config_status_p = RULE_CTRL_GetPortRatelimimtStatus(port);
    if (NULL == port_config_status_p)
    {
        RULE_CTRL_LeaveCriticalSection();
        return FALSE;
    }

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_INGRESS_PPORT_RATELIMIT, &group_id, &rule_pri))
    {
        RULE_CTRL_LeaveCriticalSection();
        return FALSE;
    }

    if (TRUE == port_config_status_p->rate_limit_install_flag)
    {
        /* if already set rate limit rule on this port,
         * should remove rule first.
         */
        if (FALSE == RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, port_config_status_p->dev_rule_id))
        {
            RULE_CTRL_LeaveCriticalSection();
            return FALSE;
        }
        port_config_status_p->rate_limit_install_flag = FALSE;
        port_config_status_p->dev_rule_id = 0;
    }


#if 0/* To be used later for trunk. */
    ace_entry.entry_qualify = DEVRM_FIELD_QUALIFY_MASK_SRCPORTTGID |
                              DEVRM_FIELD_QUALIFY_MASK_SRCMODID;
    /* need to match module_id when using SRCPORTTGID
     *  under the condition of stacking or having multiple ASICs
     */
    RULE_CTRL_SET_FILTER_SRCMODID(ace_entry, module_id);

    /* XGSIII: the Src_Port_TGID of fp_tcam rule is used for port or trunk id.
     */
    if (0 == trunk_id)
    {
        RULE_CTRL_SET_FILTER_SRCPORTTGID(ace_entry, phy_port);
    }
    else
    {
        trunk_id = RULE_CTRL_TGID_TRUNK_INDICATOR | (trunk_id -1);
        RULE_CTRL_SET_FILTER_SRCPORTTGID(ace_entry, trunk_id);
    }
#endif


    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));

    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_PBMP_CLEAR(port_pbmp);
    DEVRM_PBMP_PORT_ADD(port_pbmp, phy_port);
    RULE_CTRL_SET_FILTER_IPBM(ace_entry, port_pbmp);

    /* setup action */
    RULE_CTRL_SET_ACTION_RED_DROP(action_entry[0]);
    action_entry[0].next_action = NULL;

    /* setup meter */
    meter_entry.meter_num   = BCM_FIELD_METER_PEAK;
    meter_entry.kbits_sec   = k_bps;
    meter_entry.kbytes_burst= SYS_DFLT_RATE_LIMIT_DFLT_BURST_KBYTES;
    meter_entry.meter_mode  = BCM_FIELD_METER_MODE_FLOW;

    ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
    ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                &ace_entry, &meter_entry, &action_entry[0], FALSE);
    RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);

    port_config_status_p->rate_limit_install_flag = TRUE;
    port_config_status_p->dev_rule_id = rule_index;
    RULE_CTRL_LeaveCriticalSection();

    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalDeleteRateLimit
 *------------------------------------------------------------------------------
 * PURPOSE  : cancel rate limit on specified (unit, port)
 * INPUT    : unit, port
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_LocalDeleteRateLimit(UI32_T unit, UI32_T port)
{
    UI32_T                              module_id, device_id, phy_port;
    UI32_T                              group_id;
    int                                 rule_pri;
    RULE_CTRL_PortConfigStatus_T        *port_config_status_p;
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_INGRESS_PPORT_RATELIMIT;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(unit, port, &module_id, &device_id, &phy_port))
    {
        return FALSE; /* treat as success */
    }

    RULE_CTRL_EnterCriticalSection();
    port_config_status_p = RULE_CTRL_GetPortRatelimimtStatus(port);
    if (NULL == port_config_status_p)
    {
        RULE_CTRL_LeaveCriticalSection();
        return FALSE;
    }
    else if(FALSE == port_config_status_p->rate_limit_install_flag)
    {
        RULE_CTRL_LeaveCriticalSection();
        return TRUE; /* treat as success */
    }

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_INGRESS_PPORT_RATELIMIT, &group_id, &rule_pri))
    {
        RULE_CTRL_LeaveCriticalSection();
        return FALSE;
    }

    if (FALSE == RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, port_config_status_p->dev_rule_id))
    {
        RULE_CTRL_LeaveCriticalSection();
        return FALSE; /* treat as success */
    }

    port_config_status_p->rate_limit_install_flag = FALSE;
    port_config_status_p->dev_rule_id = 0;
    RULE_CTRL_LeaveCriticalSection();

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetRateLimit
 *------------------------------------------------------------------------------
 * PURPOSE  : set up rate limit on specified (unit, port)
 * INPUT    : unit, port, k_bps, trunk_id (0 means the port didn't join any trunk)
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : XGSIII: the Src_Port_TGID of fp_tcam rule
 *                    is used for port or trunk id.
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_SetRateLimit(UI32_T unit, UI32_T port, UI32_T trunk_id, UI32_T k_bps)
{
    UI32_T  my_drv_unit;

    if (FALSE == STKTPLG_POM_GetMyDriverUnit(&my_drv_unit))
        return FALSE;

    if (my_drv_unit != unit) /* set up local unit only */
    {
        PRINTF("\r\n[RULE_CTRL_SetRateLimit] error, suppose caller should pass local unit to rule_ctrl");
        return FALSE;
    }

    return RULE_CTRL_LocalSetRateLimit(unit, port, k_bps);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_DeleteRateLimit
 *------------------------------------------------------------------------------
 * PURPOSE  : cancel rate limit on specified (unit, port)
 * INPUT    : unit, port
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_DeleteRateLimit(UI32_T unit, UI32_T port, UI32_T trunk_id)
{
    UI32_T  my_drv_unit;

    if (FALSE == STKTPLG_POM_GetMyDriverUnit(&my_drv_unit))
        return FALSE;

    if (my_drv_unit != unit) /* set up local unit only */
    {
        PRINTF("\r\n[RULE_CTRL_DeleteRateLimit] error, suppose caller should pass local unit to rule_ctrl");
        return FALSE;
    }

    return RULE_CTRL_LocalDeleteRateLimit(unit, port);
}
#endif


#if (SYS_CPNT_QINQ == TRUE)
#if (SYS_CPNT_SWCTRL_QINQ_SERVICE == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_MGR_SERVICE_QINQ
 *------------------------------------------------------------------------------
 * PURPOSE:  for SERVICE QINQ
 *            config chip to add/delete an outter tag to packets with user setting.
 * INPUT:    unit, port - unit/port number
 *           cvid       - inner vid
 *           cpri       - inner pri
 *           svid       - outer vid
 *           spri       - outer pri
 *           is_enable  - add or delete the rule of S_QINQ
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE
 * NOTE:     TRUE means success; FALSE means faile
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_Service_QinQ(
    UI32_T unit, UI32_T port, UI32_T cvid , UI32_T cpri, UI32_T svid , UI32_T spri, BOOL_T is_enable)
{
    return TRUE;
}
#endif /*end of #if (SYS_CPNT_SWCTRL_QINQ_SERVICE == TRUE)*/

#if (SYS_CPNT_QINQ_L2PT == TRUE)
#if (SYS_CPNT_QINQ_L2PT_DA_REMARK == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetL2PTTunnelPduToCpu
 *------------------------------------------------------------------------------
 * PURPOSE : This function enables/disables trap L2PT tunnel PDU.
 * INPUT   : tunnel_da
 *           is_enable
 * OUTPUT  : None
 * RETURN  : TRUE   -- Success
 *           FALSE  -- If a given port is not available
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_SetL2PTTunnelPduToCpu(UI8_T *tunnel_da, BOOL_T is_enable)
{
    RULE_TYPE_CpuRuleInfo_T rule_info;

    memset(&rule_info, 0, sizeof(rule_info));
    memcpy(rule_info.l2pt.mac, tunnel_da, sizeof(rule_info.l2pt.mac));

    return RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_L2PT, &rule_info);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapL2ptTunnelPduToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap L2PT tunnel PDU to CPU
 * INPUT    : enable
 *            tunnel_da
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapL2ptTunnelPduToCPU(BOOL_T enable, UI8_T *tunnel_da)
{
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_DEFAULT, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);

    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_DA(ace_entry, tunnel_da);

    /* setup action */
    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(action_entry[0]);

#if (RULE_CTRL_ADD_CLASS_ID_FOR_EVERY_RULE == TRUE)
    RULE_CTRL_SET_ACTION_NEW_CLASS_ID(action_entry[1], RULE_CTRL_NEW_CLASS_ID_FOR_GLOBAL_SPVID);
    action_entry[0].next_action = &action_entry[1];
#endif

    /* config every switch chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_L2PT, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable && !is_enabled)
            return TRUE;

        if(enable)
        {
            if (!is_enabled)
            {
                ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            }

            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == ret || FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_L2PT, enable, rule_index))
            return FALSE;
    }

    return ret;
}
#endif /* (SYS_CPNT_QINQ_L2PT_DA_REMARK == TRUE) */

#if (SYS_CPNT_QINQ_L2PT_CUSTOM_PDU == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetCustomPduTrapStatusForL2PT
 *------------------------------------------------------------------------------
 * PURPOSE : This function enables/disables trap custom PDU for L2PT.
 * INPUT   : unit
 *           port
 *           id
 *           dst_mac
 *           ethertype
 *           pdu_len
 *           pdu_data
 *           pdu_mask
 *           is_enable
 * OUTPUT  : None
 * RETURN  : TRUE   -- Success
 *           FALSE  -- Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_SetCustomPduTrapStatusForL2PT(UI32_T unit, UI32_T port, UI32_T id, UI8_T *dst_mac, UI16_T ethertype, UI32_T pdu_len, UI8_T *pdu_data, UI8_T *pdu_mask, BOOL_T enable)
{
#if (SYS_ADPT_QINQ_L2PT_MAX_NBR_OF_CUSTOM_PDU_PER_PORT != 1)
#warning Not implemented for SYS_ADPT_QINQ_L2PT_MAX_NBR_OF_CUSTOM_PDU_PER_PORT > 1
#endif

    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s unit=%lu port=%lu", enable?"enable":"disable", unit, port);

    RULE_CTRL_InitParam(&param);

    /* NOTE
     *   1. current implementation support one entry per port only.
     *   2. filter PDU by dst mac and ethertype only.
     *
     * TODO:
     *   1. support more than one entry per port.
     *   2. filter PDU by classify frame format as follows:
     *         Ethernet II
     *         IEEE 802.3 with LLC 42-42-03
     *         IEEE 802.3 with SNAP
     */

    param.unit          = unit;
    param.port          = port;
    param.L2PT_CUSTOM_PDU.ethertype = ethertype;
    memcpy(param.L2PT_CUSTOM_PDU.dstmac, dst_mac, sizeof(param.L2PT_CUSTOM_PDU.dstmac));

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return RULE_CTRL_SetSharedPortRule(&param,
            (RULE_CTRL_SPR_GET_OM_HANDLER)RULE_CTRL_L2PT_GETOM_SetCustomPduTrapStatusForL2PT,
            (RULE_CTRL_SPR_SET_RULE_HANDLER)RULE_CTRL_L2PT_SETRULE_SetCustomPduTrapStatusForL2PT);
}
#endif /* (SYS_CPNT_QINQ_L2PT_CUSTOM_PDU == TRUE) */
#endif /* (SYS_CPNT_QINQ_L2PT == TRUE) */
#endif /*end of #if (SYS_CPNT_QINQ == TRUE)*/

#if (SYS_CPNT_PPPOE_IA == TRUE)
/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_PPPOE_IA_GETOM_TrapPppoedPduToCPU
 *------------------------------------------------------------------------------
 * PURPOSE : This function will enable PPPoE Discovery PDU redirect to CPU rule
 *           for specified unit and port
 * INPUT:    param_p - General parameter
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
static void* RULE_CTRL_PPPOE_IA_GETOM_TrapPppoedPduToCPU(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T  module_id, device_id, phy_port;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit,
                                                        param_p->port,
                                                        &module_id,
                                                        &device_id,
                                                        &phy_port))
    {
        return NULL;
    }

    return &shmem_data_p->pppoe_discovery[param_p->unit-1][device_id];
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_PPPOE_IA_SETRULE_TrapPppoedPduToCPU
 *------------------------------------------------------------------------------
 * PURPOSE : This function will enable PPPoE Discovery PDU redirect to CPU rule
 *           for specified unit and port
 * INPUT:    param_p - General parameter
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_PPPOE_IA_SETRULE_TrapPppoedPduToCPU(
    RULE_CTRL_PARAM_PTR param_p,
    DEVRM_PBMP_T new_pbmp)
{
    /* packet format:   ETH: 0x8863
     */
    UI32_T  ethtype = 0x8863;

    param_p->func_type  = RULE_TYPE_PACKET_TO_CPU_DEFAULT;
    RULE_CTRL_MakeParamTag(param_p, "pppoed", NULL, NULL, NULL);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, new_pbmp);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(param_p->ace_entry, ethtype);

    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(param_p->action_entries[0]);

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetPPPoEDPktToCpu
 *------------------------------------------------------------------------------
 * PURPOSE : To enable/disable trap PPPoE discover packet to CPU
 *            for specified unit/port.
 * INPUT   : unit       - unit
 *           port       - port
 *           is_enable  - TRUE to enable
 * OUTPUT  : None
 * RETURN  : TRUE       - Success
 *           FALSE      - Failed
 * NOTE    : 1. for projects who can install rule on trunk's member ports.
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_SetPPPoEDPktToCpu(
    UI32_T  unit,
    UI32_T  port,
    BOOL_T  is_enable)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s unit=%lu port=%lu", is_enable?"enable":"disable", unit, port);

    RULE_CTRL_InitParam(&param);

    param.unit          = unit;
    param.port          = port;

    if (is_enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return RULE_CTRL_SetSharedPortRule(&param,
            (RULE_CTRL_SPR_GET_OM_HANDLER)RULE_CTRL_PPPOE_IA_GETOM_TrapPppoedPduToCPU,
            (RULE_CTRL_SPR_SET_RULE_HANDLER)RULE_CTRL_PPPOE_IA_SETRULE_TrapPppoedPduToCPU);

}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetPPPoEDPktToCpuPerSystem
 *------------------------------------------------------------------------------
 * PURPOSE : To enable/disable trap PPPoE discover packet to CPU
 *            for entire system.
 * INPUT   : is_enable  - TRUE to enable
 * OUTPUT  : None
 * RETURN  : TRUE       - Success
 *           FALSE      - Failed
 * NOTE    : 1. for projects who encounter problems to install rule on
 *              trunk's member ports.
 *           2. not implemented for bcm, yet.
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_SetPPPoEDPktToCpuPerSystem(
    BOOL_T  is_enable)
{
    /* not implement for BCM
     */
    return FALSE;
}

#endif /* #if (SYS_CPNT_PPPOE_IA == TRUE) */

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetCdpPktToCpu
 *------------------------------------------------------------------------------
 * PURPOSE : This function enables/disables trap CDP PDU.
 * INPUT   : is_enable
 * OUTPUT  : None
 * RETURN  : TRUE   -- Success
 *           FALSE  -- If a given port is not available
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_SetCdpPktToCpu(BOOL_T is_enable)
{
    return RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_CDP, NULL);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetPvstPktToCpu
 *------------------------------------------------------------------------------
 * PURPOSE : This function enables/disables trap CDP PDU.
 * INPUT   : is_enable
 * OUTPUT  : None
 * RETURN  : TRUE   -- Success
 *           FALSE  -- If a given port is not available
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_SetPvstPktToCpu(BOOL_T is_enable)
{
    return RULE_CTRL_TrapPacket2Cpu(is_enable, RULE_TYPE_PacketType_PVST, NULL);
}

#if (SYS_CPNT_DOS == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetDosProtectionFilter
 *------------------------------------------------------------------------------
 * FUNCTION: This function will config DoS protection
 * INPUT   : type   - the type of DOS protection to config
 *           enable - TRUE to enable; FALSE to disable.
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_SetDosProtectionFilter(UI32_T type, BOOL_T enable)
{
    /* Not implemented
     */
    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetDosProtectionRateLimit
 *------------------------------------------------------------------------------
 * FUNCTION: This function will config DoS protection
 * INPUT   : type   - the type of DOS protection to config
 *           rate   - rate in kbps. 0 to disable.
 * OUTPUT  : None
 * RETURN  : TRUE/FALSE
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_SetDosProtectionRateLimit(UI32_T type, UI32_T rate)
{
    /* Not implemented
     */
    return TRUE;
}
#endif /* (SYS_CPNT_DOS == TRUE) */

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_NotifyIpDscp2CosChangeByLport
 *------------------------------------------------------------------------------
 * PURPOSE  : caller notify rule_ctrl which dscp to cos mapping had been changed
 * INPUT    : lport, ip_dscp
 * OUTPUT   : None
 * RETURN   : error code (OK / FAIL)
 * NOTE     : for policy-map CLI command "set ip dscp xxx"
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_NotifyIpDscp2CosChangeByLport(UI32_T lport, UI8_T ip_dscp)
{
    UI32_T  index, policy_map_index, class_map_index;

    /* in current implementation, COS reference don't care which dscp of port */

    index = 0;
    while (RULE_TYPE_OK == RULE_OM_GetNextIpDscpReference(ip_dscp, &index, &policy_map_index, &class_map_index))
    {
        /* because DSCP to CoS value mapping has been changed,
         * undo original config first then config again (with new CoS mapping)
         */
        if ((FALSE == RULE_CTRL_RemoveClassMapConfig(policy_map_index, class_map_index, FALSE)) ||
            (FALSE == RULE_CTRL_AddClassMapConfig(policy_map_index, class_map_index)))
        {
            return FALSE;
        }
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_NotifyIpPrecedence2CosChangeByLport
 *------------------------------------------------------------------------------
 * PURPOSE  : caller notify rule_ctrl which ip precedence to cos mapping had been changed
 * INPUT    : lport, ip_precedence
 * OUTPUT   : None
 * RETURN   : error code (OK / FAIL)
 * NOTE     : for policy-map CLI command "set ip precedence xxx"
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_NotifyIpPrecedence2CosChangeByLport(UI32_T lport, UI8_T ip_precedence)
{
    UI32_T  index, policy_map_index, class_map_index;

    /* in current implementation, COS reference don't care which dscp of port */

    index = 0;
    while (RULE_TYPE_OK == RULE_OM_GetNextIpPrecedenceReference(ip_precedence, &index, &policy_map_index, &class_map_index))
    {
        /* because IP Precedence to CoS value mapping has been changed,
         * undo original config first then config again (with new CoS mapping)
         */
        if ((FALSE == RULE_CTRL_RemoveClassMapConfig(policy_map_index, class_map_index, FALSE)) ||
            (FALSE == RULE_CTRL_AddClassMapConfig(policy_map_index, class_map_index)))
        {
            return FALSE;
        }
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Service
 *------------------------------------------------------------------------------
 * PURPOSE  : Rule control service
 * INPUT    : is_enable - Set or remove
 *            type      - Service type
 *            param_p   - Parameter list
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTE     : No maintain in the future
 *------------------------------------------------------------------------------
 */
BOOL_T
RULE_CTRL_Service(
    BOOL_T is_enable,
    RULE_CTRL_ServiceType_T type,
    void *param_p)
{
    switch (type)
    {
    #if (SYS_CPNT_WEBAUTH == TRUE)
        case RULE_CTRL_WEBAUTH_REDIR_HTTP:
            {
                UI32_T unit = ((RULE_CTRL_UnitPort_T*)param_p)->unit;
                UI32_T port = ((RULE_CTRL_UnitPort_T*)param_p)->port;

                return RULE_CTRL_WA_TrapHttpToCPU(is_enable, unit, port);
            }
            break;

        case RULE_CTRL_WEBAUTH_PERMIT_DHCPC:
            {
                UI32_T unit = ((RULE_CTRL_UnitPort_T*)param_p)->unit;
                UI32_T port = ((RULE_CTRL_UnitPort_T*)param_p)->port;

                return RULE_CTRL_WA_PermitDhcp(is_enable, unit, port);
            }
            break;

        case RULE_CTRL_WEBAUTH_PERMIT_DNS:
            {
                UI32_T unit = ((RULE_CTRL_UnitPort_T*)param_p)->unit;
                UI32_T port = ((RULE_CTRL_UnitPort_T*)param_p)->port;

                return RULE_CTRL_WA_PermitDns(is_enable, unit, port);
            }
            break;


        case RULE_CTRL_WEBAUTH_PERMIT_SIP:
            {
                UI32_T unit = ((RULE_CTRL_UnitPortSip_T*)param_p)->unit;
                UI32_T port = ((RULE_CTRL_UnitPortSip_T*)param_p)->port;
                UI32_T sip  = ((RULE_CTRL_UnitPortSip_T*)param_p)->sip;

                return RULE_CTRL_WA_PermitIpPacket(is_enable, unit, port, (UI8_T*)&sip);
            }
            break;

        case RULE_CTRL_WEBAUTH_DENY_IP:
            {
                UI32_T unit = ((RULE_CTRL_UnitPort_T*)param_p)->unit;
                UI32_T port = ((RULE_CTRL_UnitPort_T*)param_p)->port;

                return RULE_CTRL_WA_DenyAnyIpPacket(is_enable, unit, port);
            }
            break;
    #endif /* SYS_CPNT_WEBAUTH */

    #if (SYS_CPNT_IP_SOURCE_GUARD == TRUE)
        case RULE_CTRL_IP_SOURCE_GUARD_PERMIT_VID_SIP:
        case RULE_CTRL_IP_SOURCE_GUARD_PERMIT_SA_VID_SIP:
            {
                UI32_T unit;
                UI32_T port;
                UI32_T vid;
                UI32_T sip;
                UI8_T  sa[SYS_ADPT_MAC_ADDR_LEN];

                if (RULE_CTRL_IP_SOURCE_GUARD_PERMIT_VID_SIP == type)
                {
                    unit = ((RULE_CTRL_UnitPortVidSip_T*)param_p)->unit;
                    port = ((RULE_CTRL_UnitPortVidSip_T*)param_p)->port;
                    vid  = ((RULE_CTRL_UnitPortVidSip_T*)param_p)->vid;
                    sip  = ((RULE_CTRL_UnitPortVidSip_T*)param_p)->sip;
                    memset(sa, 0, SYS_ADPT_MAC_ADDR_LEN);

                    return RULE_CTRL_IPSG_PermitIpPacket(is_enable, unit, port, vid, (UI8_T*)&sip, NULL);
                }
                else
                {
                    unit = ((RULE_CTRL_UnitPortSaVidSip_T*)param_p)->unit;
                    port = ((RULE_CTRL_UnitPortSaVidSip_T*)param_p)->port;
                    vid  = ((RULE_CTRL_UnitPortSaVidSip_T*)param_p)->vid;
                    sip  = ((RULE_CTRL_UnitPortSaVidSip_T*)param_p)->sip;
                    memcpy(sa, ((RULE_CTRL_UnitPortSaVidSip_T*)param_p)->sa, SYS_ADPT_MAC_ADDR_LEN);

                    return RULE_CTRL_IPSG_PermitIpPacket(is_enable, unit, port, vid, (UI8_T*)&sip, sa);
                }
            }
            break;

        case RULE_CTRL_IP_SOURCE_GUARD_DENY_IP:
            {
                UI32_T unit = ((RULE_CTRL_UnitPort_T*)param_p)->unit;
                UI32_T port = ((RULE_CTRL_UnitPort_T*)param_p)->port;

                return RULE_CTRL_IPSG_DenyAnyIpPacket(is_enable, unit, port);
            }
            break;
        #endif /* SYS_CPNT_IP_SOURCE_GUARD */

    #if (SYS_CPNT_IPV6_SOURCE_GUARD == TRUE)
        case RULE_CTRL_IPV6_SOURCE_GUARD_PERMIT_VID_SIP6:
            {
                UI32_T                      vid;
                UI8_T                       sip6[SYS_TYPE_IPV6_ADDR_LEN];
                RULE_TYPE_INTERFACE_INFO_T  interface_info;

                interface_info.type       = RULE_TYPE_INTERFACE_UPORT;
                interface_info.direction  = RULE_TYPE_INBOUND;
                interface_info.uport.unit = ((RULE_CTRL_UnitPortVidSip6_T*)param_p)->unit;
                interface_info.uport.port = ((RULE_CTRL_UnitPortVidSip6_T*)param_p)->port;

                vid  = ((RULE_CTRL_UnitPortVidSip6_T*)param_p)->vid;
                memcpy (sip6, ((RULE_CTRL_UnitPortVidSip6_T*)param_p)->sip6, sizeof(sip6));

                return RULE_CTRL_IPV6SG_PermitIp6Host(is_enable, &interface_info, vid, sip6);
            }
            break;

        case RULE_CTRL_IPV6_SOURCE_GUARD_DENY_IP6:
            {
                RULE_TYPE_INTERFACE_INFO_T  interface_info;

                interface_info.type       = RULE_TYPE_INTERFACE_UPORT;
                interface_info.direction  = RULE_TYPE_INBOUND;
                interface_info.uport.unit = ((RULE_CTRL_UnitPort_T*)param_p)->unit;
                interface_info.uport.port = ((RULE_CTRL_UnitPort_T*)param_p)->port;

                return RULE_CTRL_IPV6SG_DenyAnyIp6Packet(is_enable, &interface_info);
            }
            break;
    #endif /* SYS_CPNT_IPV6_SOURCE_GUARD */

        default:
            PRINTF("%s %d: Unsupported service type(%d)\n",
                __FUNCTION__,
                __LINE__,
                type);
            break;
    }

    return FALSE;
}

#if (L4_SUPPORT_ACCTON_BACKDOOR == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_DumpFunctionInfo
 *------------------------------------------------------------------------------
 * PURPOSE  : dump all functions' information
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : for debug
 *------------------------------------------------------------------------------
 */
void RULE_CTRL_DumpFunctionInfo(void)
{
    UI32_T                      idx;
    RULE_TYPE_FunctionType_T    fun_type;
    UI32_T                      group_id;
    int                         rule_pri;
    char                        *fun_array[] = RULE_TYPE_FUNCTION_TYPE_STRING_ARRAY;

    RULE_TYPE_PRINT ("\r\n");
    RULE_TYPE_PRINT(" P: rule priority, M: group mode, selector: [stage, bitmap, count]\r\n");
    RULE_TYPE_PRINT(" =====================================================================\r\n");
    RULE_TYPE_PRINT(" fun:id|%-32s|GID| P, M, [ selector ]\r\n", "fun_name");
    RULE_TYPE_PRINT(" =====================================================================\r\n");

//    printf("     |quota:valid,total_rule,free_rule\r\n");

    for (idx = 0; idx < FP_CONFIG_NumberOfFunctionType(); idx++)
    {
        FP_CONFIG_GroupInfo_T       *group_info;
        FP_CONFIG_FunctionInfo_T    *fun_info   = FP_CONFIG_GetFunctionInfo(idx);

        if(NULL == fun_info)
            continue;

        fun_type = fun_info->function_type;
        group_id = fun_info->group_id;
        rule_pri = fun_info->rule_pri;

        group_info = FP_CONFIG_get_group_info_by_id(group_id);
        if(NULL == group_info)
            continue;

        RULE_TYPE_PRINT(" fun:%2d|%-32s|%3lu|%2x,%2lu,[%2lu,0x%03x,%2lu]\r\n",
                        fun_type, fun_array[fun_type], group_id, rule_pri,
                        group_info->group_mode,
                        group_info->selector_stage,
                        group_info->selector_bitmap,
                        group_info->selector_count);
    }
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_DumpResourceInfo
 *------------------------------------------------------------------------------
 * PURPOSE  : dump specified group information
 * INPUT    : unit, device_id, group_id
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : for debug
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_DumpResourceInfo(UI32_T unit, UI32_T device_id, UI32_T group_id)
{
    UI32_T                      i;
    RULE_CTRL_ResourceInfo_T    *res_p;
    FP_CONFIG_GroupInfo_T       *group_info;
    BOOL_T                      found;

    res_p = RULE_CTRL_GetResourceInfo(unit, device_id, group_id);
    if (NULL == res_p)
        return FALSE;

    found = FALSE;
    for (i = 0; i < FP_CONFIG_NumberOfGroup(); i++)
    {
        group_info = FP_CONFIG_get_group_info_by_id(i);
        if(NULL == group_info)
            return FALSE;

        if (group_info->group_id == group_id)
        {
            found = TRUE;
            break;
        }
    }

    if (found == FALSE)
        return FALSE;

    RULE_TYPE_PRINT("\r\n");
    RULE_TYPE_PRINT(" res: unit = %lu device = %2lu group_id = %2lu, rule = {total:%3lu, free:%3lu}\r\n",
                    unit, device_id, group_id, res_p->total_rule, res_p->free_rule);

    RULE_TYPE_PRINT("     Group = {id:%2lu mode:%2lu} Selector[stage,bitmap,count]=[%2lu,0x%04lx,%2lu]\r\n",
                    group_id, group_info->group_mode, group_info->selector_stage,
                    group_info->selector_bitmap, group_info->selector_count);

    for (i = 0; i < FP_CONFIG_NumberOfFunctionType(); i++)
    {
        FP_CONFIG_FunctionInfo_T    *fun_info   = FP_CONFIG_GetFunctionInfo(i);
        RULE_TYPE_FunctionType_T    fun_type    = fun_info->function_type;
        char                        *fun_array[]= RULE_TYPE_FUNCTION_TYPE_STRING_ARRAY;
        RULE_CTRL_RuleQuota_T       *rule_quota;

        group_info = FP_CONFIG_get_group_info_by_id(fun_info->group_id);
        if (group_info->group_id == group_id)
        {
            rule_quota = RULE_CTRL_GetRuleQuota(unit, device_id, fun_type);

            RULE_TYPE_PRINT("     |fun:%2d|%-32s\r\n"
                            "            |quota[used,total,free,cnt]=[%s,%3lu,%3lu,%3lu]|\r\n",
                            fun_type,
                            fun_array[fun_type],
                            (rule_quota->used)?"yes":"no",
                            rule_quota->total_rule,
                            rule_quota->free_rule,
                            rule_quota->rule_cnt);
        }
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_DumpCpuInterfaceStatus
 *------------------------------------------------------------------------------
 * PURPOSE  : to see the CPU interface via FP status
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : for debug
 *------------------------------------------------------------------------------
 */
void RULE_CTRL_DumpCpuInterfaceStatus()
{
    struct
    {
        RULE_TYPE_Pkt2CpuRule_T rule_type;
        char rule_name[21];
    } cpu[] =
    {
        {RULE_TYPE_Pkt2CpuRule_EAPS_MASTER_REDIRECT,"EAPS_MASTER_REDIRECT"},
        {RULE_TYPE_Pkt2CpuRule_EAPS_MASTER_DROP,    "EAPS_MASTER_DROP"},
        {RULE_TYPE_Pkt2CpuRule_EAPS_TRANSIT_COPY,   "EAPS_TRANSIT_COPY"},
        {RULE_TYPE_Pkt2CpuRule_EAPS_TRANSIT_DROP,   "EAPS_TRANSIT_DROP"},
        {RULE_TYPE_Pkt2CpuRule_DOT1X_REDIRECT,      "DOT1X_REDIRECT"},
        {RULE_TYPE_Pkt2CpuRule_DOT1X_DROP_OTHER,    "DOT1X_DROP_OTHER"},
        {RULE_TYPE_Pkt2CpuRule_ARP_REPLY,           "ARP_REPLY"},
        {RULE_TYPE_Pkt2CpuRule_ALL_ARP_REPLY,       "ALL_ARP_REPLY"},
        {RULE_TYPE_Pkt2CpuRule_ARP_REQUEST,         "ARP_REQUEST"},
        {RULE_TYPE_Pkt2CpuRule_ALL_ARP_REQUEST,     "ALL_ARP_REQUEST"},
        {RULE_TYPE_Pkt2CpuRule_RIP,                 "RIP"},
        {RULE_TYPE_Pkt2CpuRule_OSPF_MAC5,           "OSPF_MAC5"},
        {RULE_TYPE_Pkt2CpuRule_OSPF_MAC6,           "OSPF_MAC6"},
        {RULE_TYPE_Pkt2CpuRule_OSPF_OTHERS,         "OSPF_OTHERS"},
#if (SYS_CPNT_OSPF6 == TRUE)
        {RULE_TYPE_Pkt2CpuRule_OSPF6_MAC5,          "OSPF6_MAC5"},
        {RULE_TYPE_Pkt2CpuRule_OSPF6_MAC6,          "OSPF6_MAC6"},
        {RULE_TYPE_Pkt2CpuRule_OSPF6_HELLO,         "OSPF6_HELLO"},
        {RULE_TYPE_Pkt2CpuRule_OSPF6_OTHER,         "OSPF6_OTHER"},
#endif /* SYS_CPNT_OSPF6 */
        {RULE_TYPE_Pkt2CpuRule_DVMRP,               "DVMRP"},
        {RULE_TYPE_Pkt2CpuRule_PIM,                 "PIM"},
        {RULE_TYPE_Pkt2CpuRule_VRRP,                "VRRP"},
        {RULE_TYPE_Pkt2CpuRule_RIPNG,               "RIPNG"},
        {RULE_TYPE_Pkt2CpuRule_RESERVED_UDP,        "RESERVED_UDP"},
        {RULE_TYPE_Pkt2CpuRule_IPV6_MC,             "IPV6_MC"},
        {RULE_TYPE_Pkt2CpuRule_UNKNOWN_IPMC,        "UNKNOWN_IPMC"},
        {RULE_TYPE_Pkt2CpuRule_UNKNOWN_L2MC,        "UNKNOWN_L2MC"},
        {RULE_TYPE_Pkt2CpuRule_IP_BCAST,            "IP_BCAST"},
        {RULE_TYPE_Pkt2CpuRule_L2_SLF,              "L2_SLF"},
        {RULE_TYPE_Pkt2CpuRule_CFM_CONTROL,         "CFM_CONTROL"},
        {RULE_TYPE_Pkt2CpuRule_L2PT,                "L2PT"},
        {RULE_TYPE_Pkt2CpuRule_CDP,                 "CDP"},
        {RULE_TYPE_Pkt2CpuRule_PVST,                "PVST"},
        {RULE_TYPE_Pkt2CpuRule_ORG_SPECIFIC1,       "ORG_SPECIFIC1"},
        {RULE_TYPE_Pkt2CpuRule_ORG_SPECIFIC2,       "ORG_SPECIFIC2"},
        {RULE_TYPE_Pkt2CpuRule_ORG_SPECIFIC3,       "ORG_SPECIFIC3"},
        {RULE_TYPE_Pkt2CpuRule_ALL_HOST,            "ALL_HOST"},
        {RULE_TYPE_Pkt2CpuRule_ALL_ROUTER,          "ALL_ROUTER"},
        {RULE_TYPE_Pkt2CpuRule_MY_MAC_MY_IP,        "MY_MAC_MY_IP"},
        {RULE_TYPE_Pkt2CpuRule_IP_OPTION,           "IP_OPTION"},
        {RULE_TYPE_Pkt2CpuRule_SLF,                 "SLF"},
        {RULE_TYPE_Pkt2CpuRule_IGMP,                "IGMP"},
        {RULE_TYPE_Pkt2CpuRule_DHCP_CLIENT,         "DHCP_CLIENT"},
        {RULE_TYPE_Pkt2CpuRule_DHCP_SERVER,         "DHCP_SERVER"},
        {RULE_TYPE_Pkt2CpuRule_HBT,                 "HBT"},
        {RULE_TYPE_Pkt2CpuRule_BPDU,                "BPDU"},
        {RULE_TYPE_Pkt2CpuRule_L2CP,                "L2CP"},
        {RULE_TYPE_Pkt2CpuRule_ORG_SPECIFIC,        "ORG_SPECIFIC"},
        {RULE_TYPE_Pkt2CpuRule_IPV6_ALL_NODES,      "IPV6_ALL_NODES"},
        {RULE_TYPE_Pkt2CpuRule_IPV6_ALL_ROUTERS,    "IPV6_ALL_ROUTERS"},
        {RULE_TYPE_Pkt2CpuRule_UNKNOWN_IPV6MC,      "UNKNOWN_IPV6MC"},
        {RULE_TYPE_Pkt2CpuRule_DHCP6_CLIENT,        "DHCP6_CLIENT"},
        {RULE_TYPE_Pkt2CpuRule_DHCP6_SERVER,        "DHCP6_SERVER"},
        {RULE_TYPE_Pkt2CpuRule_LinkLocal,           "LinkLocal"},
        {RULE_TYPE_Pkt2CpuRule_PIM6,                "PIM6"},
    };

    RULE_CTRL_EnterCriticalSection();

    BACKDOOR_MGR_Printf("\r\n");
    BACKDOOR_MGR_Printf("CPU interface via FP\r\n");
    {
        int device_id, i;

        RULE_TYPE_PRINT("type                 [device_id|rule_id]\r\n");
        RULE_TYPE_PRINT("-------------------- ---------------------------------\r\n");

        for (i = 0; i < _countof(cpu); ++i)
        {
            BOOL_T has_rule = FALSE;

            RULE_TYPE_PRINT("%-20s", cpu[i].rule_name);

            for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT; ++device_id)
            {
                if (TRUE == shmem_data_p->cpu_rule[device_id][cpu[i].rule_type].is_enabled)
                {
                    has_rule = TRUE;
                    RULE_TYPE_PRINT(" [%lu|%5lu]",
                                    device_id,
                                    shmem_data_p->cpu_rule[device_id][cpu[i].rule_type].dev_rule_id);
                }
            }

            RULE_TYPE_PRINT("%s\r\n", (has_rule) ? "" : " na");
        }
    }

#if (SYS_CPNT_DAI_RATE_LIMIT_BY_RULE == TRUE)
    RULE_TYPE_PRINT("\r\n== ARP rate limit ==\r\n");
    {
        int unit, port;

        for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++unit)
        {
            for (port = 1; port <= SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT; ++port)
            {
                if (shmem_data_p->arp[unit-1][port-1].rule_storage.is_enable)
                {
                    RULE_TYPE_CounterRec_T cnt_rec;

                    memset(&cnt_rec, 0, sizeof(cnt_rec));

                    RULE_TYPE_PRINT("%lu/%-2lu: rate=%lu/pps, dev_rule_id=%lu",
                           unit, port, shmem_data_p->arp[unit-1][port-1].meter_rate,
                           shmem_data_p->arp[unit-1][port-1].rule_storage.rule_id);

                    if (RULE_TYPE_OK == 
                        RULE_CTRL_DAI_GetArpPacketCounterByUport(unit, port, &cnt_rec))
                    {
                        RULE_TYPE_PRINT(" counter=%lu", cnt_rec.total_packets);
                    }

                    RULE_TYPE_PRINT("\r\n");
                }
            }
        }
    }
#endif /* SYS_CPNT_DAI_RATE_LIMIT_BY_RULE */
    RULE_CTRL_LeaveCriticalSection();
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Backdoor_DiffServ_DumpClassInstance
 *------------------------------------------------------------------------------
 * PURPOSE  : show class instance
 * INPUT    : class_instance
 * OUTPUT   : none
 * RETURN   : none
 * NOTE     : for debug
 *------------------------------------------------------------------------------
 */
void
RULE_CTRL_Backdoor_DiffServ_DumpClassInstance(
    const RULE_TYPE_CLASS_INSTANCE_PTR_T class_instance)
{
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T           class_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T rule_inst_iter;
    RULE_TYPE_INSTANCE_PTR_T                    rule_inst_p;
    BOOL_T                                      show_title = TRUE;

    if (NULL == class_instance)
        return;

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_instance, &class_inst_obj);
    class_inst_obj.get_element_iterator(&class_inst_obj, &rule_inst_iter);

    BACKDOOR_MGR_Printf("\r\n");

    BACKDOOR_MGR_Printf("       << class instance >>\r\n");
    BACKDOOR_MGR_Printf("   class template: type=");
          RULE_CTRL_Backdoor_DiffServ_ShowClassType(class_instance->super.type);
    BACKDOOR_MGR_Printf(" id=%u\r\n", class_instance->id);
    BACKDOOR_MGR_Printf("        rule num : %lu\r\n", rule_inst_iter.count(&rule_inst_iter));

#if (SYS_CPNT_TIME_BASED_ACL == TRUE)
    BACKDOOR_MGR_Printf("time_range_index : %lu\r\n" , class_instance->time_range_index);
#endif /*#if (SYS_CPNT_TIME_BASED_ACL == TRUE)*/

#if (SYS_CPNT_ACL_COUNTER == TRUE)
    BACKDOOR_MGR_Printf("  counter enable : %s\r\n" , RULE_TYPE_COUNTER_ENABLE_STR(class_instance->counter_enable));
#endif /* #if (SYS_CPNT_ACL_COUNTER == TRUE) */

    for (rule_inst_iter.first(&rule_inst_iter);
         NULL != rule_inst_iter.get_instance(&rule_inst_iter);
         rule_inst_iter.next(&rule_inst_iter))
    {
        rule_inst_p = rule_inst_iter.get_instance(&rule_inst_iter);

        switch (rule_inst_p->type)
        {
            case RULE_TYPE_INST_POLICY_MAP:
            case RULE_TYPE_INST_CLASS_MAP:
            case RULE_TYPE_INST_MF_ACE:
            case RULE_TYPE_INST_ACL:
                RULE_CTRL_Backdoor_DiffServ_DumpClassInstance(
                                   (RULE_TYPE_CLASS_INSTANCE_PTR_T)rule_inst_p);
                break;

            case RULE_TYPE_INST_RULE:
                RULE_CTRL_Backdoor_DiffServ_DumpRuleInstance(show_title,
                                    (RULE_TYPE_RULE_INSTANCE_PTR_T)rule_inst_p);
                show_title = FALSE;
                break;

            default:
                ASSERT(0);
                break;
        }
    }

}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Backdoor_DiffServ_DumpRuleInstance
 *------------------------------------------------------------------------------
 * PURPOSE  : show rule instance
 * INPUT    : show_title, rule_instance
 * OUTPUT   : none
 * RETURN   : none
 * NOTE     : for debug
 *------------------------------------------------------------------------------
 */
void
RULE_CTRL_Backdoor_DiffServ_DumpRuleInstance(
    BOOL_T show_title,
    const RULE_TYPE_RULE_INSTANCE_PTR_T rule_instance)
{
    const char title_str[] = "rule      meter     action    ace \r\n";
    const char edge_line[] = "--------- --------- --------- ---------\r\n";
    const char data_fmt[] = "%9u%10u%10u%10u\r\n";

    if (TRUE == show_title)
    {
        BACKDOOR_MGR_Printf((char *)title_str);
        BACKDOOR_MGR_Printf((char *)edge_line);
    }

    if (NULL == rule_instance)
        return;

    BACKDOOR_MGR_Printf((char *)data_fmt, rule_instance->dev_rule_info.rule_id, rule_instance->meter_id,
                        rule_instance->action_id, rule_instance->ace_id);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Backdoor_DiffServ_ShowClassType
 *------------------------------------------------------------------------------
 * PURPOSE  : show class type
 * INPUT    : class_type
 * OUTPUT   : none
 * RETURN   : none
 * NOTE     : for debug
 *------------------------------------------------------------------------------
 */
void
RULE_CTRL_Backdoor_DiffServ_ShowClassType(
    RULE_TYPE_INSTANCE_TYPE_T inst_type)
{
    BACKDOOR_MGR_Printf("%s",
                        (RULE_TYPE_INST_POLICY_MAP == inst_type) ? "Policy-Map" :
                        (RULE_TYPE_INST_CLASS_MAP == inst_type) ? "Class-Map" :
                        (RULE_TYPE_INST_MF_ACE == inst_type) ? "MF" :
                        (RULE_TYPE_INST_ACL == inst_type) ? "ACL" :
                        (RULE_TYPE_INST_RULE == inst_type) ? "ACE" :
                        "unknown");
}
#endif /* end of L4_SUPPORT_ACCTON_BACKDOOR == TRUE */


/* LOCAL SUBPROGRAM BODIES */

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalInitialize
 *------------------------------------------------------------------------------
 * PURPOSE  : initialize local unit driver
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_LocalInitialize()
{
    RULE_CTRL_ResourceInfo_T        *res_info_p;
    FP_CONFIG_FunctionInfo_T        *fun_info_p;
    FP_CONFIG_GroupInfo_T           *ctrl_group;
    DEVRM_GroupEntry_T              rm_group;
    UI32_T                          device_id, index, unit;
    UI32_T                          soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    UI32_T                          group_total_rule[SYS_ADPT_FP_MAX_NBR_OF_GROUP_PER_CHIP];

    RULE_CTRL_EnterCriticalSection();

    memset(shmem_data_p, 0, sizeof(RULE_CTRL_ShmemData_T));
    memset(group_total_rule, 0, sizeof(group_total_rule));

    /* Create selector group
     */
    for (index = 0; index < FP_CONFIG_NumberOfGroup(); ++index)
    {
        ctrl_group = FP_CONFIG_get_group_info_by_id(index);
        if(NULL == ctrl_group)
        {
            LOG("Error ! FP_CONFIG_get_group_info_by_id(%lu)", index);
            goto fail_return;
        }

        if(ctrl_group->is_created == TRUE)
        {
            continue;
        }

        /* create group
         */
        rm_group.group_id = ctrl_group->group_id;
        rm_group.group_mode = ctrl_group->group_mode;
        rm_group.selector_bitmap= ctrl_group->selector_bitmap;
        memcpy(rm_group.w, ctrl_group->w, sizeof(rm_group.w));
        memcpy(rm_group.udf, ctrl_group->udf, sizeof(rm_group.udf));

        for (device_id = 0; device_id < soc_ndev; device_id++)
        {
            if (FALSE == DEVRM_PMGR_CheckSoc(device_id))
            {
                RULE_CTRL_PRINT("Error ! DEVRM_PMGR_CheckSoc(%lu)", device_id);
                goto fail_return;
            }

            if(FALSE == DEVRM_PMGR_CreateGroup(device_id, &rm_group))
            {
                RULE_CTRL_PRINT("Error ! DEVRM_PMGR_CreateGroup, index=%lu, group_id=%lu",
                    index, rm_group.group_id);
                goto fail_return;
            }

            memcpy(ctrl_group->udf, rm_group.udf, sizeof(ctrl_group->udf));

            {
                UI32_T max_nbr_of_slice = SYS_ADPT_FP_MAX_NBR_OF_RULE_PER_SELECTOR;

#ifdef SYS_ADPT_FP_MAX_NBR_OF_RULE_PER_EGRESS_SELECTOR
                if (ctrl_group->selector_stage == DEVRM_STAGE_EFP)
                {
                    max_nbr_of_slice = SYS_ADPT_FP_MAX_NBR_OF_RULE_PER_EGRESS_SELECTOR;
                }
#endif /* SYS_ADPT_FP_MAX_NBR_OF_RULE_PER_EGRESS_SELECTOR */

                
                switch(ctrl_group->group_mode)
                {
                    case DEVRM_GROUP_MODE_SINGLE:
                        group_total_rule[ctrl_group->group_id] = ctrl_group->selector_count * max_nbr_of_slice;
                        break;
                    case DEVRM_GROUP_MODE_DOUBLE:
                        group_total_rule[ctrl_group->group_id] = (ctrl_group->selector_count * max_nbr_of_slice)/2;
                        break;
                    default:
                        RULE_CTRL_PRINT("Invalid slice wide mode!\n");
                        goto fail_return;
                }
            }

            for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++unit)
            {
                res_info_p = RULE_CTRL_GetResourceInfo(unit, device_id, ctrl_group->group_id);
                if (NULL == res_info_p)
                {
                    RULE_CTRL_PRINT("Error ! RULE_CTRL_GetResourceInfo(unit=%lu, device=%lu, group_id=%lu)",
                        unit, device_id, ctrl_group->group_id);
                    goto fail_return;
                }

                res_info_p->free_rule = res_info_p->total_rule
                                      = group_total_rule[ctrl_group->group_id];
            }
        }
        ctrl_group->is_created = TRUE;
    }

    /* Init funtion resource
     */
    for (index = 0; index < FP_CONFIG_NumberOfFunctionType(); ++index)
    {
        fun_info_p = FP_CONFIG_GetFunctionInfo(index);
        if (NULL == fun_info_p)
        {
            continue;
        }

        ctrl_group = FP_CONFIG_get_group_info_by_id(fun_info_p->group_id);
        if(NULL == ctrl_group)
        {
            RULE_CTRL_PRINT("Error ! FP_CONFIG_get_group_info_by_id(%lu), index=%lu",
                fun_info_p->group_id, index);
            goto fail_return;
        }

        if(ctrl_group->is_created == FALSE)
        {
            continue;
        }

        for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++unit)
        {
            for (device_id = 0; device_id < soc_ndev; device_id++)
            {
                if (FALSE == RULE_CTRL_AddRuleQuota(unit, device_id,
                                                    ctrl_group->group_id,
                                                    group_total_rule[ctrl_group->group_id],
                                                    fun_info_p->function_type,
                                                    fun_info_p->rule_quota))
                {
                    RULE_CTRL_PRINT("Error ! RULE_CTRL_AddRuleQuota("
                                    "unit=%lu, device_id=%lu, group_id=%lu, "
                                    "group_total_rule=%lu, fun_type=%d, rule_quota=%lu)",
                                    unit, device_id, ctrl_group->group_id,
                                    group_total_rule[ctrl_group->group_id],
                                    fun_info_p->function_type, fun_info_p->rule_quota)
                    goto fail_return;
                }

                res_info_p = RULE_CTRL_GetResourceInfo(unit, device_id, ctrl_group->group_id);
                RULE_TYPE_SET_BIT_ON(res_info_p->func_type_bmp, fun_info_p->function_type);
            }
        }
    }

    RULE_CTRL_IN_Priv_InitInstance();

    /* Create class instance for ifentry
     */
    {
        UI32_T i;

        for (i = 0; i < _countof(shmem_data_p->if_table); ++i)
        {
            RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;
            RULE_TYPE_CLASS_INSTANCE_PTR_T if_inst_p;

            if_entry_p = &shmem_data_p->if_table[i];

            if_entry_p->class_inst_ptr = RULE_CTRL_IN_Priv_CreateClassInstance(RULE_TYPE_INST_ACL);
            ASSERT(RULE_TYPE_NIL != if_entry_p->class_inst_ptr.type);

            if_inst_p = RULE_CTRL_IN_Ptr2Instance(if_entry_p->class_inst_ptr);
            if_inst_p->id = 0xffff;
            if_inst_p->fun_type = RULE_TYPE_FUNCTION_TYPE_MAX;

#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)
            if_inst_p->remap_fun_type = RULE_TYPE_FUNCTION_TYPE_MAX;
#endif /* SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT */
        }
    }

    RULE_CTRL_CreateVirtualGroup();

#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)
    RULE_CTRL_InitFunTypeFreeTable();
#endif /* SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT */

    RULE_CTRL_LeaveCriticalSection();
    return TRUE;

fail_return:
    RULE_CTRL_LeaveCriticalSection();
    return FALSE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_CreateVirtualGroup
 *------------------------------------------------------------------------------
 * PURPOSE  : Create virtual group on device
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_CreateVirtualGroup()
{
    FP_CONFIG_STRUCT_T  *fp_config_p;
    UI32_T i;
    UI32_T j;
    BOOL_T ret;

    for (i = 0; i < FP_CONFIG_GetConfigSize(); ++i)
    {
        fp_config_p = FP_CONFIG_GetConfig(i);
        if (NULL == fp_config_p)
        {
            RULE_CTRL_PRINT("FP_CONFIG_GetConfig(%lu) failed", i);
            continue;
        }

        for (j = 0; j < fp_config_p->func_vector.count; ++j)
        {
            ret = DEVRM_PMGR_CreateVirtualGroup(fp_config_p->group_id,
                fp_config_p->func_vector.fd[j].func_type,
                fp_config_p->func_vector.fd[j].rule_pri);

            if (FALSE == ret)
            {
                RULE_CTRL_PRINT("DEVRM_CreateVirtualGroup(group_id=%lu, func_type=%d, pri=%d) failed",
                    fp_config_p->group_id,
                    fp_config_p->func_vector.fd[j].func_type,
                    fp_config_p->func_vector.fd[j].rule_pri);
                return FALSE;
            }
        }
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_UpdateDevInfo
 *------------------------------------------------------------------------------
 * PURPOSE:  Update device information
 * INPUT:    None
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:     Invoke when unit received a enter master mode, a hot insertion,
 *           and hot removal event
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_UpdateDevInfo()
{
    UI32_T  unit = 0;

    memset(shmem_data_p->dev_info, 0, sizeof(shmem_data_p->dev_info));

    while (STKTPLG_POM_GetNextDriverUnit(&unit))
    {
        if (FALSE == RULE_CTRL_GetDevInfo(unit, &shmem_data_p->dev_info[unit-1]))
        {
            RULE_CTRL_LOG("RULE_CTRL_GetDevInfo failed on unit(%lu)", unit);
        }

        RULE_CTRL_LOG("dev_info[%lu].num_of_chips=%lu", unit-1, shmem_data_p->dev_info[unit-1].num_of_chips);
        RULE_CTRL_LOG("dev_info[%lu].port_bit_map.all_ports = 0x%08x%08x \r\n", unit-1,
                         shmem_data_p->dev_info[unit-1].port_bit_map.all_ports.pbits[1],
                         shmem_data_p->dev_info[unit-1].port_bit_map.all_ports.pbits[0]);
        RULE_CTRL_LOG("dev_info[%lu].port_bit_map.cpu_port  = 0x%08x%08x \r\n", unit-1,
                         shmem_data_p->dev_info[unit-1].port_bit_map.cpu_port.pbits[1],
                         shmem_data_p->dev_info[unit-1].port_bit_map.cpu_port.pbits[0]);
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalIsNeedToConfigCpuRule
 *------------------------------------------------------------------------------
 * PURPOSE:  need to config chip or not
 * INPUT:    enable_flag, packet_type
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:     to avoid add an existed rule or remove a non-existed rule
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_LocalIsNeedToConfigCpuRule(
    BOOL_T enable_flag,
    RULE_TYPE_PacketType_T packet_type)
{
    BOOL_T  force_ignore = FALSE;
    BOOL_T  force_update = FALSE;
    BOOL_T  rule_existed = FALSE;

    RULE_CTRL_EnterCriticalSection();
    switch (packet_type)
    {
        /* always let driver update these rules.
         */
        case RULE_TYPE_PacketType_DHCP_CLIENT:
        case RULE_TYPE_PacketType_DHCP_SERVER:
        case RULE_TYPE_PacketType_SLF:
        case RULE_TYPE_PacketType_EAPS:
        case RULE_TYPE_PacketType_UNKNOWN_IPMC:
        case RULE_TYPE_PacketType_ARP_REQUEST:
        case RULE_TYPE_PacketType_ARP_REPLY:
        case RULE_TYPE_PacketType_UNKNOWN_IPV6MC:
        case RULE_TYPE_PacketType_L2PT:
            force_update = TRUE;
            break;

        /* MAC ACL */
        case RULE_TYPE_PacketType_DOT1X:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_DOT1X_REDIRECT].is_enabled;
            break;
        case RULE_TYPE_PacketType_RIP:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_RIP].is_enabled;
            break;
        case RULE_TYPE_PacketType_OSPF:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_OSPF_MAC5].is_enabled;
            break;
#if (SYS_CPNT_OSPF6 == TRUE)
        /* added by steven.gao for OSPFv3 */
        case RULE_TYPE_PacketType_OSPF6:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_OSPF6_OTHER].is_enabled;
            break;
#endif
        case RULE_TYPE_PacketType_PIM:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_PIM].is_enabled;
            break;
        case RULE_TYPE_PacketType_VRRP:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_VRRP].is_enabled;
            break;
        case RULE_TYPE_PacketType_IP_BCAST:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_IP_BCAST].is_enabled;
            break;
        case RULE_TYPE_PacketType_L2_SLF:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_L2_SLF].is_enabled;
            break;
        case RULE_TYPE_PacketType_ALL_HOST:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_ALL_HOST].is_enabled;
            break;
        case RULE_TYPE_PacketType_ALL_ROUTER:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_ALL_ROUTER].is_enabled;
            break;
        case RULE_TYPE_PacketType_MY_MAC_MY_IP:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_MY_MAC_MY_IP].is_enabled;
            break;
        case RULE_TYPE_PacketType_IP_OPTION:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_IP_OPTION].is_enabled;
            break;
        case RULE_TYPE_PacketType_HBT:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_HBT].is_enabled;
            break;
        case RULE_TYPE_PacketType_BPDU:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_BPDU].is_enabled;
            break;
        case RULE_TYPE_PacketType_L2CP:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_L2CP].is_enabled;
            break;
        case RULE_TYPE_PacketType_ORG_SPECIFIC:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_ORG_SPECIFIC].is_enabled;
            break;

#if (SYS_CPNT_CFM == TRUE)
        case RULE_TYPE_PacketType_CFM:
            rule_existed =  shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_CFM_CONTROL].is_enabled;
            break;
#endif
        case RULE_TYPE_PacketType_CDP:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_CDP].is_enabled;
            break;
        case RULE_TYPE_PacketType_PVST:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_PVST].is_enabled;
            break;
        case RULE_TYPE_PacketType_IPV6_ALL_NODES:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_IPV6_ALL_NODES].is_enabled;
            break;
        case RULE_TYPE_PacketType_IPV6_ALL_ROUTERS:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_IPV6_ALL_ROUTERS].is_enabled;
            break;

        case RULE_TYPE_PacketType_PIM6:
            rule_existed = shmem_data_p->cpu_rule[0][RULE_TYPE_Pkt2CpuRule_PIM6].is_enabled;
            break;

        default:
            force_ignore = TRUE;
    }
    RULE_CTRL_LeaveCriticalSection();

    /* the priority of force_ignore is higher than force_update
     */
    return (!force_ignore &&
                (force_update || (rule_existed != enable_flag)));
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalTrapPacket2Cpu
 *------------------------------------------------------------------------------
 * PURPOSE:  trap specified packet to CPU on local unit
 * INPUT:    enable_flag, packet_type, rule_info
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_LocalTrapPacket2Cpu(
    BOOL_T enable_flag,
    RULE_TYPE_PacketType_T packet_type,
    RULE_TYPE_CpuRuleInfo_T *rule_info)
{
    BOOL_T ret = FALSE;

    if(RULE_TYPE_PacketType_MAX < packet_type)
        return ret;

    RULE_CTRL_EnterCriticalSection();
    switch (packet_type)
    {
        /* MAC ACL */
        case RULE_TYPE_PacketType_EAPS:
            if(NULL == rule_info)
            {
                RULE_CTRL_LeaveCriticalSection();
                return ret;
            }
            else
            {
                ret = RULE_CTRL_TrapEapsToCPU(enable_flag, rule_info->eaps.vid, rule_info->eaps.mode);
            }
            break;

        case RULE_TYPE_PacketType_ARP_REQUEST:
            if (NULL == rule_info)
            {
                ret = RULE_CTRL_CopyArpRequestToCPU(enable_flag);
            }
            else if (rule_info->arp.all_arp_to_cpu) /* DAI enable */
            {
                /* Destroy old rule */
                ret = RULE_CTRL_CopyArpRequestToCPU(FALSE);
                ret = RULE_CTRL_TrapAllArpRequestToCPU(TRUE);
            }
            else if (!rule_info->arp.all_arp_to_cpu) /* DAI disable */
            {
                /* Destroy old rule */
                ret = RULE_CTRL_TrapAllArpRequestToCPU(FALSE);
                ret = RULE_CTRL_CopyArpRequestToCPU(TRUE);
            }
            break;
        case RULE_TYPE_PacketType_ARP_REPLY:
            if ( NULL == rule_info )
            {
                ret = RULE_CTRL_CopyArpReplyToCPU(enable_flag);
            }
            else if (rule_info->arp.all_arp_to_cpu)  /* DAI enable */
            {
                /* Destroy old rule */
                ret = RULE_CTRL_CopyArpReplyToCPU(FALSE);
                ret = RULE_CTRL_TrapAllArpReplyToCPU(TRUE);
            }
            else if (!rule_info->arp.all_arp_to_cpu) /* DAI disable */
            {
                /* Destroy old rule */
                ret = RULE_CTRL_TrapAllArpReplyToCPU(FALSE);
                ret = RULE_CTRL_CopyArpReplyToCPU(TRUE);
            }
            break;
        case RULE_TYPE_PacketType_RIP:
            ret = RULE_CTRL_TrapRipToCPU(enable_flag);
            break;
        case RULE_TYPE_PacketType_OSPF:
            ret = RULE_CTRL_TrapOspfToCPU(enable_flag);
            break;
#if (SYS_CPNT_OSPF6 == TRUE)
        /* added by steven.gao for OSPFv3 */
        case RULE_TYPE_PacketType_OSPF6:
            ret = RULE_CTRL_TrapOspf6ToCPU(enable_flag);
            break;
#endif
        case RULE_TYPE_PacketType_PIM:
            ret = RULE_CTRL_TrapPimToCPU(enable_flag);
            break;
        case RULE_TYPE_PacketType_VRRP:
            ret = RULE_CTRL_TrapVrrpToCPU(enable_flag);
            break;
        case RULE_TYPE_PacketType_UNKNOWN_IPMC:
            if(NULL == rule_info)
            {
                RULE_CTRL_LeaveCriticalSection();
                return ret;
            }
            else
            {
                ret = RULE_CTRL_TrapUnknownIpMcastToCPU(enable_flag, rule_info->common.to_cpu, rule_info->common.flood);
            }
            break;
        case RULE_TYPE_PacketType_IP_BCAST:
            ret = RULE_CTRL_TrapIpBcastToCPU(enable_flag);
            break;
        case RULE_TYPE_PacketType_L2_SLF:
            ret = RULE_CTRL_ModifyCpuQueueForL2Slf(enable_flag);
            break;
#if (SYS_CPNT_QINQ_L2PT == TRUE)
#if (SYS_CPNT_QINQ_L2PT_DA_REMARK == TRUE)
        case RULE_TYPE_PacketType_L2PT:
            if(NULL == rule_info)
            {
                RULE_CTRL_LeaveCriticalSection();
                return ret;
            }
            ret = RULE_CTRL_TrapL2ptTunnelPduToCPU(enable_flag, rule_info->l2pt.mac);
            break;
#endif
#endif
        case RULE_TYPE_PacketType_CDP:
            ret = RULE_CTRL_TrapCdpToCPU(enable_flag);
            break;
        case RULE_TYPE_PacketType_PVST:
            ret = RULE_CTRL_TrapPvstToCPU(enable_flag);
            break;
        case RULE_TYPE_PacketType_ALL_HOST:
            ret = RULE_CTRL_TrapAllHostToCPU(enable_flag);
            break;
        case RULE_TYPE_PacketType_ALL_ROUTER:
            ret = RULE_CTRL_TrapAllRouterToCPU(enable_flag);
            break;
        case RULE_TYPE_PacketType_MY_MAC_MY_IP:
            ret = RULE_CTRL_TrapMyMacMyIpToCPU(enable_flag);
            break;
        case RULE_TYPE_PacketType_IP_OPTION:
            ret = RULE_CTRL_TrapIpOptionToCPU(enable_flag);
            break;
        case RULE_TYPE_PacketType_SLF:
            if(NULL == rule_info)
            {
                RULE_CTRL_LeaveCriticalSection();
                return ret;
            }
            else
            {
                ret = RULE_CTRL_TrapSlfToCPU(enable_flag, rule_info->slf.slf_vid, rule_info->slf.action);
            }
            break;

        case RULE_TYPE_PacketType_DHCP_CLIENT:
            if(NULL == rule_info)
            {
                RULE_CTRL_LeaveCriticalSection();
                return ret;
            }
            else
            {
                ret = RULE_CTRL_TrapDhcpClientPacketToCPU(enable_flag, rule_info->common.to_cpu, rule_info->common.flood);
            }
            break;

        case RULE_TYPE_PacketType_DHCP_SERVER:
            if(NULL == rule_info)
            {
                RULE_CTRL_LeaveCriticalSection();
                return ret;
            }
            else
            {
                ret = RULE_CTRL_TrapDhcpServerPacketToCPU(enable_flag,rule_info->common.to_cpu, rule_info->common.flood);
            }
            break;
        case RULE_TYPE_PacketType_HBT:
            ret = RULE_CTRL_TrapHbtWorkAroundToCPU(enable_flag);
            break;
        case RULE_TYPE_PacketType_BPDU:
            ret = RULE_CTRL_ModifyCpuQueueForBpdu(enable_flag);
            break;
        case RULE_TYPE_PacketType_L2CP:
            ret = RULE_CTRL_ModifyCpuQueueForL2cp(enable_flag);
            break;
        case RULE_TYPE_PacketType_ORG_SPECIFIC:
            ret = RULE_CTRL_TrapOrgSpecificToCPU(enable_flag);
            break;
#if (SYS_CPNT_CFM == TRUE)
        case RULE_TYPE_PacketType_CFM:
            ret = RULE_CTRL_TrapCfmCtrlPktToCpu(enable_flag);
            break;
#endif
        case RULE_TYPE_PacketType_IPV6_ALL_NODES:
            ret = RULE_CTRL_TrapIpv6AllNodesToCPU(enable_flag);
            break;
        case RULE_TYPE_PacketType_IPV6_ALL_ROUTERS:
            ret = RULE_CTRL_TrapIpv6AllRoutersToCPU(enable_flag);
            break;

        case RULE_TYPE_PacketType_UNKNOWN_IPV6MC:
            if(NULL == rule_info)
            {
                RULE_CTRL_LeaveCriticalSection();
                return ret;
            }
            else
            {
                ret = RULE_CTRL_TrapUnknownIpv6McastToCPU(enable_flag, rule_info->common.to_cpu, rule_info->common.flood);
            }
            break;

        case RULE_TYPE_PacketType_PIM6:
            ret = RULE_CTRL_TrapPim6ToCPU(enable_flag);
            break;

        default:
            break;
    }
    RULE_CTRL_LeaveCriticalSection();

    return ret;
}

#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
static BOOL_T RULE_CTRL_Slave_TrapPacket2Cpu(ISC_Key_T *key, RULE_CTRL_IscBuf_T *ptr)
{
    BOOL_T status = TRUE;

    if(FALSE == RULE_CTRL_LocalTrapPacket2Cpu(ptr->CPUINFO.enable_flag, ptr->CPUINFO.packet_type, &(ptr->CPUINFO.rule_info)))
    {
        status = FALSE;
    }

    return status;
}
#endif /* #if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE)) */

#if 0
/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapDot1xToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap dot1x eap packet to CPU, and drop other packet.
 * INPUT    : cpu_mac
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------*/
static BOOL_T RULE_CTRL_TrapDot1xToCPU(BOOL_T enable, UI32_T ifindex, const UI8_T *cpu_mac)
{
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    DEVRM_PBMP_T                          port_bitmap;
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_DEFAULT, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);

    DEVRM_PBMP_CLEAR(ace_entry.inports_data);
    DEVRM_PBMP_PORT_ADD(port_bitmap, ifindex - 1);
    DEVRM_PBMP_OR(ace_entry.inports_data, port_bitmap);
    ace_entry.inports_mask.pbits[0] = (RULE_CTRL_PORT_BITMAP_TO_ALL_PORTS & 0x00000000ffffffffLL);
    ace_entry.inports_mask.pbits[1] = ((RULE_CTRL_PORT_BITMAP_TO_ALL_PORTS & 0xffffffff00000000LL) >> 32);

    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_EAP);
    RULE_CTRL_SET_FILTER_DA(ace_entry, cpu_mac);


    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_DOT1X);
    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(action_entry[1]);
    action_entry[0].next_action = &action_entry[1];

    /* config chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_DOT1X_REDIRECT, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_DOT1X_REDIRECT, enable, rule_index))
            return FALSE;
    }

    /* drop other packets */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);

    DEVRM_PBMP_CLEAR(ace_entry.inports_data);
    DEVRM_PBMP_PORT_ADD(port_bitmap, ifindex - 1);
    DEVRM_PBMP_OR(ace_entry.inports_data, port_bitmap);
    ace_entry.inports_mask.pbits[0] = (RULE_CTRL_PORT_BITMAP_TO_ALL_PORTS & 0x00000000ffffffffLL);
    ace_entry.inports_mask.pbits[1] = ((RULE_CTRL_PORT_BITMAP_TO_ALL_PORTS & 0xffffffff00000000LL) >> 32);

    /* setup action */
    RULE_CTRL_SET_ACTION_DROP(action_entry[0]);
    action_entry[0].next_action = NULL;

    /* config chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_DOT1X_DROP_OTHER, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_DOT1X_DROP_OTHER, enable, rule_index))
            return FALSE;
    }

    return ret;
}
#endif

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapRipToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap rip packet to CPU
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------*/
static BOOL_T RULE_CTRL_TrapRipToCPU(BOOL_T enable)
{
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_DEFAULT, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_L4DstPort);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_IPV4);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(ace_entry, RULE_CTRL_PROT_UDP);
    RULE_CTRL_SET_FILTER_DPORT(ace_entry, 520);


    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_RIP);
    RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[1]);
    action_entry[0].next_action = &action_entry[1];

    /* config chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_RIP, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_RIP, enable, rule_index))
            return FALSE;
    }

    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapOspfToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap ospf packet to CPU
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------*/
static BOOL_T RULE_CTRL_TrapOspfToCPU(BOOL_T enable)
{
    const UI8_T                         ospf_mc_mac5[SYS_ADPT_MAC_ADDR_LEN] = {0x01, 0x00, 0x5e, 0x00, 0x00, 0x05};
    const UI8_T                         ospf_mc_mac6[SYS_ADPT_MAC_ADDR_LEN] = {0x01, 0x00, 0x5e, 0x00, 0x00, 0x06};
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;


    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_DEFAULT, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_DA(ace_entry, ospf_mc_mac5);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_IPV4);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(ace_entry, RULE_CTRL_PROT_OSPFIGP);

    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_OSPF);
    RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[1]);
    action_entry[0].next_action = &action_entry[1];

    /* config mac5 to chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_OSPF_MAC5, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_OSPF_MAC5, enable, rule_index))
            return FALSE;
    }

    /* config mac6 to chip
     */
    RULE_CTRL_SET_FILTER_DA(ace_entry, ospf_mc_mac6);
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_OSPF_MAC6, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_OSPF_MAC6, enable, rule_index))
            return FALSE;
    }

    /* config rule for other OSPF packets to chip */
    memset(ace_entry.dstmac_data, 0, SYS_ADPT_MAC_ADDR_LEN);
    memset(ace_entry.dstmac_mask, 0, SYS_ADPT_MAC_ADDR_LEN);
    DEVRM_SHR_BITCLR(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_OSPF_OTHERS, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_OSPF_OTHERS, enable, rule_index))
            return FALSE;
    }

    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapPimToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap pim packet to CPU
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------*/
static BOOL_T RULE_CTRL_TrapPimToCPU(BOOL_T enable)
{
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_DEFAULT, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_Ttl);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_IPV4);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(ace_entry, RULE_CTRL_PROT_PIM);
    RULE_CTRL_SET_FILTER_TTL(ace_entry, 1);

    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_PIM);
    RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[1]);
    action_entry[0].next_action = &action_entry[1];

    /* config chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_PIM, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_PIM, enable, rule_index))
            return FALSE;
    }

    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapVrrpToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap vrrp packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------*/
static BOOL_T RULE_CTRL_TrapVrrpToCPU(BOOL_T enable)
{
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_DEFAULT, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_IPV4);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(ace_entry, RULE_CTRL_PROT_VRRP);

    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_VRRP);
    RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[1]);
    action_entry[0].next_action = &action_entry[1];

    /* config chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_VRRP, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_VRRP, enable, rule_index))
            return FALSE;
    }

    return ret;
}


/* added by steven.gao for OSPFv3 */
#if (SYS_CPNT_OSPF6 == TRUE)

/******************************************************************************
 * FUNCTION NAME - RULE_CTRL_TrapOspf6ToCPU
 * PURPOSE  :
 *        Configure the rules in the chip to trap OSPFv3 packet to CPU
 * ARGs     :
 *      1. enable:      enable/disable status
 *
 * RETURN   :
 *
 * NOTES    :
 *
 ******************************************************************************/
static BOOL_T RULE_CTRL_TrapOspf6ToCPU(BOOL_T enable)
{
    const UI8_T             ospf6_mac5[SYS_ADPT_MAC_ADDR_LEN] = {0x33, 0x33, 0x00, 0x00, 0x00, 0x05};
    const UI8_T             ospf6_mac6[SYS_ADPT_MAC_ADDR_LEN] = {0x33, 0x33, 0x00, 0x00, 0x00, 0x06};
    UI32_T                  device_id;
    BOOL_T                  ret = TRUE, is_enabled = FALSE;
    UI32_T                  group_id, rule_index;
    int                     rule_pri;
    DEVRM_AceEntry_T        ace_entry;
    DEVRM_ActionEntry_T     action_entry[2];
    UI32_T                  soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T    fun_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_DEFAULT, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_IPV6);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(ace_entry, RULE_CTRL_PROT_OSPFIGP);

    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_OSPF);
    RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[1]);
    action_entry[0].next_action = &action_entry[1];

    /* config mac5 to chip */
    RULE_CTRL_SET_FILTER_DA(ace_entry, ospf6_mac5);
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_OSPF6_MAC5, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                                    &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_OSPF6_MAC5, enable, rule_index))
            return FALSE;
    }

    /* config mac6 to chip */
    RULE_CTRL_SET_FILTER_DA(ace_entry, ospf6_mac6);
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_OSPF6_MAC6, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                            &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_OSPF6_MAC6, enable, rule_index))
            return FALSE;
    }

    /* config rule for other OSPFv3 packets to chip */
    memset(ace_entry.dstmac_data, 0, SYS_ADPT_MAC_ADDR_LEN);
    memset(ace_entry.dstmac_mask, 0, SYS_ADPT_MAC_ADDR_LEN);
    DEVRM_SHR_BITCLR(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_OSPF6_OTHER, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                                &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_OSPF6_OTHER, enable, rule_index))
            return FALSE;
    }

    return ret;
}

#endif


/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapIpBcastToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap ip broadcast packet to CPU
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapIpBcastToCPU(BOOL_T enable)
{
    UI8_T                               mac_bcast[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_PRIO_6;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_PRIO_6, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_IPV4);
    RULE_CTRL_SET_FILTER_DA(ace_entry, mac_bcast);

    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_IP_BCAST);
    RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[1]);
    action_entry[0].next_action = &action_entry[1];

    /* config chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_IP_BCAST, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_IP_BCAST, enable, rule_index))
            return FALSE;
    }
    return ret;
}

#if (SYS_CPNT_IGMPSNP == TRUE && SYS_CPNT_IGMPSNP_RESERVE_ADDRESS_PACKET_CHIP_TRAP_TO_CPU_BUT_NOT_FORWARD == FALSE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_IGMPSNP_DO_CancelReservedMulticastToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : cancel trap igmp reserved ipv4 multicast packet to CPU
 * INPUT    : param_p
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_IGMPSNP_DO_CancelReservedMulticastToCPU(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI8_T mcast_addr[] = {0x01, 0x00, 0x5E, 0x00, 0x00, 0x00};
    UI8_T mcast_mask[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00};
    UI32_T dip_addr = L_STDLIB_Hton32(0xe0000000); /* 224.0.0.0 */
    UI32_T dip_mask = L_STDLIB_Hton32(0xffffff00); /* 255.255.255.0 */

    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_PRIO_6;
    param_p->sys_rule_storage_p = &shmem_data_p->igmpsnp_reserved.rule_storage;

    RULE_CTRL_MakeParamTag(param_p, "igmpsnp", "reserved", "igmpsnp-reserved", NULL);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(param_p->ace_entry);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(param_p->ace_entry, RULE_CTRL_ETHER_TYPE_IPV4);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    RULE_CTRL_SET_FILTER_DA_MASK(param_p->ace_entry, mcast_addr, mcast_mask);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstIp);
    RULE_CTRL_SET_FILTER_DIP_MASK(param_p->ace_entry, dip_addr, dip_mask);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IngressStpState);
    RULE_CTRL_SET_FILTER_ING_STP_STATE(param_p->ace_entry, STG_FORWORDING);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_L2DestHit);
    RULE_CTRL_SET_FILTER_L2_DST_HIT(param_p->ace_entry, 0, 1);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_L3DestHostHit);
    RULE_CTRL_SET_FILTER_L3_DSTHOST_HIT(param_p->ace_entry, 0, 1);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);
    RULE_CTRL_SET_FILTER_HIG_PACKET(param_p->ace_entry, 0, 0xff);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(param_p->ace_entry, RULE_CTRL_PROT_UDP);

    RULE_CTRL_SET_ACTION_SWITCH_TO_CPU_CANCEL(param_p->action_entries[0]);

    return TRUE;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_IGMPSNP_CancelReservedMulticastToCPU
 * ---------------------------------------------------------------------
 * PURPOSE  : cancel trap igmp reserved ipv4 multicast packet to CPU
 * INPUT    : enable - TRUE: cancel trap
 *                     FALSE: trap
 * OUTPUT   : none
 * RETURN   : TRUE/FALSE
 * NOTES    : none
 * ---------------------------------------------------------------------
*/
static BOOL_T RULE_CTRL_IGMPSNP_CancelReservedMulticastToCPU(
    BOOL_T enable)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s", enable ? "enabled" : "disable");

    RULE_CTRL_InitParam(&param);

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    param.flags        |= RULE_CTRL_OPT_ALL_DEVICES;

   return _rule_ctrl_set_rule(&param, RULE_CTRL_IGMPSNP_DO_CancelReservedMulticastToCPU);
}
#endif /* SYS_CPNT_IGMPSNP && !SYS_CPNT_IGMPSNP_RESERVE_ADDRESS_PACKET_CHIP_TRAP_TO_CPU_BUT_NOT_FORWARD */

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapUnknownIpMcastToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap unknown ip multicast packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapUnknownIpMcastToCPU(BOOL_T enable, BOOL_T to_cpu, BOOL_T flood)
{
    UI8_T                               mcast_addr[6] = {0x01, 0x00, 0x5E, 0x00, 0x00, 0x00};
    UI8_T                               mcast_mask[6] = {0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00};
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index, action;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_PRIO_6;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_PRIO_6, &group_id, &rule_pri))
        return FALSE;

    if ((FALSE == to_cpu) && (FALSE == flood))
      action = RULE_CTRL_ACTION_DROP;
    else if ((FALSE == to_cpu) && flood)
      action = RULE_CTRL_ACTION_FLOOD;
    else if (to_cpu && (FALSE == flood))
      action = RULE_CTRL_ACTION_TRAP_TO_CPU;
    else
      action = RULE_CTRL_ACTION_TRAP_AND_FLOOD;


    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_IngressStpState);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_L2DestHit);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_L3DestHostHit);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_IPV4);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(ace_entry, RULE_CTRL_PROT_UDP);
    RULE_CTRL_SET_FILTER_DA_MASK(ace_entry, mcast_addr, mcast_mask);
    RULE_CTRL_SET_FILTER_ING_STP_STATE(ace_entry, STG_FORWORDING);
    RULE_CTRL_SET_FILTER_L2_DST_HIT(ace_entry, 0, 1);
    RULE_CTRL_SET_FILTER_L3_DSTHOST_HIT(ace_entry, 0, 1);

    /* setup action */
    switch(action)
    {
        case RULE_CTRL_ACTION_DROP:
            RULE_CTRL_SET_ACTION_DROP(action_entry[0]);
            action_entry[0].next_action = NULL;
            break;
        case RULE_CTRL_ACTION_FLOOD:
            RULE_CTRL_SET_ACTION_EGRESS_MASK(action_entry[0], RULE_CTRL_PORT_BITMAP_TO_CPU_ONLY);/*not work*/
            RULE_CTRL_SET_ACTION_COPY_TO_CPU_CANCEL(action_entry[1]);/*drop packet which is flooded to CPU by PFM.*/
            action_entry[0].next_action = &action_entry[1];
            break;
        case RULE_CTRL_ACTION_TRAP_TO_CPU:
            RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_UNKNOW_IPMC);
            RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(action_entry[1]);
            action_entry[0].next_action = &action_entry[1];
            break;
        case RULE_CTRL_ACTION_TRAP_AND_FLOOD:
            RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_UNKNOW_IPMC);
            RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[1]);
            action_entry[0].next_action = &action_entry[1];
            break;
        default:
            return FALSE;
    }


    /* remove existed rule first. */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_UNKNOWN_IPMC, &is_enabled, &rule_index))
            return FALSE;

        if(enable)
        {
            if(is_enabled)/*1)update rule*/
            {
                ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
                ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
                ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                            &ace_entry, NULL, &action_entry[0], FALSE);
                RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
            }
            else/*2)add rule*/
            {
                ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
                ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                            &ace_entry, NULL, &action_entry[0], FALSE);
                RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
            }
        }
        if(!enable)
        {
            if(is_enabled)/*3)delete rule*/
            {
                ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
            }
            else/*4)should not go here*/
                return TRUE;
        }


        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_UNKNOWN_IPMC, enable, rule_index))
            return FALSE;
    }


    return ret;
}

/* 2008-07-21, Jinfeng Chen:
    Will use it later.
 */
#if 0
/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapUnknownIpMcastToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap unknown ip multicast packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapUnknownL2McastToCPU(BOOL_T enable)
{
    UI8_T                               mcast_addr[6] = {0x01, 0x00, 0x00, 0x00, 0x00, 0x00};
    UI8_T                               mcast_mask[6] = {0xFF, 0x00, 0x00, 0x00, 0x00, 0x00};
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index, action;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_LOW, &group_id, &rule_pri))
        return FALSE;


    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_IngressStpState);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_L2DestHit);

    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_DA_MASK(ace_entry, mcast_addr, mcast_mask);
    RULE_CTRL_SET_FILTER_ING_STP_STATE(ace_entry, STG_FORWORDING);
    RULE_CTRL_SET_FILTER_L2_DST_HIT(ace_entry, 0, 1);

    /* setup action */
    RULE_CTRL_SET_ACTION_DROP(action_entry[0]);
    action_entry[0].next_action = NULL;

    /* remove existed rule first. */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_UNKNOWN_L2MC, &is_enabled, &rule_index))
            return FALSE;

        if(enable)
        {
            if(is_enabled)/*1)update rule*/
            {
                ret &= DEVRM_PMGR_DestroyRule(device_id, rule_index);
                ret &= DEVRM_PMGR_AllocateRule(device_id, group_id, rule_pri, &rule_index);
                ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                            &ace_entry, NULL, &action_entry[0], FALSE);
            }
            else/*2)add rule*/
            {
                ret &= DEVRM_PMGR_AllocateRule(device_id, group_id, rule_pri, &rule_index);
                ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                            &ace_entry, NULL, &action_entry[0], FALSE);
            }
        }
        if(!enable)
        {
            if(is_enabled)/*3)delete rule*/
            {
                ret &= DEVRM_PMGR_DestroyRule(device_id, rule_index);
            }
            else/*4)should not go here*/
                return TRUE;
        }


        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_UNKNOWN_L2MC, enable, rule_index))
            return FALSE;
    }


    return ret;
}
#endif

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapIpOptionToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap ipv4 packet with option to CPU
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapIpOptionToCPU(BOOL_T enable)
{
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_PRIO_4;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_PRIO_4, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    /* 2008-07-04, Jinfeng Chen:
        The following operation will be done at below
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_IpType);
     */
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_IPV4);
    RULE_CTRL_ADD_FILTER_IPTYPE((&ace_entry), bcmFieldIpTypeIpv4WithOpts)

    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_IP_OPTION);
    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(action_entry[1]);
    action_entry[0].next_action = &action_entry[1];

    /* config chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_IP_OPTION, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_IP_OPTION, enable, rule_index))
            return FALSE;
    }

    return ret;
}


/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapCdpToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap CDP packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapCdpToCPU(BOOL_T enable)
{
    static UI8_T                        cdp_da[SYS_ADPT_MAC_ADDR_LEN] = {0x01, 0x00, 0x0c, 0xcc, 0xcc, 0xcc};

    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_DEFAULT, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);

    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_DA(ace_entry, cdp_da);

    /* setup action */
    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(action_entry[0]);

#if (RULE_CTRL_ADD_CLASS_ID_FOR_EVERY_RULE == TRUE)
    RULE_CTRL_SET_ACTION_NEW_CLASS_ID(action_entry[1], RULE_CTRL_NEW_CLASS_ID_FOR_GLOBAL_SPVID);
    action_entry[0].next_action = &action_entry[1];
#endif

    /* config every switch chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_CDP, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == ret || FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_CDP, enable, rule_index))
            return FALSE;
    }

    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapPvstToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap PVST packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapPvstToCPU(BOOL_T enable)
{
    static UI8_T                        cdp_da[SYS_ADPT_MAC_ADDR_LEN] = {0x01, 0x00, 0x0c, 0xcc, 0xcc, 0xcd};

    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_DEFAULT, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);

    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_DA(ace_entry, cdp_da);

    /* setup action */
    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(action_entry[0]);

#if (RULE_CTRL_ADD_CLASS_ID_FOR_EVERY_RULE == TRUE)
    RULE_CTRL_SET_ACTION_NEW_CLASS_ID(action_entry[1], RULE_CTRL_NEW_CLASS_ID_FOR_GLOBAL_SPVID);
    action_entry[0].next_action = &action_entry[1];
#endif

    /* config every switch chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_PVST, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == ret || FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_PVST, enable, rule_index))
            return FALSE;
    }

    return ret;
}


/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapAllHostToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap all host packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapAllHostToCPU(BOOL_T enable)
{
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;
    UI32_T                              dip_addr = L_STDLIB_Hton32(0xe0000001); /* 224.0.0.1 */

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_DEFAULT, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstIp);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_IPV4);
    RULE_CTRL_SET_FILTER_DIP(ace_entry, dip_addr);

    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_ALL_HOST);
    RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[1]);
    action_entry[0].next_action = &action_entry[1];

    /* config chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_ALL_HOST, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_ALL_HOST, enable, rule_index))
            return FALSE;
    }

    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapMyMacMyIpToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap my_mac/my_ip packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapMyMacMyIpToCPU(BOOL_T enable)
{
    /* MyMac + MyIp(exclude Link-Local): use L2table with L3 bit on + host route table
     *                                   --> match L2table and host route table redirect to CPU
     * MyIp(Link-Local): Use RULE_CTRL_IP6_TrapLinkLocalToCPU()
     * So this function is not needed now
     */
    return TRUE;

#if 0
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_DEFAULT, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstPortTgid);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_IngressStpState);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_L3DestHostHit);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_DSTPORTTGID(ace_entry, SYS_ADPT_RULE_CTRL_PHY_NUM_OF_CPU_PORT);
    RULE_CTRL_SET_FILTER_ING_STP_STATE(ace_entry, STG_FORWORDING);
    RULE_CTRL_SET_FILTER_L3_DSTHOST_HIT(ace_entry, 1, 1);

    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    ace_entry.dstmac_mask[0] = 0x01;
    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_MYMAC_MYIP);
    RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[1]);
    action_entry[0].next_action = &action_entry[1];

    /* config chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_MY_MAC_MY_IP, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= DEVRM_PMGR_AllocateRule(device_id, group_id, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
        }
        else
        {
            ret &= DEVRM_PMGR_DestroyRule(device_id, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_MY_MAC_MY_IP, enable, rule_index))
            return FALSE;
    }

    return ret;
#endif
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_ModifyCpuQueueForL2Slf
 *------------------------------------------------------------------------------
 * PURPOSE  : when l2 slf packet is trapped to cpu, set its priority to be 1.
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_ModifyCpuQueueForL2Slf(BOOL_T enable)
{
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry;
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_LOW;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_LOW, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_IngressStpState);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_L2SrcHit);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_ING_STP_STATE(ace_entry, STG_FORWORDING);
    RULE_CTRL_SET_FILTER_L2_SRC_HIT(ace_entry, 0, 1);

    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry, SYS_ADPT_CPU_QUEUE_L2_SLF);


    /* config chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_L2_SLF, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry, FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_L2_SLF, enable, rule_index))
            return FALSE;
    }

    return ret;
}


/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapAllRouterToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap all router packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapAllRouterToCPU(BOOL_T enable)
{
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;
    UI32_T                              dip_addr = L_STDLIB_Hton32(0xe0000002); /* 224.0.0.2 */

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_DEFAULT, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstIp);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_IPV4);
    RULE_CTRL_SET_FILTER_DIP(ace_entry, dip_addr);

    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_ALL_ROUTER);
    RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[1]);
    action_entry[0].next_action = &action_entry[1];

    /* config chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_ALL_ROUTER, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_ALL_ROUTER, enable, rule_index))
            return FALSE;
    }

    return ret;
}

#if 0
/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapDhcpToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap default DHCP packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapDhcpToCPU(BOOL_T enable)
{
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_PRIO_4;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_PRIO_4, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_L4SrcPort);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_L4DstPort);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_IPV4);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(ace_entry, RULE_CTRL_PROT_UDP);
    RULE_CTRL_SET_FILTER_DPORT(ace_entry, DHCP_SERVER_PORT);
    RULE_CTRL_SET_FILTER_SPORT(ace_entry, DHCP_CLIENT_PORT);

    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_DHCP);
    RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[1]);
    action_entry[0].next_action = &action_entry[1];

    /* add client rule */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_DHCP_CLIENT, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_DHCP_CLIENT, enable, rule_index))
            return FALSE;
    }

    /* add server rule */
    RULE_CTRL_SET_FILTER_DPORT(ace_entry, DHCP_CLIENT_PORT);
    RULE_CTRL_SET_FILTER_SPORT(ace_entry, DHCP_SERVER_PORT);
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_DHCP_SERVER, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_DHCP_SERVER, enable, rule_index))
            return FALSE;
    }
    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapDhcpSnoopingToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap DHCP snooping packet to CPU
 * INPUT    : enable, vid
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapDhcpSnoopingToCPU(BOOL_T enable/*, UI32_T vid*/)
{
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;

    /*fuzhimin,20090505, need trap dhcp pkt per vlan?*/

    /*if (vid <= 0 || vid > 4096)
    {
        LOG("\r\n Invalid vlan id!");
        return FALSE;
    }*/

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_DEFAULT, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    /*DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_OuterVlan);*//*fuzhimin,20090505*/
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_L4SrcPort);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_L4DstPort);

    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_IPV4);
    /*RULE_CTRL_SET_FILTER_OUTERVLAN(ace_entry, vid);*//*fuzhimin,20090505*/
    RULE_CTRL_SET_FILTER_IPPROTOCOL(ace_entry, RULE_CTRL_PROT_UDP);
    RULE_CTRL_SET_FILTER_DPORT(ace_entry, DHCP_SERVER_PORT);
    RULE_CTRL_SET_FILTER_SPORT(ace_entry, DHCP_CLIENT_PORT);

    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_DHCP);

    /* Use copy to CPU + drip to replace redirect CPU, becuase CPU
     * port does not join to all VLAN, so the action
     * bcmFieldActionRedirectPbmp was not working
     * (RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU).
     */
    RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[1]);
    action_entry[0].next_action = &action_entry[1];
    RULE_CTRL_SET_ACTION_DROP(action_entry[1]);

    /* config client rule */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        /*if(FALSE == RULE_CTRL_GetDhcpSnoopingRule(device_id, vid, TRUE, &rule_index))
            return FALSE;*/
        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_DHCP_CLIENT_REDIRECT, &is_enabled, &rule_index))
            return FALSE;

        if((is_enabled = ((rule_index)? TRUE : FALSE))  == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
            rule_index = 0;
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_DHCP_CLIENT_REDIRECT, enable, rule_index))
            return FALSE;
    }

    RULE_CTRL_SET_FILTER_DPORT(ace_entry, DHCP_CLIENT_PORT);
    RULE_CTRL_SET_FILTER_SPORT(ace_entry, DHCP_SERVER_PORT);

    /* config server rule */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_DHCP_SERVER_REDIRECT, &is_enabled, &rule_index))
            return FALSE;

        if((is_enabled = ((rule_index)? TRUE : FALSE))  == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
            rule_index = 0;
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_DHCP_SERVER_REDIRECT, enable, rule_index))
            return FALSE;
    }

    return ret;
}
#endif /* 0 */

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapDhcpClientPacketToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap DHCP client packet to CPU
 * INPUT    : enable
 *            to_cpu
 *            flood
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapDhcpClientPacketToCPU(BOOL_T enable, BOOL_T to_cpu, BOOL_T flood)
{
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[3];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    UI8_T                               action = RULE_CTRL_ACTION_DROP;
    BOOL_T                              is_enabled = FALSE;
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_PRIO_4, &group_id, &rule_pri))
        return FALSE;

    if ((FALSE == to_cpu) && (FALSE == flood))
      action = RULE_CTRL_ACTION_DROP;
    else if ((FALSE == to_cpu) && flood)
      action = RULE_CTRL_ACTION_FLOOD;
    else if (to_cpu && (FALSE == flood))
      action = RULE_CTRL_ACTION_TRAP_TO_CPU;
    else
      action = RULE_CTRL_ACTION_TRAP_AND_FLOOD;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_L4SrcPort);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_L4DstPort);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_IPV4);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(ace_entry, RULE_CTRL_PROT_UDP);

    RULE_CTRL_SET_FILTER_DPORT(ace_entry, DHCP_SERVER_PORT);


    /* setup action */
    switch(action)
    {
        case RULE_CTRL_ACTION_DROP:
            RULE_CTRL_SET_ACTION_DROP(action_entry[0]);
            action_entry[0].next_action = NULL;
            break;
        case RULE_CTRL_ACTION_TRAP_TO_CPU:
            RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_DHCP);
			RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[1]);
            action_entry[0].next_action = &action_entry[1];
			RULE_CTRL_SET_ACTION_DROP(action_entry[2]);
			action_entry[1].next_action = &action_entry[2];
            break;
        case RULE_CTRL_ACTION_TRAP_AND_FLOOD:
            RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_DHCP);
            RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[1]);
            action_entry[0].next_action = &action_entry[1];
            break;
        case RULE_CTRL_ACTION_FLOOD:
            RULE_CTRL_SET_ACTION_EGRESS_MASK(action_entry[0], RULE_CTRL_PORT_BITMAP_TO_CPU_ONLY);/*not work*/
            RULE_CTRL_SET_ACTION_COPY_TO_CPU_CANCEL(action_entry[1]);/*drop packet which is flooded to CPU by PFM.*/
            action_entry[0].next_action = &action_entry[1];
            break;
        default:
            return FALSE;
    }

    /* remove existed rule first. */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_DHCP_CLIENT, &is_enabled, &rule_index))
            return FALSE;

        if(enable)
        {
            /* add & update rule
             */
            if(is_enabled)
            {
                ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type,rule_index);
            }

            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type,rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                                      &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            if (!is_enabled)
            {
                return TRUE;
            }

            /* delete rule
             */
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_DHCP_CLIENT, enable, rule_index))
            return FALSE;
    }

    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapDhcpServerPacketToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap DHCP server packet to CPU
 * INPUT    : enable
 *            to_cpu
 *            flood
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapDhcpServerPacketToCPU(BOOL_T enable,BOOL_T to_cpu, BOOL_T flood)
{
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[3];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    UI8_T                               action = RULE_CTRL_ACTION_DROP;
    BOOL_T                              is_enabled = FALSE;
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_PRIO_4, &group_id, &rule_pri))
        return FALSE;

    if ((FALSE == to_cpu) && (FALSE == flood))
      action = RULE_CTRL_ACTION_DROP;
    else if ((FALSE == to_cpu) && flood)
      action = RULE_CTRL_ACTION_FLOOD;
    else if (to_cpu && (FALSE == flood))
      action = RULE_CTRL_ACTION_TRAP_TO_CPU;
    else
      action = RULE_CTRL_ACTION_TRAP_AND_FLOOD;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_L4SrcPort);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_L4DstPort);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_IPV4);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(ace_entry, RULE_CTRL_PROT_UDP);

    RULE_CTRL_SET_FILTER_DPORT(ace_entry, DHCP_CLIENT_PORT);


    /* setup action */
    switch(action)
    {
        case RULE_CTRL_ACTION_DROP:
            RULE_CTRL_SET_ACTION_DROP(action_entry[0]);
            action_entry[0].next_action = NULL;
            break;
        case RULE_CTRL_ACTION_TRAP_TO_CPU:
            RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_DHCP);
			RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[1]);
            action_entry[0].next_action = &action_entry[1];
			RULE_CTRL_SET_ACTION_DROP(action_entry[2]);
			action_entry[1].next_action = &action_entry[2];
            break;
        case RULE_CTRL_ACTION_TRAP_AND_FLOOD:
            RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_DHCP);
            RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[1]);
            action_entry[0].next_action = &action_entry[1];
            break;
        case RULE_CTRL_ACTION_FLOOD:
            RULE_CTRL_SET_ACTION_EGRESS_MASK(action_entry[0], RULE_CTRL_PORT_BITMAP_TO_CPU_ONLY);/*not work*/
            RULE_CTRL_SET_ACTION_COPY_TO_CPU_CANCEL(action_entry[1]);/*drop packet which is flooded to CPU by PFM.*/
            action_entry[0].next_action = &action_entry[1];
            break;
        default:
            return FALSE;
    }


    /* remove existed rule first. */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_DHCP_SERVER, &is_enabled, &rule_index))
            return FALSE;

        if(enable)
        {
            /* add & update rule
             */
            if(is_enabled)
            {
                ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type,rule_index);
            }

            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type,rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                                      &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            if (!is_enabled)
            {
                return TRUE;
            }

            /* delete rule
             */
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_DHCP_SERVER, enable, rule_index))
            return FALSE;
    }

    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapEapsToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap EAPS packet to CPU and drop other packet in the VLAN.
 * INPUT    : enable, vid, mode
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapEapsToCPU(BOOL_T enable, UI32_T vid, UI32_T mode)
{
    UI8_T                               mac_eaps[6] = {0x00, 0xe0, 0x2b, 0x00, 0x00, 0x04};
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_type, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_HIGH;

    if (vid <= 0 || vid > 4096)
    {
        LOG("\r\n Invalid vlan id!");
        return FALSE;
    }
    if((mode != SYS_ADPT_EAPS_TRANSITION_MODE)  && (mode != SYS_ADPT_EAPS_MASTER_MODE)){
        LOG("\r\n Only support master mode and Transition mode");
        return FALSE;
    }

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_HIGH, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    //DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_OuterVlan);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    //RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_OUTERVLAN(ace_entry, vid);
    RULE_CTRL_SET_FILTER_DA(ace_entry, mac_eaps);

    /* setup action */
    if(mode == SYS_ADPT_EAPS_MASTER_MODE)
    {
        RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_EAPS);
        RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(action_entry[1]);
        action_entry[0].next_action = &action_entry[1];
    }
    else
    {
        RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_EAPS);
        RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[1]);
        action_entry[0].next_action = &action_entry[1];
    }

    /* trap eaps packet to cpu */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(mode == SYS_ADPT_EAPS_MASTER_MODE)
            rule_type = RULE_TYPE_Pkt2CpuRule_EAPS_MASTER_REDIRECT;
        else
            rule_type = RULE_TYPE_Pkt2CpuRule_EAPS_TRANSIT_COPY;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, rule_type, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, rule_type, enable, rule_index))
            return FALSE;
    }

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    memset(&action_entry, 0, sizeof(action_entry));
    //DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_OuterVlan);

    //RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_OUTERVLAN(ace_entry, vid);

    /* setup action */
    RULE_CTRL_SET_ACTION_DROP(action_entry[0]);
    action_entry[0].next_action = NULL;

    /* drop other packet in the VLAN */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(mode == SYS_ADPT_EAPS_MASTER_MODE)
            rule_type = RULE_TYPE_Pkt2CpuRule_EAPS_MASTER_DROP;
        else
            rule_type = RULE_TYPE_Pkt2CpuRule_EAPS_TRANSIT_DROP;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, rule_type, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, rule_type, enable, rule_index))
            return FALSE;
    }
    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapDhcpSnoopingToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap DHCP snooping packet to CPU
 * INPUT    : enable, vid, action
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapSlfToCPU(BOOL_T enable, UI16_T vid, UI8_T action)
{
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI8_T                               old_action = 0;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[3];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_PRIO_7;

    if (vid <= 0 || vid > 4096)
    {
        LOG("\r\n Invalid vlan id!");
        return FALSE;
    }

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_PRIO_7, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_OuterVlan);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_L2SrcHit);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_OUTERVLAN(ace_entry, vid);
    RULE_CTRL_SET_FILTER_L2_SRC_HIT(ace_entry, 0, 1);


    /* setup action */
    if(SLF_REDIRECT == action)
    {
        RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_L2_SLF);
        RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[1]);
        RULE_CTRL_SET_ACTION_DROP(action_entry[2]);
        action_entry[0].next_action = &action_entry[1];
        action_entry[1].next_action = &action_entry[2];
    }
    else if(SLF_DROP== action)
    {
        RULE_CTRL_SET_ACTION_DROP(action_entry[0]);
        action_entry[0].next_action = NULL;
    }

    /* config client rule */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetSlfRule(device_id, vid, &is_enabled, &old_action, &rule_index))
            return FALSE;

        if(enable)
        {
            if(old_action == action)/*0)no change*/
                return TRUE;

            /* add & update rule
             */
            if(is_enabled)
            {
                ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
            }

            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                                      &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            if (!is_enabled)
            {
                return TRUE;
            }

            /* delete rule
             */
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetSlfRule(device_id, vid, enable, action, rule_index))
            return FALSE;
    }

    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_CopyArpReplyToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : Copy arp reply packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_CopyArpReplyToCPU(BOOL_T enable)
{
    UI32_T                   device_id;
    BOOL_T                   ret = TRUE, is_enabled = FALSE;
    UI32_T                   group_id, rule_index;
    int                      rule_pri;
    DEVRM_AceEntry_T         ace_entry;
    DEVRM_ActionEntry_T      action_entry[2];
    UI32_T                   soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T fun_type = RULE_TYPE_PACKET_TO_CPU_PRIO_3;

    LOG("%s", enable ? "Enable" : "Disable");

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_PRIO_3, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_IngressStpState);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_L2DestHit);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_ARP);
    RULE_CTRL_SET_FILTER_ING_STP_STATE(ace_entry, STG_FORWORDING);
    RULE_CTRL_SET_FILTER_L2_DST_HIT(ace_entry, 1, 1);

    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_ARP_REPLY);
    RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[1]);
    action_entry[0].next_action = &action_entry[1];

    /* config chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_ARP_REPLY, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_ARP_REPLY, enable, rule_index))
            return FALSE;
    }

    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_CopyArpRequestToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap arp request packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_CopyArpRequestToCPU(BOOL_T enable)
{
    const UI8_T               arp_req_mac[SYS_ADPT_MAC_ADDR_LEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    UI32_T                    device_id;
    BOOL_T                    ret = TRUE, is_enabled = FALSE;
    UI32_T                    group_id, rule_index;
    int                       rule_pri;
    DEVRM_AceEntry_T          ace_entry;
    DEVRM_ActionEntry_T       action_entry[2];
    UI32_T                    soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T  fun_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;

    LOG("%s", enable ? "Enable" : "Disable");

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_DEFAULT, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_ARP);
    RULE_CTRL_SET_FILTER_DA(ace_entry, arp_req_mac);

    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_ARP_REQUEST);
    RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[1]);
    action_entry[0].next_action = &action_entry[1];

    /* config chip
     */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_ARP_REQUEST, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_ARP_REQUEST, enable, rule_index))
            return FALSE;
    }

    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapAllArpReplyToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap arp reply packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapAllArpReplyToCPU(BOOL_T enable)
{
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_PRIO_4;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(fun_type, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_ARP);

    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_ARP_REPLY);
    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(action_entry[1]);
    action_entry[0].next_action = &action_entry[1];

    /* config chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_ARP_REPLY, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_ARP_REPLY, enable, rule_index))
            return FALSE;
    }


    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapAllArpRequestToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap arp request packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapAllArpRequestToCPU(BOOL_T enable)
{
    const UI8_T                         arp_req_mac[SYS_ADPT_MAC_ADDR_LEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_DEFAULT, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_ARP);
    RULE_CTRL_SET_FILTER_DA(ace_entry, arp_req_mac);

    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_ARP_REQUEST);
    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(action_entry[1]);
    action_entry[0].next_action = &action_entry[1];

    /* config chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_ARP_REQUEST, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_ARP_REQUEST, enable, rule_index))
            return FALSE;
    }

    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_IGMPSNP_DO_SetIgmpRule
 *------------------------------------------------------------------------------
 * PURPOSE  : set rule to trap/cancel igmp control packet to CPU
 * INPUT    : param_p
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_IGMPSNP_DO_SetIgmpRule(
    RULE_CTRL_PARAM_PTR param_p)
{
    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_PRIO_3;
    param_p->sys_rule_storage_p = &shmem_data_p->igmpsnp_control.rule_storage;

    RULE_CTRL_MakeParamTag(param_p, "ipv4", "igmp", "igmpsnp", "ipv4-igmp");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(param_p->ace_entry);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(param_p->ace_entry, RULE_CTRL_ETHER_TYPE_IPV4);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(param_p->ace_entry, RULE_CTRL_PROT_IGMP);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);
    RULE_CTRL_SET_FILTER_HIG_PACKET(param_p->ace_entry, 0, 0xff);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_Ttl);
    RULE_CTRL_SET_FILTER_TTL(param_p->ace_entry, 1);

    if (TRUE == param_p->igmp.to_cpu)
    {
        RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[0], SYS_ADPT_CPU_QUEUE_IGMP);
        RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(param_p->action_entries[1]);
        param_p->action_entries[0].next_action = &param_p->action_entries[1];
    }
    else
    {
        RULE_CTRL_SET_ACTION_SWITCH_TO_CPU_CANCEL(param_p->action_entries[0]);
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_IGMPSNP_SetIgmpRule
 *------------------------------------------------------------------------------
 * PURPOSE  : trap igmp query/report packet to CPU
 * INPUT    : enable - set rule or not
              to_cpu - TRUE : trap igmp control packet to CPU
                       FALSE : cancel trap igmp control packet to CPU
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_IGMPSNP_SetIgmpRule(BOOL_T enable, BOOL_T to_cpu)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s", enable ? "enabled" : "disable");

    RULE_CTRL_InitParam(&param);

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    param.flags        |= RULE_CTRL_OPT_ALL_DEVICES;

    param.igmp.to_cpu = to_cpu;

   return _rule_ctrl_set_rule(&param, RULE_CTRL_IGMPSNP_DO_SetIgmpRule);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_DO_SetOrgSpecific1Packet
 *------------------------------------------------------------------------------
 * PURPOSE  : Set rule handler for Organization Specific 1 packet
 * INPUT    : param_p
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_DO_SetOrgSpecific1Packet(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI8_T org_spec1_da[] = SYS_DFLT_ORG_SPEC1_DA;
    UI8_T cpu_mac[SYS_ADPT_MAC_ADDR_LEN];

    STKTPLG_POM_GetLocalUnitBaseMac(cpu_mac);

    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;
    param_p->sys_rule_storage_p = &shmem_data_p->org_spec1.rule_storage;

    if(param_p->flags & RULE_CTRL_OPT_INSTALL)
    {
        shmem_data_p->org_spec1.to_cpu = param_p->CPU_CTRL.to_cpu;
        shmem_data_p->org_spec1.flood  = param_p->CPU_CTRL.flood;
    }
    else
    {
        param_p->CPU_CTRL.to_cpu = shmem_data_p->org_spec1.to_cpu;
        param_p->CPU_CTRL.flood  = shmem_data_p->org_spec1.flood;
    }

    RULE_CTRL_MakeParamTag(param_p, "org", "specific1", "org-specific1", NULL);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(param_p->ace_entry);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);
    RULE_CTRL_SET_FILTER_HIG_PACKET(param_p->ace_entry, 0, 0xff);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    RULE_CTRL_SET_FILTER_DA(param_p->ace_entry, org_spec1_da);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_SrcMac);
    RULE_CTRL_SET_FILTER_SA(param_p->ace_entry, cpu_mac);

    if (param_p->CPU_CTRL.to_cpu == TRUE)
    {
        RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(param_p->action_entries[0]);
        param_p->action_entries[0].next_action = NULL;
    }
    else
    {
        RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[0]);
        param_p->action_entries[0].next_action = NULL;
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetOrgSpecific1Packet
 *------------------------------------------------------------------------------
 * PURPOSE  : Set rule for Organization Specific 1 packet
 * INPUT    : enable - Set TRUE as add rule
 *                     Set FLASE as remove
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_SetOrgSpecific1Packet(
    BOOL_T enable,
    BOOL_T to_cpu,
    BOOL_T flood)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s", enable ? "enabled" : "disable");

    RULE_CTRL_InitParam(&param);

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    param.flags        |= RULE_CTRL_OPT_ALL_DEVICES;

    param.CPU_CTRL.to_cpu = to_cpu;
    param.CPU_CTRL.flood = flood;

    return _rule_ctrl_set_rule(&param, RULE_CTRL_DO_SetOrgSpecific1Packet);
}

#if (SYS_CPNT_UDLD == TRUE)
/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_UDLD_DO_SetUdldPacket
 *------------------------------------------------------------------------------
 * PURPOSE  : Set rule for UDLP packet
 * INPUT    : param_p
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_UDLD_DO_SetUdldPacket(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI8_T org_spec2_da[] = SYS_DFLT_ORG_SPEC2_DA;

    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;
    param_p->sys_rule_storage_p = &shmem_data_p->udld.rule_storage;

    if(param_p->flags & RULE_CTRL_OPT_INSTALL)
    {
        shmem_data_p->udld.to_cpu = param_p->CPU_CTRL.to_cpu;
        shmem_data_p->udld.flood  = param_p->CPU_CTRL.flood;
    }
    else
    {
        param_p->CPU_CTRL.to_cpu = shmem_data_p->udld.to_cpu;
        param_p->CPU_CTRL.flood  = shmem_data_p->udld.flood;
    }

    RULE_CTRL_MakeParamTag(param_p, "udld", "org", "specific2", "udld-org-specific2");

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(param_p->ace_entry);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);
    RULE_CTRL_SET_FILTER_HIG_PACKET(param_p->ace_entry, 0, 0xff);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    RULE_CTRL_SET_FILTER_DA(param_p->ace_entry, org_spec2_da);

    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(param_p->action_entries[0]);

    if ((FALSE == param_p->CPU_CTRL.to_cpu) && (FALSE == param_p->CPU_CTRL.flood))
    {
        RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[0]);
        param_p->action_entries[0].next_action = NULL;
    }
    else if ((FALSE == param_p->CPU_CTRL.to_cpu) && param_p->CPU_CTRL.flood)
    {
        RULE_CTRL_SET_ACTION_EGRESS_MASK(param_p->action_entries[0], RULE_CTRL_PORT_BITMAP_TO_CPU_ONLY);/*not work*/
        RULE_CTRL_SET_ACTION_COPY_TO_CPU_CANCEL(param_p->action_entries[1]);/*drop packet which is flooded to CPU by PFM.*/
        param_p->action_entries[0].next_action = &param_p->action_entries[1];
    }
    else if (param_p->CPU_CTRL.to_cpu && (FALSE == param_p->CPU_CTRL.flood))
    {
        RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[0], SYS_ADPT_CPU_QUEUE_UDLD);
        RULE_CTRL_SET_ACTION_COPY_TO_CPU(param_p->action_entries[1]);
        param_p->action_entries[0].next_action = &param_p->action_entries[1];
        RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[2]);
        param_p->action_entries[1].next_action = &param_p->action_entries[2];
    }
    else
    {
        RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[0], SYS_ADPT_CPU_QUEUE_UDLD);
        RULE_CTRL_SET_ACTION_COPY_TO_CPU(param_p->action_entries[1]);
        param_p->action_entries[0].next_action = &param_p->action_entries[1];
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_UDLD_SetUdldPacket
 *------------------------------------------------------------------------------
 * PURPOSE  : Set rule for UDLP packet
 * INPUT    : enable - Set TRUE as add rule
 *                     Set FLASE as remove
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_UDLD_SetUdldPacket(
    BOOL_T enable,
    BOOL_T to_cpu,
    BOOL_T flood)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s", enable ? "enabled" : "disable");

    RULE_CTRL_InitParam(&param);

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    param.flags        |= RULE_CTRL_OPT_ALL_DEVICES;

    param.CPU_CTRL.to_cpu = to_cpu;
    param.CPU_CTRL.flood = flood;

    return _rule_ctrl_set_rule(&param, RULE_CTRL_UDLD_DO_SetUdldPacket);
}
#endif /* SYS_CPNT_UDLD */

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_DO_SetOrgSpecific3Packet
 *------------------------------------------------------------------------------
 * PURPOSE  : Set rule handler for Organization Specific 3 packet
 * INPUT    : param_p
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_DO_SetOrgSpecific3Packet(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI8_T org_spec3_da[] = SYS_DFLT_ORG_SPEC3_DA;

    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;
    param_p->sys_rule_storage_p = &shmem_data_p->org_spec3.rule_storage;

    if(param_p->flags & RULE_CTRL_OPT_INSTALL)
    {
        shmem_data_p->org_spec3.to_cpu = param_p->CPU_CTRL.to_cpu;
        shmem_data_p->org_spec3.flood  = param_p->CPU_CTRL.flood;
    }
    else
    {
        param_p->CPU_CTRL.to_cpu = shmem_data_p->org_spec3.to_cpu;
        param_p->CPU_CTRL.flood  = shmem_data_p->org_spec3.flood;
    }

    RULE_CTRL_MakeParamTag(param_p, "org", "specific3", "org-specific3", NULL);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(param_p->ace_entry);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);
    RULE_CTRL_SET_FILTER_HIG_PACKET(param_p->ace_entry, 0, 0xff);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    RULE_CTRL_SET_FILTER_DA(param_p->ace_entry, org_spec3_da);

    if ((param_p->CPU_CTRL.to_cpu == TRUE) && (param_p->CPU_CTRL.flood == TRUE))
    {
        RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[0],
            SYS_ADPT_CPU_QUEUE_ORG_SPECIFIC3);
        RULE_CTRL_SET_ACTION_COPY_TO_CPU(param_p->action_entries[1]);
        param_p->action_entries[0].next_action = &param_p->action_entries[1];
    }
    else if (    (param_p->CPU_CTRL.to_cpu == TRUE)
              && (param_p->CPU_CTRL.flood == FALSE)
            )
    {
        RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[0],
            SYS_ADPT_CPU_QUEUE_ORG_SPECIFIC3);
        RULE_CTRL_SET_ACTION_COPY_TO_CPU(param_p->action_entries[1]);
        param_p->action_entries[0].next_action = &param_p->action_entries[1];
        RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[2]);
        param_p->action_entries[1].next_action = &param_p->action_entries[2];
    }
    else if (    (param_p->CPU_CTRL.to_cpu == FALSE)
              && (param_p->CPU_CTRL.flood == TRUE)
            )
    {
        /*not work*/
        RULE_CTRL_SET_ACTION_EGRESS_MASK(param_p->action_entries[0],
            RULE_CTRL_PORT_BITMAP_TO_CPU_ONLY);
        /*drop packet which is flooded to CPU by PFM.*/
        RULE_CTRL_SET_ACTION_COPY_TO_CPU_CANCEL(param_p->action_entries[1]);
        param_p->action_entries[0].next_action = &param_p->action_entries[1];
    }
    else
    {
        RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[0]);
        param_p->action_entries[0].next_action = NULL;
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetOrgSpecific3Packet
 *------------------------------------------------------------------------------
 * PURPOSE  : Set rule for Organization Specific 3 packet
 * INPUT    : enable - Set TRUE as add rule
 *                     Set FLASE as remove
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_SetOrgSpecific3Packet(
    BOOL_T enable,
    BOOL_T to_cpu,
    BOOL_T flood)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s", enable ? "enabled" : "disable");

    RULE_CTRL_InitParam(&param);

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    param.flags        |= RULE_CTRL_OPT_ALL_DEVICES;

    param.CPU_CTRL.to_cpu = to_cpu;
    param.CPU_CTRL.flood = flood;

    return _rule_ctrl_set_rule(&param, RULE_CTRL_DO_SetOrgSpecific3Packet);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapHbtWorkAroundToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : Workaround OP code 0 packet priority (HBT packet shall go through queue 7)
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapHbtWorkAroundToCPU(BOOL_T enable)
{
#if (SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK > 1)
#if 1
    DEVRM_PBMP_T                        stacking_pbmp;
#else
    UI32_T                              stacking_pbmp;
#endif
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_HIGH;
    UI32_T                              dev_id, up_port, down_port;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_HIGH, &group_id, &rule_pri))
        return FALSE;

    if (STKTPLG_OM_GetStackingPortPhyDevPortId(STKTPLG_TYPE_STACKING_PORT_UP_LINK, &dev_id, &up_port) == FALSE)
    {
        LOG("Failed to get device id and phy port of uplink stacking port\n");
        return FALSE;
    }
    if (STKTPLG_OM_GetStackingPortPhyDevPortId(STKTPLG_TYPE_STACKING_PORT_DOWN_LINK, &dev_id, &down_port) == FALSE)
    {
        LOG("Failed to get device id and phy port of downlink stacking port\n");
        return FALSE;
    }

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_MHOpcode);

    /* stacking port */
#if 1
    DEVRM_PBMP_CLEAR(stacking_pbmp);
    DEVRM_PBMP_PORT_ADD(stacking_pbmp, up_port);
    DEVRM_PBMP_PORT_ADD(stacking_pbmp, down_port);
#else
    stacking_pbmp = 0;
    stacking_pbmp |= 1 << up_port;
    stacking_pbmp |= 1 << down_port;
#endif
    RULE_CTRL_SET_FILTER_IPBM(ace_entry, stacking_pbmp);
    RULE_CTRL_SET_FILTER_MHOPCODE(ace_entry, BCM_FIELD_MHOPCODE_CONTROL);

    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_STKTPLG);
    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(action_entry[1]);
    action_entry[0].next_action = &action_entry[1];

#if 0//(RULE_CTRL_ADD_CLASS_ID_FOR_EVERY_RULE == TRUE)
    RULE_CTRL_SET_ACTION_NEW_CLASS_ID(dev_ae[1], RULE_CTRL_NEW_CLASS_ID_FOR_GLOBAL_SPVID);
    dev_ae[0].next_action = &dev_ae[1];
#endif

    /* config chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_HBT, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == ret || FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_HBT, enable, rule_index))
            return FALSE;
    }

    return ret;
#else
    return TRUE;
#endif /* end of #if (SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK > 1) */
}


/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_ModifyCpuQueueForBpdu
 *------------------------------------------------------------------------------
 * PURPOSE  : BPDU is trapped to CPU by l2_user_entry, set its queue to 7.
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : for 0180c200000x, please ref bcm/esw/l2_cache.c for ptp requirement
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_ModifyCpuQueueForBpdu(BOOL_T enable)
{
    const UI8_T                         bpdu_mac[SYS_ADPT_MAC_ADDR_LEN] = {0x01, 0x80, 0xc2, 0x00, 0x00, 0x00};
    const UI8_T                         bpdu_mask[SYS_ADPT_MAC_ADDR_LEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xf0};
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry;
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_PRIO_3;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_PRIO_3, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_DA_MASK(ace_entry, bpdu_mac, bpdu_mask);

    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry, SYS_ADPT_CPU_QUEUE_BPDU);

    /* config mac5 to chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_BPDU, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry, FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_BPDU, enable, rule_index))
            return FALSE;
    }

    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_ModifyCpuQueueForL2cp
 *------------------------------------------------------------------------------
 * PURPOSE  : L2CP is trapped to CPU by l2_user_entry, set its queue to 5.
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_ModifyCpuQueueForL2cp(BOOL_T enable)
{
    const UI8_T                         l2cp_mac[SYS_ADPT_MAC_ADDR_LEN] = {0x01, 0x80, 0xc2, 0x00, 0x00, 0x00};
    const UI8_T                         l2cp_mask[SYS_ADPT_MAC_ADDR_LEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0x00};
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry;
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_DEFAULT, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_DA_MASK(ace_entry, l2cp_mac, l2cp_mask);

    /* setup action */
    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry, SYS_ADPT_CPU_QUEUE_L2CP);

    /* config mac5 to chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_L2CP, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry, FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_L2CP, enable, rule_index))
            return FALSE;
    }

    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapOrgSpecificToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap organization specific packet to CPU
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapOrgSpecificToCPU(BOOL_T enable)
{
    static UI8_T                        org_specific_da[SYS_ADPT_MAC_ADDR_LEN] = {(UI8_T)(SYS_DFLT_CLUSTER_ADDR_WORD1>>8),
                                                                                  (UI8_T)(SYS_DFLT_CLUSTER_ADDR_WORD1),
                                                                                  (UI8_T)(SYS_DFLT_CLUSTER_ADDR_WORD2>>8),
                                                                                  (UI8_T)(SYS_DFLT_CLUSTER_ADDR_WORD2),
                                                                                  (UI8_T)(SYS_DFLT_CLUSTER_ADDR_WORD3>>8),
                                                                                  (UI8_T)(SYS_DFLT_CLUSTER_ADDR_WORD3)};

    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_DEFAULT, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);

    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_DA(ace_entry, org_specific_da);

    /* setup action */
    RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[0]);

#if (RULE_CTRL_ADD_CLASS_ID_FOR_EVERY_RULE == TRUE)
    RULE_CTRL_SET_ACTION_NEW_CLASS_ID(action_entry[1], RULE_CTRL_NEW_CLASS_ID_FOR_GLOBAL_SPVID);
    action_entry[0].next_action = &action_entry[1];
#endif

    /* config every switch chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_ORG_SPECIFIC, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == ret || FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_ORG_SPECIFIC, enable, rule_index))
            return FALSE;
    }

    return ret;
}

#if (SYS_CPNT_CFM == TRUE)
/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_TrapCfmCtrlPktToCpu
 *------------------------------------------------------------------------------
 * PURPOSE : This function will enable rule redirect cfm control packet to CPU
 * INPUT   : None
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapCfmCtrlPktToCpu(BOOL_T enable)
{
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[3];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_PRIO_3;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_PRIO_3, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);

    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);

    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_CFM);

    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_L2CP);
    action_entry[0].next_action = &action_entry[1];

#if 1
    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU(action_entry[1]);
#else
    RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU2(action_entry[1], action_entry[2]);
#endif

    /* remove existed rule first. */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_CFM_CONTROL, &is_enabled, &rule_index))
            return FALSE;

        if(enable)
        {
            if(is_enabled)/*1)update rule*/
            {

                ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
                ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
                ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                            &ace_entry, NULL, &action_entry[0], FALSE);
                RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
            }
            else/*2)add rule*/
            {
                ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
                ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                            &ace_entry, NULL, &action_entry[0], FALSE);
                RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
            }
        }
        if(!enable)
        {
            if(is_enabled)/*3)delete rule*/
            {
                ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
            }
            else/*4)should not go here*/
                return TRUE;
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_CFM_CONTROL, enable, rule_index))
            return FALSE;
    }

    return ret;
}
#endif /* #if (SYS_CPNT_CFM == TRUE) */

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapIpv6AllNodesToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap IPv6 to all nodes packet to CPU
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapIpv6AllNodesToCPU(BOOL_T enable)
{
    static UI8_T                        ipv6_allnodes_addr[SYS_ADPT_MAC_ADDR_LEN] = {0x33, 0x33, 0x00, 0x00, 0x00, 0x01};
    static UI8_T                        ipv6_allnodes_mask[SYS_ADPT_MAC_ADDR_LEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_DEFAULT, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);

    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_DA_MASK(ace_entry, ipv6_allnodes_addr, ipv6_allnodes_mask);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_IPV6);

    /* setup action */
    RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[0]);

#if (RULE_CTRL_ADD_CLASS_ID_FOR_EVERY_RULE == TRUE)
    RULE_CTRL_SET_ACTION_NEW_CLASS_ID(action_entry[1], RULE_CTRL_NEW_CLASS_ID_FOR_GLOBAL_SPVID);
    action_entry[0].next_action = &action_entry[1];
#endif

    /* config every switch chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_IPV6_ALL_NODES, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == ret || FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_IPV6_ALL_NODES, enable, rule_index))
            return FALSE;
    }

    return ret;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapIpv6AllRoutersToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap IPv6 to all rounters packet to CPU
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapIpv6AllRoutersToCPU(BOOL_T enable)
{
    static UI8_T                        ipv6_allrouters_addr[SYS_ADPT_MAC_ADDR_LEN] = {0x33, 0x33, 0x00, 0x00, 0x00, 0x02};
    static UI8_T                        ipv6_allrouters_mask[SYS_ADPT_MAC_ADDR_LEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_DEFAULT;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_DEFAULT, &group_id, &rule_pri))
        return FALSE;

    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);

    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_DA_MASK(ace_entry, ipv6_allrouters_addr, ipv6_allrouters_mask);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_IPV6);

    /* setup action */
    RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[0]);

#if (RULE_CTRL_ADD_CLASS_ID_FOR_EVERY_RULE == TRUE)
    RULE_CTRL_SET_ACTION_NEW_CLASS_ID(action_entry[1], RULE_CTRL_NEW_CLASS_ID_FOR_GLOBAL_SPVID);
    action_entry[0].next_action = &action_entry[1];
#endif

    /* config every switch chip */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_IPV6_ALL_ROUTERS, &is_enabled, &rule_index))
            return FALSE;

        if(is_enabled == enable)
            return TRUE;

        if(enable)
        {
            ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
            ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                        &ace_entry, NULL, &action_entry[0], FALSE);
            RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
        }
        else
        {
            ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
        }

        if(FALSE == ret || FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_IPV6_ALL_ROUTERS, enable, rule_index))
            return FALSE;
    }

    return ret;
}

static BOOL_T RULE_CTRL_TrapPim6ToCPU(BOOL_T enable)
{
    UI8_T                               pim6_dst_addr[SYS_ADPT_IPV6_ADDR_LEN] =
        {
            0XFF, 0X02, 0X00, 0X00,
            0X00, 0X00, 0X00, 0X00,
            0X00, 0X00, 0X00, 0X00,
            0X00, 0X00, 0X00, 0X0D
        };

    RULE_TYPE_Pkt2CpuRule_T             cpu_rule_type = RULE_TYPE_Pkt2CpuRule_PIM6;

    FP_CONFIG_GroupInfo_T               *group_info;
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_ActionEntry_T                 action_entry[2];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_PIM6;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_PIM6,
                                                        &group_id,
                                                        &rule_pri))
    {
        LOG("RULE_CTRL_GetFunctionInfoByFunctionType for RULE_TYPE_PACKET_TO_CPU_PIM6 fail");
        return FALSE;
    }

    group_info = FP_CONFIG_get_group_info_by_id(group_id);


    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstIp6);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_Ip6NextHeader);

    memcpy(ace_entry.dstip6_data, pim6_dst_addr, SYS_ADPT_IPV6_ADDR_LEN);
    memset(ace_entry.dstip6_mask, 0xFF, SYS_ADPT_IPV6_ADDR_LEN);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_IP6_NEXTHEADER(ace_entry, RULE_CTRL_PROT_PIM);

    /* Use copy to CPU + drip to replace redirect CPU, becuase CPU
     * port does not join to all VLAN, so the action
     * bcmFieldActionRedirectPbmp was not working
     * (RULE_CTRL_SET_ACTION_REDIRECT_TO_CPU).
     */
    RULE_CTRL_SET_ACTION_COPY_TO_CPU(action_entry[0]);
    action_entry[0].next_action = &action_entry[1];

    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[1], SYS_ADPT_CPU_QUEUE_PIM);
    action_entry[1].next_action = NULL;

    /* remove existed rule first. */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, cpu_rule_type, &is_enabled, &rule_index))
            return FALSE;

        if(enable)
        {
            if(is_enabled)/*1)update rule*/
            {
                ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
                ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
                ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                            &ace_entry, NULL, &action_entry[0], FALSE);
                RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
            }
            else/*2)add rule*/
            {
                ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
                ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                            &ace_entry, NULL, &action_entry[0], FALSE);
                RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
            }
        }
        if(!enable)
        {
            if(is_enabled)/*3)delete rule*/
            {
                ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
            }
            else/*4)should not go here*/
                return TRUE;
        }

        if(FALSE == RULE_CTRL_SetCpuRule(device_id, cpu_rule_type, enable, rule_index)){
            return FALSE;
            }
    }

    return ret;
}


/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_TrapUnknownIpv6McastToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap unknown ipv6 multicast packet to CPU
 * INPUT    : enable
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_TrapUnknownIpv6McastToCPU(BOOL_T enable, BOOL_T to_cpu, BOOL_T flood)
{
    UI8_T                               mcast_addr[6] = {0x33, 0x33, 0x00, 0x00, 0x00, 0x00};
    UI8_T                               mcast_mask[6] = {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00};
    UI32_T                              device_id;
    BOOL_T                              ret = TRUE, is_enabled = FALSE;
    UI32_T                              group_id, rule_index, action;
    int                                 rule_pri;
    DEVRM_AceEntry_T                    ace_entry;
    DEVRM_MeterEntry_T                  meter_entry;
    DEVRM_ActionEntry_T                 action_entry[3];
    UI32_T                              soc_ndev = DEVRM_PMGR_GetNumberOfChips();
    RULE_TYPE_FunctionType_T            fun_type = RULE_TYPE_PACKET_TO_CPU_PRIO_6;

    if(FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(RULE_TYPE_PACKET_TO_CPU_PRIO_6, &group_id, &rule_pri))
        return FALSE;

    if ((FALSE == to_cpu) && (FALSE == flood))
        action = RULE_CTRL_ACTION_DROP;
    else if ((FALSE == to_cpu) && flood)
        action = RULE_CTRL_ACTION_FLOOD;
    else if (to_cpu && (FALSE == flood))
        action = RULE_CTRL_ACTION_TRAP_TO_CPU;
    else
        action = RULE_CTRL_ACTION_TRAP_AND_FLOOD;


    /* setup rule/filter */
    memset(&ace_entry, 0, sizeof(ace_entry));
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_IngressStpState);
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig);

    RULE_CTRL_SET_FILTER_HIG_PACKET(ace_entry, 0, 0xff);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(ace_entry);
    RULE_CTRL_SET_FILTER_ETHER_TYPE(ace_entry, RULE_CTRL_ETHER_TYPE_IPV6);
    RULE_CTRL_SET_FILTER_DA_MASK(ace_entry, mcast_addr, mcast_mask);
    RULE_CTRL_SET_FILTER_ING_STP_STATE(ace_entry, STG_FORWORDING);

    #if (SYS_CPNT_MULTICAST_USING_IPMC == TRUE)
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_L3DestHostHit);
    RULE_CTRL_SET_FILTER_L3_DSTHOST_HIT(ace_entry, 0, 1);
    #else
    DEVRM_SHR_BITSET(ace_entry.w, DEVRM_FIELD_QUALIFY_L2DestHit);
    RULE_CTRL_SET_FILTER_L2_DST_HIT(ace_entry, 0, 1);
    #endif

    /* setup meter */
    memset(&meter_entry, 0, sizeof(meter_entry));
    meter_entry.meter_num   = BCM_FIELD_METER_PEAK;
    meter_entry.kbits_sec   = 64; /* k_bps */
    meter_entry.kbytes_burst= SYS_DFLT_RATE_LIMIT_DFLT_BURST_KBYTES;
    meter_entry.meter_mode  = BCM_FIELD_METER_MODE_FLOW;

    /* setup action */
    switch(action)
    {
        case RULE_CTRL_ACTION_DROP:
            RULE_CTRL_SET_ACTION_DROP(action_entry[0]);
            action_entry[0].next_action = NULL;
            break;
        case RULE_CTRL_ACTION_FLOOD:
            RULE_CTRL_SET_ACTION_EGRESS_MASK(action_entry[0], RULE_CTRL_PORT_BITMAP_TO_CPU_ONLY);/*not work*/
            RULE_CTRL_SET_ACTION_COPY_TO_CPU_CANCEL(action_entry[1]);/*drop packet which is flooded to CPU by PFM.*/
            action_entry[0].next_action = &action_entry[1];
            break;

        case RULE_CTRL_ACTION_TRAP_TO_CPU:
            RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_UNKNOW_IPMC);
            memset(&action_entry[1], 0, sizeof(DEVRM_ActionEntry_T));
            action_entry[1].action = bcmFieldActionGpCopyToCpu;
            action_entry[0].next_action = &action_entry[1];

            RULE_CTRL_SET_ACTION_DROP(action_entry[2]);
            action_entry[1].next_action = &action_entry[2];
            break;

        case RULE_CTRL_ACTION_TRAP_AND_FLOOD:
            RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(action_entry[0], SYS_ADPT_CPU_QUEUE_UNKNOW_IPMC);
            memset(&action_entry[1], 0, sizeof(DEVRM_ActionEntry_T));
            action_entry[1].action = bcmFieldActionGpCopyToCpu;
            action_entry[0].next_action = &action_entry[1];
            break;

        default:
            return FALSE;
    }


    /* remove existed rule first. */
    for (device_id = 0; device_id < soc_ndev; device_id++)
    {
        if (!DEVRM_PMGR_CheckSoc(device_id))
            return FALSE;

        if(FALSE == RULE_CTRL_GetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_UNKNOWN_IPV6MC, &is_enabled, &rule_index))
            return FALSE;

        if(enable)
        {
            if(is_enabled)/*1)update rule*/
            {
                ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
                ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
                ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                            &ace_entry,
                            (to_cpu)?&meter_entry:NULL,
                            &action_entry[0], FALSE);
                RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
            }
            else/*2)add rule*/
            {
                ret &= RULE_CTRL_temp_Allocate_Rule(device_id, group_id, fun_type, rule_pri, &rule_index);
                ret &= DEVRM_PMGR_SetRule(device_id, group_id, rule_index,
                            &ace_entry,
                            (to_cpu)?&meter_entry:NULL,
                            &action_entry[0], FALSE);
                RULE_CTRL_LOG("Device ID=%lu Rule Index=%lu", device_id, rule_index);
            }
        }
        if(!enable)
        {
            if(is_enabled)/*3)delete rule*/
            {
                ret &= RULE_CTRL_temp_Destroy_Rule(device_id, group_id, fun_type, rule_index);
            }
            else/*4)should not go here*/
                return TRUE;
        }


        if(FALSE == RULE_CTRL_SetCpuRule(device_id, RULE_TYPE_Pkt2CpuRule_UNKNOWN_IPV6MC, enable, rule_index))
            return FALSE;
    }


    return ret;
}

#if (SYS_CPNT_DHCPV6 == TRUE)
/* ---------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_DHCP6_DO_TrapDHCP6ClientPacketToCPU
 * ---------------------------------------------------------------------
 * PURPOSE  : trap DHCPv6 client packet to CPU
 * INPUT    : param_p
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 * ---------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_DHCP6_DO_TrapDHCP6ClientPacketToCPU(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI8_T   action = RULE_CTRL_ACTION_FLOOD;

    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_PRIO_3;
    param_p->sys_rule_storage_p = &shmem_data_p->dhcpv6_client_cpu_rule.rule_storage;

    if(param_p->flags & RULE_CTRL_OPT_INSTALL)
    {
        shmem_data_p->dhcpv6_client_cpu_rule.to_cpu = param_p->CPU_CTRL.to_cpu;
        shmem_data_p->dhcpv6_client_cpu_rule.flood  = param_p->CPU_CTRL.flood;
    }
    else
    {
        param_p->CPU_CTRL.to_cpu = shmem_data_p->dhcpv6_client_cpu_rule.to_cpu;
        param_p->CPU_CTRL.flood  = shmem_data_p->dhcpv6_client_cpu_rule.flood;
    }

    RULE_CTRL_MakeParamTag(param_p, "ipv6", "ipv6-dhcp", "ipv6-dhcp-client", NULL);

    /* decide action */
    if ((FALSE == param_p->CPU_CTRL.to_cpu) && (FALSE == param_p->CPU_CTRL.flood))
      action = RULE_CTRL_ACTION_DROP;
    else if ((FALSE == param_p->CPU_CTRL.to_cpu) && param_p->CPU_CTRL.flood)
      action = RULE_CTRL_ACTION_FLOOD;
    else if (param_p->CPU_CTRL.to_cpu && (FALSE == param_p->CPU_CTRL.flood))
      action = RULE_CTRL_ACTION_TRAP_TO_CPU;
    else
      action = RULE_CTRL_ACTION_TRAP_AND_FLOOD;

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(param_p->ace_entry);

    RULE_CTRL_ADD_FILTER_IPTYPE((&param_p->ace_entry), bcmFieldIpTypeIpv6);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(param_p->ace_entry, RULE_CTRL_PROT_UDP);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_L4DstPort);
    RULE_CTRL_SET_FILTER_DPORT(param_p->ace_entry, DHCP6_SERVER_PORT);

    /* setup action */
    switch(action)
    {
        case RULE_CTRL_ACTION_DROP:
            RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[0]);
            param_p->action_entries[0].next_action = NULL;
            break;
        case RULE_CTRL_ACTION_TRAP_TO_CPU:
            RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[0], SYS_ADPT_CPU_QUEUE_DHCP6);
			RULE_CTRL_SET_ACTION_COPY_TO_CPU(param_p->action_entries[1]);
            param_p->action_entries[0].next_action = &param_p->action_entries[1];
			RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[2]);
			param_p->action_entries[1].next_action = &param_p->action_entries[2];
            break;
        case RULE_CTRL_ACTION_TRAP_AND_FLOOD:
            RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[0], SYS_ADPT_CPU_QUEUE_DHCP6);
            RULE_CTRL_SET_ACTION_COPY_TO_CPU(param_p->action_entries[1]);
            param_p->action_entries[0].next_action = &param_p->action_entries[1];
            break;
        case RULE_CTRL_ACTION_FLOOD:
            RULE_CTRL_SET_ACTION_EGRESS_MASK(param_p->action_entries[0], RULE_CTRL_PORT_BITMAP_TO_CPU_ONLY);/*not work*/
            RULE_CTRL_SET_ACTION_COPY_TO_CPU_CANCEL(param_p->action_entries[1]);/*drop packet which is flooded to CPU by PFM.*/
            param_p->action_entries[0].next_action = &param_p->action_entries[1];
            break;
        default:
            return FALSE;
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_DHCP6_TrapDHCP6ClientPacketToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap DHCPv6 client packet to CPU
 * INPUT    : enable
 *            to_cpu
 *            flood
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
BOOL_T
RULE_CTRL_DHCP6_TrapDHCP6ClientPacketToCPU(
  BOOL_T enable, BOOL_T to_cpu, BOOL_T flood)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s "
                  "to cpu:%s "
                  "flood :%s\r\n",
                  enable ? "enabled" : "disable",
                  to_cpu ? "TRUE":"FALSE",
                  flood  ? "TRUE":"FALSE");

    RULE_CTRL_InitParam(&param);

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    param.CPU_CTRL.to_cpu = to_cpu;
    param.CPU_CTRL.flood = flood;

    param.flags        |= RULE_CTRL_OPT_ALL_DEVICES;

   return _rule_ctrl_set_rule(&param, RULE_CTRL_DHCP6_DO_TrapDHCP6ClientPacketToCPU);

}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_DHCP6_DO_TrapDHCP6ServerPacketToCPU
 * ---------------------------------------------------------------------
 * PURPOSE  : trap DHCPv6 server packet to CPU
 * INPUT    : param_p
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 * ---------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_DHCP6_DO_TrapDHCP6ServerPacketToCPU(
  RULE_CTRL_PARAM_PTR param_p)
{
    UI8_T   action = RULE_CTRL_ACTION_FLOOD;

    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_PRIO_3;
    param_p->sys_rule_storage_p = &shmem_data_p->dhcpv6_server_cpu_rule.rule_storage;

    if(param_p->flags & RULE_CTRL_OPT_INSTALL)
    {
        shmem_data_p->dhcpv6_server_cpu_rule.to_cpu = param_p->CPU_CTRL.to_cpu;
        shmem_data_p->dhcpv6_server_cpu_rule.flood  = param_p->CPU_CTRL.flood;
    }
    else
    {
        param_p->CPU_CTRL.to_cpu = shmem_data_p->dhcpv6_server_cpu_rule.to_cpu;
        param_p->CPU_CTRL.flood  = shmem_data_p->dhcpv6_server_cpu_rule.flood;
    }

    RULE_CTRL_MakeParamTag(param_p, "ipv6", "ipv6-dhcp", "ipv6-dhcp-server", NULL);

    /* decide action */
    if ((FALSE == param_p->CPU_CTRL.to_cpu) && (FALSE == param_p->CPU_CTRL.flood))
      action = RULE_CTRL_ACTION_DROP;
    else if ((FALSE == param_p->CPU_CTRL.to_cpu) && param_p->CPU_CTRL.flood)
      action = RULE_CTRL_ACTION_FLOOD;
    else if (param_p->CPU_CTRL.to_cpu && (FALSE == param_p->CPU_CTRL.flood))
      action = RULE_CTRL_ACTION_TRAP_TO_CPU;
    else
      action = RULE_CTRL_ACTION_TRAP_AND_FLOOD;

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    RULE_CTRL_SET_FILTER_IPBM_WITH_ALL_PORTS(param_p->ace_entry);

    RULE_CTRL_ADD_FILTER_IPTYPE((&param_p->ace_entry), bcmFieldIpTypeIpv6);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol);
    RULE_CTRL_SET_FILTER_IPPROTOCOL(param_p->ace_entry, RULE_CTRL_PROT_UDP);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_L4DstPort);
    RULE_CTRL_SET_FILTER_DPORT(param_p->ace_entry, DHCP6_CLIENT_PORT);

    /* setup action */
    switch(action)
    {
        case RULE_CTRL_ACTION_DROP:
            RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[0]);
            param_p->action_entries[0].next_action = NULL;
            break;
        case RULE_CTRL_ACTION_TRAP_TO_CPU:
            RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[0], SYS_ADPT_CPU_QUEUE_DHCP6);
			RULE_CTRL_SET_ACTION_COPY_TO_CPU(param_p->action_entries[1]);
            param_p->action_entries[0].next_action = &param_p->action_entries[1];
			RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[2]);
			param_p->action_entries[1].next_action = &param_p->action_entries[2];
            break;
        case RULE_CTRL_ACTION_TRAP_AND_FLOOD:
            RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[0], SYS_ADPT_CPU_QUEUE_DHCP6);
            RULE_CTRL_SET_ACTION_COPY_TO_CPU(param_p->action_entries[1]);
            param_p->action_entries[0].next_action = &param_p->action_entries[1];
            break;
        case RULE_CTRL_ACTION_FLOOD:
            RULE_CTRL_SET_ACTION_EGRESS_MASK(param_p->action_entries[0], RULE_CTRL_PORT_BITMAP_TO_CPU_ONLY);/*not work*/
            RULE_CTRL_SET_ACTION_COPY_TO_CPU_CANCEL(param_p->action_entries[1]);/*drop packet which is flooded to CPU by PFM.*/
            param_p->action_entries[0].next_action = &param_p->action_entries[1];
            break;
        default:
            return FALSE;
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_DHCP6_TrapDHCP6ServerPacketToCPU
 *------------------------------------------------------------------------------
 * PURPOSE  : trap DHCPv6 server packet to CPU
 * INPUT    : enable
 *            to_cpu
 *            flood
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
BOOL_T
RULE_CTRL_DHCP6_TrapDHCP6ServerPacketToCPU(
  BOOL_T enable, BOOL_T to_cpu, BOOL_T flood)
{
    RULE_CTRL_PARAM param;

    RULE_CTRL_LOG("%s "
                  "to cpu:%s "
                  "flood :%s\r\n",
                  enable ? "enabled" : "disable",
                  to_cpu ? "TRUE":"FALSE",
                  flood  ? "TRUE":"FALSE");

    RULE_CTRL_InitParam(&param);

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    param.CPU_CTRL.to_cpu = to_cpu;
    param.CPU_CTRL.flood = flood;

    param.flags        |= RULE_CTRL_OPT_ALL_DEVICES;

   return _rule_ctrl_set_rule(&param, RULE_CTRL_DHCP6_DO_TrapDHCP6ServerPacketToCPU);

}
#endif /* end of (SYS_CPNT_DHCPV6 == TRUE)*/

#if (SYS_CPNT_DAI_RATE_LIMIT_BY_RULE == TRUE)
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_DAI_GetArpPacketCounterByUport(
  UI32_T unit,
  UI32_T port,
  RULE_TYPE_CounterRec_T *counter_rec_p)
{
    RULE_CTRL_RULE_STORAGE *rs_p;
    UI32_T  device_id;

    if (unit < 1 || SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK < unit)
    {
        return RULE_TYPE_INVALID_PARAMETER;
    }

    if (port < 1 || SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT < port)
    {
        return RULE_TYPE_INVALID_PARAMETER;
    }

    rs_p = &shmem_data_p->arp[unit-1][port-1].rule_storage;

    if (FALSE == rs_p->is_enable)
    {
        return RULE_TYPE_NO_MATCH;
    }

    device_id = RULE_CTRL_Priv_UPortToDeviceId(unit, port);

    if (FALSE == RULE_CTRL_GetRuleCounter(unit, device_id, rs_p->rule_id, counter_rec_p))
    {
        return RULE_TYPE_FAIL;
    }

    return RULE_TYPE_OK;
}

static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_DAI_ClearArpPacketCounterByUport(
    UI32_T unit,
    UI32_T port)
{
    RULE_CTRL_RULE_STORAGE *rs_p;
    UI32_T  device_id;

    if (unit < 1 || SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK < unit)
    {
        return RULE_TYPE_INVALID_PARAMETER;
    }

    if (port < 1 || SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT < port)
    {
        return RULE_TYPE_INVALID_PARAMETER;
    }

    rs_p = &shmem_data_p->arp[unit-1][port-1].rule_storage;

    if (FALSE == rs_p->is_enable)
    {
        return RULE_TYPE_NO_MATCH;
    }

    device_id = RULE_CTRL_Priv_UPortToDeviceId(unit, port);

    if (FALSE == RULE_CTRL_ClearRuleCounter(unit, device_id, rs_p->rule_id))
    {
        return RULE_TYPE_FAIL;
    }

    return RULE_TYPE_OK;
}

/* ---------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_DAI_DO_TrapArpPacketToCpuWithRate
 * ---------------------------------------------------------------------
 * PURPOSE  : trap ARP packet to CPU and set rate limit
 * INPUT    : param_p
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTES    : None
 * ---------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_DAI_DO_TrapArpPacketToCpuWitherRate(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T      module_id, device_id, phy_port;
    DEVRM_PBMP_T port_bit_map;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit, param_p->port,
                                                        &module_id, &device_id, &phy_port))
    {
        return FALSE;
    }

    param_p->func_type = RULE_TYPE_PACKET_TO_CPU_PRIO_3;
    param_p->rule_storage_p = &shmem_data_p->arp[param_p->unit-1][param_p->port-1].rule_storage;
    shmem_data_p->arp[param_p->unit-1][param_p->port-1].meter_rate = param_p->arp.rate;

    RULE_CTRL_MakeParamTag(param_p, "dai", "arp", "arp-rate-limit", NULL);

    DEVRM_SHR_BITSET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
    DEVRM_PBMP_CLEAR(port_bit_map);
    DEVRM_PBMP_PORT_ADD(port_bit_map, phy_port);
    RULE_CTRL_SET_FILTER_IPBM(param_p->ace_entry, port_bit_map);

    RULE_CTRL_ADD_FILTER_IPTYPE((&param_p->ace_entry), bcmFieldIpTypeArp);

    /* setup action
     */
    memset(&param_p->action_entries[0], 0, sizeof(DEVRM_ActionEntry_T));
    param_p->action_entries[0].action = bcmFieldActionGpCopyToCpu;
    param_p->action_entries[0].next_action = &param_p->action_entries[1];

    memset(&param_p->action_entries[1], 0, sizeof(DEVRM_ActionEntry_T));
    param_p->action_entries[1].action = bcmFieldActionRpSwitchToCpuCancel;
    param_p->action_entries[1].next_action = &param_p->action_entries[2];

    RULE_CTRL_SET_ACTION_DROP(param_p->action_entries[2]);
    param_p->action_entries[2].next_action = &param_p->action_entries[3];    

    RULE_CTRL_SET_ACTION_MODIFY_CPU_QUEUE(param_p->action_entries[3], SYS_ADPT_CPU_QUEUE_ARP_REQUEST);
    param_p->action_entries[3].next_action = NULL;

    /* setup meter
     */
    param_p->meter_enabled = TRUE;
    memset(&param_p->meter_entry, 0, sizeof(param_p->meter_entry));
    param_p->meter_entry.meter_num    = BCM_FIELD_METER_PEAK;
    param_p->meter_entry.kbits_sec    = param_p->arp.rate;
    param_p->meter_entry.kbytes_burst = 1;
    param_p->meter_entry.meter_mode   = BCM_FIELD_METER_MODE_FLOW;
    param_p->meter_entry.meter_type   = DEVRM_POLICER_METER_TYPE_PACKET;

    /* setup counter
     */
    param_p->counter_enabled = TRUE;

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_DAI_TrapArpPacketToCpuWithRate
 *------------------------------------------------------------------------------
 * PURPOSE  : trap ARP packet to CPU and set rate limit
 * INPUT    : enable    - TRUE:  add rule
 *                        FALSE: Delete rule.
 *            interface - interface information
 *            rate      - packet rate per second
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK / RULE_TYPE_FAIL
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_DAI_TrapArpPacketToCpuWithRate(
    BOOL_T enable,
    RULE_TYPE_INTERFACE_INFO_T *interface_p,
    UI32_T rate)
{
    RULE_CTRL_PARAM param;

    LOG_IF(*interface_p, "%s, rate = %lu", enable ? "enabled" : "disable", rate);

    RULE_CTRL_InitParam(&param);

    switch (interface_p->type)
    {
        case RULE_TYPE_INTERFACE_UPORT:
            param.unit = interface_p->uport.unit;
            param.port = interface_p->uport.port;
            break;

        case RULE_TYPE_INTERFACE_TRUNK:
            return RULE_TYPE_OK;

        default:
            return RULE_TYPE_FAIL;
    }

    if (enable)
    {
        param.flags    |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    param.arp.rate = rate;
    
    return _rule_ctrl_set_rule(&param, RULE_CTRL_DAI_DO_TrapArpPacketToCpuWitherRate);
    
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME  - RULE_CTRL_DAI_GetArpPacketCounter
 *------------------------------------------------------------------------------
 * PURPOSE  : Get the rule counter for the ARP packet trapped to CPU 
 * INPUT    : interface_p    - interface information
 *            trunk_member_p - trunk member port bit map
 *            reset          - TRUE: clear counter, FALSE: not clear
 * OUTPUT   : total_cnt_p - The total counter
 * RETURN   : RULE_TYPE_OK / RULE_TYPE_FAIL
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_DAI_GetArpPacketCounter(
    RULE_TYPE_INTERFACE_INFO_T *interface_p,
    RULE_TYPE_TRUNK_MEMBER_T *trunk_member_p,
    BOOL_T reset,
    UI32_T *total_cnt_p)
{
    if (interface_p == NULL ||
        total_cnt_p == NULL)
    {
        return RULE_TYPE_INVALID_PARAMETER;
    }

    LOG_IF(*interface_p, "Start!");

    switch (interface_p->type)
    {
        case RULE_TYPE_INTERFACE_UPORT:
        {
            RULE_TYPE_RETURN_TYPE_T ret;
            RULE_TYPE_CounterRec_T counter_rec;
            
            ret = RULE_CTRL_DAI_GetArpPacketCounterByUport(interface_p->uport.unit,
                                                           interface_p->uport.port,
                                                           &counter_rec);
            if (ret != RULE_TYPE_OK)
            {
                return ret;
            }

            if (TRUE == reset)
            {
                RULE_CTRL_DAI_ClearArpPacketCounterByUport(interface_p->uport.unit,
                                                           interface_p->uport.port);
            }

            *total_cnt_p = counter_rec.total_packets;
        }
        break;

        case RULE_TYPE_INTERFACE_TRUNK:
        {
            UI32_T unit, port;
            RULE_TYPE_RETURN_TYPE_T ret;
            RULE_TYPE_CounterRec_T counter_rec;

            *total_cnt_p = 0;

            if (trunk_member_p == NULL)
            {
                return RULE_TYPE_INVALID_PARAMETER;
            }

            if (interface_p->trunk_id < 1 ||
                SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM < interface_p->trunk_id)
            {
                return RULE_TYPE_INVALID_PARAMETER;
            }

            for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++unit)
            {
                for (port = 1; port <= SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT; ++port)
                {
                    if (RULE_TYPE_IS_BIT_ON(trunk_member_p->port_list[unit-1], port-1))
                    {
                        ret = RULE_CTRL_DAI_GetArpPacketCounterByUport(unit, port, &counter_rec);
                        if (ret != RULE_TYPE_OK)
                        {
                            LOG("Fail to get conter on trunk=%lu at unit=%lu, port=%lu",
                                interface_p->trunk_id, unit, port);
                            return ret;
                        }

                        if (TRUE == reset)
                        {
                            RULE_CTRL_DAI_ClearArpPacketCounterByUport(unit, port);
                        }

                        *total_cnt_p += counter_rec.total_packets;
                    }
                }
            }                
        }
        break;

        default:
            return RULE_TYPE_INVALID_PARAMETER;
    }

    return RULE_TYPE_OK;
}
#endif /* SYS_CPNT_DAI_RATE_LIMIT_BY_RULE */

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_GetRuleNumberByClassMap
 *------------------------------------------------------------------------------
 * PURPOSE  : calculate a class-map occupy rule number
 * INPUT    : class_map
 * OUTPUT   : rule_nbr
 * RETURN   : TRUE/FALSE.
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_GetRuleNumberByClassMap(const RULE_TYPE_ClassMap_T *class_map, UI32_T *rule_nbr)
{
    UI32_T  index, rule_cnt;

    if ((NULL == class_map) || (NULL == rule_nbr))
        return FALSE;

    *rule_nbr = 0;

    for (index = 0; index < class_map->class_element_count; ++index)
    {
        switch(class_map->class_type[index])
        {
            case RULE_TYPE_CLASS_MF:
                (*rule_nbr)++;
                break;

            case RULE_TYPE_CLASS_ACL:
                /* In current design, we don't configure aces of deny
                   action (for QoS) on the chip, so we count aces of
                   permit action only.
                 */
                if (RULE_TYPE_OK != RULE_OM_GetNumberOfPermitAcesByAclIndex(
                        class_map->class_index_list[index], &rule_cnt))
                {
                    return FALSE; /* should not go here */
                }

                (*rule_nbr) += rule_cnt;
                break;

            default:
                return FALSE; /* should not go here */
        }
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_CheckResourceOnPortListForQosPurpose
 *------------------------------------------------------------------------------
 * PURPOSE  : check every port in port list free rule number for QoS purpose
 * INPUT    : group_id, req_nbr, port_list
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_CheckResourceOnPortListForQosPurpose(
    UI32_T group_id,
    UI32_T req_nbr,
    const UI8_T *port_list)
{
    UI32_T                      ifindex, unit, port;
    UI32_T                      module_id, device_id, phy_port;
    UI32_T                      pre_ifindex, pre_unit, pre_device_id;
    UI32_T                      port_nbr_on_chip;
    RULE_CTRL_ResourceInfo_T    *res_p;

    if(SYS_ADPT_FP_MAX_NBR_OF_GROUP_PER_CHIP <= group_id)
        return FALSE;

    if (NULL == port_list)
        return FALSE;

    pre_ifindex = pre_unit = pre_device_id = 0;
    port_nbr_on_chip = 0;

    /* search port list then check free resource on this selector */
    for (ifindex = 1; SYS_ADPT_TOTAL_NBR_OF_LPORT >= ifindex; ++ifindex)
    {
        if (RULE_CTRL_IS_BIT_OFF(port_list, (ifindex - 1))) /* to zero-based */
            continue;

        unit = STKTPLG_OM_IFINDEX_TO_UNIT(ifindex);
        port = STKTPLG_OM_IFINDEX_TO_PORT(ifindex);

        if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(unit, port, &module_id, &device_id, &phy_port))
            return FALSE;

        if ((0 != pre_unit) && (0 != pre_device_id) &&
            ((unit != pre_unit) || (device_id != pre_device_id)))
        {
            res_p = RULE_CTRL_GetResourceInfo(pre_unit, pre_device_id, group_id);
            if (NULL == res_p)
                return FALSE;

            if (res_p->free_rule < (req_nbr * port_nbr_on_chip))
            {
                return FALSE;  /* not enough resource */
            }

            /* clear port number and restart from next chip */
            port_nbr_on_chip = 0;
        }
        else
        {
            ++port_nbr_on_chip;
        }

        pre_unit = unit;
        pre_device_id = device_id;
        pre_ifindex = ifindex;

    } /* end for ifindex */

    if (0 == pre_ifindex)
        return TRUE; /* no need to check */

    res_p = RULE_CTRL_GetResourceInfo(pre_unit, pre_device_id, group_id);
    if (NULL == res_p)
        return FALSE;


    if (res_p->free_rule < (req_nbr * port_nbr_on_chip))
    {
        return FALSE;  /* not enough resource */
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_FreeResourceInfo
 *------------------------------------------------------------------------------
 * PURPOSE  : increase free rule number
 * INPUT    : unit, device_id, group_id, rule_id
 * OUTPUT   : None
 * RETURN   : TRUE -- succeeded / FALSE -- failed
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_FreeResourceInfo(
    UI32_T unit,
    UI32_T device_id,
    UI32_T group_id)
{
    RULE_CTRL_ResourceInfo_T    *resource_p;

    resource_p = RULE_CTRL_GetResourceInfo(unit, device_id, group_id);
    if (NULL == resource_p)
        return FALSE;

    /* FIXME: remove this function ?? 
     *        the resource counting is moving to RULE_CTRL_Allocate_Rule
     */
    //++(resource_p->free_rule);

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalGetRuleInstanceFromClassInstanceByAceId
 *------------------------------------------------------------------------------
 * PURPOSE:  Get a rule instance from class instance
 * INPUT:    class_inst_p   - class instance
 *           ace_id         - ACE ID
 * OUTPUT:   None
 * RETURN:   Object pointer of rule instance
 * NOTE:     NONE
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RULE_INSTANCE_PTR_T
RULE_CTRL_LocalGetRuleInstanceFromClassInstanceByAceId(
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    UI32_T  ace_id)
{
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T           class_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T rule_inst_iter;
    RULE_TYPE_RULE_INSTANCE_PTR_T               rule_inst_p;

    ASSERT(NULL != class_inst_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_inst_p, &class_inst_obj);
    class_inst_obj.get_element_iterator(&class_inst_obj, &rule_inst_iter);

    for (rule_inst_iter.first(&rule_inst_iter);
         NULL != rule_inst_iter.get_instance(&rule_inst_iter);
         rule_inst_iter.next(&rule_inst_iter))
    {
        rule_inst_p = (RULE_TYPE_RULE_INSTANCE_PTR_T) rule_inst_iter.get_instance(&rule_inst_iter);

        if (rule_inst_p->ace_id == ace_id)
        {
            return rule_inst_p;
        }
    }

    return NULL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_InitInstance
 *------------------------------------------------------------------------------
 * PURPOSE  : Initialize instance table
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : Initialize before any instance operations
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_Priv_InitInstance()
{
    shmem_data_p->_container_pool.buffer_offset =
    L_CVRT_GET_OFFSET(&shmem_data_p->_container_pool,
                      &shmem_data_p->_container_pool_buf);
    shmem_data_p->_container_pool.buffer_len = sizeof(shmem_data_p->_container_pool_buf);
    shmem_data_p->_container_pool.partition_len = sizeof(*shmem_data_p->_container_pool_buf);
    L_PT_ShMem_Create(&shmem_data_p->_container_pool);

    shmem_data_p->_class_inst_pool.buffer_offset =
    L_CVRT_GET_OFFSET(&shmem_data_p->_class_inst_pool,
                      &shmem_data_p->_class_inst_pool_buf);
    shmem_data_p->_class_inst_pool.buffer_len = sizeof(shmem_data_p->_class_inst_pool_buf);
    shmem_data_p->_class_inst_pool.partition_len = sizeof(*shmem_data_p->_class_inst_pool_buf);
    L_PT_ShMem_Create(&shmem_data_p->_class_inst_pool);

    shmem_data_p->_rule_inst_pool.buffer_offset =
    L_CVRT_GET_OFFSET(&shmem_data_p->_rule_inst_pool,
                      &shmem_data_p->_rule_inst_pool_buf);
    shmem_data_p->_rule_inst_pool.buffer_len = sizeof(shmem_data_p->_rule_inst_pool_buf);
    shmem_data_p->_rule_inst_pool.partition_len = sizeof(*shmem_data_p->_rule_inst_pool_buf);
    L_PT_ShMem_Create(&shmem_data_p->_rule_inst_pool);

#ifdef RULE_CTRL_INSTANCE_DEBUG_ON
    {
        UI32_T i;

        for (i = 0; i < _countof(shmem_data_p->_container_pool_buf); ++ i)
        {
            shmem_data_p->_container_pool_buf[i].check_code = _CONTAINER_CHECK_CODE;
        }

        for (i = 0; i < _countof(shmem_data_p->_class_inst_pool_buf); ++ i)
        {
            shmem_data_p->_class_inst_pool_buf[i].check_code = _CLASS_INSTANCE_CHECK_CODE;
        }

        for (i = 0; i < _countof(shmem_data_p->_rule_inst_pool_buf); ++ i)
        {
            shmem_data_p->_rule_inst_pool_buf[i].check_code = _RULE_INSTANCE_CHECK_CODE;
        }
    }
#endif /* RULE_CTRL_INSTANCE_DEBUG_ON */

}

#ifdef RULE_CTRL_INSTANCE_DEBUG_ON
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_ValidateContainer
 *------------------------------------------------------------------------------
 * PURPOSE  : Validate container
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : Only for debug
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_Priv_ValidateContainer(
    const RULE_TYPE_CONTAINER_T *in)
{
    UI32_T i;
    UI32_T f;

    ASSERT(NULL != in);

    ASSERT(TRUE == RULE_CTRL_IS_CONTAINER_TYPE(in->super.type));
    ASSERT(_CONTAINER_CHECK_CODE == in->check_code);

    ASSERT(RULE_TYPE_NIL == in->super.links.first_node.type);
    ASSERT(RULE_TYPE_NIL == in->super.links.last_node.type);

    /* The array of container shall be packed
     */
    f = _countof(in->array);
    for (i = 0; i < _countof(in->array); ++ i)
    {
        if (RULE_TYPE_NIL == in->array[i].ptr.type)
        {
            f = i;
            break;
        }
    }

    for (i = f; i < _countof(in->array); ++ i)
    {
        ASSERT(RULE_TYPE_NIL == in->array[i].ptr.type);
    }
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_ValidateClassInstance
 *------------------------------------------------------------------------------
 * PURPOSE  : Validate class instance
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : Only for debug
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_Priv_ValidateClassInstance(
    const RULE_TYPE_CLASS_INSTANCE_T *in)
{
    ASSERT(NULL != in);

    ASSERT(TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(in->super.type));
    ASSERT(_CLASS_INSTANCE_CHECK_CODE == in->check_code);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_ValidateRuleInstance
 *------------------------------------------------------------------------------
 * PURPOSE  : Validate rule instance
 * INPUT    : None
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : Only for debug
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_Priv_ValidateRuleInstance(
    const RULE_TYPE_RULE_INSTANCE_T *in)
{
    ASSERT(NULL != in);

    ASSERT(TRUE == RULE_CTRL_IS_RULE_INSTANCE_TYPE(in->super.type));
    ASSERT(_RULE_INSTANCE_CHECK_CODE == in->check_code);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_ValidatePtr
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_Priv_ValidatePtr(
    RULE_TYPE_INSTANCE_T *in)
{
    ASSERT(NULL != in);

    if (TRUE == RULE_CTRL_IS_CONTAINER_TYPE(in->type))
    {
        RULE_CTRL_IN_Priv_ValidateContainer((RULE_TYPE_CONTAINER_T *) in);
    }
    else if (TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(in->type))
    {
        RULE_CTRL_IN_Priv_ValidateClassInstance((RULE_TYPE_CLASS_INSTANCE_T *) in);
    }
    else if (TRUE == RULE_CTRL_IS_RULE_INSTANCE_TYPE(in->type))
    {
        RULE_CTRL_IN_Priv_ValidateRuleInstance((RULE_TYPE_RULE_INSTANCE_T *) in);
    }
    else
    {
        ASSERT(0);
    }
}
#endif /* RULE_CTRL_INSTANCE_DEBUG_ON */

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_BaseAddress
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
void *
RULE_CTRL_IN_BaseAddress(
    RULE_TYPE_INSTANCE_TYPE_T type)
{
    if (TRUE == RULE_CTRL_IS_CONTAINER_TYPE(type))
    {
        return &shmem_data_p->_container_pool;
    }
    else if (TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(type))
    {
        return &shmem_data_p->_class_inst_pool;
    }
    else if (TRUE == RULE_CTRL_IS_RULE_INSTANCE_TYPE(type))
    {
        return &shmem_data_p->_rule_inst_pool;
    }

    ASSERT(0);
    return NULL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_GetFirstAddress
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
void *
RULE_CTRL_IN_FirstNodeAddress(
    RULE_TYPE_INSTANCE_TYPE_T type)
{
    if (TRUE == RULE_CTRL_IS_CONTAINER_TYPE(type))
    {
        return &shmem_data_p->_container_pool_buf;
    }
    else if (TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(type))
    {
        return &shmem_data_p->_class_inst_pool_buf;
    }
    else if (TRUE == RULE_CTRL_IS_RULE_INSTANCE_TYPE(type))
    {
        return &shmem_data_p->_rule_inst_pool_buf;
    }

    ASSERT(0);
    return NULL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_CountOf
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
UI32_T
RULE_CTRL_IN_CountOf(
    RULE_TYPE_INSTANCE_TYPE_T type)
{
    if (TRUE == RULE_CTRL_IS_CONTAINER_TYPE(type))
    {
        return _countof(shmem_data_p->_container_pool_buf);
    }
    else if (TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(type))
    {
        return _countof(shmem_data_p->_class_inst_pool_buf);
    }
    else if (TRUE == RULE_CTRL_IS_RULE_INSTANCE_TYPE(type))
    {
        return _countof(shmem_data_p->_rule_inst_pool_buf);
    }

    ASSERT(0);
    return 0;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_SizeOf
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
UI32_T
RULE_CTRL_IN_SizeOf(
    RULE_TYPE_INSTANCE_T *in)
{
    ASSERT(NULL != in);

    if (TRUE == RULE_CTRL_IS_CONTAINER_TYPE(in->type))
    {
        return sizeof(shmem_data_p->_container_pool_buf[0]);
    }
    else if (TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(in->type))
    {
        return sizeof(shmem_data_p->_class_inst_pool_buf[0]);
    }
    else if (TRUE == RULE_CTRL_IS_RULE_INSTANCE_TYPE(in->type))
    {
        return sizeof(shmem_data_p->_rule_inst_pool_buf[0]);
    }

    ASSERT(0);
    return 0;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_IndexOf
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
UI32_T
RULE_CTRL_IN_IndexOf(
    RULE_TYPE_INSTANCE_T *in_p)
{
    RULE_TYPE_SHM_POINTER_T ptr = {RULE_TYPE_NIL, 0};
    UI32_T size_desc_to_buf;

    ASSERT(NULL != in_p);

    RULE_CTRL_IN_VALIDATE_PTR(in_p);

    ptr.type = in_p->type;
    ptr.offset = L_CVRT_GET_OFFSET(RULE_CTRL_IN_BaseAddress(in_p->type), in_p);

    size_desc_to_buf = RULE_CTRL_IN_FirstNodeAddress(in_p->type) -
                                           RULE_CTRL_IN_BaseAddress(in_p->type);

    ASSERT((ptr.offset - size_desc_to_buf) % RULE_CTRL_IN_SizeOf(in_p) == 0);

    return (ptr.offset - size_desc_to_buf) / RULE_CTRL_IN_SizeOf(in_p);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_AtIndex
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
void *
RULE_CTRL_IN_AtIndex(
    RULE_TYPE_INSTANCE_TYPE_T type,
    UI32_T index)
{
    void *ary;

    ary = RULE_CTRL_IN_FirstNodeAddress(type);

    ASSERT(NULL != ary);

    /* Make sure the index was in the range
     */
    if (RULE_CTRL_IN_CountOf(type) <= index)
    {
        return NULL;
    }

    if (TRUE == RULE_CTRL_IS_CONTAINER_TYPE(type))
    {
        return &((RULE_TYPE_CONTAINER_T *)ary)[index];
    }
    else if (TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(type))
    {
        return &((RULE_TYPE_CLASS_INSTANCE_T *)ary)[index];
    }
    else if (TRUE == RULE_CTRL_IS_RULE_INSTANCE_TYPE(type))
    {
        return &((RULE_TYPE_RULE_INSTANCE_T *)ary)[index];
    }

    ASSERT(0);
    return NULL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_IndexOfClassInstance
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
UI32_T
RULE_CTRL_IN_IndexOfClassInstance(
    RULE_TYPE_CLASS_INSTANCE_T *in_p)
{
    return RULE_CTRL_IN_IndexOf((RULE_TYPE_INSTANCE_T *) in_p);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_IndexOfRuleInstance
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
UI32_T
RULE_CTRL_IN_IndexOfRuleInstance(
    RULE_TYPE_RULE_INSTANCE_T *in_p)
{
    return RULE_CTRL_IN_IndexOf((RULE_TYPE_INSTANCE_T *) in_p);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Ptr2Instance
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
void *
RULE_CTRL_IN_Ptr2Instance(
    RULE_TYPE_SHM_POINTER_T ptr)
{
    if (RULE_TYPE_NIL == ptr.type)
    {
        return NULL;
    }

    return L_CVRT_GET_PTR(RULE_CTRL_IN_BaseAddress(ptr.type), ptr.offset);
}

RULE_TYPE_SHM_POINTER_T
RULE_CTRL_IN_Instance2Ptr(
    const RULE_TYPE_INSTANCE_PTR_T in)
{
    RULE_TYPE_SHM_POINTER_T ptr = {RULE_TYPE_NIL, 0};

    if (NULL == in)
    {
        return ptr;
    }

    RULE_CTRL_IN_VALIDATE_PTR(in);

    ptr.type = in->type;
    ptr.offset = L_CVRT_GET_OFFSET(RULE_CTRL_IN_BaseAddress(in->type), in);

    return ptr;
}

#pragma mark Linked List Functions

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * Linked List Functions
 *
 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 */

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_LL_Priv_InsertAfter
 *------------------------------------------------------------------------------
 * PURPOSE  : Inserts node after the specified node
 * INPUT    : list_ptr      - list
 *            new_ptr       - inserts node after this node
 *            new_node_ptr  - new node
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_LL_Priv_InsertAfter(
    RULE_TYPE_SHM_POINTER_T list_ptr,
    RULE_TYPE_SHM_POINTER_T node_ptr,
    RULE_TYPE_SHM_POINTER_T new_node_ptr)
{
    RULE_TYPE_INSTANCE_T *list;
    RULE_TYPE_INSTANCE_T *node;
    RULE_TYPE_INSTANCE_T *new_node;

    ASSERT(RULE_TYPE_NIL != list_ptr.type);
    ASSERT(RULE_TYPE_NIL != node_ptr.type);
    ASSERT(RULE_TYPE_NIL != new_node_ptr.type);

    list = RULE_CTRL_IN_Ptr2Instance(list_ptr);
    node = RULE_CTRL_IN_Ptr2Instance(node_ptr);
    new_node = RULE_CTRL_IN_Ptr2Instance(new_node_ptr);

    RULE_CTRL_IN_VALIDATE_PTR(list);
    RULE_CTRL_IN_VALIDATE_PTR(node);
    RULE_CTRL_IN_VALIDATE_PTR(new_node);

    new_node->links.prev = node_ptr;
    new_node->links.next = node->links.next;

    if (RULE_TYPE_NIL == node->links.next.type)
    {
        list->links.last_node = new_node_ptr;
    }
    else
    {
        RULE_TYPE_INSTANCE_T *next = RULE_CTRL_IN_Ptr2Instance(node_ptr);

        RULE_CTRL_IN_VALIDATE_PTR(next);

        next->links.prev = new_node_ptr;
    }

    node->links.next = new_node_ptr;
    new_node->links.parent = list_ptr;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_LL_Priv_InsertBefore
 *------------------------------------------------------------------------------
 * PURPOSE  : Inserts node before the specified node
 * INPUT    : list_ptr      - list
 *            new_ptr       - inserts node before this node
 *            new_node_ptr  - new node
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_LL_Priv_InsertBefore(
    RULE_TYPE_SHM_POINTER_T list_ptr,
    RULE_TYPE_SHM_POINTER_T node_ptr,
    RULE_TYPE_SHM_POINTER_T new_node_ptr)
{
    RULE_TYPE_INSTANCE_T *list;
    RULE_TYPE_INSTANCE_T *node;
    RULE_TYPE_INSTANCE_T *new_node;

    ASSERT(RULE_TYPE_NIL != list_ptr.type);
    ASSERT(RULE_TYPE_NIL != node_ptr.type);
    ASSERT(RULE_TYPE_NIL != new_node_ptr.type);

    list = RULE_CTRL_IN_Ptr2Instance(list_ptr);
    node = RULE_CTRL_IN_Ptr2Instance(node_ptr);
    new_node = RULE_CTRL_IN_Ptr2Instance(new_node_ptr);

    RULE_CTRL_IN_VALIDATE_PTR(list);
    RULE_CTRL_IN_VALIDATE_PTR(node);
    RULE_CTRL_IN_VALIDATE_PTR(new_node);

    new_node->links.prev = node->links.prev;
    new_node->links.next = node_ptr;

    if (RULE_TYPE_NIL == node->links.prev.type)
    {
        list->links.first_node = new_node_ptr;
    }
    else
    {
        RULE_TYPE_INSTANCE_T *prev = RULE_CTRL_IN_Ptr2Instance(node->links.prev);

        RULE_CTRL_IN_VALIDATE_PTR(prev);
        prev->links.next = new_node_ptr;
    }

    node->links.prev = new_node_ptr;
    new_node->links.parent = list_ptr;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_LL_Priv_InsertBeginning
 *------------------------------------------------------------------------------
 * PURPOSE  : Inserts node before current first node
 * INPUT    : list_ptr      - list
 *            new_node_ptr  - new node
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_LL_Priv_InsertBeginning(
    RULE_TYPE_SHM_POINTER_T list_ptr,
    RULE_TYPE_SHM_POINTER_T new_node_ptr)
{
    RULE_TYPE_INSTANCE_T *list;
    RULE_TYPE_INSTANCE_T *new_node;

    ASSERT(RULE_TYPE_NIL != list_ptr.type);
    ASSERT(RULE_TYPE_NIL != new_node_ptr.type);

    list = RULE_CTRL_IN_Ptr2Instance(list_ptr);
    new_node = RULE_CTRL_IN_Ptr2Instance(new_node_ptr);

    RULE_CTRL_IN_VALIDATE_PTR(list);
    RULE_CTRL_IN_VALIDATE_PTR(new_node);

    if (RULE_TYPE_NIL == list->links.first_node.type)
    {
        list->links.first_node = new_node_ptr;
        list->links.last_node  = new_node_ptr;
        new_node->links.parent = list_ptr;

        memset(&new_node->links.prev, 0, sizeof(new_node->links.prev));
        memset(&new_node->links.next, 0, sizeof(new_node->links.next));
    }
    else
    {
        RULE_CTRL_IN_LL_Priv_InsertBefore(list_ptr, list->links.first_node, new_node_ptr);
    }
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_LL_Priv_InsertEnd
 *------------------------------------------------------------------------------
 * PURPOSE  : Append node
 * INPUT    : list_ptr      - list
 *            new_node_ptr  - new node
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_LL_Priv_InsertEnd(
    RULE_TYPE_SHM_POINTER_T list_ptr,
    RULE_TYPE_SHM_POINTER_T new_node_ptr)
{
    RULE_TYPE_INSTANCE_T *list;
    RULE_TYPE_INSTANCE_T *new_node;

    ASSERT(RULE_TYPE_NIL != list_ptr.type);
    ASSERT(RULE_TYPE_NIL != new_node_ptr.type);

    list = RULE_CTRL_IN_Ptr2Instance(list_ptr);
    new_node = RULE_CTRL_IN_Ptr2Instance(new_node_ptr);

    RULE_CTRL_IN_VALIDATE_PTR(list);
    RULE_CTRL_IN_VALIDATE_PTR(new_node);

    if (RULE_TYPE_NIL == list->links.last_node.type)
    {
        RULE_CTRL_IN_LL_Priv_InsertBeginning(list_ptr, new_node_ptr);
    }
    else
    {
        RULE_CTRL_IN_LL_Priv_InsertAfter(list_ptr, list->links.last_node, new_node_ptr);
    }
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_LL_Priv_Remove
 *------------------------------------------------------------------------------
 * PURPOSE  : Remove node
 * INPUT    : list_ptr      - list
 *            node_ptr      - removed node
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_LL_Priv_Remove(
    RULE_TYPE_SHM_POINTER_T list_ptr,
    RULE_TYPE_SHM_POINTER_T node_ptr)
{
    RULE_TYPE_INSTANCE_T *list;
    RULE_TYPE_INSTANCE_T *node;

    ASSERT(RULE_TYPE_NIL != list_ptr.type);
    ASSERT(RULE_TYPE_NIL != node_ptr.type);

    list = RULE_CTRL_IN_Ptr2Instance(list_ptr);
    node = RULE_CTRL_IN_Ptr2Instance(node_ptr);

    RULE_CTRL_IN_VALIDATE_PTR(list);
    RULE_CTRL_IN_VALIDATE_PTR(node);

    if (RULE_TYPE_NIL == node->links.prev.type)
    {
        list->links.first_node = node->links.next;
    }
    else
    {
        RULE_TYPE_INSTANCE_T *prev = RULE_CTRL_IN_Ptr2Instance(node->links.prev);

        RULE_CTRL_IN_VALIDATE_PTR(prev);
        prev->links.next = node->links.next;
    }

    if (RULE_TYPE_NIL == node->links.next.type)
    {
        list->links.last_node = node->links.prev;
    }
    else
    {
        RULE_TYPE_INSTANCE_T *next = RULE_CTRL_IN_Ptr2Instance(node->links.next);

        RULE_CTRL_IN_VALIDATE_PTR(next);
        next->links.prev = node->links.prev;
    }

    node->links.parent.type = RULE_TYPE_NIL;

    memset(&node->links.prev, 0, sizeof(node->links.prev));
    memset(&node->links.next, 0, sizeof(node->links.next));
}

#pragma mark Class/Rule Instance Functions

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * Class/Rule Instance Functions
 *
 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 */

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_CreateInstance
 *------------------------------------------------------------------------------
 * PURPOSE  : Create instance
 * INPUT    : base_addr - base address of entry table
 *            type      - type of instance
 * OUTPUT   : None
 * RETURN   : Pointer of instance entry
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_SHM_POINTER_T
RULE_CTRL_IN_Priv_CreateInstance(
    void *base_addr,
    RULE_TYPE_INSTANCE_TYPE_T type)
{
    RULE_TYPE_SHM_POINTER_T ptr = {RULE_TYPE_NIL, 0};
    RULE_TYPE_INSTANCE_T *in;

    ASSERT(NULL != base_addr);
    ASSERT(RULE_TYPE_INST_TYPE_FIRST <= type && type <= RULE_TYPE_INST_TYPE_LAST);

    in = L_PT_ShMem_Allocate(base_addr);

    if (NULL == in)
    {
        return ptr;
    }

    memset(in, 0, sizeof(*in));

    in->type = type;

    ptr.offset = L_CVRT_GET_OFFSET(base_addr, in);
    ptr.type = type;

    return ptr;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_DestroyInstance
 *------------------------------------------------------------------------------
 * PURPOSE  : Destroy instance
 * INPUT    : ptr   - pointer of instance entry
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_Priv_DestroyInstance(
    RULE_TYPE_SHM_POINTER_T ptr)
{
    RULE_TYPE_INSTANCE_T *in;

    if (RULE_TYPE_NIL == ptr.type)
    {
        ASSERT(0);
        return;
    }

    in = RULE_CTRL_IN_Ptr2Instance(ptr);

    RULE_CTRL_IN_VALIDATE_PTR(in);

    in->type = RULE_TYPE_NIL;
    memset(&in->links, 0, sizeof(in->links));

    L_PT_ShMem_Free(RULE_CTRL_IN_BaseAddress(ptr.type), in);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_CreateContainer
 *------------------------------------------------------------------------------
 * PURPOSE  : Create container
 * INPUT    : type  - type of instance
 * OUTPUT   : None
 * RETURN   : Pointer of instance entry
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_SHM_POINTER_T
RULE_CTRL_IN_Priv_CreateContainer()
{
    RULE_TYPE_INSTANCE_TYPE_T type = RULE_TYPE_INST_CONTAINER;

    RULE_TYPE_SHM_POINTER_T ptr = {RULE_TYPE_NIL, 0};
    RULE_TYPE_CONTAINER_T *in;
    void *base_addr = NULL;

    base_addr = RULE_CTRL_IN_BaseAddress(type);
    ptr =  RULE_CTRL_IN_Priv_CreateInstance(base_addr, type);

    if (RULE_TYPE_NIL == ptr.type)
    {
        return ptr;
    }

    in = RULE_CTRL_IN_Ptr2Instance(ptr);

    RULE_CTRL_IN_VALIDATE_PTR(in);

    return ptr;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_CreateClassInstance
 *------------------------------------------------------------------------------
 * PURPOSE  : Create class instance
 * INPUT    : type  - type of instance
 * OUTPUT   : None
 * RETURN   : Pointer of instance entry
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_SHM_POINTER_T
RULE_CTRL_IN_Priv_CreateClassInstance(
    RULE_TYPE_INSTANCE_TYPE_T type)
{
    RULE_TYPE_SHM_POINTER_T ptr = {RULE_TYPE_NIL, 0};
    RULE_TYPE_CLASS_INSTANCE_T *in;
    void *base_addr = NULL;

    if (TRUE != RULE_CTRL_IS_CLASS_INSTANCE_TYPE(type))
    {
        return ptr;
    }

    base_addr = RULE_CTRL_IN_BaseAddress(type);
    ptr = RULE_CTRL_IN_Priv_CreateInstance(base_addr, type);

    if (RULE_TYPE_NIL == ptr.type)
    {
        return ptr;
    }

    in = RULE_CTRL_IN_Ptr2Instance(ptr);
    in->id = 0xCCCC;

    RULE_CTRL_IN_VALIDATE_CLASS_INST(in);

    return ptr;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_CreateRuleInstance
 *------------------------------------------------------------------------------
 * PURPOSE  : Create rule instance
 * INPUT    : type  - type of instance
 * OUTPUT   : None
 * RETURN   : Pointer of instance entry
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_SHM_POINTER_T
RULE_CTRL_IN_Priv_CreateRuleInstance(
    RULE_TYPE_INSTANCE_TYPE_T type)
{
    RULE_TYPE_SHM_POINTER_T ptr = {RULE_TYPE_NIL, 0};
    RULE_TYPE_RULE_INSTANCE_T *in;
    void *base_addr = NULL;

    if (TRUE != RULE_CTRL_IS_RULE_INSTANCE_TYPE(type))
    {
        return ptr;
    }

    base_addr = RULE_CTRL_IN_BaseAddress(type);
    ptr =  RULE_CTRL_IN_Priv_CreateInstance(base_addr, type);

    if (RULE_TYPE_NIL == ptr.type)
    {
        return ptr;
    }

    in = RULE_CTRL_IN_Ptr2Instance(ptr);

    RULE_CTRL_IN_VALIDATE_RULE_INST(in);

    in->id = 0xCCCC;
    in->dev_rule_info.rule_id = 0x01020304;

    RULE_CTRL_IN_VALIDATE_PTR(in);

    return ptr;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_DestroyContainerInstance
 *------------------------------------------------------------------------------
 * PURPOSE  : Destroy a container object
 * INPUT    : ptr   - pointer of instance entry
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : All child instance also be destroied
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_Priv_DestroyContainer(
    RULE_TYPE_SHM_POINTER_T ptr)
{
    RULE_TYPE_CONTAINER_T                   *in;
    RULE_TYPE_CONTAINER_OBJECT_T            this;
    RULE_TYPE_CONTAINER_ELEMENT_ITERATOR_T  iter;

    if (RULE_TYPE_NIL == ptr.type)
    {
        ASSERT(0);
        return;
    }

    in = RULE_CTRL_IN_Ptr2Instance(ptr);

    RULE_CTRL_IN_VALIDATE_PTR(in);

    RULE_CTRL_IN_Priv_ConstructContainerObject(in, &this);
    this.get_element_iterator(&this, &iter);

    for (iter.last(&iter); NULL != iter.get_instance(&iter); iter.last(&iter))
    {
        RULE_TYPE_SHM_POINTER_T child = iter.get_ptr(&iter);

        RULE_CTRL_IN_Priv_Container_RemoveInstance(&this, RULE_CTRL_IN_Ptr2Instance(child));

        if (TRUE == RULE_CTRL_IS_CONTAINER_TYPE(child.type))
        {
            RULE_CTRL_IN_Priv_DestroyContainer(child);
        }
        else if (TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(child.type))
        {
            RULE_CTRL_IN_Priv_DestroyClassInstance(child);
        }
        else if (TRUE == RULE_CTRL_IS_RULE_INSTANCE_TYPE(child.type))
        {
            RULE_CTRL_IN_Priv_DestroyRuleInstance(child);
        }
        else
        {
            ASSERT(0);
        }
    }

    RULE_CTRL_IN_Priv_DestroyInstance(ptr);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_DestroyClassInstance
 *------------------------------------------------------------------------------
 * PURPOSE  : Destroy class instance
 * INPUT    : ptr   - pointer of instance entry
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : All child instance also be destroied
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_Priv_DestroyClassInstance(
    RULE_TYPE_SHM_POINTER_T ptr)
{
    RULE_TYPE_CLASS_INSTANCE_T                  *in;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T           this;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T iter;

    if (RULE_TYPE_NIL == ptr.type)
    {
        ASSERT(0);
        return;
    }

    in = RULE_CTRL_IN_Ptr2Instance(ptr);

    RULE_CTRL_IN_VALIDATE_CLASS_INST(in);

    if (0 < in->ref_count)
    {
        in->ref_count -= 1;
    }

    /* We shared the class instance of ACL and include all children instance
     * But only add the ref_count for the class instance of ACL only. The
     * ref_count of the children instance shall always be 0.
     * When the 0 < ref_count, don't remove child instance and self.
     */
    if (0 < in->ref_count)
    {
        return;
    }

    ASSERT(0 == in->ref_count);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(in, &this);
    this.get_element_iterator(&this, &iter);

    for (iter.last(&iter); NULL != iter.get_instance(&iter); iter.last(&iter))
    {
        RULE_TYPE_SHM_POINTER_T child = iter.get_ptr(&iter);

        RULE_CTRL_IN_LL_Priv_Remove(ptr, child);

        if (TRUE == RULE_CTRL_IS_CONTAINER_TYPE(child.type))
        {
            RULE_CTRL_IN_Priv_DestroyContainer(child);
        }
        else if (TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(child.type))
        {
            RULE_CTRL_IN_Priv_DestroyClassInstance(child);
        }
        else if (TRUE == RULE_CTRL_IS_RULE_INSTANCE_TYPE(child.type))
        {
            RULE_CTRL_IN_Priv_DestroyRuleInstance(child);
        }
        else
        {
            ASSERT(0);
        }
    }

    in->id = 0xDDDD;

    RULE_CTRL_IN_Priv_DestroyInstance(ptr);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_DestroyRuleInstance
 *------------------------------------------------------------------------------
 * PURPOSE  : Destroy rule instance
 * INPUT    : ptr   - pointer of instance entry
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_Priv_DestroyRuleInstance(
    RULE_TYPE_SHM_POINTER_T ptr)
{
    RULE_TYPE_RULE_INSTANCE_T *in;

    if (RULE_TYPE_NIL == ptr.type)
    {
        ASSERT(0);
        return;
    }

    in = RULE_CTRL_IN_Ptr2Instance(ptr);

    RULE_CTRL_IN_VALIDATE_RULE_INST(in);

    in->id = 0xDDDD;
    in->dev_rule_info.rule_id = 0x06070809;

    RULE_CTRL_IN_Priv_DestroyInstance(ptr);
}

#pragma mark Help Functions

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * Help Function for operating the rule/class instances
 *
 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_IN_Priv_Container_AddInstance(
    RULE_TYPE_CONTAINER_OBJECT_T *this,
    const RULE_TYPE_INSTANCE_PTR_T in)
{
    RULE_TYPE_SHM_POINTER_T ptr = {RULE_TYPE_NIL, 0};
    UI32_T i;
    UI32_T f = _countof(this->inst->array);

    ASSERT(NULL != this);
    ASSERT(NULL != in);

    ptr = RULE_CTRL_IN_Instance2Ptr(in);
    if (RULE_TYPE_NIL == ptr.type)
    {
        return RULE_TYPE_INVALID_PARAMETER;
    }

    for (i = 0; i < _countof(this->inst->array); ++ i)
    {
        if (0 == memcmp(&ptr, &this->inst->array[i].ptr, sizeof(ptr)))
        {
            return RULE_TYPE_OK;
        }

        if (f == _countof(this->inst->array))
        {
            if (RULE_TYPE_NIL == this->inst->array[i].ptr.type)
            {
                f = i;
            }
        }
    }

    if (f < _countof(this->inst->array))
    {
        this->inst->array[f].ptr = ptr;
        in->links.parent = this->ptr;
        return RULE_TYPE_OK;
    }

    return RULE_TYPE_FAIL;
}

static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_IN_Priv_Container_RemoveInstance(
    RULE_TYPE_CONTAINER_OBJECT_T *this,
    const RULE_TYPE_INSTANCE_PTR_T in)
{
    RULE_TYPE_SHM_POINTER_T ptr = {RULE_TYPE_NIL, 0};
    UI32_T i;

    ASSERT(NULL != this);
    ASSERT(NULL != in);

    ptr = RULE_CTRL_IN_Instance2Ptr(in);
    if (RULE_TYPE_NIL == ptr.type)
    {
        return RULE_TYPE_INVALID_PARAMETER;
    }

    for (i = 0; i < _countof(this->inst->array); ++ i)
    {
        if (0 == memcmp(&ptr, &this->inst->array[i].ptr, sizeof(ptr)))
        {
            if (i < (_countof(this->inst->array) - 1))
            {
                memmove(&this->inst->array[i].ptr,
                        &this->inst->array[i + 1].ptr,
                        (_countof(this->inst->array) - (i + 1)) * sizeof(this->inst->array[0]));
            }

            memset(&this->inst->array[ _countof(this->inst->array)- 1 ].ptr, 0,
                   sizeof(this->inst->array[0]));

            this->inst->array[ _countof(this->inst->array)- 1 ].ptr.type = RULE_TYPE_NIL;

            in->links.parent.type = RULE_TYPE_NIL;

            return RULE_TYPE_OK;
        }
    }

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_IN_Priv_Container_AddClassInstanceObject(
    RULE_TYPE_CONTAINER_OBJECT_T *this,
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T *new_obj)
{
    return RULE_CTRL_IN_Priv_Container_AddInstance(this,
                                      (RULE_TYPE_INSTANCE_PTR_T) new_obj->inst);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_IN_Priv_Container_AddRuleInstanceObject(
    RULE_TYPE_CONTAINER_OBJECT_T *this,
    RULE_TYPE_RULE_INSTANCE_OBJECT_T *new_obj)
{
    return RULE_CTRL_IN_Priv_Container_AddInstance(this,
                                      (RULE_TYPE_INSTANCE_PTR_T) new_obj->inst);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_IN_Priv_Container_RemoveClassInstanceObject(
    RULE_TYPE_CONTAINER_OBJECT_T *this,
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T *obj)
{
    return RULE_CTRL_IN_Priv_Container_RemoveInstance(this,
                                          (RULE_TYPE_INSTANCE_PTR_T) obj->inst);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_IN_Priv_Container_RemoveRuleInstanceObject(
    RULE_TYPE_CONTAINER_OBJECT_T *this,
    RULE_TYPE_RULE_INSTANCE_OBJECT_T *obj)
{
    return RULE_CTRL_IN_Priv_Container_RemoveInstance(this,
                                          (RULE_TYPE_INSTANCE_PTR_T) obj->inst);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_ClassInstanceElementIterator_UpdateInstance
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_INSTANCE_T *
RULE_CTRL_IN_Priv_ContainerElementIterator_UpdateInstance(
    RULE_TYPE_CONTAINER_ELEMENT_ITERATOR_T *this)
{
    ASSERT(NULL != this);

    if (RULE_TYPE_NIL == this->curr_ptr.type)
    {
        this->curr_inst = NULL;
    }
    else
    {
        this->curr_inst = RULE_CTRL_IN_Ptr2Instance(this->curr_ptr);

        RULE_CTRL_IN_VALIDATE_PTR(this->curr_inst);
    }

    return this->curr_inst;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_INSTANCE_T *
RULE_CTRL_IN_Priv_ContainerElementIterator_First(
    RULE_TYPE_CONTAINER_ELEMENT_ITERATOR_T *this)
{
    ASSERT(NULL != this);
    ASSERT(NULL != this->inst);

    this->curr_idx = 0;

    this->curr_ptr = this->inst->array[this->curr_idx].ptr;

    return RULE_CTRL_IN_Priv_ContainerElementIterator_UpdateInstance(this);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_INSTANCE_T *
RULE_CTRL_IN_Priv_ContainerElementIterator_Last(
    RULE_TYPE_CONTAINER_ELEMENT_ITERATOR_T *this)
{
    ASSERT(NULL != this);
    ASSERT(NULL != this->inst);

    for (this->curr_idx = _countof(this->inst->array) - 1; 0 < this->curr_idx;  -- this->curr_idx)
    {
        if (RULE_TYPE_NIL != this->inst->array[this->curr_idx].ptr.type)
        {
            break;
        }
    }

    ASSERT(this->curr_idx < _countof(this->inst->array));

    this->curr_ptr = this->inst->array[this->curr_idx].ptr;

    return RULE_CTRL_IN_Priv_ContainerElementIterator_UpdateInstance(this);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_INSTANCE_T *
RULE_CTRL_IN_Priv_ContainerElementIterator_Next(
    RULE_TYPE_CONTAINER_ELEMENT_ITERATOR_T *this)
{
    ASSERT(NULL != this);
    ASSERT(NULL != this->inst);

    if (_countof(this->inst->array) <= ++ this->curr_idx)
    {
        this->curr_ptr.type = RULE_TYPE_NIL;
    }
    else
    {
        ASSERT(this->curr_idx < _countof(this->inst->array));

        this->curr_ptr = this->inst->array[this->curr_idx].ptr;
    }

    return RULE_CTRL_IN_Priv_ContainerElementIterator_UpdateInstance(this);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_INSTANCE_T *
RULE_CTRL_IN_Priv_ContainerElementIterator_Prev(
    RULE_TYPE_CONTAINER_ELEMENT_ITERATOR_T *this)
{
    ASSERT(NULL != this);
    ASSERT(NULL != this->inst);

    if (0 == this->curr_idx)
    {
        this->curr_ptr.type = RULE_TYPE_NIL;
    }
    else
    {
        ASSERT(this->curr_idx < _countof(this->inst->array));

        this->curr_ptr = this->inst->array[-- this->curr_idx].ptr;
    }

    return RULE_CTRL_IN_Priv_ContainerElementIterator_UpdateInstance(this);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IN_Priv_ContainerElementIterator_EOF(
    RULE_TYPE_CONTAINER_ELEMENT_ITERATOR_T *this)
{
    ASSERT(NULL != this);
    ASSERT(NULL != this->inst);

    return (NULL == this->curr_inst) ? TRUE : FALSE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IN_Priv_ContainerElementIterator_HasNext(
    RULE_TYPE_CONTAINER_ELEMENT_ITERATOR_T *this)
{
    ASSERT(NULL != this);
    ASSERT(NULL != this->inst);

    if (this->curr_idx == _countof(this->inst->array) - 1)
    {
        return FALSE;
    }

    return (RULE_TYPE_NIL != this->inst->array[this->curr_idx + 1].ptr.type) ? TRUE : FALSE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IN_Priv_ContainerElementIterator_HasPrev(
    RULE_TYPE_CONTAINER_ELEMENT_ITERATOR_T *this)
{
    ASSERT(NULL != this);
    ASSERT(NULL != this->inst);

    if (this->curr_idx == 0)
    {
        return FALSE;
    }

    return (RULE_TYPE_NIL != this->inst->array[this->curr_idx - 1].ptr.type) ? TRUE : FALSE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static UI32_T
RULE_CTRL_IN_Priv_ContainerElementIterator_Count(
    RULE_TYPE_CONTAINER_ELEMENT_ITERATOR_T *this)
{
    RULE_TYPE_CONTAINER_ELEMENT_ITERATOR_T that;
    UI32_T count = 0;

    ASSERT(NULL != this);

    that = *this;

    for (that.first(&that); NULL != that.get_instance(&that); that.next(&that))
    {
        ++ count;
    }

    return count;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_SHM_POINTER_T
RULE_CTRL_IN_Priv_ContainerElementIterator_GetPtr(
    RULE_TYPE_CONTAINER_ELEMENT_ITERATOR_T *this)
{
    ASSERT(NULL != this);
    ASSERT(NULL != this->inst);

    return this->curr_ptr;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_INSTANCE_T *
RULE_CTRL_IN_Priv_ContainerElementIterator_GetInstance(
    RULE_TYPE_CONTAINER_ELEMENT_ITERATOR_T *this)
{
    ASSERT(NULL != this);
    ASSERT(NULL != this->inst);

    return this->curr_inst;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_Priv_Container_GetElementIterator(
    RULE_TYPE_CONTAINER_OBJECT_T *this,
    RULE_TYPE_CONTAINER_ELEMENT_ITERATOR_T *iter)
{
    ASSERT(NULL != this);
    ASSERT(NULL != iter);

    RULE_CTRL_IN_VALIDATE_PTR(this->inst);

    memset(iter, 0, sizeof(*iter));

    iter->ptr           = this->ptr;
    iter->inst          = this->inst;
    iter->curr_ptr      = this->ptr;
    iter->curr_inst     = (RULE_TYPE_INSTANCE_T *) this->inst;

    iter->first         = RULE_CTRL_IN_Priv_ContainerElementIterator_First;
    iter->last          = RULE_CTRL_IN_Priv_ContainerElementIterator_Last;
    iter->next          = RULE_CTRL_IN_Priv_ContainerElementIterator_Next;
    iter->prev          = RULE_CTRL_IN_Priv_ContainerElementIterator_Prev;
    iter->eof           = RULE_CTRL_IN_Priv_ContainerElementIterator_EOF;
    iter->has_next      = RULE_CTRL_IN_Priv_ContainerElementIterator_HasNext;
    iter->has_prev      = RULE_CTRL_IN_Priv_ContainerElementIterator_HasPrev;
    iter->count         = RULE_CTRL_IN_Priv_ContainerElementIterator_Count;
    iter->get_ptr       = RULE_CTRL_IN_Priv_ContainerElementIterator_GetPtr;
    iter->get_instance  = RULE_CTRL_IN_Priv_ContainerElementIterator_GetInstance;

    iter->first(iter);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_ConstructContainerObjectFromPointer
 *------------------------------------------------------------------------------
 * PURPOSE  : Consturct class instance object from pointer of instance entry
 * INPUT    : ptr   - pointer of instance entry
 * OUTPUT   : out   - instance object
 * RETURN   : None
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_Priv_ConstructContainerObjectFromPointer(
    RULE_TYPE_SHM_POINTER_T ptr,
    RULE_TYPE_CONTAINER_OBJECT_T *out)
{
    ASSERT(RULE_TYPE_NIL != ptr.type);

    out->ptr = ptr;
    out->inst = RULE_CTRL_IN_Ptr2Instance(out->ptr);

    RULE_CTRL_IN_VALIDATE_PTR(out->inst);

    out->add                    = RULE_CTRL_IN_Priv_Container_AddInstance;
    out->remove                 = RULE_CTRL_IN_Priv_Container_RemoveInstance;
    out->add_class_obj          = RULE_CTRL_IN_Priv_Container_AddClassInstanceObject;
    out->add_rule_obj           = RULE_CTRL_IN_Priv_Container_AddRuleInstanceObject;
    out->remove_class_obj       = RULE_CTRL_IN_Priv_Container_RemoveClassInstanceObject;
    out->remove_rule_obj        = RULE_CTRL_IN_Priv_Container_RemoveRuleInstanceObject;
    out->get_element_iterator   = RULE_CTRL_IN_Priv_Container_GetElementIterator;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_ConstructContainerObject
 *------------------------------------------------------------------------------
 * PURPOSE  : Consturct container object from class instance
 * INPUT    : in    - source container
 * OUTPUT   : out   - instance object
 * RETURN   : None
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_Priv_ConstructContainerObject(
    const RULE_TYPE_CONTAINER_T *in,
    RULE_TYPE_CONTAINER_OBJECT_T *out)
{
    RULE_TYPE_SHM_POINTER_T ptr = {RULE_TYPE_NIL, 0};

    ASSERT(NULL != in);

    RULE_CTRL_IN_VALIDATE_PTR(in);

    ptr.type = in->super.type;
    ptr.offset = L_CVRT_GET_OFFSET(RULE_CTRL_IN_BaseAddress(in->super.type), in);

    RULE_CTRL_IN_Priv_ConstructContainerObjectFromPointer(ptr, out);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_CreateContainerObject
 *------------------------------------------------------------------------------
 * PURPOSE  : Create container object
 * INPUT    : type  - type of instance
 * OUTPUT   : out   - instance object
 * RETURN   : RULE_TYPE_OK; error code
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_IN_Priv_CreateContainerObject(
    RULE_TYPE_CONTAINER_OBJECT_T *out)
{
    RULE_TYPE_SHM_POINTER_T ptr;

    ASSERT(NULL != out);

    memset(out, 0, sizeof(*out));

    ptr = RULE_CTRL_IN_Priv_CreateContainer();
    if (RULE_TYPE_NIL == ptr.type)
    {
        return RULE_TYPE_FAIL;
    }

    RULE_CTRL_IN_Priv_ConstructContainerObjectFromPointer(ptr, out);
    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_DestroyContainerObject
 *------------------------------------------------------------------------------
 * PURPOSE  : Destroy container
 * INPUT    : this  - instance object
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK; error code
 * NOTE     : All child instance also be destroied
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_IN_Priv_DestroyContainerObject(
    RULE_TYPE_CONTAINER_OBJECT_T *this)
{
    ASSERT(NULL != this);

    RULE_CTRL_IN_Priv_DestroyContainer(this->ptr);
    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_ClassInstanceElementIterator_UpdateInstance
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_INSTANCE_T *
RULE_CTRL_IN_Priv_ClassInstanceElementIterator_UpdateInstance(
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T *this)
{
    ASSERT(NULL != this);

    if (RULE_TYPE_NIL == this->curr_ptr.type)
    {
        this->curr_inst = NULL;
    }
    else
    {
        this->curr_inst = RULE_CTRL_IN_Ptr2Instance(this->curr_ptr);

        RULE_CTRL_IN_VALIDATE_PTR(this->curr_inst);
    }

    return this->curr_inst;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_INSTANCE_T *
RULE_CTRL_IN_Priv_ClassInstanceElementIterator_First(
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T *this)
{
    ASSERT(NULL != this);
    ASSERT(NULL != this->inst);

    this->curr_ptr = this->inst->super.links.first_node;

    return RULE_CTRL_IN_Priv_ClassInstanceElementIterator_UpdateInstance(this);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_INSTANCE_T *
RULE_CTRL_IN_Priv_ClassInstanceElementIterator_Last(
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T *this)
{
    ASSERT(NULL != this);
    ASSERT(NULL != this->inst);

    this->curr_ptr = this->inst->super.links.last_node;

    return RULE_CTRL_IN_Priv_ClassInstanceElementIterator_UpdateInstance(this);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_INSTANCE_T *
RULE_CTRL_IN_Priv_ClassInstanceElementIterator_Next(
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T *this)
{
    ASSERT(NULL != this);
    ASSERT(NULL != this->inst);

    this->curr_ptr = this->curr_inst->links.next;

    return RULE_CTRL_IN_Priv_ClassInstanceElementIterator_UpdateInstance(this);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_INSTANCE_T *
RULE_CTRL_IN_Priv_ClassInstanceElementIterator_Prev(
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T *this)
{
    ASSERT(NULL != this);
    ASSERT(NULL != this->inst);

    this->curr_ptr = this->curr_inst->links.prev;

    return RULE_CTRL_IN_Priv_ClassInstanceElementIterator_UpdateInstance(this);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IN_Priv_ClassInstanceElementIterator_EOF(
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T *this)
{
    ASSERT(NULL != this);
    ASSERT(NULL != this->inst);

    return (NULL == this->curr_inst) ? TRUE : FALSE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IN_Priv_ClassInstanceElementIterator_HasNext(
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T *this)
{
    ASSERT(NULL != this);
    ASSERT(NULL != this->inst);

    return (this->curr_inst && RULE_TYPE_NIL != this->curr_inst->links.next.type) ? TRUE : FALSE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_IN_Priv_ClassInstanceElementIterator_HasPrev(
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T *this)
{
    ASSERT(NULL != this);
    ASSERT(NULL != this->inst);

    return (this->curr_inst && RULE_TYPE_NIL != this->curr_inst->links.prev.type) ? TRUE : FALSE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static UI32_T
RULE_CTRL_IN_Priv_ClassInstanceElementIterator_Count(
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T *this)
{
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T that;
    UI32_T count = 0;

    ASSERT(NULL != this);

    that = *this;

    for (that.first(&that); NULL != that.get_instance(&that); that.next(&that))
    {
        ++ count;
    }

    return count;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_SHM_POINTER_T
RULE_CTRL_IN_Priv_ClassInstanceElementIterator_GetPtr(
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T *this)
{
    ASSERT(NULL != this);
    ASSERT(NULL != this->inst);

    return this->curr_ptr;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_INSTANCE_T *
RULE_CTRL_IN_Priv_ClassInstanceElementIterator_GetInstance(
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T *this)
{
    ASSERT(NULL != this);
    ASSERT(NULL != this->inst);

    return this->curr_inst;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_IN_Priv_ClassInstance_AddInstance(
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T *this,
    const RULE_TYPE_INSTANCE_PTR_T in)
{
    ASSERT(NULL != this);
    ASSERT(NULL != in);

    RULE_CTRL_IN_LL_Priv_InsertEnd(this->ptr, RULE_CTRL_IN_Instance2Ptr(in));
    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_IN_Priv_ClassInstance_RemoveInstance(
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T *this,
    const RULE_TYPE_INSTANCE_PTR_T in)
{
    ASSERT(NULL != this);
    ASSERT(NULL != in);

    RULE_CTRL_IN_LL_Priv_Remove(this->ptr, RULE_CTRL_IN_Instance2Ptr(in));
    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_IN_Priv_AddClassInstanceObject(
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T *this,
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T *new_obj)
{
    return RULE_CTRL_IN_Priv_ClassInstance_AddInstance(this,
                                                       (RULE_TYPE_INSTANCE_PTR_T) new_obj->inst);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_IN_Priv_AddRuleInstanceObject(
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T *this,
    RULE_TYPE_RULE_INSTANCE_OBJECT_T *new_obj)
{
    return RULE_CTRL_IN_Priv_ClassInstance_AddInstance(this,
                                                       (RULE_TYPE_INSTANCE_PTR_T) new_obj->inst);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_IN_Priv_RemoveClassInstanceObject(
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T *this,
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T *obj)
{
    return RULE_CTRL_IN_Priv_ClassInstance_RemoveInstance(this,
                                                          (RULE_TYPE_INSTANCE_PTR_T) obj->inst);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_IN_Priv_RemoveRuleInstanceObject(
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T *this,
    RULE_TYPE_RULE_INSTANCE_OBJECT_T *obj)
{
    return RULE_CTRL_IN_Priv_ClassInstance_RemoveInstance(this,
                                                          (RULE_TYPE_INSTANCE_PTR_T) obj->inst);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME -
 *------------------------------------------------------------------------------
 * PURPOSE  :
 * INPUT    :
 * OUTPUT   :
 * RETURN   :
 * NOTE     :
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_Priv_GetElementIterator(
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T *this,
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T *iter)
{
    ASSERT(NULL != this);
    ASSERT(NULL != iter);

    RULE_CTRL_IN_VALIDATE_PTR(this->inst);

    memset(iter, 0, sizeof(*iter));

    iter->ptr           = this->ptr;
    iter->inst          = this->inst;
    iter->curr_ptr      = this->ptr;
    iter->curr_inst     = (RULE_TYPE_INSTANCE_T *) this->inst;

    iter->first         = RULE_CTRL_IN_Priv_ClassInstanceElementIterator_First;
    iter->last          = RULE_CTRL_IN_Priv_ClassInstanceElementIterator_Last;
    iter->next          = RULE_CTRL_IN_Priv_ClassInstanceElementIterator_Next;
    iter->prev          = RULE_CTRL_IN_Priv_ClassInstanceElementIterator_Prev;
    iter->eof           = RULE_CTRL_IN_Priv_ClassInstanceElementIterator_EOF;
    iter->has_next      = RULE_CTRL_IN_Priv_ClassInstanceElementIterator_HasNext;
    iter->has_prev      = RULE_CTRL_IN_Priv_ClassInstanceElementIterator_HasPrev;
    iter->count         = RULE_CTRL_IN_Priv_ClassInstanceElementIterator_Count;
    iter->get_ptr       = RULE_CTRL_IN_Priv_ClassInstanceElementIterator_GetPtr;
    iter->get_instance  = RULE_CTRL_IN_Priv_ClassInstanceElementIterator_GetInstance;

    iter->first(iter);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer
 *------------------------------------------------------------------------------
 * PURPOSE  : Consturct class instance object from pointer of instance entry
 * INPUT    : ptr   - pointer of instance entry
 * OUTPUT   : out   - instance object
 * RETURN   : None
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(
    RULE_TYPE_SHM_POINTER_T ptr,
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T *out)
{
    ASSERT(RULE_TYPE_NIL != ptr.type);

    out->ptr = ptr;
    out->inst = RULE_CTRL_IN_Ptr2Instance(out->ptr);

    RULE_CTRL_IN_VALIDATE_CLASS_INST(out->inst);

    out->add                    = RULE_CTRL_IN_Priv_ClassInstance_AddInstance;
    out->remove                 = RULE_CTRL_IN_Priv_ClassInstance_RemoveInstance;
    out->add_class_obj          = RULE_CTRL_IN_Priv_AddClassInstanceObject;
    out->add_rule_obj           = RULE_CTRL_IN_Priv_AddRuleInstanceObject;
    out->remove_class_obj       = RULE_CTRL_IN_Priv_RemoveClassInstanceObject;
    out->remove_rule_obj        = RULE_CTRL_IN_Priv_RemoveRuleInstanceObject;
    out->get_element_iterator   = RULE_CTRL_IN_Priv_GetElementIterator;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_ConstructClassInstanceObject
 *------------------------------------------------------------------------------
 * PURPOSE  : Consturct class instance object from class instance
 * INPUT    : in    - source class instance
 * OUTPUT   : out   - instance object
 * RETURN   : None
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_Priv_ConstructClassInstanceObject(
    const RULE_TYPE_CLASS_INSTANCE_T *in,
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T *out)
{
    RULE_TYPE_SHM_POINTER_T ptr = {RULE_TYPE_NIL, 0};

    ASSERT(NULL != in);

    RULE_CTRL_IN_VALIDATE_CLASS_INST(in);

    ptr.type = in->super.type;
    ptr.offset = L_CVRT_GET_OFFSET(RULE_CTRL_IN_BaseAddress(in->super.type), in);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(ptr, out);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_CreateClassInstanceObject
 *------------------------------------------------------------------------------
 * PURPOSE  : Create class instance object
 * INPUT    : type  - type of instance
 * OUTPUT   : out   - instance object
 * RETURN   : RULE_TYPE_OK; error code
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_IN_Priv_CreateClassInstanceObject(
    RULE_TYPE_INSTANCE_TYPE_T type,
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T *out)
{
    RULE_TYPE_SHM_POINTER_T ptr;

    ASSERT(NULL != out);

    memset(out, 0, sizeof(*out));

    ptr = RULE_CTRL_IN_Priv_CreateClassInstance(type);
    if (RULE_TYPE_NIL == ptr.type)
    {
        return RULE_TYPE_FAIL;
    }

    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(ptr, out);
    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_DestroyClassInstanceObject
 *------------------------------------------------------------------------------
 * PURPOSE  : Destroy class instance
 * INPUT    : this  - instance object
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK; error code
 * NOTE     : All child instance also be destroied
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_IN_Priv_DestroyClassInstanceObject(
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T *this)
{
    ASSERT(NULL != this);

    RULE_CTRL_IN_Priv_DestroyClassInstance(this->ptr);
    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_ConstructRuleInstanceObjectFromPointer
 *------------------------------------------------------------------------------
 * PURPOSE  : Consturct rule instance object from pointer of instance entry
 * INPUT    : ptr   - pointer of instance entry
 * OUTPUT   : out   - instance object
 * RETURN   : None
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_Priv_ConstructRuleInstanceObjectFromPointer(
    RULE_TYPE_SHM_POINTER_T ptr,
    RULE_TYPE_RULE_INSTANCE_OBJECT_T *out)
{
    ASSERT(RULE_TYPE_NIL != ptr.type);

    out->ptr = ptr;
    out->inst = RULE_CTRL_IN_Ptr2Instance(out->ptr);

    RULE_CTRL_IN_VALIDATE_RULE_INST(out->inst);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_ConstructRuleInstanceObject
 *------------------------------------------------------------------------------
 * PURPOSE  : Consturct rule instance object from rule instance
 * INPUT    : in    - source rule instance
 * OUTPUT   : out   - instance object
 * RETURN   : None
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_IN_Priv_ConstructRuleInstanceObject(
    RULE_TYPE_RULE_INSTANCE_T *in,
    RULE_TYPE_RULE_INSTANCE_OBJECT_T *out)
{
    RULE_TYPE_SHM_POINTER_T ptr = {RULE_TYPE_NIL, 0};

    ASSERT(NULL != in);

    RULE_CTRL_IN_VALIDATE_PTR(in);

    ptr.type = in->super.type;
    ptr.offset = L_CVRT_GET_OFFSET(RULE_CTRL_IN_BaseAddress(in->super.type), in);

    RULE_CTRL_IN_Priv_ConstructRuleInstanceObjectFromPointer(ptr, out);
}


/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_CreateRuleInstanceObject
 *------------------------------------------------------------------------------
 * PURPOSE  : Create rule instance object
 * INPUT    : type  - type of instance
 * OUTPUT   : out   - instance object
 * RETURN   : RULE_TYPE_OK; error code
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_IN_Priv_CreateRuleInstanceObject(
    RULE_TYPE_INSTANCE_TYPE_T type,
    RULE_TYPE_RULE_INSTANCE_OBJECT_T *out)
{
    RULE_TYPE_SHM_POINTER_T ptr;

    ASSERT(NULL != out);

    memset(out, 0, sizeof(*out));

    ptr = RULE_CTRL_IN_Priv_CreateRuleInstance(type);
    if (RULE_TYPE_NIL == ptr.type)
    {
        return RULE_TYPE_FAIL;
    }

    RULE_CTRL_IN_Priv_ConstructRuleInstanceObjectFromPointer(ptr, out);

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IN_Priv_DestroyRuleInstanceObject
 *------------------------------------------------------------------------------
 * PURPOSE  : Destroy rule instance
 * INPUT    : this  - instance object
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK; error code
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_IN_Priv_DestroyRuleInstanceObject(
    RULE_TYPE_RULE_INSTANCE_OBJECT_T *this)
{
    ASSERT(NULL != this);

    RULE_CTRL_IN_Priv_DestroyRuleInstance(this->ptr);
    return RULE_TYPE_OK;
}

//
// Help Functions
//

//
// RULE_CTRL_IN_Priv_Walk
//
static void
RULE_CTRL_IN_Priv_Walk(
    RULE_TYPE_INSTANCE_PTR_T in,
    void(*fn)(RULE_TYPE_INSTANCE_PTR_T, void*),
    void *cooike)
{
    ASSERT(NULL != in);

    if (TRUE == RULE_CTRL_IS_CONTAINER_TYPE(in->type))
    {
        RULE_TYPE_CONTAINER_OBJECT_T obj;
        RULE_TYPE_CONTAINER_ELEMENT_ITERATOR_T iter;

        RULE_CTRL_IN_Priv_ConstructContainerObject((RULE_TYPE_CONTAINER_PTR_T) in, &obj);
        obj.get_element_iterator(&obj, &iter);

        for (iter.first(&iter); NULL != iter.get_instance(&iter); iter.next(&iter))
        {
            RULE_TYPE_INSTANCE_PTR_T child;

            child = iter.get_instance(&iter);

            RULE_CTRL_IN_Priv_Walk(child, fn, cooike);
        }
    }
    else if (TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(in->type))
    {
        RULE_TYPE_CLASS_INSTANCE_OBJECT_T obj;
        RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T iter;

        RULE_CTRL_IN_Priv_ConstructClassInstanceObject((RULE_TYPE_CLASS_INSTANCE_PTR_T) in, &obj);
        obj.get_element_iterator(&obj, &iter);

        for (iter.first(&iter); NULL != iter.get_instance(&iter); iter.next(&iter))
        {
            RULE_TYPE_INSTANCE_PTR_T child;

            child = iter.get_instance(&iter);

            RULE_CTRL_IN_Priv_Walk(child, fn, cooike);
        }
    }
    else if (TRUE == RULE_CTRL_IS_RULE_INSTANCE_TYPE(in->type))
    {
    }
    else
    {
        ASSERT(0);
    }

    fn(in, cooike);
}

//
// RULE_CTRL_IN_Priv_FindIf
//
typedef struct
{
    BOOL_T (*fn) (RULE_TYPE_INSTANCE_PTR_T, void *);
    void *fn_param;

    RULE_TYPE_INSTANCE_PTR_T result;
} RULE_CTRL_FIND_IF_PARAM_T, *RULE_CTRL_FIND_IF_PARAM_PTR_T;

static void
RULE_CTRL_IN_Priv_FindIf_CallBack(
    RULE_TYPE_INSTANCE_PTR_T in,
    void *cookie)
{
    RULE_CTRL_FIND_IF_PARAM_PTR_T param = cookie;
    BOOL_T b_result;

    if (param->result)
    {
        return;
    }

    b_result = param->fn(in, param->fn_param);
    if (TRUE == b_result)
    {
        param->result = in;
    }
}

static RULE_TYPE_INSTANCE_PTR_T
RULE_CTRL_IN_Priv_FindIf(
    RULE_TYPE_INSTANCE_PTR_T in,
    BOOL_T (*fn)(RULE_TYPE_INSTANCE_PTR_T, void*),
    void *cookie)
{
    RULE_CTRL_FIND_IF_PARAM_T param = {0};

    param.fn = fn;
    param.fn_param = cookie;

    RULE_CTRL_IN_Priv_Walk(in, RULE_CTRL_IN_Priv_FindIf_CallBack, &param);

    return param.result;
}

//
// RULE_CTRL_IN_Priv_CountIf
//
typedef struct
{
    BOOL_T (*fn) (RULE_TYPE_INSTANCE_PTR_T, void *);
    void *fn_param;

    UI32_T result;
} RULE_CTRL_COUNT_IF_PARAM_T, *RULE_CTRL_COUNT_IF_PARAM_PTR_T;

static void
RULE_CTRL_IN_Priv_CountIf_CallBack(
    RULE_TYPE_INSTANCE_PTR_T in,
    void *cookie)
{
    RULE_CTRL_COUNT_IF_PARAM_PTR_T param = cookie;
    BOOL_T b_result;

    b_result = param->fn(in, param->fn_param);
    if (TRUE == b_result)
    {
        param->result += 1;
    }
}

static UI32_T
RULE_CTRL_IN_Priv_CountIf(
    RULE_TYPE_INSTANCE_PTR_T in,
    BOOL_T (*fn)(RULE_TYPE_INSTANCE_PTR_T, void*),
    void *cookie)
{
    RULE_CTRL_COUNT_IF_PARAM_T param = {0};

    param.fn = fn;
    param.fn_param = cookie;

    RULE_CTRL_IN_Priv_Walk(in, RULE_CTRL_IN_Priv_CountIf_CallBack, &param);

    return param.result;
}

#pragma mark End of Instance Functions
#pragma mark -

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetQoSAce2Dev
 *------------------------------------------------------------------------------
 * PURPOSE  : install a rule for QoS ace to ASIC.
 *
 * INPUT    :   unit, port:
 *                group_id:
 *                 rule_id: device rule id to install.
 *               ace_entry:
 *             meter_entry:
 *            action_entry:
 *                  sm_rid: share meter id with this device rule id.
 *
 * OUTPUT   : None
 *
 * RETURN   : TRUE/FALSE
 *
 * NOTE     : if sm_rid == RULE_CTRL_NO_SHARE_METER_ENTRY_ID
 *            we need to create a new meter for rule_id
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_SetQoSAce2Dev(
    BOOL_T is_ingress,
    UI32_T unit,
    UI32_T port,
    UI32_T group_id,
    UI32_T rule_id,
    const RULE_TYPE_Ace_Entry_T *ace_entry_p,
    const RULE_TYPE_TBParamEntry_T *meter_entry_p,
    const RULE_TYPE_Action_T *action_entry_p,
    UI32_T sm_rid)
{
    UI32_T              ifindex, module_id, device_id, phy_port;

    DEVRM_ActionEntry_T *dev_action_p;
    DEVRM_MeterEntry_T  *meter_p =NULL;
    DEVRM_AceEntry_T    dev_ace_entry;
    DEVRM_MeterEntry_T  dev_meter_entry;
    DEVRM_PBMP_T          port_bit_map;


    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(unit, port, &module_id, &device_id, &phy_port))
        return FALSE;

    memset(&dev_ace_entry, 0, sizeof(DEVRM_AceEntry_T));
    memset(&dev_meter_entry, 0, sizeof(DEVRM_MeterEntry_T));

    if (FALSE == RULE_CTRL_ConvertAce2DevForQosPurpose(unit, port, ace_entry_p, &dev_ace_entry))
    {
        return FALSE;
    }

    if(is_ingress)
    {
        DEVRM_SHR_BITSET(dev_ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);

        DEVRM_PBMP_CLEAR(port_bit_map);
        DEVRM_PBMP_PORT_ADD(port_bit_map, phy_port);
        RULE_CTRL_SET_FILTER_IPBM(dev_ace_entry, port_bit_map);
    }
    else
    {
        DEVRM_SHR_BITSET(dev_ace_entry.w, DEVRM_FIELD_QUALIFY_OutPort);
        dev_ace_entry.outport_data = phy_port;
        dev_ace_entry.outport_mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    ifindex = STKTPLG_OM_UPORT_TO_IFINDEX(unit, port);

    dev_action_p = RULE_CTRL_Convert_Action2DEV(ifindex, is_ingress,
                       action_entry_p); /* MUST free returned pointer */
    if (NULL == dev_action_p)
        return FALSE;

    /* if we have a sm_rid, we need to set meter_p to NULL,
       then RULE_CTRL_Set_Rule will not create a new meter.
     */
    if (RULE_CTRL_NO_SHARE_METER_ENTRY_ID == sm_rid && NULL != meter_entry_p)
    {
        if (TRUE == RULE_CTRL_LocalConvertMeter2Dev(meter_entry_p, &dev_meter_entry))
            meter_p = &dev_meter_entry;
    }

    if (FALSE == RULE_CTRL_SET_RULE(unit, port, device_id, group_id,
                    rule_id, &dev_ace_entry, meter_p, dev_action_p, FALSE))
    {
        LOG("RULE_CTRL_SetQoSAce2Dev: RULE_CTRL_Share_Meter filed.");
        RULE_CTRL_FreeDevActionListMemory(dev_action_p);
        return FALSE;
    }

    RULE_CTRL_FreeDevActionListMemory(dev_action_p);

    /* if we have a sm_rid, we need to call RULE_CTRL_Share_Meter
       to share the meter.
     */
    if (RULE_CTRL_NO_SHARE_METER_ENTRY_ID != sm_rid)
    {
        if (FALSE == RULE_CTRL_SHARE_METER(unit, port, device_id, sm_rid, rule_id))
        {
            LOG("RULE_CTRL_SetQoSAce2Dev: RULE_CTRL_Share_Meter filed.");
            return FALSE;
        }
    }

    return TRUE;
}

static BOOL_T
RULE_CTRL_LocalConvertMeter2Dev(
    const RULE_TYPE_TBParamEntry_T *meter_entry_p,
    DEVRM_MeterEntry_T *dev_meter_entry)
{
    dev_meter_entry->meter_mode = meter_entry_p->meter_model;
    if(BCM_FIELD_METER_MODE_FLOW == dev_meter_entry->meter_mode)
    {
        dev_meter_entry->meter_num   = BCM_FIELD_METER_PEAK;
    }

    dev_meter_entry->kbits_sec   = meter_entry_p->rate;
    dev_meter_entry->kbytes_burst = ((meter_entry_p->burst_size + 500) / 1000);
    dev_meter_entry->peak_kbits_sec   = meter_entry_p->peak_rate;
    dev_meter_entry->peak_kbytes_burst = ((meter_entry_p->peak_burst_size + 500) / 1000);

    return TRUE;
}

static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Ifindex_To_Interface(
    UI32_T ifindex,
    RULE_TYPE_INTERFACE_INFO_T *interface_p)
{
    ASSERT(NULL != interface_p);

#define TOTAL_NBR_OF_ETHER (SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK * SYS_ADPT_MAX_NBR_OF_PORT_PER_UNIT)

    if (SYS_ADPT_ETHER_1_IF_INDEX_NUMBER <= ifindex &&
        ifindex <= (SYS_ADPT_ETHER_1_IF_INDEX_NUMBER + TOTAL_NBR_OF_ETHER - 1))
    {
        interface_p->type = RULE_TYPE_INTERFACE_UPORT;
        interface_p->uport.unit = STKTPLG_OM_IFINDEX_TO_UNIT(ifindex);
        interface_p->uport.port = STKTPLG_OM_IFINDEX_TO_PORT(ifindex);
    }
    else if (SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER <= ifindex &&
             ifindex <= (SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER + SYS_ADPT_MAX_NBR_OF_TRUNK_PER_SYSTEM - 1))
    {
        interface_p->type = RULE_TYPE_INTERFACE_TRUNK;
        interface_p->trunk_id = STKTPLG_OM_IFINDEX_TO_TRUNKID(ifindex);
    }
    else if (SYS_ADPT_CPU_1_IF_INDEX_NUMBER == ifindex)
    {
        interface_p->type = RULE_TYPE_INTERFACE_CPU_PORT;
    }
#if (RULE_CTRL_HAVE_CRAFT_PORT == TRUE)
    else if (SYS_ADPT_CRAFT_INTERFACE_IFINDEX == ifindex)
    {
        interface_p->type = RULE_TYPE_INTERFACE_CRAFT_PORT;
    }
#endif /* RULE_CTRL_HAVE_CRAFT_PORT */
    else if (RULE_TYPE_ALL_PORTS_1_IF_INDEX_NUMBER == ifindex)
    {
        interface_p->type = RULE_TYPE_INTERFACE_ALL_UNIT;
    }
    else
    {
        ASSERT(0);
        return RULE_TYPE_FAIL;
    }

    return RULE_TYPE_OK;

#undef TOTAL_NBR_OF_ETHER
}

static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Interface_To_Ifindex(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p,
    UI32_T *ifindex_p)
{
    ASSERT(NULL != interface_p);

    switch (interface_p->type)
    {
        case RULE_TYPE_INTERFACE_UPORT:
            *ifindex_p = STKTPLG_OM_UPORT_TO_IFINDEX(interface_p->uport.unit,
                                                     interface_p->uport.port);
            break;

        case RULE_TYPE_INTERFACE_TRUNK:
            *ifindex_p = STKTPLG_OM_TRUNKID_TO_IFINDEX(interface_p->trunk_id);
            break;

        case RULE_TYPE_INTERFACE_CPU_PORT:
            *ifindex_p = SYS_ADPT_CPU_1_IF_INDEX_NUMBER;
            break;

#if (RULE_CTRL_HAVE_CRAFT_PORT == TRUE)
        case RULE_TYPE_INTERFACE_CRAFT_PORT:
            *ifindex_p = SYS_ADPT_CRAFT_INTERFACE_IFINDEX;
            break;
#endif /* RULE_CTRL_HAVE_CRAFT_PORT */

        case RULE_TYPE_INTERFACE_ALL_UNIT:
            *ifindex_p = RULE_TYPE_ALL_PORTS_1_IF_INDEX_NUMBER;
            break;

        default:
            ASSERT(0);
            *ifindex_p = 0xffffffff;
            return RULE_TYPE_FAIL;
    }

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_ConvertDev2IscAction
 *------------------------------------------------------------------------------
 * PURPOSE  : convert devrm action to isc buffer action
 * INPUT    : dev_action
 * OUTPUT   : isc_buf
 * RETURN   : TRUE -- succeeded / FALSE -- failed
 * NOTE     : because dev_action is a link-list, MUST translate it to array
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_ConvertDev2IscAction(const DEVRM_ActionEntry_T *dev_action, RULE_CTRL_IscBuf_T *isc_buf)
{
    const DEVRM_ActionEntry_T   *action_iter_p;

    if ((NULL == dev_action) || (NULL == isc_buf))
        return FALSE;

    /* convert action iteratively */
    for (action_iter_p = dev_action, isc_buf->RULECTRLINFO.action_nbr = 0;
        NULL != action_iter_p;
        action_iter_p = action_iter_p->next_action, ++(isc_buf->RULECTRLINFO.action_nbr))
    {
        if (RULE_CTRL_ISC_MAX_NBR_OF_ACTION <= isc_buf->RULECTRLINFO.action_nbr)
        {
            printf("\r\n[RULE_CTRL_ConvertDev2IscAction] ISC can't send action more than %d", RULE_CTRL_ISC_MAX_NBR_OF_ACTION);
            return FALSE;
        }

        memcpy (&isc_buf->RULECTRLINFO.action_entry[isc_buf->RULECTRLINFO.action_nbr],
                    action_iter_p, sizeof(DEVRM_ActionEntry_T));
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_ConvertIsc2DevAction
 *------------------------------------------------------------------------------
 * PURPOSE  : convert isc buffer action to devrm action
 * INPUT    : isc_buf
 * OUTPUT   : isc_buf->action_entry[i].next_action
 * RETURN   : TRUE -- succeeded / FALSE -- failed
 * NOTE     : because action in isc buffer is an array, MUST translate it to a link-list
 *            ONLY change the next_action pointer by ISC acction_entry array
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_ConvertIsc2DevAction(RULE_CTRL_IscBuf_T *isc_buf)
{
    UI32_T                  index;

    if (NULL == isc_buf)
        return FALSE;

    if ((0 >= isc_buf->RULECTRLINFO.action_nbr) || (RULE_CTRL_ISC_MAX_NBR_OF_ACTION <= isc_buf->RULECTRLINFO.action_nbr))
        return FALSE;

    for (index = 1; index < isc_buf->RULECTRLINFO.action_nbr; ++index)
    {
        isc_buf->RULECTRLINFO.action_entry[index - 1].next_action = &isc_buf->RULECTRLINFO.action_entry[index];
    }

    /* ensure last entry point to NULL */
    isc_buf->RULECTRLINFO.action_entry[isc_buf->RULECTRLINFO.action_nbr - 1].next_action = NULL;
    return TRUE;
}

static BOOL_T
RULE_CTRL_SetAce2Dev(
    BOOL_T is_ingress,
    UI32_T unit,
    UI32_T port,
    UI32_T group_id,
    UI32_T dev_rule_id,
    const RULE_TYPE_Ace_Entry_T *ace_entry_p,
    UI32_T ace_index,
    RULE_TYPE_COUNTER_ENABLE_T counter_enable)
{
    DEVRM_PBMP_T  port_bit_map;
    UI32_T      module_id, device_id, phy_port;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(unit, port, &module_id, &device_id, &phy_port))
        return FALSE;

    DEVRM_PBMP_CLEAR(port_bit_map);
    DEVRM_PBMP_PORT_ADD(port_bit_map, phy_port);

    return RULE_CTRL_AddRule2DevForAclPurpose(is_ingress, unit, port, device_id,
        group_id, dev_rule_id, port_bit_map, ace_entry_p, ace_index, counter_enable);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_ConvertAce2DevForAclPurpose
 *------------------------------------------------------------------------------
 * PURPOSE  : convert an ace of ACL to a dev ace and action entry
 * INPUT    : ace_entry
 * OUTPUT   : dev_ace_entry, action_entry
 * RETURN   : TRUE/FALSE.
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_ConvertAce2DevForAclPurpose(
    RULE_TYPE_Ace_Entry_T *ace_entry,
    DEVRM_AceEntry_T *dev_ace_entry,
    DEVRM_ActionEntry_T *action_entry)
{
    if ((NULL == ace_entry) || (NULL == dev_ace_entry) || (NULL == action_entry))
        return FALSE;

    memset(dev_ace_entry, 0, sizeof(DEVRM_AceEntry_T));

    RULE_CTRL_INITIALIZE_ACTION_ENTRY(action_entry);

    if (RULE_TYPE_ACE_DENY == ace_entry->access)
    {
        RULE_CTRL_SET_ACTION_DROP(action_entry[0]);
#if (SYS_CPNT_ACL_DENY_DISCARD_ALL_PACKET_FOR_MEF_9_DISCARD_L2CP == TRUE)
        RULE_CTRL_SET_ACTION_SWITCH_TO_CPU_CANCEL(action_entry[1]);
        action_entry[0].next_action = &action_entry[1];
#endif
    }
    else
    {
        /* Drop packet while one of the MAC/IPv4/IPv6 ACL action is deny
         */
        //RULE_CTRL_SET_ACTION_DROP_CANCEL(action_entry[0]);
    }

    switch(ace_entry->ace_type)
    {
        case RULE_TYPE_MAC_ACL:

            if (FALSE == RULE_CTRL_ConvertMacAce2DevAce(&ace_entry->u.mac, dev_ace_entry))
                return FALSE;
            break;

        case RULE_TYPE_IP_ACL:
        case RULE_TYPE_IP_STD_ACL:
        case RULE_TYPE_IP_EXT_ACL:

            if (FALSE == RULE_CTRL_ConvertIpAce2DevAce(&ace_entry->u.ip, dev_ace_entry))
                return FALSE;
            break;

        case RULE_TYPE_MF:
            return FALSE;

        case RULE_TYPE_IPV6_ACL:
        case RULE_TYPE_IPV6_STD_ACL:
        case RULE_TYPE_IPV6_EXT_ACL:

            if (FALSE == RULE_CTRL_ConvertIpv6Ace2DevAce(&ace_entry->u.ipv6, dev_ace_entry))
                return FALSE;
            break;

        default:
            return FALSE;
    }
    return TRUE;
}


/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_ConvertAce2DevForQosPurpose
 *------------------------------------------------------------------------------
 * PURPOSE  : convert an ace of QoS to a dev ace
 * INPUT    : unit, port, ace_entry
 * OUTPUT   : dev_ace_entry
 * RETURN   : TRUE/FALSE.
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_ConvertAce2DevForQosPurpose(
    UI32_T unit,
    UI32_T port,
    const RULE_TYPE_Ace_Entry_T *ace_entry,
    DEVRM_AceEntry_T *dev_ace_entry)
{
    if ((NULL == ace_entry) || (NULL == dev_ace_entry))
        return FALSE;

    memset(dev_ace_entry, 0, sizeof(DEVRM_AceEntry_T));

#if 0
    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(unit, port, &module_id, &device_id, &phy_port))
        return FALSE;

    dev_ace_entry->entry_qualify |= DEVRM_FIELD_QUALIFY_MASK_SRCPORTTGID;
    dev_ace_entry->srcporttgid_data = phy_port;
    memset(&dev_ace_entry->srcporttgid_mask, 0xff, sizeof(dev_ace_entry->srcporttgid_mask));
#endif

    switch(ace_entry->ace_type)
    {
        case RULE_TYPE_MAC_ACL:
            if (FALSE == RULE_CTRL_ConvertMacAce2DevAce(&ace_entry->u.mac, dev_ace_entry))
                return FALSE;
            break;

        case RULE_TYPE_IP_ACL:
        case RULE_TYPE_IP_STD_ACL:
        case RULE_TYPE_IP_EXT_ACL:
            if (FALSE == RULE_CTRL_ConvertIpAce2DevAce(&ace_entry->u.ip, dev_ace_entry))
                return FALSE;
            RULE_CTRL_ADD_FILTER_IPTYPE(dev_ace_entry, bcmFieldIpTypeIpv4Any);
            break;

        case RULE_TYPE_MF:
            return FALSE;

        case RULE_TYPE_IPV6_ACL:
        case RULE_TYPE_IPV6_STD_ACL:
        case RULE_TYPE_IPV6_EXT_ACL:
            if (FALSE == RULE_CTRL_ConvertIpv6Ace2DevAce(&ace_entry->u.ipv6, dev_ace_entry))
                return FALSE;
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_ConvertMacAce2DevAce
 *------------------------------------------------------------------------------
 * PURPOSE  : convert mac ace to dev ace
 * INPUT    : mac_ace, dev_ace
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_ConvertMacAce2DevAce(const RULE_TYPE_MacAce_Entry_T *mac_ace, DEVRM_AceEntry_T *dev_ace)
{
    if ((NULL == mac_ace) || (NULL == dev_ace))
        return FALSE;

    switch (mac_ace->acePktformat)
    {
        case VAL_diffServMacAcePktformat_any:
            RULE_CTRL_ADD_FILTER_L2FORMAT(dev_ace, bcmFieldL2FormatAny);
            break;

        case VAL_diffServMacAcePktformat_untagged_Eth2:
            RULE_CTRL_ADD_FILTER_L2FORMAT(dev_ace, bcmFieldL2FormatEthII);
            RULE_CTRL_ADD_FILTER_VLANFORMAT(dev_ace, 0, BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED);
            break;

        case VAL_diffServMacAcePktformat_untagged802Dot3:
            RULE_CTRL_ADD_FILTER_L2FORMAT(dev_ace, bcmFieldL2Format802dot3);
            RULE_CTRL_ADD_FILTER_VLANFORMAT(dev_ace, 0, BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED);
            break;

        case VAL_diffServMacAcePktformat_tagggedEth2:
            RULE_CTRL_ADD_FILTER_L2FORMAT(dev_ace, bcmFieldL2FormatEthII);
            RULE_CTRL_ADD_FILTER_VLANFORMAT(dev_ace, BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED, BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED);
            break;

        case VAL_diffServMacAcePktformat_tagged802Dot3:
            RULE_CTRL_ADD_FILTER_L2FORMAT(dev_ace, bcmFieldL2Format802dot3);
            RULE_CTRL_ADD_FILTER_VLANFORMAT(dev_ace, BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED, BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED);
            break;

        default:
            break; /* ignore this field */
    }

    if (FALSE == RULE_CTRL_IsNullMac(mac_ace->aceSourceMacAddrBitmask))
    {
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_SrcMac);
        memcpy(dev_ace->srcmac_data, mac_ace->aceSourceMacAddr, SYS_ADPT_MAC_ADDR_LEN);
        memcpy(dev_ace->srcmac_mask, mac_ace->aceSourceMacAddrBitmask, SYS_ADPT_MAC_ADDR_LEN);
    }

    if (FALSE == RULE_CTRL_IsNullMac(mac_ace->aceDestMacAddrBitmask))
    {
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_DstMac);
        memcpy(dev_ace->dstmac_data, mac_ace->aceDestMacAddr, SYS_ADPT_MAC_ADDR_LEN);
        memcpy(dev_ace->dstmac_mask, mac_ace->aceDestMacAddrBitmask, SYS_ADPT_MAC_ADDR_LEN);
    }

    if (mac_ace->aceVidOp == VAL_diffServMacAceVidOp_equal)
    {
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_OuterVlan);
        dev_ace->outvlan_data = mac_ace->aceMinVid;
        dev_ace->outvlan_mask = mac_ace->aceVidBitmask & 0xfff;
    }

    if (mac_ace->aceCosOp == VAL_diffServMacAceCosOp_equal)
    {
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_OuterVlanPri);
        dev_ace->outvlanpri_data = mac_ace->aceMinCos;
        dev_ace->outvlanpri_mask = mac_ace->aceCosBitmask;
    }

    if (mac_ace->aceEtherTypeOp == VAL_diffServMacAceEtherTypeOp_equal)
    {
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_EtherType);
        dev_ace->ethertype_data = mac_ace->aceMinEtherType;
        dev_ace->ethertype_mask = mac_ace->aceEtherTypeBitmask;

        /* match eth-2 packet only, if packet format is not specified.
         *
         * Note:
         *   seems xgs3 can not exactly match ethertype
         *     if input packet is not eth-2 packet.
         */
        if (bcmFieldL2FormatAny == dev_ace->l2format)
        {
            RULE_CTRL_ADD_FILTER_L2FORMAT(dev_ace, bcmFieldL2FormatEthII);
        }
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_ConvertIpAce2DevAce
 *------------------------------------------------------------------------------
 * PURPOSE  : convert ip ace to dev ace
 * INPUT    : ip_ace, dev_ace
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_ConvertIpAce2DevAce(const RULE_TYPE_IpAce_Entry_T *ip_ace, DEVRM_AceEntry_T *dev_ace)
{
    if ((NULL == ip_ace) || (NULL == dev_ace))
        return FALSE;

    if(ip_ace->aceSourceIpAddrBitmask != RULE_TYPE_ACL_IP_BITMASK_ANY)
    {
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_SrcIp);
        dev_ace->srcip_data = ip_ace->aceSourceIpAddr;
        dev_ace->srcip_mask = ip_ace->aceSourceIpAddrBitmask;
    }

    if(ip_ace->aceDestIpAddrBitmask != RULE_TYPE_ACL_IP_BITMASK_ANY)
    {
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_DstIp);
        dev_ace->dstip_data = ip_ace->aceDestIpAddr;
        dev_ace->dstip_mask = ip_ace->aceDestIpAddrBitmask;
    }

    if (ip_ace->aceProtocol != RULE_TYPE_UNDEF_IP_PROTOCOL)
    {
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_IpProtocol);
        RULE_CTRL_SET_FILTER_IPPROTOCOL((*dev_ace), ip_ace->aceProtocol);
    }

    if (ip_ace->acePrec != RULE_TYPE_UNDEF_IP_PRECEDENCE)
    {
        RULE_CTRL_ADD_FILTER_DSCP(dev_ace, ip_ace->acePrec, RULE_CTRL_PRECEDENCE_MASK,
                                    RULE_CTRL_PRECEDENCE_OFFSET_IN_TOS_FIELD);
    }

    if (ip_ace->aceTos != RULE_TYPE_UNDEF_IP_TOS)
    {
        RULE_CTRL_ADD_FILTER_DSCP(dev_ace, ip_ace->aceTos, RULE_CTRL_TOS_MASK,
                                    RULE_CTRL_TOS_OFFSET_IN_TOS_FIELD);
    }

    if (ip_ace->aceDscp != RULE_TYPE_UNDEF_IP_DSCP)
    {
        RULE_CTRL_ADD_FILTER_DSCP(dev_ace, ip_ace->aceDscp, RULE_CTRL_DSCP_MASK,
                                    RULE_CTRL_DSCP_OFFSET_IN_TOS_FIELD);
    }

    if (ip_ace->aceSourcePortOp == VAL_diffServIpAceSourcePortOp_equal) /* currently only support this operator */
    {
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_L4SrcPort);
        dev_ace->l4_srcport_data = ip_ace->aceMinSourcePort;
        dev_ace->l4_srcport_mask = ip_ace->aceSourcePortBitmask;
    }

    if (ip_ace->aceDestPortOp == VAL_diffServIpAceDestPortOp_equal) /* currently only support this operator */
    {
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_L4DstPort);
        dev_ace->l4_dstport_data = ip_ace->aceMinDestPort;
        dev_ace->l4_dstport_mask = ip_ace->aceDestPortBitmask;
    }

    if (ip_ace->aceControlCodeBitmask != MIN_diffServIpAceControlCodeBitmask)
    {
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_TcpControl);
        dev_ace->tcpcontrol_data = ip_ace->aceControlCode;
        dev_ace->tcpcontrol_mask = ip_ace->aceControlCodeBitmask;
    }

    /* match ipv4 packets only
     */
    RULE_CTRL_ADD_FILTER_IPTYPE(dev_ace, bcmFieldIpTypeIpv4Any);

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_ConvertIpv6Ace2DevAce
 *------------------------------------------------------------------------------
 * PURPOSE  : convert ipv6 ace to dev ace
 * INPUT    : ipv6_ace, dev_ace
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_ConvertIpv6Ace2DevAce(const RULE_TYPE_Ipv6Ace_Entry_T *ipv6_ace, DEVRM_AceEntry_T *dev_ace)
{
    if ((FALSE == RULE_CTRL_ConvertIpv6Ace2ExtDevAce(ipv6_ace, dev_ace)) ||
        (FALSE == RULE_CTRL_ConvertIpv6Ace2StdDevAce(ipv6_ace, dev_ace)))
    {
        return FALSE;
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_ConvertIpv6Ace2ExtDevAce
 *------------------------------------------------------------------------------
 * PURPOSE  : convert ipv6 ace to dev ace of ext selector
 * INPUT    : ipv6_ace, dev_ace
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_ConvertIpv6Ace2ExtDevAce(const RULE_TYPE_Ipv6Ace_Entry_T *ipv6_ace, DEVRM_AceEntry_T *dev_ace)
{
#define IS_NOT_ZERO_IP6_ADDR(addr) \
    (!(addr[0]==0 && addr[1]==0 && addr[2]==0 && addr[3]==0 &&      \
       addr[4]==0 && addr[5]==0 && addr[6]==0 && addr[7]==0 &&      \
       addr[8]==0 && addr[9]==0 && addr[10]==0 && addr[11]==0 &&    \
       addr[12]==0 && addr[13]==0 && addr[14]==0 && addr[15]==0))

    if ((NULL == ipv6_ace) || (NULL == dev_ace))
        return FALSE;

    if (IS_NOT_ZERO_IP6_ADDR(ipv6_ace->aceSourceIpAddrBitmask))
    {
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_SrcIp6);
        memcpy(dev_ace->srcip6_data, ipv6_ace->aceSourceIpAddr, SYS_ADPT_IPV6_ADDR_LEN);
        memcpy(dev_ace->srcip6_mask, ipv6_ace->aceSourceIpAddrBitmask, SYS_ADPT_IPV6_ADDR_LEN);
    }

    if (IS_NOT_ZERO_IP6_ADDR(ipv6_ace->aceDestIpAddrBitmask))
    {
        #if (SYS_ADPT_ACL_MAX_DST_IPV6_PREFIX_LEN <= 64)
        {
            DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_DstIp6High);
            memcpy(dev_ace->dstip6high_data, ipv6_ace->aceDestIpAddr, SYS_ADPT_IPV6_ADDR_LEN);
            memcpy(dev_ace->dstip6high_mask, ipv6_ace->aceDestIpAddrBitmask, SYS_ADPT_IPV6_ADDR_LEN);
        }
        #else
        {
            DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_DstIp6);
            memcpy(dev_ace->dstip6_data, ipv6_ace->aceDestIpAddr, SYS_ADPT_IPV6_ADDR_LEN);
            memcpy(dev_ace->dstip6_mask, ipv6_ace->aceDestIpAddrBitmask, SYS_ADPT_IPV6_ADDR_LEN);
        }
        #endif /* SYS_ADPT_ACL_MAX_DST_IPV6_PREFIX_LEN */
    }

    if (ipv6_ace->aceNextHeader != RULE_TYPE_UNDEF_IPV6_NEXT_HEADER)
    {
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_Ip6NextHeader);
        dev_ace->ip6nextheader_data = ipv6_ace->aceNextHeader;
        memset(&dev_ace->ip6nextheader_mask, 0xff, sizeof(dev_ace->ip6nextheader_mask));
    }

    if (ipv6_ace->aceDscp != RULE_TYPE_UNDEF_IPV6_DSCP)
    {
        /* in IPv6 use Traffic Class field to represent DSCP and its definition is same with IPv4 TOS field */
        RULE_CTRL_ADD_FILTER_TC(dev_ace, ipv6_ace->aceDscp, RULE_CTRL_DSCP_MASK,
                                    RULE_CTRL_DSCP_OFFSET_IN_TOS_FIELD);
    }

    if (ipv6_ace->aceFlowLabel != RULE_TYPE_UNDEF_IPV6_FLOW_LABEL)
    {
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_Ip6FlowLabel);
        dev_ace->ip6flowlabel_data = ipv6_ace->aceFlowLabel;
        dev_ace->ip6flowlabel_mask = 0xFFFFF; /* flow-label only has 20 bits */
    }

    if (ipv6_ace->aceSourcePortOp == VAL_diffServIpv6AceSourcePortOp_equal)
    {
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_L4SrcPort);
        dev_ace->l4_srcport_data = ipv6_ace->aceMinSourcePort;
        dev_ace->l4_srcport_mask = ipv6_ace->aceSourcePortBitmask;
    }

    if (ipv6_ace->aceDestPortOp == VAL_diffServIpv6AceDestPortOp_equal)
    {
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_L4DstPort);
        dev_ace->l4_dstport_data = ipv6_ace->aceMinDestPort;
        dev_ace->l4_dstport_mask = ipv6_ace->aceDestPortBitmask;
    }

    /* match ipv6 packets only
     */
    RULE_CTRL_ADD_FILTER_IPTYPE(dev_ace, bcmFieldIpTypeIpv6);

    return TRUE;

#undef IS_NOT_ZERO_IP6_ADDR
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_ConvertIpv6Ace2StdDevAce
 *------------------------------------------------------------------------------
 * PURPOSE  : convert ipv6 ace to dev ace of std selector
 * INPUT    : ipv6_ace, dev_ace
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_ConvertIpv6Ace2StdDevAce(const RULE_TYPE_Ipv6Ace_Entry_T *ipv6_ace, DEVRM_AceEntry_T *dev_ace)
{
#define IS_NOT_ZERO_IP6_ADDR(addr) \
    (!(addr[0]==0 && addr[1]==0 && addr[2]==0 && addr[3]==0 &&      \
       addr[4]==0 && addr[5]==0 && addr[6]==0 && addr[7]==0 &&      \
       addr[8]==0 && addr[9]==0 && addr[10]==0 && addr[11]==0 &&    \
       addr[12]==0 && addr[13]==0 && addr[14]==0 && addr[15]==0))

    UI8_T mask[SYS_ADPT_IPV6_ADDR_LEN];

    if ((NULL == ipv6_ace) || (NULL == dev_ace))
        return FALSE;

    memcpy(mask, ipv6_ace->aceSourceIpAddrBitmask, SYS_ADPT_IPV6_ADDR_LEN);

    if (IS_NOT_ZERO_IP6_ADDR(mask))
    {
        DEVRM_SHR_BITSET(dev_ace->w, DEVRM_FIELD_QUALIFY_SrcIp6);
        memcpy(dev_ace->srcip6_data, ipv6_ace->aceSourceIpAddr, SYS_ADPT_IPV6_ADDR_LEN);
        memcpy(dev_ace->srcip6_mask, mask, SYS_ADPT_IPV6_ADDR_LEN);
    }

    /* match ipv6 packets only
     */
    RULE_CTRL_ADD_FILTER_IPTYPE(dev_ace, bcmFieldIpTypeIpv6);

    return TRUE;

#undef IS_NOT_ZERO_IP6_ADDR
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_AddRule2DevForAclPurpose
 *------------------------------------------------------------------------------
 * PURPOSE  : add rule to chip by ace entry
 * INPUT    : device_id, rule_id, port_bit_map, ace_entry, ace_index
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_AddRule2DevForAclPurpose(
    BOOL_T is_ingress,
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T group_id,
    UI32_T rule_id,
    DEVRM_PBMP_T port_bit_map,
    const RULE_TYPE_Ace_Entry_T *ace_entry_p,
    UI32_T ace_index,
    RULE_TYPE_COUNTER_ENABLE_T counter_enable)
{
    switch (ace_entry_p->ace_type)
    {
        case RULE_TYPE_MAC_ACL:
            return RULE_CTRL_AddMacRule2DevForAclPurpose(is_ingress, unit, port,
                       device_id, group_id, rule_id, port_bit_map,
                       ace_entry_p->access, &ace_entry_p->u.mac, counter_enable);

        case RULE_TYPE_IP_ACL:
        case RULE_TYPE_IP_STD_ACL:
        case RULE_TYPE_IP_EXT_ACL:
            return RULE_CTRL_AddIpRule2DevForAclPurpose(is_ingress, unit, port,
                       device_id, group_id, rule_id, port_bit_map,
                       ace_entry_p->access, &ace_entry_p->u.ip, counter_enable);

        case RULE_TYPE_IPV6_ACL:
        case RULE_TYPE_IPV6_STD_ACL:
        case RULE_TYPE_IPV6_EXT_ACL:
            return RULE_CTRL_AddIpv6Rule2DevForAclPurpose(is_ingress, unit, port,
                       device_id, group_id, rule_id, port_bit_map,
                       ace_entry_p->access, &ace_entry_p->u.ipv6, ace_entry_p->ace_type, counter_enable);

        case RULE_TYPE_MF:
        default:
            ASSERT(0);
            return FALSE;  /* should not go here */
    }

    return FALSE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_AddMacRule2DevForAclPurpose
 *------------------------------------------------------------------------------
 * PURPOSE  : add rule to chip by mac ace entry
 * INPUT    : unit, port, device_id, rule_id, mac_ace
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_AddMacRule2DevForAclPurpose(
    BOOL_T is_ingress,
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T group_id,
    UI32_T rule_id,
    DEVRM_PBMP_T port_bit_map,
    const RULE_TYPE_AceAction_T action,
    const RULE_TYPE_MacAce_Entry_T *mac_ace,
    RULE_TYPE_COUNTER_ENABLE_T counter_enable)
{
    UI32_T                              module_id, phy_port;
    DEVRM_AceEntry_T                    dev_ace;
    DEVRM_ActionEntry_T                 dev_action[2];

    if (NULL == mac_ace)
        return FALSE;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(unit, port, &module_id, &device_id, &phy_port))
        return FALSE;

    memset(&dev_ace, 0, sizeof(DEVRM_AceEntry_T));

    RULE_CTRL_INITIALIZE_ACTION_ENTRY(dev_action);

    if (FALSE == RULE_CTRL_ConvertMacAce2DevAce(mac_ace, &dev_ace))
        return FALSE;

    if(is_ingress)
    {
        DEVRM_SHR_BITSET(dev_ace.w, DEVRM_FIELD_QUALIFY_InPorts);
        RULE_CTRL_SET_FILTER_IPBM(dev_ace, port_bit_map);
    }
    else
    {
        DEVRM_SHR_BITSET(dev_ace.w, DEVRM_FIELD_QUALIFY_OutPort);
        dev_ace.outport_data = phy_port;
        dev_ace.outport_mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    if (RULE_TYPE_ACE_DENY == action)
    {
        RULE_CTRL_SET_ACTION_DROP(dev_action[0]);
#if (SYS_CPNT_ACL_DENY_DISCARD_ALL_PACKET_FOR_MEF_9_DISCARD_L2CP == TRUE)
        RULE_CTRL_SET_ACTION_SWITCH_TO_CPU_CANCEL(dev_action[1]);
        dev_action[0].next_action = &dev_action[1];
#endif
    }
    else
    {
        /* Drop packet while one of the MAC/IPv4/IPv6 ACL action is deny
         */
        //RULE_CTRL_SET_ACTION_DROP_CANCEL(dev_action[0]);
    }

    return RULE_CTRL_SET_RULE(unit, port, device_id, group_id,
                              rule_id, &dev_ace, NULL, dev_action, counter_enable);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_AddIpRule2DevForAclPurpose
 *------------------------------------------------------------------------------
 * PURPOSE  : add rule to chip by ip ace entry
 * INPUT    : unit, port, device_id, rule_id, ip_ace
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_AddIpRule2DevForAclPurpose(
    BOOL_T is_ingress,
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T group_id,
    UI32_T rule_id,
    DEVRM_PBMP_T port_bit_map,
    const RULE_TYPE_AceAction_T action,
    const RULE_TYPE_IpAce_Entry_T *ip_ace,
    RULE_TYPE_COUNTER_ENABLE_T counter_enable)
{
    UI32_T                              module_id, phy_port;
    DEVRM_AceEntry_T                    dev_ace;
    DEVRM_ActionEntry_T                 dev_action[2];

    if (NULL == ip_ace)
        return FALSE;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(unit, port, &module_id, &device_id, &phy_port))
        return FALSE;

    memset(&dev_ace, 0, sizeof(DEVRM_AceEntry_T));

    RULE_CTRL_INITIALIZE_ACTION_ENTRY(dev_action);

    if (FALSE == RULE_CTRL_ConvertIpAce2DevAce(ip_ace, &dev_ace))
    {
        return FALSE;
    }

    if(is_ingress)
    {
        DEVRM_SHR_BITSET(dev_ace.w, DEVRM_FIELD_QUALIFY_InPorts);
        RULE_CTRL_SET_FILTER_IPBM(dev_ace, port_bit_map);
    }
    else
    {
        DEVRM_SHR_BITSET(dev_ace.w, DEVRM_FIELD_QUALIFY_OutPort);
        dev_ace.outport_data = phy_port;
        dev_ace.outport_mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    if (RULE_TYPE_ACE_DENY == action)
    {
        RULE_CTRL_SET_ACTION_DROP(dev_action[0]);
#if (SYS_CPNT_ACL_DENY_DISCARD_ALL_PACKET_FOR_MEF_9_DISCARD_L2CP == TRUE)
        RULE_CTRL_SET_ACTION_SWITCH_TO_CPU_CANCEL(dev_action[1]);
        dev_action[0].next_action = &dev_action[1];
#endif
    }
    else
    {
        /* Drop packet while one of the MAC/IPv4/IPv6 ACL action is deny
         */
        //RULE_CTRL_SET_ACTION_DROP_CANCEL(dev_action[0]);
    }

    /*  2008-11-28, Jinfeng Chen:
        If the rule is "deny/permit any any", apply it to L2 not only IP packet.
        Otherwise only apply it to IP packet.
     */
    if(!RULE_OM_IsDefaultIpACE(ip_ace))
    {
        RULE_CTRL_ADD_FILTER_IPTYPE((&dev_ace), bcmFieldIpTypeIpv4Any);
    }

    return RULE_CTRL_SET_RULE(unit, port, device_id, group_id,
                              rule_id, &dev_ace, NULL, dev_action, counter_enable);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_AddIpv6Rule2DevForAclPurpose
 *------------------------------------------------------------------------------
 * PURPOSE  : add ipv6 ace rule to chip by ipv6 entry
 * INPUT    : unit, port, device_id, rule_id, ipv6_ace, ace_index
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_AddIpv6Rule2DevForAclPurpose(
    BOOL_T is_ingress,
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T group_id,
    UI32_T rule_id,
    DEVRM_PBMP_T port_bit_map,
    const RULE_TYPE_AceAction_T action,
    const RULE_TYPE_Ipv6Ace_Entry_T *ipv6_ace,
    UI32_T ace_type,
    RULE_TYPE_COUNTER_ENABLE_T counter_enable)
{
    UI32_T  module_id, phy_port;
    DEVRM_AceEntry_T                    dev_ace;
    DEVRM_ActionEntry_T                 dev_action[2];

    if (NULL == ipv6_ace)
        return FALSE;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(unit, port, &module_id, &device_id, &phy_port))
    {
        return FALSE;
    }

    memset(&dev_ace, 0, sizeof(DEVRM_AceEntry_T));

    switch (ace_type)
    {
    case RULE_TYPE_IPV6_STD_ACL:

        if (FALSE == RULE_CTRL_ConvertIpv6Ace2StdDevAce(ipv6_ace, &dev_ace))
        {
            LOG("RULE_CTRL_ConvertIpv6Ace2StdDevAce fail");
            return FALSE;
        }
        break;

    case RULE_TYPE_IPV6_EXT_ACL:

        if (FALSE == RULE_CTRL_ConvertIpv6Ace2ExtDevAce(ipv6_ace, &dev_ace))
        {
            LOG("RULE_CTRL_ConvertIpv6Ace2ExtDevAce fail");
            return FALSE;
        }
        break;

    default:
        LOG("Unknown ace type");
        return FALSE;
    }

    if(is_ingress)
    {
        DEVRM_SHR_BITSET(dev_ace.w, DEVRM_FIELD_QUALIFY_InPorts);
        RULE_CTRL_SET_FILTER_IPBM(dev_ace, port_bit_map);
    }
    else
    {
        DEVRM_SHR_BITSET(dev_ace.w, DEVRM_FIELD_QUALIFY_OutPort);
        dev_ace.outport_data = phy_port;
        dev_ace.outport_mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    RULE_CTRL_INITIALIZE_ACTION_ENTRY(dev_action);

    if (RULE_TYPE_ACE_DENY == action)
    {
        RULE_CTRL_SET_ACTION_DROP(dev_action[0]);
#if (SYS_CPNT_ACL_DENY_DISCARD_ALL_PACKET_FOR_MEF_9_DISCARD_L2CP == TRUE)
        RULE_CTRL_SET_ACTION_SWITCH_TO_CPU_CANCEL(dev_action[1]);
        dev_action[0].next_action = &dev_action[1];
#endif
    }
    else
    {
        /* Drop packet while one of the MAC/IPv4/IPv6 ACL action is deny
         */
        //RULE_CTRL_SET_ACTION_DROP_CANCEL(dev_action[0]);
    }

    return RULE_CTRL_SET_RULE(unit, port, device_id, group_id, rule_id,
                              &dev_ace, NULL, dev_action, counter_enable);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalSetACL2DEV
 *------------------------------------------------------------------------------
 * PURPOSE  : Allocate and set rule for an ACL
 * INPUT    : unit, port, acl_id
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK ; Error code
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalSetACL2DEV(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    UI32_T acl_id,
    const RULE_TYPE_Acl_T *acl_entry_p,
    UI32_T time_range_index,
    RULE_TYPE_COUNTER_ENABLE_T counter_enable)
{
    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T group_id = 0xffffffff;
    UI32_T ace_index = 0;

    RULE_TYPE_AclType_T ace_type = 0;

    //
    // --== Duplicated code start
    //
    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

    RULE_TYPE_CONTAINER_PTR_T acl_container_p;
    RULE_TYPE_CONTAINER_OBJECT_T acl_container_obj;

    RULE_CTRL_INSTANCE_TYPE_ID_T param;
    //
    // --== End of duplicated code
    //

    RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p = NULL;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T acl_inst_obj;

    RULE_TYPE_Ace_Entry_T ace_entry;
    UI32_T rule_index = 0;

    UI32_T module_id, device_id, phy_port;
    RULE_CTRL_ResourceInfo_T *res_p = NULL;
    int rule_pri = 9999;
    BOOL_T is_active = TRUE;
    RULE_TYPE_FunctionType_T fun_type = RULE_TYPE_FUNCTION_TYPE_MAX;

    RULE_TYPE_FunctionType_T remap_fun_type = RULE_TYPE_FUNCTION_TYPE_MAX;

    BOOL_T b_result;

    ASSERT(NULL != interface_p);
    ASSERT(RULE_TYPE_INTERFACE_UPORT == interface_p->type);
    ASSERT(RULE_TYPE_INBOUND == interface_p->direction ||
           RULE_TYPE_OUTBOUND == interface_p->direction);
    ASSERT(NULL != acl_entry_p);

    LOG_IF(*interface_p, "aclId = %lu timeRangeId = %lu, counter = %s",
           acl_id, time_range_index, RULE_TYPE_COUNTER_ENABLE_STR(counter_enable));

    /** PATCH CODE !!
     * Remove this if we can well handle for undo set rule.
     */
    result = RULE_CTRL_LocalCheckAclOnBinding(interface_p, acl_id);
    if (RULE_TYPE_OK != result)
    {
        return result;
    }

    /** Due to chip limitation that it can not apply ACL and policy map
     * on egress direction at the same time.
     */
    if (RULE_TYPE_OUTBOUND == interface_p->direction)
    {
        RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;

        policy_map_inst_p = RULE_CTRL_Priv_GetPolicyMapInstance(interface_p);
        if (NULL != policy_map_inst_p)
        {
            LOG("<Error> Can't bind ACL and policy-map on egress direction at the same time");
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(interface_p->uport.unit,
                                                        interface_p->uport.port,
                                                        &module_id,
                                                        &device_id,
                                                        &phy_port))
    {
        ASSERT(0); // check by pubic function
        return RULE_TYPE_INVALID_PARAMETER;
    }

    //
    // --== Duplicated code start
    //
    if_entry_p = RULE_CTRL_Priv_GetIfEntry(interface_p);
    ASSERT(NULL != if_entry_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                              &if_class_obj);

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_CONTAINER;
    param.id = RULE_TYPE_INST_ACL;

    acl_container_p = (RULE_TYPE_CONTAINER_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                RULE_CTRL_Priv_IsMatchTypeId,
                                                                                &param);
    if (NULL == acl_container_p)
    {
        result = RULE_CTRL_IN_Priv_CreateContainerObject(&acl_container_obj);
        if (RULE_TYPE_OK != result)
        {
            /* Don't want to trigger rule defrag, so return FAIL
             */
            result = RULE_TYPE_FAIL;
            LOG("<Error> Insufficient container object");
            goto undo;
        }

        if_class_obj.add(&if_class_obj, (RULE_TYPE_INSTANCE_PTR_T) acl_container_obj.inst);

        acl_container_p = acl_container_obj.inst;

        acl_container_p->id = RULE_TYPE_INST_ACL;
    }
    else
    {
        RULE_CTRL_IN_Priv_ConstructContainerObject(acl_container_p, &acl_container_obj);
    }

    ASSERT(NULL != acl_container_p);
    ASSERT(acl_container_p == acl_container_obj.inst);

    param.type = RULE_TYPE_INST_ACL;
    param.id = acl_id;

    acl_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) acl_container_p,
                                                                                RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                &param);
    if (NULL != acl_inst_p)
    {
        LOG("<Error> Already bind the ACL");
        return RULE_TYPE_INVALID_PARAMETER;
    }
    //
    // --== End of duplicated code
    //

    acl_inst_p = NULL;

    /** The egress direction have not 'inports' qualify. So it does not support
     * ACL sharing.
     */
    if (RULE_TYPE_OUTBOUND == interface_p->direction)
    {
        goto dont_share;
    }

    acl_inst_p = RULE_CTRL_Priv_GetSharingAclInstance_2(interface_p, acl_id,
                                                        acl_entry_p,
                                                        time_range_index,
                                                        counter_enable);
    if (NULL != acl_inst_p)
    {
        ASSERT(RULE_TYPE_INTERFACE_UPORT == interface_p->type);
        ASSERT(acl_inst_p->id == acl_id);

        result = acl_container_obj.add(&acl_container_obj, (RULE_TYPE_INSTANCE_PTR_T) acl_inst_p);
        ASSERT(RULE_TYPE_OK == result);

        if (RULE_TYPE_OK != result)
        {
            LOG("<Internal Error> Add ACL instance");
            goto undo;
        }

        acl_inst_p->ref_count += 1;

        result = RULE_CTRL_Update_PortBitMap(RULE_TYPE_INBOUND == interface_p->direction ? TRUE : FALSE,
                                             TRUE,
                                             interface_p->uport.unit,
                                             interface_p->uport.port,
                                             acl_entry_p,
                                             acl_inst_p);
        if (RULE_TYPE_OK != result)
        {
            LOG("<Error> Update rule");
            goto undo;
        }

        return RULE_TYPE_OK;
    }

dont_share:

    if (FALSE == RULE_CTRL_GetFunctionInfoByAceTypeAndDirection(TRUE,
                                                                interface_p->direction == RULE_TYPE_INBOUND ? TRUE : FALSE,
                                                                acl_entry_p->acl_type,
                                                                &group_id,
                                                                &rule_pri))
    {
        result = RULE_TYPE_INVALID_PARAMETER;

        LOG("<Error> Get group ID");
        goto undo;
    }

    if (FALSE == RULE_CTRL_GetFunctionTypeForACLAndQoS(TRUE,
                                                       interface_p->direction == RULE_TYPE_INBOUND ? TRUE : FALSE,
                                                       acl_entry_p->acl_type,
                                                       &fun_type))
    {
        result = RULE_TYPE_INVALID_PARAMETER;

        LOG("<Error> Get function type");
        goto undo;
    }


    result = RULE_CTRL_Priv_FindBestFitFunctionType(interface_p->uport.unit,
                                                    device_id,
                                                    interface_p->direction,
                                                    acl_entry_p, &remap_fun_type);
    if (RULE_TYPE_OK != result)
    {
        return result;
    }

    RULE_CTRL_GetFunctionInfoByFunctionType(remap_fun_type, &group_id, &rule_pri);

    result = RULE_CTRL_Priv_SetupGroupByFunctionType(fun_type, remap_fun_type);
    ASSERT(RULE_TYPE_OK == result);

    res_p = RULE_CTRL_GetResourceInfo(interface_p->uport.unit,
                                      device_id, group_id);
    ASSERT(NULL != res_p);

    if (res_p->free_rule < acl_entry_p->ace_count)
    {
        result = RULE_TYPE_INSUFFICIENT_RESOURCE;

        LOG("<Error> Insuficient rule");
        goto undo;
    }

    ASSERT(NULL == acl_inst_p);

    /* install a new ACL instance on device
     */
    acl_inst_p = NULL;
    acl_inst_obj.inst = NULL;

    result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL, &acl_inst_obj);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> No any class instance available");
        goto undo;
    }

    result = acl_container_obj.add(&acl_container_obj, (RULE_TYPE_INSTANCE_PTR_T) acl_inst_obj.inst);
    ASSERT(RULE_TYPE_OK == result);

    if (RULE_TYPE_OK != result)
    {
        LOG("<Internal Error> Add ACL instance");
        goto undo;
    }

    acl_inst_p = acl_inst_obj.inst;

    acl_inst_p->ref_count = 1;
    acl_inst_p->acl_id = acl_id;

#if (SYS_CPNT_TIME_BASED_ACL == TRUE)
    acl_inst_p->time_range_index = time_range_index;
#endif /* SYS_CPNT_TIME_BASED_ACL */

#if (SYS_CPNT_ACL_COUNTER == TRUE)
    acl_inst_p->counter_enable = counter_enable;
#endif /* SYS_CPNT_ACL_COUNTER */

    acl_inst_p->fun_type = fun_type;

#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)
    acl_inst_p->remap_fun_type = remap_fun_type;

    if (acl_inst_p->fun_type != acl_inst_p->remap_fun_type)
    {
        const char *ary[] = RULE_TYPE_FUNCTION_TYPE_STRING_ARRAY;

        LOG("Eth %lu/%-2lu/%s, %s, %s --> %s \r\n",
            interface_p->uport.unit,
            interface_p->uport.port,
            RULE_TYPE_INBOUND == interface_p->direction ? "in" : "out",
            acl_entry_p->acl_name,
            ary[acl_inst_p->fun_type], ary[acl_inst_p->remap_fun_type]);
    }
#endif /* SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT */

    for (ace_index = 0;
         RULE_TYPE_OK == RULE_OM_GetNextAceByAcl(acl_id, &ace_type, &ace_index, &ace_entry);)
    {
        RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p;
        RULE_TYPE_CLASS_INSTANCE_OBJECT_T ace_inst_obj;

        RULE_TYPE_RULE_INSTANCE_OBJECT_T rule_inst_obj;

        int priority;

        /**
         * Create ACE instance
         */
        result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACE, &ace_inst_obj);
        if (RULE_TYPE_OK != result)
        {
            LOG("<Error> Failed to create ACE instance");
            goto undo;
        }

        ace_inst_p = ace_inst_obj.inst;

        ASSERT(NULL != ace_inst_p);

        ace_inst_p->id = ace_index;

        ace_inst_p->fun_type = acl_inst_p->fun_type;
#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)
        ace_inst_p->remap_fun_type = acl_inst_p->remap_fun_type;
#endif /* SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT */

        acl_inst_obj.add_class_obj(&acl_inst_obj, &ace_inst_obj);

        result = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &rule_inst_obj);
        if (RULE_TYPE_OK != result)
        {
            LOG("<Error> Create rule instance");
            goto undo;
        }

        result = RULE_CTRL_Priv_GetAcePriorityInAcl(acl_id, ace_index, &priority);
        ASSERT(RULE_TYPE_OK == result);

        rule_inst_obj.inst->ace_id = ace_index;

        rule_inst_obj.inst->dev_rule_info.unit = interface_p->uport.unit;
        rule_inst_obj.inst->dev_rule_info.device = device_id;
        rule_inst_obj.inst->dev_rule_info.group_id = group_id;
        rule_inst_obj.inst->dev_rule_info.fun_type = remap_fun_type;
        rule_inst_obj.inst->dev_rule_info.priority = priority;

        memset(rule_inst_obj.inst->dev_rule_info.port_bmp.pbits,
               0,
               sizeof(rule_inst_obj.inst->dev_rule_info.port_bmp.pbits));
        DEVRM_PBMP_PORT_ADD(rule_inst_obj.inst->dev_rule_info.port_bmp, phy_port);

        rule_inst_obj.inst->dev_rule_info.rule_id = 0;
        rule_inst_obj.inst->active = FALSE;

        ace_inst_obj.add_rule_obj(&ace_inst_obj, &rule_inst_obj);

        b_result = RULE_CTRL_RequestRuleByQuota(rule_inst_obj.inst->dev_rule_info.unit,
                                                rule_inst_obj.inst->dev_rule_info.device,
                                                rule_inst_obj.inst->dev_rule_info.fun_type,
                                                RULE_CTRL_REQUEST_RESOURCE_ALLOCATE,
                                                1);
        ASSERT(TRUE == b_result);

        rule_index = RULE_TYPE_UNDEF_RULE_INDEX;

#if (SYS_CPNT_TIME_BASED_ACL == TRUE)
        is_active = RULE_CTRL_LocalCheckRuleInActiveByTimeRange(ace_entry.time_range_index, time_range_index);
#endif /* SYS_CPNT_TIME_BASED_ACL */

        if (TRUE == is_active)
        {
            /*allocate rule set rule*/
            if (FALSE == RULE_CTRL_ALLOCATE_RULE(interface_p->uport.unit,
                                                 interface_p->uport.port,
                                                 rule_inst_obj.inst->dev_rule_info.device,
                                                 rule_inst_obj.inst->dev_rule_info.group_id,
                                                 rule_inst_obj.inst->dev_rule_info.fun_type,
                                                 rule_inst_obj.inst->dev_rule_info.priority,
                                                 &rule_index))
            {
                result = RULE_TYPE_INSUFFICIENT_RESOURCE;

                LOG("<Error> Allocate rule");
                goto undo;
            }

            rule_inst_obj.inst->dev_rule_info.rule_id = rule_index;
            rule_inst_obj.inst->active = TRUE;

            if (FALSE == RULE_CTRL_SetAce2Dev(RULE_TYPE_INBOUND == interface_p->direction ? TRUE : FALSE,
                                              interface_p->uport.unit,
                                              interface_p->uport.port,
                                              rule_inst_obj.inst->dev_rule_info.group_id,
                                              rule_inst_obj.inst->dev_rule_info.rule_id,
                                              &ace_entry, ace_index, counter_enable))
            {
                result = RULE_TYPE_FAIL;

                LOG("<Error> SetAce2Dev");
                goto undo;
            }
        }
    }

    return RULE_TYPE_OK;

undo:

    {
        RULE_TYPE_RETURN_TYPE_T temp_result;

        temp_result = RULE_CTRL_LocalRemoveACLFromDEV(interface_p, acl_id, acl_entry_p);
        ASSERT(RULE_TYPE_OK == temp_result);
    }

    ASSERT(RULE_TYPE_OK != result);
    return result;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalRemoveACLFromDEV
 *------------------------------------------------------------------------------
 * PURPOSE  : Remove ACL rule
 * INPUT    : unit, port, acl_id, is_trunk
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK ; Error code
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalRemoveACLFromDEV(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    UI32_T acl_id,
    const RULE_TYPE_Acl_T *acl_entry_p)
{
    RULE_TYPE_RETURN_TYPE_T result;

    //
    // --== Duplicated code start
    //
    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

    RULE_TYPE_CONTAINER_PTR_T acl_container_p;
    RULE_TYPE_CONTAINER_OBJECT_T acl_container_obj;

    RULE_CTRL_INSTANCE_TYPE_ID_T param;
    //
    // --== End of duplicated code
    //

    RULE_TYPE_CLASS_INSTANCE_PTR_T      acl_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T   acl_inst_obj;

    ASSERT(NULL != interface_p);
    ASSERT(interface_p->type < RULE_TYPE_INTERFACE_MAX);
    ASSERT(RULE_TYPE_INBOUND == interface_p->direction ||
           RULE_TYPE_OUTBOUND == interface_p->direction);
    ASSERT(NULL != acl_entry_p);

    LOG_IF(*interface_p, "aclId = %lu", acl_id);

    //
    // --== Duplicated code start
    //
    if_entry_p = RULE_CTRL_Priv_GetIfEntry(interface_p);
    ASSERT(NULL != if_entry_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                              &if_class_obj);

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_CONTAINER;
    param.id = RULE_TYPE_INST_ACL;

    acl_container_p = (RULE_TYPE_CONTAINER_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                RULE_CTRL_Priv_IsMatchTypeId,
                                                                                &param);
    if (NULL == acl_container_p)
    {
        return RULE_TYPE_OK;
    }

    RULE_CTRL_IN_Priv_ConstructContainerObject(acl_container_p, &acl_container_obj);

    ASSERT(NULL != acl_container_p);
    ASSERT(acl_container_p == acl_container_obj.inst);

    param.type = RULE_TYPE_INST_ACL;
    param.id = acl_id;

    acl_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) acl_container_p,
                                                                                RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                &param);
    //
    // --== End of duplicated code
    //

    ASSERT(acl_inst_p->acl_id == acl_id);

    if (NULL != acl_inst_p)
    {
        RULE_CTRL_IN_Priv_ConstructClassInstanceObject(acl_inst_p, &acl_inst_obj);

        ASSERT(0 < acl_inst_p->ref_count);

        acl_inst_p->ref_count -= 1;

        if (0 < acl_inst_p->ref_count)
        {
            result = RULE_CTRL_Update_PortBitMap(RULE_TYPE_INBOUND == interface_p->direction ? TRUE : FALSE,
                                                 FALSE,
                                                 interface_p->uport.unit,
                                                 interface_p->uport.port,
                                                 acl_entry_p,
                                                 acl_inst_p);
            ASSERT(RULE_TYPE_OK == result);
        }

        ASSERT(NULL != acl_inst_p && acl_inst_obj.inst == acl_inst_p);
        acl_container_obj.remove_class_obj(&acl_container_obj, &acl_inst_obj);

        if (0 == acl_inst_p->ref_count)
        {
            RULE_CTRL_LocalFreeRulesByRuleGroup(acl_inst_p);

            RULE_CTRL_Priv_RecycleGroup();

            ASSERT(NULL != acl_inst_p && acl_inst_obj.inst == acl_inst_p);

            RULE_CTRL_IN_Priv_DestroyClassInstanceObject(&acl_inst_obj);
        }
    }

    {
        RULE_TYPE_CONTAINER_ELEMENT_ITERATOR_T iter;

        acl_container_obj.get_element_iterator(&acl_container_obj, &iter);
        if (0 == iter.count(&iter))
        {
            if_class_obj.remove(&if_class_obj, (RULE_TYPE_INSTANCE_PTR_T) acl_container_obj.inst);

            result = RULE_CTRL_IN_Priv_DestroyContainerObject(&acl_container_obj);
            ASSERT(RULE_TYPE_OK == result);
        }
    }

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalAddAce2DEV
 *------------------------------------------------------------------------------
 * PURPOSE  : add a rule to chip and check whether the acl use on ACL or QoS
 * INPUT    : acl_index, acl_entry, rule_entry
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK ; Error code
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalAddAce2DEV(
    UI32_T acl_index,
    const RULE_TYPE_Acl_T *acl_entry_p,
    const RULE_TYPE_Ace_Entry_T *ace_entry_p)
{
    UI32_T  group_id;
    UI8_T   port_list[RULE_TYPE_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST];
    UI32_T  port_nbr;
    int     rule_pri;

    RULE_TYPE_RETURN_TYPE_T result;

    BOOL_T  update_qos = TRUE;

    /* check QoS hardware resource if it's a PERMIT ACE
     * suppose a port can bind a QoS ACL only once
     */
    if (FALSE == RULE_CTRL_GetFunctionInfoByAceTypeAndDirection(FALSE, TRUE, ace_entry_p->ace_type, &group_id, &rule_pri))
    {
        update_qos = FALSE;
    }

    if ((TRUE == update_qos)
        && (RULE_TYPE_ACE_PERMIT == ace_entry_p->access))
    {
        if (RULE_TYPE_OK == RULE_OM_Get_PortListByClassMapList(acl_entry_p->class_map_bit_list, port_list, &port_nbr))
        {
            if (FALSE == RULE_CTRL_CheckResourceOnPortListForQosPurpose(group_id, 1, port_list))
                return RULE_TYPE_INSUFFICIENT_RESOURCE; /* not enought resource */
        }
    }

    /* config ingress ACL to every chip on per unit */
    result = RULE_CTRL_LocalAddAce2DevForAclPurpose(TRUE, acl_index, acl_entry_p, ace_entry_p);
    if (RULE_TYPE_OK != result)
        return result;

    /* In current design, we don't configure aces of deny action (for QoS) on the chip.
     */
    if ((TRUE == update_qos)
        && (RULE_TYPE_ACE_PERMIT == ace_entry_p->access))
    {
        result = RULE_CTRL_LocalAddAce2DevForQosPurpose(acl_index, acl_entry_p, ace_entry_p, port_list);
        ASSERT(RULE_TYPE_OK == result);
        if (RULE_TYPE_OK != result)
        {
            LOG("Critical error!!! RULE_CTRL_LocalAddAce2DevForQosPurpose fail\r\n");
            return result;
        }
    }

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalAddAce2DevForAclPurpose
 *------------------------------------------------------------------------------
 * PURPOSE  : add a rule to chip according to the acl's port list
 * INPUT    : acl_index, acl_entry, rule_entry
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : if there is no port bound to this acl, return TRUE (do nothing)
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalAddAce2DevForAclPurpose(
    BOOL_T is_ingress,
    UI32_T acl_index,
    const RULE_TYPE_Acl_T *acl_entry_p,
    const RULE_TYPE_Ace_Entry_T *ace_entry_p)
{
    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T if_entry_index;

    UI32_T group_id;
    UI32_T module_id, device_id, phy_port;
    UI32_T rule_index = RULE_TYPE_UNDEF_RULE_INDEX, ace_index;

    int                         rule_pri;

    RULE_CTRL_ResourceInfo_T    *res_p;
    BOOL_T                      is_active = TRUE;
    RULE_TYPE_FunctionType_T    fun_type;

    BOOL_T                      b_result;

    if ((NULL == acl_entry_p) || (NULL == ace_entry_p) ||
        (RULE_TYPE_OK != RULE_OM_GetAceIndexFromAclByAceEntry(acl_index, ace_entry_p, &ace_index)))
    {
        return RULE_TYPE_INVALID_PARAMETER;
    }

    for (if_entry_index = 0;
         if_entry_index < _countof(shmem_data_p->if_table);
         ++ if_entry_index)
    {
        RULE_TYPE_INTERFACE_INFO_T interface;

        RULE_TYPE_CLASS_INSTANCE_OBJECT_T acl_inst_obj;

        RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;

        RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p;

        RULE_CTRL_INSTANCE_TYPE_ID_T param;

        int priority;

        RULE_CTRL_Priv_IfEntry_Index_To_Interface(if_entry_index, &interface);

        acl_inst_p = RULE_CTRL_Priv_GetAclInstanceById(&interface, acl_index);
        if (NULL == acl_inst_p)
        {
            continue;
        }

        RULE_CTRL_IN_Priv_ConstructClassInstanceObject(acl_inst_p, &acl_inst_obj);

        result = RULE_CTRL_Priv_GetAcePriorityInAcl(acl_index, ace_index, &priority);
        ASSERT(RULE_TYPE_OK == result);

        //
        // TODO: Support user port now
        //
        ASSERT(RULE_TYPE_INTERFACE_UPORT == interface.type);

        memset(&param, 0, sizeof(param));

        param.type = RULE_TYPE_INST_RULE;
        param.id = ace_index;

        ace_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) acl_inst_p,
                                                                                    RULE_CTRL_Priv_IsMatchTypeId,
                                                                                    &param);
        if (NULL != ace_inst_p)
        {
            result = RULE_CTRL_Update_PortBitMap(RULE_TYPE_INBOUND == interface.direction ? TRUE : FALSE,
                                                 TRUE,
                                                 interface.uport.unit,
                                                 interface.uport.port,
                                                 acl_entry_p,
                                                 acl_inst_p);
            if (RULE_TYPE_OK != result)
            {
                LOG("<Error> Update rule");
                goto undo;
            }
        }
        else
        {
            RULE_TYPE_CLASS_INSTANCE_OBJECT_T ace_inst_obj;
            RULE_TYPE_RULE_INSTANCE_OBJECT_T rule_inst_obj;
            RULE_TYPE_COUNTER_ENABLE_T counter_enable = RULE_TYPE_COUNTER_DISABLE;

#if (SYS_CPNT_ACL_COUNTER == TRUE)
            counter_enable = acl_inst_p->counter_enable;
#endif /* SYS_CPNT_ACL_COUNTER */

            b_result = DEV_SWDRV_PMGR_Logical2PhyDevicePortID(interface.uport.unit,
                                                              interface.uport.port,
                                                              &module_id, &device_id, &phy_port);
            ASSERT(TRUE == b_result);

            fun_type = acl_inst_p->fun_type;

#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)
            fun_type = acl_inst_p->remap_fun_type;
#endif /* SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT */

            b_result = RULE_CTRL_GetFunctionInfoByFunctionType(fun_type, &group_id,
                                                               &rule_pri);
            ASSERT(TRUE == b_result);

            b_result = RULE_CTRL_RequestRuleByQuota(interface.uport.unit, device_id, fun_type,
                                                    RULE_CTRL_REQUEST_RESOURCE_ALLOCATE_TEST,
                                                    1);
            if (TRUE != b_result)
            {
                result = RULE_TYPE_INSUFFICIENT_RESOURCE;

                LOG("<Error> Reach rule quota");
                goto undo;
            }

            res_p = RULE_CTRL_GetResourceInfo(interface.uport.unit, device_id, group_id);
            ASSERT(NULL != res_p);

            if (0 == res_p->free_rule)
            {
                result = RULE_TYPE_INSUFFICIENT_RESOURCE;

                LOG("<Error> Insufficient rule");
                goto undo;
            }

            /**
             * Create ACE instance
             */
            result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACE, &ace_inst_obj);
            if (RULE_TYPE_OK != result)
            {
                LOG("<Error> Failed to create ACE instance");
                goto undo;
            }

            ASSERT(NULL == ace_inst_p);

            ace_inst_p = ace_inst_obj.inst;

            ASSERT(NULL != ace_inst_p);

            ace_inst_p->id = ace_index;
            acl_inst_obj.add_class_obj(&acl_inst_obj, &ace_inst_obj);

            result = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &rule_inst_obj);
            if (RULE_TYPE_OK != result)
            {
                LOG("Not more rule instance available");
                goto undo;
            }

            rule_inst_obj.inst->ace_id = ace_index;

            rule_inst_obj.inst->dev_rule_info.unit = interface.uport.unit;
            rule_inst_obj.inst->dev_rule_info.device = device_id;
            rule_inst_obj.inst->dev_rule_info.group_id = group_id;
            rule_inst_obj.inst->dev_rule_info.fun_type = fun_type;
            rule_inst_obj.inst->dev_rule_info.priority = priority;

            memset(rule_inst_obj.inst->dev_rule_info.port_bmp.pbits,
                   0,
                   sizeof(rule_inst_obj.inst->dev_rule_info.port_bmp.pbits));
            DEVRM_PBMP_PORT_ADD(rule_inst_obj.inst->dev_rule_info.port_bmp, phy_port);

            rule_inst_obj.inst->dev_rule_info.rule_id = 0;
            rule_inst_obj.inst->active = FALSE;
            ace_inst_obj.add_rule_obj(&ace_inst_obj, &rule_inst_obj);

#if (SYS_CPNT_TIME_BASED_ACL == TRUE)
            is_active = RULE_CTRL_LocalCheckRuleInActiveByTimeRange(ace_entry_p->time_range_index, acl_inst_p->time_range_index);
#endif /* SYS_CPNT_TIME_BASED_ACL */

            if (TRUE == is_active)
            {
                if (FALSE == RULE_CTRL_ALLOCATE_RULE(interface.uport.unit,
                                                     interface.uport.port,
                                                     rule_inst_obj.inst->dev_rule_info.device,
                                                     rule_inst_obj.inst->dev_rule_info.group_id,
                                                     rule_inst_obj.inst->dev_rule_info.fun_type,
                                                     rule_inst_obj.inst->dev_rule_info.priority,
                                                     &rule_index))
                {
                    result = RULE_TYPE_INSUFFICIENT_RESOURCE;

                    LOG("RULE_CTRL_Allocate_Rule ( unit(%lu),port(%lu),device_id(%lu),group_id(%lu),rule_pri(%d) )",
                        interface.uport.unit, interface.uport.port, device_id, group_id, rule_pri);
                    goto undo;
                }

                rule_inst_obj.inst->dev_rule_info.rule_id = rule_index;
                rule_inst_obj.inst->active = TRUE;

                if (FALSE == RULE_CTRL_SetAce2Dev(RULE_TYPE_INBOUND == interface.direction ? TRUE : FALSE,
                                                  interface.uport.unit,
                                                  interface.uport.port,
                                                  rule_inst_obj.inst->dev_rule_info.group_id,
                                                  rule_inst_obj.inst->dev_rule_info.rule_id,
                                                  ace_entry_p,
                                                  ace_index,
                                                  counter_enable))
                {
                    result = RULE_TYPE_FAIL;

                    LOG("<Error> SetAce2Dev");
                    goto undo;
                }
            }

            RULE_CTRL_RequestRuleByQuota(interface.uport.unit, device_id, fun_type,
                                         RULE_CTRL_REQUEST_RESOURCE_ALLOCATE, 1);
        }
    }

    return RULE_TYPE_OK;

undo:
    {
        RULE_TYPE_RETURN_TYPE_T temp_result;
        temp_result = RULE_CTRL_LocalRemoveAceFromDEV(acl_index, acl_entry_p, ace_entry_p);
        ASSERT(RULE_TYPE_OK == temp_result);
    }

    ASSERT(RULE_TYPE_OK != result);

    return result;
}

typedef struct
{
    UI32_T acl_index;
    UI32_T ace_index;
    const RULE_TYPE_Acl_T *acl_entry_p;
    const RULE_TYPE_Ace_Entry_T *ace_entry_p;

    RULE_TYPE_INTERFACE_INFO_PTR_T interface_p;
    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;

    RULE_TYPE_RETURN_TYPE_T result;
} RULE_CTRL_ADD_ACE_PARAM_T, *RULE_CTRL_ADD_ACE_PARAM_PTR_T;

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalAddAce2DevForQosPurpose
 *------------------------------------------------------------------------------
 * PURPOSE  : add a rule to chip according to the qos's port list
 * INPUT    : acl_index, acl_entry, rule_entry, port_list
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : if there is no port bound to this qos, return TRUE (do nothing)
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalAddAce2DevForQosPurpose(
    UI32_T acl_index,
    const RULE_TYPE_Acl_T *acl_entry_p,
    const RULE_TYPE_Ace_Entry_T *ace_entry_p,
    const UI8_T *port_list)
{
    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T if_entry_index;

    UI32_T ace_index;

    if ((NULL == acl_entry_p) || (NULL == ace_entry_p))
    {
        return RULE_TYPE_INVALID_PARAMETER;
    }

    /* If SYS_CPNT_DIFFSERV_USE_DENY_ACE_IN_ACL is FALSE,
     *   we do not configure an ace with deny action to chip (for DiffServ).
     */
#if (SYS_CPNT_DIFFSERV_USE_DENY_ACE_IN_ACL != TRUE)
    if (RULE_TYPE_ACE_DENY == ace_entry_p->access)
    {
        return RULE_TYPE_OK;
    }
#endif /* #if (SYS_CPNT_DIFFSERV_USE_DENY_ACE_IN_ACL != TRUE) */

    result = RULE_OM_GetAceIndexFromAclByAceEntry(acl_index, ace_entry_p, &ace_index);
    if (RULE_TYPE_OK != result)
    {
        return result;
    }

    for (if_entry_index = 0;
         if_entry_index < _countof(shmem_data_p->if_table);
         ++ if_entry_index)
    {
        //
        // --== Duplicated code start
        //
        RULE_TYPE_INTERFACE_INFO_T interface;

        RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

        RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;
        RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;

        RULE_CTRL_INSTANCE_TYPE_ID_T find_param;
        //
        // --== End of duplicated code
        //

        RULE_CTRL_Priv_IfEntry_Index_To_Interface(if_entry_index, &interface);
        //
        // --== Duplicated code start
        //
        if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
        ASSERT(NULL != if_entry_p);

        RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                  &if_class_obj);

        memset(&find_param, 0, sizeof(find_param));

        find_param.type = RULE_TYPE_INST_POLICY_MAP;

        policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                           RULE_CTRL_Priv_IsClassInstanceMatchType,
                                                                                           &find_param);
        //
        // --== End of duplicated code
        //

        while (NULL != policy_map_inst_p)
        {
            RULE_CTRL_ADD_ACE_PARAM_T param;

            memset(&param, 0, sizeof(param));

            param.acl_index = acl_index;
            param.ace_index = ace_index;
            param.acl_entry_p = acl_entry_p;
            param.ace_entry_p = ace_entry_p;
            param.result = RULE_TYPE_OK;

            param.interface_p = &interface;
            param.policy_map_inst_p = policy_map_inst_p;

            RULE_CTRL_IN_Priv_Walk((RULE_TYPE_INSTANCE_PTR_T)policy_map_inst_p,
                                   RULE_CTRL_LocalAddAce2DevForQosPurpose_Hello,
                                   &param);

            if (RULE_TYPE_OK != param.result)
            {
                result = param.result;
                goto undo;
            }

            policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetNextSiblingIf((RULE_TYPE_INSTANCE_PTR_T)policy_map_inst_p,
                                                                                                RULE_CTRL_Priv_IsClassInstanceMatchType,
                                                                                                &find_param);
        }
    }

    return RULE_TYPE_OK;

undo:
    ASSERT(RULE_TYPE_OK != result);
    return result;
}

static void
RULE_CTRL_LocalAddAce2DevForQosPurpose_Hello(
    RULE_TYPE_INSTANCE_PTR_T in,
    void *cookie)
{
    RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;

    RULE_CTRL_ADD_ACE_PARAM_PTR_T param_p;
    UI32_T ui_acl_index;

    param_p = (RULE_CTRL_ADD_ACE_PARAM_PTR_T)cookie;

    ASSERT(NULL != param_p->acl_entry_p);
    ASSERT(NULL != param_p->ace_entry_p);
    ASSERT(NULL != param_p->interface_p);
    ASSERT(NULL != param_p->policy_map_inst_p);

#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
    if (param_p->acl_entry_p->flag_hide == TRUE)
    {
        ui_acl_index = param_p->acl_entry_p->owner.class_id;
    }
    else
#endif
    {
        ui_acl_index = param_p->acl_index;
    }

    acl_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)in;
    if (RULE_TYPE_INST_ACL == acl_inst_p->super.type &&
        acl_inst_p->id == param_p->acl_index)
    {
        RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p;

        RULE_TYPE_PolicyElement_T policy_element;

        RULE_TYPE_CLASS_INSTANCE_OBJECT_T class_map_inst_obj;
        RULE_TYPE_CLASS_INSTANCE_OBJECT_T acl_inst_obj;
        RULE_TYPE_CLASS_INSTANCE_OBJECT_T ace_inst_obj;

        RULE_TYPE_RULE_INSTANCE_OBJECT_T rule_inst_obj;

        int priority;

        UI32_T meter_id;
        RULE_TYPE_TBParamEntry_T meter_entry;
        RULE_TYPE_Action_T action_entry;

        UI32_T                      rule_index=0;
        UI32_T                      action_id;
        UI32_T                      sm_rid = RULE_CTRL_NO_SHARE_METER_ENTRY_ID;

        BOOL_T b_result;

        class_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T) RULE_CTRL_IN_Ptr2Instance(acl_inst_p->super.links.parent);
        ASSERT(NULL != class_map_inst_p);
        ASSERT(RULE_TYPE_INST_CLASS_MAP == class_map_inst_p->super.type);

        RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_map_inst_p, &class_map_inst_obj);

        ASSERT(param_p->policy_map_inst_p == (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_IN_Ptr2Instance(class_map_inst_p->super.links.parent));

        param_p->result = RULE_OM_GetPolicyMapElementFromPolicyMapByClassMap(param_p->policy_map_inst_p->id,
                                                                             class_map_inst_p->id,
                                                                             &policy_element);
        ASSERT(RULE_TYPE_OK == param_p->result);

        param_p->result = RULE_CTRL_Priv_GetClassMapElementPriorityInClassMap(param_p->policy_map_inst_p->id,
                                                                              class_map_inst_p->id,
                                                                              RULE_TYPE_CLASS_ACL,
                                                                              ui_acl_index,
                                                                              &priority);
        ASSERT(RULE_TYPE_OK == param_p->result);

        param_p->result = RULE_OM_GetActionEntryByIndex(policy_element.action_index, &action_entry);
        ASSERT(RULE_TYPE_OK == param_p->result);

        param_p->result = RULE_OM_GetMeterEntryByIndex(policy_element.meter_index, &meter_entry);
        if (RULE_TYPE_OK != param_p->result)
        {
            meter_id = 0;
        }
        else
        {
            meter_id = policy_element.meter_index;
        }

        /**
         * Create ACE instance
         */
        param_p->result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACE, &ace_inst_obj);
        if (RULE_TYPE_OK != param_p->result)
        {
            LOG("<Error> Failed to create mf/ace instance");
            return;
        }

        ASSERT(NULL != ace_inst_obj.inst);

        ace_inst_obj.inst->id = param_p->ace_index;
//        ace_inst_obj.inst->mvl_pkt_type = remapped_pkt_type;

        RULE_CTRL_IN_Priv_ConstructClassInstanceObject(acl_inst_p, &acl_inst_obj);
        acl_inst_obj.add_class_obj(&acl_inst_obj, &ace_inst_obj);

        /**
         * Add rule
         */
        {
            UI32_T module_id, device_id, phy_port;
            UI32_T group_id;

            RULE_CTRL_ResourceInfo_T *res_p;
            RULE_TYPE_FunctionType_T fun_type = RULE_TYPE_FUNCTION_TYPE_MAX;

            int rule_pri;

            ASSERT(RULE_TYPE_INTERFACE_UPORT == param_p->interface_p->type);

            b_result = DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->interface_p->uport.unit,
                                                              param_p->interface_p->uport.port,
                                                              &module_id, &device_id, &phy_port);
            ASSERT(TRUE == b_result);

            fun_type = acl_inst_p->fun_type;

#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)
            ASSERT(acl_inst_p->remap_fun_type == acl_inst_p->fun_type);
            fun_type = acl_inst_p->remap_fun_type;
#endif /* SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT */

            b_result = RULE_CTRL_GetFunctionInfoByFunctionType(fun_type, &group_id,
                                                               &rule_pri);
            ASSERT(TRUE == b_result);

            b_result = RULE_CTRL_RequestRuleByQuota(param_p->interface_p->uport.unit,
                                                    device_id, fun_type,
                                                    RULE_CTRL_REQUEST_RESOURCE_ALLOCATE_TEST,
                                                    1);
            if (TRUE != b_result)
            {
                param_p->result = RULE_TYPE_INSUFFICIENT_RESOURCE;
                LOG("<Error> Reach rule quota");
                return;
            }

            res_p = RULE_CTRL_GetResourceInfo(param_p->interface_p->uport.unit,
                                              device_id, group_id);
            ASSERT(NULL != res_p);

            if (0 == res_p->free_rule)
            {
                param_p->result = RULE_TYPE_INSUFFICIENT_RESOURCE;
                LOG("<Error> Insufficient rule");
                return;
            }

            param_p->result = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &rule_inst_obj);
            if (RULE_TYPE_OK != param_p->result)
            {
                LOG("<Error> Failed to create rule instance");
                return;
            }

            rule_inst_obj.inst->ace_id = param_p->ace_index;

            rule_inst_obj.inst->dev_rule_info.unit = param_p->interface_p->uport.unit;
            rule_inst_obj.inst->dev_rule_info.device = device_id;
            rule_inst_obj.inst->dev_rule_info.group_id = group_id;
            rule_inst_obj.inst->dev_rule_info.fun_type = fun_type;
            rule_inst_obj.inst->dev_rule_info.priority = priority;

            rule_inst_obj.inst->dev_rule_info.rule_id = 0;
            rule_inst_obj.inst->active = FALSE;
            ace_inst_obj.add_rule_obj(&ace_inst_obj, &rule_inst_obj);

            b_result = RULE_CTRL_ALLOCATE_RULE(rule_inst_obj.inst->dev_rule_info.unit,
                                               param_p->interface_p->uport.port,
                                               rule_inst_obj.inst->dev_rule_info.device,
                                               rule_inst_obj.inst->dev_rule_info.group_id,
                                               rule_inst_obj.inst->dev_rule_info.fun_type,
                                               rule_inst_obj.inst->dev_rule_info.priority,
                                               &rule_index);
            if (TRUE != b_result)
            {
                param_p->result = RULE_TYPE_INSUFFICIENT_RESOURCE;
                LOG("<Error> Insufficient rule");
                return;
            }

            rule_inst_obj.inst->dev_rule_info.rule_id = rule_index;
            rule_inst_obj.inst->action_id = action_id;
            rule_inst_obj.inst->meter_id = meter_id;

            rule_inst_obj.inst->active = TRUE;

            if (meter_id != 0)
            {
#if (SYS_CPNT_DIFFSERV_SEPARATE_METERS != TRUE)
                sm_rid = RULE_CTRL_LocalGetFirstDevRuleIDofOneClassMap(class_map_inst_obj.inst,
                                                                       rule_inst_obj.inst->dev_rule_info.unit,
                                                                       rule_inst_obj.inst->dev_rule_info.device);
                if (sm_rid == rule_inst_obj.inst->dev_rule_info.rule_id)
                {
                    sm_rid = RULE_CTRL_NO_SHARE_METER_ENTRY_ID;
                }
#endif
            }

            b_result = RULE_CTRL_RequestRuleByQuota(rule_inst_obj.inst->dev_rule_info.unit,
                                                    rule_inst_obj.inst->dev_rule_info.device,
                                                    rule_inst_obj.inst->dev_rule_info.fun_type,
                                                    RULE_CTRL_REQUEST_RESOURCE_ALLOCATE,
                                                    1);
            ASSERT(TRUE == b_result);


            if (TRUE != RULE_CTRL_SetQoSAce2Dev(RULE_TYPE_INBOUND == param_p->interface_p->direction ? TRUE : FALSE,
                                                rule_inst_obj.inst->dev_rule_info.unit,
                                                param_p->interface_p->uport.port,
                                                rule_inst_obj.inst->dev_rule_info.group_id,
                                                rule_inst_obj.inst->dev_rule_info.rule_id,
                                                param_p->ace_entry_p,
                                                (0 != meter_id) ? &meter_entry : NULL,
                                                &action_entry, sm_rid))
            {
                param_p->result = RULE_TYPE_FAIL;
                LOG("<Error> Set rule");
                return;
            }
        }
    }
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalRemoveAceFromDEV
 *------------------------------------------------------------------------------
 * PURPOSE  : remove rule for ACE of ACL
 * INPUT    : acl_id - ACL index
 *            acl_entry_p - ACL
 *            ace_entry_p - ACE
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK; error code
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalRemoveAceFromDEV(
    UI32_T acl_id,
    const RULE_TYPE_Acl_T *acl_entry_p,
    const RULE_TYPE_Ace_Entry_T *ace_entry_p)
{
    RULE_TYPE_RETURN_TYPE_T result;

    result = RULE_CTRL_LocalRemoveAceFromDevForAclPurpose(TRUE, acl_id, acl_entry_p, ace_entry_p);
    if (RULE_TYPE_OK != result)
        return result;

    result = RULE_CTRL_LocalRemoveAceFromDevForQosPurpose(acl_id, acl_entry_p, ace_entry_p);
    ASSERT(RULE_TYPE_OK == result);

    return result;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalRemoveAceFromDevForAclPurpose
 *------------------------------------------------------------------------------
 * PURPOSE  : remove a rule from chip according to the acl's port list
 * INPUT    : acl_index, acl_entry, rule_entry
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : if there is no port bound to this acl, return TRUE (do nothing)
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalRemoveAceFromDevForAclPurpose(
    BOOL_T is_ingress,
    UI32_T acl_index,
    const RULE_TYPE_Acl_T *acl_entry_p,
    const RULE_TYPE_Ace_Entry_T *ace_entry_p)
{
    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T ace_index;

    UI32_T if_entry_index;

    if ((NULL == acl_entry_p) || (NULL == ace_entry_p) ||
        (RULE_TYPE_OK != RULE_OM_GetAceIndexFromAclByAceEntry(acl_index, ace_entry_p, &ace_index)))
    {
        return RULE_TYPE_INVALID_PARAMETER;
    }

    for (if_entry_index = 0;
         if_entry_index < _countof(shmem_data_p->if_table);
         ++ if_entry_index)
    {
        RULE_TYPE_INTERFACE_INFO_T interface;

        RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

        RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

        RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;
        RULE_TYPE_CLASS_INSTANCE_OBJECT_T acl_inst_obj;

        RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p;
        RULE_TYPE_CLASS_INSTANCE_OBJECT_T ace_inst_obj;

        RULE_CTRL_INSTANCE_TYPE_ID_T param;

        RULE_CTRL_Priv_IfEntry_Index_To_Interface(if_entry_index, &interface);

        //
        // --== Duplicated code start
        //
        if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
        ASSERT(NULL != if_entry_p);

        RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                  &if_class_obj);

        memset(&param, 0, sizeof(param));

        param.type = RULE_TYPE_INST_ACL;
        param.id = acl_index;

        acl_inst_p = RULE_CTRL_Priv_GetAclInstanceById(&interface, acl_index);

        //
        // --== End of duplicated code
        //

        if (NULL == acl_inst_p)
        {
            continue;
        }

        RULE_CTRL_IN_Priv_ConstructClassInstanceObject(acl_inst_p, &acl_inst_obj);

        param.type = RULE_TYPE_INST_ACE;
        param.id = ace_index;

        ace_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) acl_inst_p,
                                                                                    RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                    &param);
        if (NULL == ace_inst_p)
        {
            continue;
        }

        result = RULE_CTRL_LocalFreeRulesByRuleGroup(ace_inst_p);
        ASSERT(RULE_TYPE_OK == result);

        RULE_CTRL_IN_Priv_ConstructClassInstanceObject(ace_inst_p, &ace_inst_obj);

        acl_inst_obj.remove_class_obj(&acl_inst_obj, &ace_inst_obj);
        RULE_CTRL_IN_Priv_DestroyClassInstanceObject(&ace_inst_obj);
    }

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalRemoveAceFromDevForQosPurpose
 *------------------------------------------------------------------------------
 * PURPOSE  : remove a rule to chip according to the qos's port list
 * INPUT    : acl_index, acl_entry, rule_entry, port_list
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : if there is no port bound to this qos, return TRUE (do nothing)
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalRemoveAceFromDevForQosPurpose(
    UI32_T acl_index,
    const RULE_TYPE_Acl_T *acl_entry_p,
    const RULE_TYPE_Ace_Entry_T *ace_entry_p)
{
    RULE_TYPE_RETURN_TYPE_T result;
    UI32_T if_entry_index;

    UI32_T ace_index;

    if ((NULL == acl_entry_p) || (NULL == ace_entry_p))
    {
        return RULE_TYPE_INVALID_PARAMETER;
    }

    result = RULE_OM_GetAceIndexFromAclByAceEntry(acl_index, ace_entry_p, &ace_index);
    if (RULE_TYPE_OK != result)
    {
        return result;
    }

    for (if_entry_index = 0;
         if_entry_index < _countof(shmem_data_p->if_table);
         ++ if_entry_index)
    {
        //
        // --== Duplicated code start
        //
        RULE_TYPE_INTERFACE_INFO_T interface;

        RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

        RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;
        RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;

        RULE_CTRL_INSTANCE_TYPE_ID_T find_param;
        //
        // --== End of duplicated code
        //

        RULE_CTRL_Priv_IfEntry_Index_To_Interface(if_entry_index, &interface);
        //
        // --== Duplicated code start
        //
        if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
        ASSERT(NULL != if_entry_p);

        RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                  &if_class_obj);

        memset(&find_param, 0, sizeof(find_param));

        find_param.type = RULE_TYPE_INST_POLICY_MAP;
        //
        // --== End of duplicated code
        //

        for (policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                                RULE_CTRL_Priv_IsClassInstanceMatchType,
                                                                                                &find_param);
             NULL != policy_map_inst_p;
             policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetNextSiblingIf((RULE_TYPE_INSTANCE_PTR_T)policy_map_inst_p,
                                                                                                 RULE_CTRL_Priv_IsClassInstanceMatchType,
                                                                                                 &find_param))
        {
            RULE_CTRL_INSTANCE_TYPE_ID_T find_class_map_param;
            RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p;

            memset(&find_class_map_param, 0, sizeof(find_class_map_param));

            find_class_map_param.type = RULE_TYPE_INST_CLASS_MAP;

            for (class_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) policy_map_inst_p,
                                                                                                   RULE_CTRL_Priv_IsClassInstanceMatchType,
                                                                                                   &find_class_map_param);
                 NULL != class_map_inst_p;
                 class_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetNextSiblingIf((RULE_TYPE_INSTANCE_PTR_T) class_map_inst_p,
                                                                                                    RULE_CTRL_Priv_IsClassInstanceMatchType,
                                                                                                    &find_class_map_param))
            {

                RULE_CTRL_INSTANCE_TYPE_ID_T find_acl_param;
                RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;

                memset(&find_acl_param, 0, sizeof(find_acl_param));

                find_acl_param.type = RULE_TYPE_INST_ACL;
                find_acl_param.id = acl_index;

                for (acl_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) class_map_inst_p,
                                                                                                 RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                                 &find_acl_param);
                     NULL != acl_inst_p;
                     acl_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetNextSiblingIf((RULE_TYPE_INSTANCE_PTR_T) acl_inst_p,
                                                                                                  RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                                  &find_acl_param))
                {
                    RULE_CTRL_INSTANCE_TYPE_ID_T find_ace_param;
                    RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p;

                    memset(&find_ace_param, 0, sizeof(find_ace_param));

                    find_ace_param.type = RULE_TYPE_INST_ACE;
                    find_ace_param.id = ace_index;

                    ace_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_IN_Priv_FindIf((RULE_TYPE_INSTANCE_PTR_T) acl_inst_p,
                                                                                          RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                          &find_ace_param);
                    if (NULL != ace_inst_p)
                    {
                        RULE_TYPE_CLASS_INSTANCE_OBJECT_T acl_inst_obj;
                        RULE_TYPE_CLASS_INSTANCE_OBJECT_T ace_inst_obj;

                        result = RULE_CTRL_LocalFreeRulesByRuleGroup(ace_inst_p);
                        ASSERT(RULE_TYPE_OK == result);

                        RULE_CTRL_IN_Priv_ConstructClassInstanceObject(acl_inst_p, &acl_inst_obj);
                        RULE_CTRL_IN_Priv_ConstructClassInstanceObject(ace_inst_p, &ace_inst_obj);

                        acl_inst_obj.remove_class_obj(&acl_inst_obj, &ace_inst_obj);
                        RULE_CTRL_IN_Priv_DestroyClassInstanceObject(&ace_inst_obj);
                    }
                }
            }
        }
    }

    return RULE_TYPE_OK;
}

#if (SYS_CPNT_TIME_BASED_ACL == TRUE)
/*--------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_ProcessTimeRangeStatusChange
 *---------------------------------------------------------------------------
 * PURPOSE: Process time_range status change
 * INPUT:  isChanged_list, status_list.
 * OUTPUT: None.
 * RETURN: TRUE/FALSE.
 * NOTES:  None.
 *---------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_ProcessTimeRangeStatusChange(UI8_T *isChanged_list, UI8_T *status_list)
{
    UI32_T                            i;
    UI8_T state_change_list[SYS_ADPT_TIME_RANGE_MAX_NBR_OF_ENTRY] = {0};

    /* update time range table
     */

    RULE_CTRL_EnterCriticalSection();

    for (i = 0; i < SYS_ADPT_TIME_RANGE_MAX_NBR_OF_ENTRY; ++i)
    {
        if (isChanged_list[(UI32_T)(i>>3)] & (1 << (7 - (i%8))))
        {
            if (status_list[(UI32_T)(i>>3)] & (1 << (7 - (i%8))))
            {
                state_change_list[i] = RULE_TYPE_TIME_RANGE_IN_ACTIVE;
            }
            else
            {
                state_change_list[i] = RULE_TYPE_TIME_RANGE_UN_ACTIVE;
            }
        }
    }

    for (i = 0; i < _countof(shmem_data_p->if_table); ++ i)
    {
        RULE_TYPE_INTERFACE_INFO_T interface;

        RULE_CTRL_Priv_IfEntry_Index_To_Interface(i, &interface);
        RULE_CTRL_LocalUpdateTimeACLRelationRulePerInterface(&interface, state_change_list);
    }

    RULE_CTRL_LeaveCriticalSection();

    return TRUE;
} /* END FUNCTION - BOOL_T RULE_CTRL_ProcessTimeRangeStatusChange() */

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalUpdateTimeACLRelationRulePerInterface
 *------------------------------------------------------------------------------
 * PURPOSE: Process timer alarm event from timer
 * INPUT:  None
 * OUTPUT: None
 * RETURN: TRUE/FALSE
 * NOTES:  None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalUpdateTimeACLRelationRulePerInterface(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    UI8_T *state_change_list)
{
    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

    RULE_TYPE_CONTAINER_PTR_T acl_container_p;
    RULE_TYPE_CONTAINER_OBJECT_T acl_container_obj;
    RULE_TYPE_CONTAINER_ELEMENT_ITERATOR_T acl_inst_iter;

    RULE_CTRL_INSTANCE_TYPE_ID_T param;

    //
    // --== Duplicated code start
    //
    if_entry_p = RULE_CTRL_Priv_GetIfEntry(interface_p);
    ASSERT(NULL != if_entry_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                              &if_class_obj);

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_CONTAINER;
    param.id = RULE_TYPE_INST_ACL;

    acl_container_p = (RULE_TYPE_CONTAINER_PTR_T) RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                 RULE_CTRL_Priv_IsMatchTypeId,
                                                                                 &param);
    if (NULL == acl_container_p)
    {
        return RULE_TYPE_OK;
    }

    RULE_CTRL_IN_Priv_ConstructContainerObject(acl_container_p, &acl_container_obj);
    acl_container_obj.get_element_iterator(&acl_container_obj, &acl_inst_iter);

    for (acl_inst_iter.first(&acl_inst_iter);
         NULL != acl_inst_iter.get_instance(&acl_inst_iter);
         acl_inst_iter.next(&acl_inst_iter))
    {
        RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;

        acl_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T) acl_inst_iter.get_instance(&acl_inst_iter);

        RULE_CTRL_LocalUpdateTimeACLRelationRulePerInterface_ACL(interface_p, state_change_list, acl_inst_p);
    }
    //
    // --== End of duplicated code
    //

    return RULE_TYPE_OK;
}

static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalUpdateTimeACLRelationRulePerInterface_ACL(
    const RULE_TYPE_INTERFACE_INFO_PTR_T interface_p,
    UI8_T *state_change_list,
    RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T acl_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T ace_inst_iter;

    UI8_T do_action, default_action; /* store the state of time-range-compare-list */

    ASSERT(NULL != interface_p);
    ASSERT(RULE_TYPE_INTERFACE_UPORT == interface_p->type);
    ASSERT(NULL != acl_inst_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(acl_inst_p, &acl_inst_obj);
    acl_inst_obj.get_element_iterator(&acl_inst_obj, &ace_inst_iter);

    /* get default action */
    if (RULE_TYPE_UNDEF_TIME_RANGE == acl_inst_p->time_range_index)
    {
        default_action = RULE_TYPE_TIME_RANGE_IN_ACTIVE;
    }
    else
    {
        default_action = state_change_list[acl_inst_p->time_range_index];
    }

    for (ace_inst_iter.first(&ace_inst_iter);
         NULL != ace_inst_iter.get_instance(&ace_inst_iter);
         ace_inst_iter.next(&ace_inst_iter))
    {
        RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p;

        RULE_TYPE_Ace_Entry_T ace_entry;

        ace_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T) ace_inst_iter.get_instance(&ace_inst_iter);
        ASSERT(NULL != ace_inst_p);

        result = RULE_OM_GetAceByIndex(ace_inst_p->id, &ace_entry);
        ASSERT(RULE_TYPE_OK == result);

        if (RULE_TYPE_OK != result)
        {
            LOG("<Internal Error> Failed to get ACE entry");
            continue;
        }

        {
            RULE_TYPE_CLASS_INSTANCE_OBJECT_T ace_inst_obj;
            RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T rule_inst_iter;

            RULE_CTRL_IN_Priv_ConstructClassInstanceObject(ace_inst_p, &ace_inst_obj);
            ace_inst_obj.get_element_iterator(&ace_inst_obj, &rule_inst_iter);

            for (rule_inst_iter.first(&rule_inst_iter);
                 NULL != rule_inst_iter.get_instance(&rule_inst_iter);
                 rule_inst_iter.next(&rule_inst_iter))
            {
                RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;

                rule_inst_p = (RULE_TYPE_RULE_INSTANCE_PTR_T) rule_inst_iter.get_instance(&rule_inst_iter);

                 /* decide do which action */
                if (RULE_TYPE_UNDEF_TIME_RANGE == ace_entry.time_range_index)
                {
                    do_action = default_action;
                }
                else
                {
                    do_action = state_change_list[ace_entry.time_range_index];
                }

                if (RULE_TYPE_TIME_RANGE_IN_ACTIVE == do_action)
                {
                    if (TRUE == rule_inst_p->active)
                    {
                        /* do nothing */
                    }
                    else
                    {
                        DEVRM_PBMP_T port_bit_map;
                        RULE_TYPE_COUNTER_ENABLE_T  counter_enable = RULE_TYPE_COUNTER_DISABLE;

#if (SYS_CPNT_ACL_COUNTER == TRUE)
                        counter_enable = acl_inst_p->counter_enable;
#endif /* SYS_CPNT_ACL_COUNTER */

                        /*allocate rule set rule*/
                        if (FALSE == RULE_CTRL_ALLOCATE_RULE(rule_inst_p->dev_rule_info.unit,
                                                             interface_p->uport.port,
                                                             rule_inst_p->dev_rule_info.device,
                                                             rule_inst_p->dev_rule_info.group_id,
                                                             rule_inst_p->dev_rule_info.fun_type,
                                                             rule_inst_p->dev_rule_info.priority,
                                                             &rule_inst_p->dev_rule_info.rule_id))
                        {
                            LOG("<Error> Failed to allocate rule");
                            continue;
                        }

                        rule_inst_p->active = TRUE;

                        ASSERT(sizeof(port_bit_map) <= sizeof(rule_inst_p->dev_rule_info.port_bmp));
                        memcpy(&port_bit_map, &rule_inst_p->dev_rule_info.port_bmp, sizeof(port_bit_map));

                        if (FALSE == RULE_CTRL_AddRule2DevForAclPurpose(RULE_TYPE_INBOUND == interface_p->direction ? TRUE : FALSE,
                                                                        rule_inst_p->dev_rule_info.unit,
                                                                        interface_p->uport.port,
                                                                        rule_inst_p->dev_rule_info.device,
                                                                        rule_inst_p->dev_rule_info.group_id,
                                                                        rule_inst_p->dev_rule_info.rule_id,
                                                                        port_bit_map,
                                                                        &ace_entry, ace_inst_p->id,
                                                                        counter_enable))
                        {
                            LOG("<Error> Failed to set rule on dev");
                            continue;
                        }

                    }
                } /* end of if (RULE_TYPE_TIME_RANGE_IN_ACTIVE == do_action) */
                else if (RULE_TYPE_TIME_RANGE_UN_ACTIVE == do_action)
                {
                    if (TRUE == rule_inst_p->active)
                    {
                        if (FALSE == RULE_CTRL_DESTROY_RULE(rule_inst_p->dev_rule_info.unit,
                                                            1,
                                                            rule_inst_p->dev_rule_info.device,
                                                            rule_inst_p->dev_rule_info.group_id,
                                                            rule_inst_p->dev_rule_info.fun_type,
                                                            rule_inst_p->dev_rule_info.rule_id))
                        {
                            LOG("<Error> Failed to destroy rule on dev");
                            continue;
                        }

                        rule_inst_p->active = FALSE;
                    }
                }
            }
        }
    }

    return TRUE;

}
#endif /* SYS_CPNT_TIME_BASED_ACL */

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalCheckRuleInActiveByTimeRange
 *------------------------------------------------------------------------------
 * PURPOSE  : Check a ace if be in-active in this moment
 * INPUT    : ace_time_range_id, acl_time_range_id
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTE     : first check "ace_time_range_id" (first priority), if fail then
 *                  check "acl_time_range_id" (2nd priority)
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_LocalCheckRuleInActiveByTimeRange(
    UI32_T ace_time_range_id,
    UI32_T acl_time_range_id)
{
#if (SYS_CPNT_TIME_BASED_ACL == TRUE)
    BOOL_T is_active = TRUE;

    /* check the state of time-range entry relation with ace : (first priority)
       if no time-range binds to ace, it will return failed.
       If it fail, then to check acl-port time-range.
     */
    if (TIME_RANGE_ERROR_TYPE_NONE == TIME_RANGE_OM_IsTimeRangeEntryActive(ace_time_range_id, &is_active))
    {
        return is_active;
    }

    /* check the state of time-range entry relation with acl : (second priority)
       if no time-range binds to acl and port, it will return failed.
     */
    if (TIME_RANGE_ERROR_TYPE_NONE == TIME_RANGE_OM_IsTimeRangeEntryActive(acl_time_range_id, &is_active))
    {
        return is_active;
    }
#endif

    /* no any time-range is relation with ace */
    return TRUE;
}

static BOOL_T
RULE_CTRL_GetFunctionTypeForACLAndQoS(
    BOOL_T                      is_acl,
    BOOL_T                      is_ingress,
    UI32_T                      ace_type,
    RULE_TYPE_FunctionType_T    *fun_type_p)
{
    if (NULL == fun_type_p)
    {
        return FALSE;
    }

    switch(ace_type)
    {
        case RULE_TYPE_MAC_ACL:
            if(is_acl)
            {
                *fun_type_p = (is_ingress ? RULE_TYPE_INGRESS_MAC_ACL : RULE_TYPE_EGRESS_MAC_ACL);
            }
            else
            {
                if (is_ingress)
                {
                    *fun_type_p = RULE_TYPE_MAC_DIFFSERV;
                }
                else
                {
                    *fun_type_p = RULE_TYPE_EGRESS_MAC_DIFFSERV;
                }
            }
            break;
        case RULE_TYPE_IP_ACL:
        case RULE_TYPE_IP_STD_ACL:
        case RULE_TYPE_IP_EXT_ACL:
            if(is_acl)
            {
                *fun_type_p = (is_ingress ? RULE_TYPE_INGRESS_IP_ACL : RULE_TYPE_EGRESS_IP_ACL);
            }
            else
            {
                if (is_ingress)
                {
                    *fun_type_p = RULE_TYPE_IP_DIFFSERV;
                }
                else
                {
                    *fun_type_p = RULE_TYPE_EGRESS_IP_DIFFSERV;
                }
            }
            break;

        case RULE_TYPE_IPV6_STD_ACL:
            if (is_acl)
            {
                if (is_ingress)
                {
                    *fun_type_p = RULE_TYPE_INGRESS_IPV6_STD_ACL;
                }
                else
                {
                    *fun_type_p = RULE_TYPE_EGRESS_IPV6_STD_ACL;
                }
            }
            else
            {
                if (is_ingress)
                {
                    *fun_type_p = RULE_TYPE_INGRESS_IPV6_STD_DIFFSERV;
                }
                else
                {
                    *fun_type_p = RULE_TYPE_EGRESS_IPV6_STD_DIFFSERV;
                }
            }
            break;

        case RULE_TYPE_IPV6_EXT_ACL:
            if (is_acl)
            {
                if (is_ingress)
                {
                    *fun_type_p = RULE_TYPE_INGRESS_IPV6_EXT_ACL;
                }
                else
                {
                    *fun_type_p = RULE_TYPE_EGRESS_IPV6_EXT_ACL;
                }
            }
            else
            {
                if (is_ingress)
                {
                    *fun_type_p = RULE_TYPE_INGRESS_IPV6_EXT_DIFFSERV;
                }
                else
                {
                    *fun_type_p = RULE_TYPE_EGRESS_IPV6_EXT_DIFFSERV;
                }
            }
            break;

        default :
            ASSERT(0);
            return FALSE;
    }

    return TRUE;
}

static BOOL_T
RULE_CTRL_GetFunctionInfoByAceTypeAndDirection(BOOL_T is_acl, BOOL_T is_ingress, UI32_T ace_type, UI32_T *group_id, int *rule_pri)
{
    RULE_TYPE_FunctionType_T fun_type;
    FP_CONFIG_FunctionInfo_T *fun_info;
    FP_CONFIG_GroupInfo_T    *grp_info_p;

    if (FALSE == RULE_CTRL_GetFunctionTypeForACLAndQoS(is_acl,
                                                       is_ingress,
                                                       ace_type,
                                                       &fun_type))
    {
        return FALSE;
    }

    fun_info = FP_CONFIG_get_function_info_by_type(fun_type);
    if(NULL == fun_info)
        return FALSE;

    grp_info_p = FP_CONFIG_get_group_info_by_id(fun_info->group_id);
    *group_id = grp_info_p->group_id;
    *rule_pri = fun_info->rule_pri;

    return TRUE;
}

static BOOL_T
RULE_CTRL_GetFunctionInfoByFunctionType(
    UI32_T fun_type,
    UI32_T *group_id,
    int *rule_pri)
{
    FP_CONFIG_FunctionInfo_T *fun_info;
    FP_CONFIG_GroupInfo_T    *grp_info_p;

    if(RULE_TYPE_FUNCTION_TYPE_MAX <= fun_type)
        return FALSE;

    if(NULL == group_id || NULL == rule_pri)
        return FALSE;

    fun_info = FP_CONFIG_get_function_info_by_type(fun_type);
    if(NULL == fun_info)
        return FALSE;

    grp_info_p = FP_CONFIG_get_group_info_by_id(fun_info->group_id);

    *group_id = grp_info_p->group_id;
    *rule_pri = fun_info->rule_pri;

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalCheckQualifySet
 *------------------------------------------------------------------------------
 * PURPOSE  : Patch code !! Check the qualify bit is fine or not for IPv6 ACE
 * INPUT    : fun_type - function type
 *            ace_entry_p - ACE
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK; error code
 * NOTES    : Patch function, FIXME: Remove this function
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalCheckQualifySet(
    UI32_T fun_type,
    const RULE_TYPE_Ace_Entry_T *ace_entry_p)
{
    FP_CONFIG_FunctionInfo_T *fun_info_p;
    FP_CONFIG_GroupInfo_T *grp_info_p;

    fun_info_p = FP_CONFIG_get_function_info_by_type(fun_type);
    if (NULL == fun_info_p)
    {
        return RULE_TYPE_FAIL;
    }

    grp_info_p = FP_CONFIG_get_group_info_by_id(fun_info_p->group_id);
    if (NULL == grp_info_p)
    {
        return RULE_TYPE_FAIL;
    }

    switch (ace_entry_p->ace_type)
    {
        case RULE_TYPE_IPV6_EXT_ACL:
            if (ace_entry_p->u.ipv6.aceFlowLabel != RULE_TYPE_UNDEF_IPV6_FLOW_LABEL)
            {
                if (0 == DEVRM_SHR_BITGET(grp_info_p->w, DEVRM_FIELD_QUALIFY_Ip6FlowLabel))
                {
                    return RULE_TYPE_FAIL;
                }
            }
            break;

        default:
            break;
    }

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalCheckQosACLQualifySet
 *------------------------------------------------------------------------------
 * PURPOSE  : RULE_CTRL_LocalCheckQosACLQualifySet
 * INPUT    : interface_p - interface
 *            policy_map_index - index of policy map
 *            policy_map_p - policy map
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK; error code
 * NOTES    : Patch function, FIXME: Remove this function
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalCheckQosACLQualifySet(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p,
    BOOL_T is_acl,
    UI32_T acl_index)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_Ace_Entry_T ace_entry;
    RULE_TYPE_AclType_T ace_type;
    UI32_T ace_index;

    ASSERT(NULL != interface_p);

    ace_index = 0;

    while (RULE_TYPE_OK == RULE_OM_GetNextAceByAcl(acl_index, &ace_type, &ace_index, &ace_entry))
    {
        RULE_TYPE_FunctionType_T fun_type;

        if (FALSE == RULE_CTRL_GetFunctionTypeForACLAndQoS(is_acl,
                                                           RULE_TYPE_INBOUND == interface_p->direction ? TRUE : FALSE,
                                                           ace_entry.ace_type,
                                                           &fun_type))
        {
            return RULE_TYPE_FAIL;
        }

        result = RULE_CTRL_LocalCheckQualifySet(fun_type, &ace_entry);
        if (RULE_TYPE_OK != result)
        {
            return result;
        }
    }

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalCheckAclOnBinding
 *------------------------------------------------------------------------------
 * PURPOSE  : RULE_CTRL_LocalCheckAclOnBinding
 * INPUT    : interface_p - interface
 *            policy_map_index - index of policy map
 *            policy_map_p - policy map
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK; error code
 * NOTES    : Patch function, FIXME: Remove this function
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalCheckAclOnBinding(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p,
    UI32_T acl_index)
{
    return RULE_CTRL_LocalCheckQosACLQualifySet(interface_p, TRUE, acl_index);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalCheckPolicyMapQualifySet
 *------------------------------------------------------------------------------
 * PURPOSE  : RULE_CTRL_LocalCheckPolicyMapQualifySet
 * INPUT    : interface_p - interface
 *            policy_map_index - index of policy map
 *            policy_map_p - policy map
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK; error code
 * NOTES    : Patch function, FIXME: Remove this function
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalCheckPolicyMapQualifySet(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p,
    UI32_T policy_map_index,
    const RULE_TYPE_PolicyMap_T *policy_map_p)
{
    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T px;

    ASSERT(NULL != interface_p);
    ASSERT(NULL != policy_map_p);

    for (px = 0; px < policy_map_p->element_count; ++ px)
    {
        RULE_TYPE_PolicyElement_T policy_element;
        RULE_TYPE_ClassMap_T      class_map;

        result = RULE_OM_GetPolicyMapElement(policy_map_p->policy_map_element_index_list[px],
                                             &policy_element);
        if (RULE_TYPE_OK != result)
        {
            return result;
        }

        result = RULE_OM_GetClassMap(policy_element.class_map_index, &class_map);
        if (RULE_TYPE_OK != result)
        {
            return result;
        }

        switch (class_map.class_map_match_type)
        {
            case RULE_TYPE_CLASS_MAP_MATCH_ANY:
            {
                UI32_T cx;

                for (cx = 0; cx < class_map.class_element_count; ++ cx)
                {
                    RULE_TYPE_ClassType_T class_type = class_map.class_type[cx];
                    UI32_T class_id = class_map.class_index_list[cx];

                    if (class_type == RULE_TYPE_CLASS_MF)
                    {
                        RULE_TYPE_Ace_Entry_T ace_entry;

                        RULE_TYPE_FunctionType_T fun_type;

                        result = RULE_OM_GetAceByIndex(class_id, &ace_entry);
                        if (RULE_TYPE_OK != result)
                        {
                            return result;
                        }

                        if (FALSE == RULE_CTRL_GetFunctionTypeForACLAndQoS(FALSE,
                                                                           RULE_TYPE_INBOUND == interface_p->direction ? TRUE : FALSE,
                                                                           ace_entry.ace_type,
                                                                           &fun_type))
                        {
                            return RULE_TYPE_FAIL;
                        }

                        result = RULE_CTRL_LocalCheckQualifySet(fun_type, &ace_entry);
                        if (RULE_TYPE_OK != result)
                        {
                            return result;
                        }
                    }
                    else if (class_type == RULE_TYPE_CLASS_ACL)
                    {
                        result = RULE_CTRL_LocalCheckQosACLQualifySet(interface_p,
                                                                      FALSE, // is_acl
                                                                      class_id);
                        if (RULE_TYPE_OK != result)
                        {
                            return result;
                        }
                    }
                }

                break;
            }

#if (SYS_CPNT_QOS_V2_CLASS_MAP_MATCH_ALL == TRUE)
            case RULE_TYPE_CLASS_MAP_MATCH_ALL:
            {
                UI32_T  agg_acl_index;

                /* Create a working ACL which aggregate all ACE.
                 */
                result = RULE_OM_BuildMatchAllClassMapRule(class_map_index, &agg_acl_index);
                if (RULE_TYPE_OK != result)
                {
                    return result;
                }

                result = RULE_CTRL_LocalCheckQosACLQualifySet(interface_p,
                                                              FALSE, // is_acl
                                                              agg_acl_index);
                if (RULE_TYPE_OK != result)
                {
                    return result;
                }

                break;
            }
#endif
            default:
                break;
        }
    }

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalCheckPolicyMapOnBinding
 *------------------------------------------------------------------------------
 * PURPOSE  : RULE_CTRL_LocalCheckPolicyMapOnBinding
 * INPUT    : interface_p - interface
 *            policy_map_index - index of policy map
 *            policy_map_p - policy map
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK; error code
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalCheckPolicyMapOnBinding(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p,
    UI32_T policy_map_index,
    const RULE_TYPE_PolicyMap_T *policy_map_p)
{
    RULE_TYPE_RETURN_TYPE_T   result;

    RULE_CTRL_ResourceInfo_T  *res_p;
    UI32_T                    module_id, device_id, phy_port;
    RULE_TYPE_PolicyMap_T     policy_map;
    RULE_TYPE_PolicyElement_T policy_element;
    RULE_TYPE_ClassMap_T      class_map;
    RULE_TYPE_Acl_T           acl_entry;
    UI32_T                    total_mac_rule_count = 0;
    UI32_T                    total_ipv4_count = 0;
    UI32_T                    total_std_ipv6_count = 0, total_ext_ipv6_count = 0;
    UI32_T                    shift_nbr = 0;
    UI32_T                    i = 0, j = 0;
    UI32_T                    uport_index;
    UI32_T                    group_id = 0;
    int                       rule_pri;

    ASSERT(RULE_TYPE_INTERFACE_UPORT == interface_p->type);

    /** PATCH CODE !!
     * Remove this if we can well handle for undo set rule.
     */
    result = RULE_CTRL_LocalCheckPolicyMapQualifySet(interface_p, policy_map_index, policy_map_p);
    if (RULE_TYPE_OK != result)
    {
        return result;
    }

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(interface_p->uport.unit,
                                                        interface_p->uport.port,
                                                        &module_id,
                                                        &device_id,
                                                        &phy_port))
    {
        return RULE_TYPE_INVALID_PARAMETER;
    }

    memset(&policy_map, 0, sizeof(RULE_TYPE_PolicyMap_T));
    memset(&policy_element, 0, sizeof(RULE_TYPE_PolicyElement_T));
    memset(&class_map, 0, sizeof(RULE_TYPE_ClassMap_T));
    memset(&acl_entry, 0, sizeof(RULE_TYPE_Acl_T));

    ASSERT(RULE_TYPE_INTERFACE_UPORT == interface_p->type);

    uport_index = STKTPLG_OM_UPORT_TO_IFINDEX(interface_p->uport.unit,
                                              interface_p->uport.port);
    shift_nbr = uport_index-1;
    if (RULE_TYPE_OK == RULE_OM_GetPolicyMap(policy_map_index, &policy_map))
    {
        UI8_T *port_list_p = (RULE_TYPE_INBOUND == interface_p->direction) ?
                                policy_map.qos_port_list :
                                policy_map.egress_qos_port_list;

        /*if the port has already bind do not check and return*/
        if (RULE_CTRL_IS_BIT_ON(port_list_p, shift_nbr))
        {
            return RULE_TYPE_ALREADY_BIND;
        }
        for (i = 0; i < policy_map.element_count; i++)
        {
            if (RULE_TYPE_OK == RULE_OM_GetPolicyMapElement(policy_map.policy_map_element_index_list[i], &policy_element))
            {
                if (RULE_TYPE_OK == RULE_OM_GetClassMap(policy_element.class_map_index, &class_map))
                {
                    for (j=0;j<class_map.class_element_count;j++)
                    {
                        switch (class_map.class_type[j])
                        {
                            case RULE_TYPE_CLASS_MF:
                                total_mac_rule_count += 1;
                                break;

                            case RULE_TYPE_CLASS_ACL:
                                if (RULE_TYPE_OK == RULE_OM_GetAclByIndex(class_map.class_index_list[j], &acl_entry))
                                {
                                    switch (acl_entry.acl_type)
                                    {
                                        case RULE_TYPE_MAC_ACL:
                                            total_mac_rule_count += acl_entry.ace_count;
                                            break;

                                        case RULE_TYPE_IP_ACL:
                                        case RULE_TYPE_IP_STD_ACL:
                                        case RULE_TYPE_IP_EXT_ACL:
                                            total_ipv4_count += acl_entry.ace_count;
                                            break;

                                        case RULE_TYPE_IPV6_ACL:
                                            return RULE_TYPE_FAIL;

                                        case RULE_TYPE_IPV6_STD_ACL:
                                            total_std_ipv6_count += acl_entry.ace_count;
                                            break;
                                        case RULE_TYPE_IPV6_EXT_ACL:
                                            total_ext_ipv6_count += acl_entry.ace_count;
                                            break;

                                        default:
                                            break;
                                    }
                                }
                                break;

                            default:
                                break;
                        }
                    }
                }
            }
        }

        if (total_mac_rule_count > 0)
        {
            if(FALSE == RULE_CTRL_GetFunctionInfoByAceTypeAndDirection(FALSE,
                                                                       RULE_TYPE_INBOUND == interface_p->direction ? TRUE : FALSE,
                                                                       RULE_TYPE_MAC_ACL,
                                                                       &group_id,
                                                                       &rule_pri))
            {
                return RULE_TYPE_FAIL;
            }

            res_p = RULE_CTRL_GetResourceInfo(interface_p->uport.unit, device_id, group_id);
            if (NULL == res_p)
            {
                return RULE_TYPE_INVALID_PARAMETER;
            }

            if (res_p->free_rule < total_mac_rule_count)
            {
                return RULE_TYPE_INSUFFICIENT_RESOURCE;
            }

            if (FALSE == RULE_CTRL_RequestRuleByQuota(interface_p->uport.unit, device_id,
                                                      RULE_TYPE_INBOUND == interface_p->direction ? RULE_TYPE_MAC_DIFFSERV : RULE_TYPE_EGRESS_MAC_DIFFSERV,
                                                      RULE_CTRL_REQUEST_RESOURCE_ALLOCATE_TEST,
                                                      total_mac_rule_count))
            {
                return RULE_TYPE_INSUFFICIENT_RESOURCE;
            }
        }

        if (total_ipv4_count > 0)
        {
            if(FALSE == RULE_CTRL_GetFunctionInfoByAceTypeAndDirection(FALSE,
                                                                       RULE_TYPE_INBOUND == interface_p->direction ? TRUE : FALSE,
                                                                       RULE_TYPE_IP_ACL,
                                                                       &group_id,
                                                                       &rule_pri))
            {
                return RULE_TYPE_FAIL;
            }

            res_p = RULE_CTRL_GetResourceInfo(interface_p->uport.unit, device_id, group_id);
            if (NULL == res_p)
            {
                return RULE_TYPE_INVALID_PARAMETER;
            }

            if (res_p->free_rule < total_ipv4_count)
            {
                return RULE_TYPE_INSUFFICIENT_RESOURCE;
            }

            if (FALSE == RULE_CTRL_RequestRuleByQuota(interface_p->uport.unit, device_id,
                                                      RULE_TYPE_INBOUND == interface_p->direction ? RULE_TYPE_IP_DIFFSERV : RULE_TYPE_EGRESS_IP_DIFFSERV,
                                                      RULE_CTRL_REQUEST_RESOURCE_ALLOCATE_TEST,
                                                      total_ipv4_count))
            {
                return RULE_TYPE_INSUFFICIENT_RESOURCE;
            }
        }

        if (total_std_ipv6_count > 0)
        {
            if(FALSE == RULE_CTRL_GetFunctionInfoByAceTypeAndDirection(FALSE,
                                                                       RULE_TYPE_INBOUND == interface_p->direction ? TRUE : FALSE,
                                                                       RULE_TYPE_IPV6_STD_ACL,
                                                                       &group_id,
                                                                       &rule_pri))
            {
                return RULE_TYPE_FAIL;
            }

            res_p = RULE_CTRL_GetResourceInfo(interface_p->uport.unit, device_id, group_id);
            if (NULL == res_p)
            {
                return RULE_TYPE_INVALID_PARAMETER;
            }

            if (res_p->free_rule < total_std_ipv6_count)
            {
                return RULE_TYPE_INSUFFICIENT_RESOURCE;
            }

            if (FALSE == RULE_CTRL_RequestRuleByQuota(interface_p->uport.unit, device_id,
                                                      RULE_TYPE_INBOUND == interface_p->direction ? RULE_TYPE_INGRESS_IPV6_STD_DIFFSERV : RULE_TYPE_EGRESS_IPV6_STD_DIFFSERV,
                                                      RULE_CTRL_REQUEST_RESOURCE_ALLOCATE_TEST,
                                                      total_std_ipv6_count))
            {
                return RULE_TYPE_INSUFFICIENT_RESOURCE;
            }
        }

        if (total_ext_ipv6_count > 0)
        {
            if(FALSE == RULE_CTRL_GetFunctionInfoByAceTypeAndDirection(FALSE,
                                                                       RULE_TYPE_INBOUND == interface_p->direction ? TRUE : FALSE,
                                                                       RULE_TYPE_IPV6_EXT_ACL,
                                                                       &group_id,
                                                                       &rule_pri))
            {
                return RULE_TYPE_FAIL;
            }

            res_p = RULE_CTRL_GetResourceInfo(interface_p->uport.unit, device_id, group_id);
            if (NULL == res_p)
            {
                return RULE_TYPE_INVALID_PARAMETER;
            }

            if (res_p->free_rule < total_ext_ipv6_count)
            {
                return RULE_TYPE_INSUFFICIENT_RESOURCE;
            }

            if (FALSE == RULE_CTRL_RequestRuleByQuota(interface_p->uport.unit, device_id,
                                                      RULE_TYPE_INBOUND == interface_p->direction ? RULE_TYPE_INGRESS_IPV6_EXT_DIFFSERV : RULE_TYPE_EGRESS_IPV6_EXT_DIFFSERV,
                                                      RULE_CTRL_REQUEST_RESOURCE_ALLOCATE_TEST,
                                                      total_ext_ipv6_count))
            {
                return RULE_TYPE_INSUFFICIENT_RESOURCE;
            }
        }

    }

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalSetPolicyMap2DEV
 *------------------------------------------------------------------------------
 * PURPOSE  : add rule for policy-map
 * INPUT    : interface_p - interface binding the policy-map
 *            policy_map_index - policy-map index
 *            policy_map_p - policy-map
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK; error code
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalSetPolicyMap2DEV(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p,
    UI32_T policy_map_index,
    const RULE_TYPE_PolicyMap_T *policy_map_p)
{
    UI32_T                  px;
    RULE_TYPE_RETURN_TYPE_T result;

    //
    // --== Duplicated code start
    //
    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T policy_map_inst_obj;
    RULE_CTRL_INSTANCE_TYPE_ID_T param;
    //
    // --== End of duplicated code
    //

    ASSERT(NULL != interface_p);
    ASSERT(interface_p->type < RULE_TYPE_INTERFACE_MAX);
    ASSERT(RULE_TYPE_INBOUND == interface_p->direction ||
           RULE_TYPE_OUTBOUND == interface_p->direction);
    ASSERT(NULL != policy_map_p);

    LOG_IF(*interface_p, "policyMapId = %lu", policy_map_index);

    result = RULE_CTRL_LocalCheckPolicyMapOnBinding(interface_p,
                                                    policy_map_index,
                                                    policy_map_p);
    if (RULE_TYPE_OK != result)
    {
        return result;
    }

    //
    // --== Duplicated code start
    //
    if_entry_p = RULE_CTRL_Priv_GetIfEntry(interface_p);
    ASSERT(NULL != if_entry_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                              &if_class_obj);

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_POLICY_MAP;
    param.id = policy_map_index;

    policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                       RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                       &param);
    /** Not allow to bind the same policy map twice
     */
    if (NULL != policy_map_inst_p)
    {
        return RULE_TYPE_OK;
    }

    ASSERT(NULL == policy_map_inst_p);

    result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_POLICY_MAP,
                                                         &policy_map_inst_obj);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Failed to create policy-map instance");
        goto undo;
    }

    policy_map_inst_p = policy_map_inst_obj.inst;

    ASSERT(NULL != policy_map_inst_p);
    ASSERT(policy_map_inst_p == policy_map_inst_obj.inst);

    policy_map_inst_p->id = policy_map_index;
//    policy_map_inst_p->mvl_pkt_type = RULE_TYPE_PACKET_NIL;

    if_class_obj.add_class_obj(&if_class_obj, &policy_map_inst_obj);

    //
    // Rule OM
    //
    result = RULE_CTRL_Priv_SetPolicyMapInstance(interface_p, policy_map_inst_p);
    ASSERT(RULE_TYPE_OK == result);
    //
    // --== End of duplicated code
    //

    for (px = 0; px < policy_map_p->element_count; ++px)
    {
        UI32_T policy_element_index = policy_map_p->policy_map_element_index_list[px];

        RULE_TYPE_PolicyElement_T policy_element;

        result = RULE_OM_GetPolicyMapElement(policy_element_index, &policy_element);
        ASSERT(RULE_TYPE_OK == result);

        result = RULE_CTRL_LocalSetClassMap2DEV(interface_p,
                                                policy_map_index,
                                                policy_map_p,
                                                policy_map_inst_obj.inst,
                                                policy_element.class_map_index,
                                                policy_element.meter_index,
                                                policy_element.action_index);
        if (RULE_TYPE_OK != result)
        {
            goto undo;
        }
    }

    return RULE_TYPE_OK;

undo:

    {
        RULE_TYPE_RETURN_TYPE_T temp_result;

        temp_result = RULE_CTRL_LocalRemovePolicyMap2DEV(interface_p,
                                                         policy_map_index,
                                                         policy_map_p);
        ASSERT(RULE_TYPE_OK == temp_result);
    }

    ASSERT(RULE_TYPE_OK != result);
    return result;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalRemovePolicyMap2DEV
 *------------------------------------------------------------------------------
 * PURPOSE  : remove rule for policy-map
 * INPUT    : interface_p - interface binding the policy-map
 *            policy_map_index - policy-map index
 *            policy_map_p - policy-map
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK; error code
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalRemovePolicyMap2DEV(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p,
    UI32_T policy_map_index,
    const RULE_TYPE_PolicyMap_T *policy_map_p)
{
    UI32_T                  px;
    RULE_TYPE_RETURN_TYPE_T result;

    //
    // --== Duplicated code start
    //
    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T policy_map_inst_obj;

    RULE_CTRL_INSTANCE_TYPE_ID_T param;
    //
    // --== End of duplicated code
    //

    ASSERT(NULL != interface_p);
    ASSERT(interface_p->type < RULE_TYPE_INTERFACE_MAX);
    ASSERT(RULE_TYPE_INBOUND == interface_p->direction ||
           RULE_TYPE_OUTBOUND == interface_p->direction);
    ASSERT(NULL != policy_map_p);

    LOG_IF(*interface_p, "policyMapId = %lu", policy_map_index);

    //
    // --== Duplicated code start
    //
    if_entry_p = RULE_CTRL_Priv_GetIfEntry(interface_p);
    ASSERT(NULL != if_entry_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                              &if_class_obj);

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_POLICY_MAP;
    param.id = policy_map_index;

    policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                       RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                       &param);

    if (NULL == policy_map_inst_p)
    {
        return RULE_TYPE_OK;
    }
    //
    // --== End of duplicated code
    //

    for (px = 0; px < policy_map_p->element_count; ++px)
    {
        UI32_T policy_element_index = policy_map_p->policy_map_element_index_list[px];
        RULE_TYPE_PolicyElement_T   policy_element;

        result = RULE_OM_GetPolicyMapElement(policy_element_index, &policy_element);
        ASSERT(RULE_TYPE_OK == result);

        result = RULE_CTRL_LocalRemoveClassMap2DEV(interface_p,
                                                   policy_map_index,
                                                   policy_map_p,
                                                   policy_map_inst_p,
                                                   policy_element.class_map_index,
                                                   policy_element.meter_index,
                                                   policy_element.action_index);
        ASSERT(RULE_TYPE_OK == result);
        if (RULE_TYPE_OK != result)
        {
            LOG("<Internal Error> Failed to remove class-map");
        }
    }

    ASSERT(NULL != policy_map_inst_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(policy_map_inst_p, &policy_map_inst_obj);
    ASSERT(NULL != policy_map_inst_obj.inst &&
           policy_map_inst_p == policy_map_inst_obj.inst);

    if_class_obj.remove_class_obj(&if_class_obj, &policy_map_inst_obj);
    RULE_CTRL_IN_Priv_DestroyClassInstanceObject(&policy_map_inst_obj);

    policy_map_inst_p = NULL;
    policy_map_inst_obj.inst = NULL;

    //
    // Rule OM !!
    //
    result = RULE_CTRL_Priv_SetPolicyMapInstance(interface_p, NULL);
    ASSERT(RULE_TYPE_OK == result);

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalSetClassMap2DEV
 *------------------------------------------------------------------------------
 * PURPOSE  : add rule for class-map
 * INPUT    : interface_p - interface binding the policy-map
 *            policy_map_index - policy-map index
 *            class_map_index - class-map index
 *            meter_id - meter entry index
 *            action_id - action entry index
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK; error code
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalSetClassMap2DEV(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p,
    UI32_T policy_map_index,
    const RULE_TYPE_PolicyMap_T *policy_map_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p,
    UI32_T class_map_index,
    UI32_T meter_index,
    UI32_T action_index)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_ClassMap_T class_map;

    //
    // --== Duplicated code start
    //
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T policy_map_inst_obj;

    RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T class_map_inst_obj;

    RULE_CTRL_INSTANCE_TYPE_ID_T param;
    //
    // --== End of duplicated code
    //

    ASSERT(NULL != interface_p);
    ASSERT(interface_p->type < RULE_TYPE_INTERFACE_MAX);
    ASSERT(RULE_TYPE_INBOUND == interface_p->direction ||
           RULE_TYPE_OUTBOUND == interface_p->direction);
    ASSERT(NULL != policy_map_p);
    ASSERT(NULL != policy_map_inst_p);
    ASSERT(RULE_TYPE_NIL != policy_map_inst_p->super.type);

    LOG_IF(*interface_p, "policyMapId = %lu, classMapId = %lu, meterId = %lu, actionId = %lu",
           policy_map_index,
           class_map_index,
           meter_index,
           action_index);

    result = RULE_OM_GetClassMap(class_map_index, &class_map);

    if (RULE_TYPE_OK != result)
    {
        return result;
    }

    //
    // --== Duplicated code start
    //
    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(policy_map_inst_p,
                                                   &policy_map_inst_obj);

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_CLASS_MAP;
    param.id = class_map_index;

    class_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) policy_map_inst_p,
                                                                                      RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                      &param);

    /** Not allow to bind the same class map twice
     */
    if (NULL != class_map_inst_p)
    {
        return RULE_TYPE_OK;
    }

    ASSERT(NULL == class_map_inst_p);

    if (NULL == class_map_inst_p)
    {
        result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_CLASS_MAP,
                                                             &class_map_inst_obj);
        if (RULE_TYPE_OK != result)
        {
            LOG("<Error> Failed to create class-map instance");
            goto undo;
        }

        class_map_inst_p = class_map_inst_obj.inst;

        ASSERT(NULL != class_map_inst_p);

        class_map_inst_p->id = class_map_index;
//        class_map_inst_p->mvl_pkt_type = RULE_TYPE_PACKET_NIL;

        ASSERT(NULL != policy_map_inst_p);
        ASSERT(policy_map_inst_p == policy_map_inst_obj.inst);

        policy_map_inst_obj.add_class_obj(&policy_map_inst_obj, &class_map_inst_obj);
    }
    //
    // --== End of duplicated code
    //

    switch (class_map.class_map_match_type)
    {
        case RULE_TYPE_CLASS_MAP_MATCH_ANY:
        {
            UI32_T cx;

            for (cx = 0; cx < class_map.class_element_count; ++cx)
            {
                RULE_TYPE_ClassType_T class_type = class_map.class_type[cx];
                UI32_T class_id = class_map.class_index_list[cx];

                if (class_type == RULE_TYPE_CLASS_MF)
                {
                    result = RULE_CTRL_LocalSetMF2DEV(interface_p,
                                                      policy_map_index,
                                                      class_map_index,
                                                      class_id,
                                                      meter_index,
                                                      action_index);
                    if (RULE_TYPE_OK != result)
                    {
                        goto undo;
                    }
                }
                else if (class_type == RULE_TYPE_CLASS_ACL)
                {
#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
                    RULE_TYPE_Acl_T acl_entry;

                    result = RULE_OM_GetAclByIndex(class_id, &acl_entry);
                    if (RULE_TYPE_OK != result)
                    {
                        goto undo;
                    }
                    if (TRUE == acl_entry.flag_aggregate_done)
                    {
                       class_id = acl_entry.aggregate_acl_index;
                    }
#endif /* SYS_CPNT_ACL_AUTO_COMPRESS_ACE */
                    result = RULE_CTRL_LocalSetQoSACL2DEV(interface_p,
                                                          policy_map_index,
                                                          class_map_index,
                                                          class_id,
                                                          meter_index,
                                                          action_index);
                    if (RULE_TYPE_OK != result)
                    {
                        goto undo;
                    }
                }

            }

            break;
        }
#if (SYS_CPNT_QOS_V2_CLASS_MAP_MATCH_ALL == TRUE)
        case RULE_TYPE_CLASS_MAP_MATCH_ALL:
        {
            UI32_T  agg_acl_index;

            /* Create a working ACL which aggregate all ACE.
             */
            result = RULE_OM_BuildMatchAllClassMapRule(class_map_index, &agg_acl_index);
            if (RULE_TYPE_OK != result)
            {
                goto undo;
            }

            result = RULE_CTRL_LocalSetQoSACL2DEV(interface_p,
                                                  policy_map_index,
                                                  class_map_index,
                                                  agg_acl_index,
                                                  meter_index,
                                                  action_index);
            if (RULE_TYPE_OK != result)
            {
                goto undo;
            }

            break;
        }
#endif /* #if (SYS_CPNT_QOS_V2_CLASS_MAP_MATCH_ALL == TRUE) */

        default:
            LOG("<Internal Error> invalid match-type %u", class_map.class_map_match_type);
            ASSERT(0);
            return RULE_TYPE_INVALID_PARAMETER;
    }

    return RULE_TYPE_OK;

undo:
    {
        RULE_TYPE_RETURN_TYPE_T temp_result;

        temp_result = RULE_CTRL_LocalRemoveClassMap2DEV(interface_p,
                                                        policy_map_index,
                                                        policy_map_p,
                                                        policy_map_inst_p,
                                                        class_map_index,
                                                        meter_index,
                                                        action_index);
        ASSERT(RULE_TYPE_OK == temp_result);
    }

    ASSERT(RULE_TYPE_OK != result);
    return result;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalRemoveClassMap2DEV
 *------------------------------------------------------------------------------
 * PURPOSE  : Remove rule for class-map
 * INPUT    : interface_p - interface binding the policy-map
 *            policy_map_index - policy-map index
 *            class_map_index - class-map index
 *            meter_id - meter entry index
 *            action_id - action entry index
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK; error code
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalRemoveClassMap2DEV(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p,
    UI32_T  policy_map_index,
    const RULE_TYPE_PolicyMap_T *policy_map_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p,
    UI32_T  class_map_index,
    UI32_T  meter_index,
    UI32_T  action_index)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_ClassMap_T class_map;

    //
    // --== Duplicated code start
    //
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T policy_map_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T class_map_inst_obj;

    RULE_CTRL_INSTANCE_TYPE_ID_T param;
    //
    // --== End of duplicated code
    //

    ASSERT(NULL != interface_p);
    ASSERT(interface_p->type < RULE_TYPE_INTERFACE_MAX);
    ASSERT(RULE_TYPE_INBOUND == interface_p->direction ||
           RULE_TYPE_OUTBOUND == interface_p->direction);
    ASSERT(NULL != policy_map_p);
    ASSERT(NULL != policy_map_inst_p);
    ASSERT(RULE_TYPE_NIL != policy_map_inst_p->super.type);

    LOG_IF(*interface_p, "policyMapId = %lu, classMapId = %lu, meterId = %lu, actionId = %lu",
           policy_map_index,
           class_map_index,
           meter_index,
           action_index);

    result = RULE_OM_GetClassMap(class_map_index, &class_map);

    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> failed to get class-map(%lu)", class_map_index);
        return result;
    }

    //
    // --== Duplicated code start
    //
    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(policy_map_inst_p, &policy_map_inst_obj);

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_CLASS_MAP;
    param.id = class_map_index;

    class_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) policy_map_inst_p,
                                                                                      RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                      &param);

    if (NULL == class_map_inst_p)
    {
        return RULE_TYPE_OK;
    }

    //
    // --== End of duplicated code
    //

    switch (class_map.class_map_match_type)
    {
        case RULE_TYPE_CLASS_MAP_MATCH_ANY:
        {
            UI32_T cx;

            for (cx = 0; cx < class_map.class_element_count; ++cx)
            {
                RULE_TYPE_ClassType_T class_type = class_map.class_type[cx];
                UI32_T class_id = class_map.class_index_list[cx];

                if (class_type == RULE_TYPE_CLASS_MF)
                {
                    result = RULE_CTRL_LocalRemoveMF2DEV(interface_p,
                                                         policy_map_index,
                                                         class_map_index,
                                                         class_id,
                                                         meter_index,
                                                         action_index);
                    ASSERT(RULE_TYPE_OK == result);
                    if (RULE_TYPE_OK != result)
                    {
                        return result;
                    }
                }
                else if (class_type == RULE_TYPE_CLASS_ACL)
                {
#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
                    RULE_TYPE_Acl_T acl_entry;

                    result = RULE_OM_GetAclByIndex(class_id, &acl_entry);
                    if (RULE_TYPE_OK != result)
                    {
                        return result;
                    }
                    if (TRUE == acl_entry.flag_aggregate_done)
                    {
                        class_id = acl_entry.aggregate_acl_index;
                    }
#endif
                    result = RULE_CTRL_LocalRemoveQoSACL2DEV(interface_p,
                                                             policy_map_index,
                                                             class_map_index,
                                                             class_id,
                                                             meter_index,
                                                             action_index);
                    ASSERT(RULE_TYPE_OK == result);
                    if (RULE_TYPE_OK != result)
                    {
                        return result;
                    }
                }
            }

            break;
        }

#if (SYS_CPNT_QOS_V2_CLASS_MAP_MATCH_ALL == TRUE)
        case RULE_TYPE_CLASS_MAP_MATCH_ALL:
        {
            result = RULE_CTRL_LocalRemoveQoSACL2DEV(interface_p,
                                                     policy_map_index,
                                                     class_map_index,
                                                     class_map.class_ext.aggregate_index,
                                                     meter_index,
                                                     action_index);
            ASSERT(RULE_TYPE_OK == result);
            if (RULE_TYPE_OK != result)
            {
                return result;
            }

            if (FALSE == RULE_CTRL_Priv_HaveMatchAllClassMapBeReferred(class_map_index))
            {
                RULE_OM_DelMatchAllClassMapRule(class_map_index);
            }
            break;
        }
#endif /* #if (SYS_CPNT_QOS_V2_CLASS_MAP_MATCH_ALL == TRUE) */

        default:
            LOG("<Internal Error> Invalid match-type %u", class_map.class_map_match_type);
            return RULE_TYPE_INVALID_PARAMETER;
    }

    ASSERT(NULL != class_map_inst_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_map_inst_p, &class_map_inst_obj);

    ASSERT(class_map_inst_p == class_map_inst_obj.inst);
    ASSERT(NULL != policy_map_inst_p);
    ASSERT(policy_map_inst_p == policy_map_inst_obj.inst);

    policy_map_inst_obj.remove_class_obj(&policy_map_inst_obj, &class_map_inst_obj);
    RULE_CTRL_IN_Priv_DestroyClassInstanceObject(&class_map_inst_obj);

    class_map_inst_p = NULL;
    class_map_inst_obj.inst = NULL;

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalSyncClassMap2DEV
 *------------------------------------------------------------------------------
 * PURPOSE  : Sync status of class map to device
 * INPUT    : policy_map_index - index of policy map
 *            class_map_index  - index of class map
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK; error code
 * NOTES    : This function do nothing when error occured. The caller need to
 *            consist status between device and OM for this situation.
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalSyncClassMap2DEV(
    UI32_T policy_map_index,
    UI32_T class_map_index)
{
    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T i;
    //
    // --== Duplicated code start
    //
    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;
    RULE_CTRL_INSTANCE_TYPE_ID_T param;
    //
    // --== End of duplicated code
    //

    RULE_TYPE_PolicyMap_T       policy_map;

    RULE_TYPE_ClassMap_T        class_map;
    RULE_TYPE_PolicyElement_T   policy_element;

    result = RULE_OM_GetPolicyMap(policy_map_index, &policy_map);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    result = RULE_OM_GetClassMap(class_map_index, &class_map);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    result = RULE_OM_GetPolicyMapElementFromPolicyMapByClassMap(policy_map_index, class_map_index, &policy_element);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Invalid parameter");
        return RULE_TYPE_INVALID_PARAMETER;
    }

    for (i = 0; i < _countof(shmem_data_p->if_table); ++ i)
    {
        RULE_TYPE_INTERFACE_INFO_T interface;

        RULE_CTRL_Priv_IfEntry_Index_To_Interface(i, &interface);

        //
        // --== Duplicated code start
        //
        if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
        ASSERT(NULL != if_entry_p);

        RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                  &if_class_obj);

        memset(&param, 0, sizeof(param));

        param.type = RULE_TYPE_INST_POLICY_MAP;
        param.id = policy_map_index;

        policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                           RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                           &param);
        //
        // --== End of duplicated code
        //
        if (NULL == policy_map_inst_p)
        {
            continue;
        }

        result = RULE_CTRL_LocalRemoveClassMap2DEV(&interface, policy_map_index, &policy_map,
                                                   policy_map_inst_p,
                                                   policy_element.class_map_index,
                                                   policy_element.meter_index,
                                                   policy_element.action_index);
        ASSERT(RULE_TYPE_OK == result);
        if (RULE_TYPE_OK != result)
        {
            return result;
        }

        result = RULE_CTRL_LocalSetClassMap2DEV(&interface, policy_map_index, &policy_map,
                                                policy_map_inst_p,
                                                policy_element.class_map_index,
                                                policy_element.meter_index,
                                                policy_element.action_index);
        if (RULE_TYPE_OK != result)
        {
            return result;
        }
    }

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalSetQoSACL2DEV
 *------------------------------------------------------------------------------
 * PURPOSE  : Add rule for ACL of class-map
 * INPUT    : interface_p - interface binding the policy-map
 *            policy_map_index - policy-map index
 *            class_map_index - class-map index
 *            acl_id - aggregate_acl_index
 *            meter_id - meter entry index
 *            action_id - action entry index
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK; error code
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalSetQoSACL2DEV(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p,
    UI32_T policy_map_index,
    UI32_T class_map_index,
    UI32_T acl_id,
    UI32_T meter_id,
    UI32_T action_id)
{
    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T module_id, device_id, phy_port;
    UI32_T group_id = 0;
    UI32_T rule_nbr;
    UI32_T ace_index;
    UI32_T rule_index = 0;
    UI32_T sm_rid = RULE_CTRL_NO_SHARE_METER_ENTRY_ID;

    RULE_TYPE_AclType_T ace_type;

    //
    // --== Duplicated code start
    //
    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T policy_map_inst_obj;

    RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T class_map_inst_obj;

    RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T acl_inst_obj;

    RULE_CTRL_INSTANCE_TYPE_ID_T param;
    //
    // --== End of duplicated code
    //

    RULE_CTRL_ResourceInfo_T *res_p;

    RULE_TYPE_Acl_T acl_entry;
    RULE_TYPE_Ace_Entry_T ace_entry;

    int priority;
    int rule_pri;
    UI32_T ui_acl_index;

    RULE_TYPE_TBParamEntry_T meter_entry, *p_meter_entry = NULL;
    RULE_TYPE_Action_T action_entry;
    RULE_TYPE_FunctionType_T fun_type = RULE_TYPE_FUNCTION_TYPE_MAX;

    BOOL_T is_meter_existed;
    BOOL_T b_result;

    ASSERT(NULL != interface_p);
    ASSERT(RULE_TYPE_INTERFACE_UPORT == interface_p->type);
    ASSERT(RULE_TYPE_INBOUND == interface_p->direction ||
           RULE_TYPE_OUTBOUND == interface_p->direction);

    LOG_IF(*interface_p, "policyMapId = %lu, classMapId = %lu, aclId = %lu, meterId = %lu, actionId = %lu",
           policy_map_index,
           class_map_index,
           acl_id,
           meter_id,
           action_id);

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(interface_p->uport.unit,
                                                        interface_p->uport.port,
                                                        &module_id,
                                                        &device_id,
                                                        &phy_port))
    {
        return RULE_TYPE_INVALID_PARAMETER;
    }

    result = RULE_OM_GetAclByIndex(acl_id, &acl_entry);
    if (RULE_TYPE_OK != result)
    {
        return result;
    }

#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
    if (acl_entry.flag_hide == TRUE)
    {
        ui_acl_index = acl_entry.owner.class_id;
    }
    else
#endif
    {
        ui_acl_index = acl_id;
    }

    result = RULE_CTRL_Priv_GetClassMapElementPriorityInClassMap(policy_map_index,
                                                                 class_map_index,
                                                                 RULE_TYPE_CLASS_ACL,
                                                                 ui_acl_index,
                                                                 &priority);
    ASSERT(RULE_TYPE_OK == result);

    /** If failed to get action means no action.
     */
    memset(&action_entry, 0, sizeof(RULE_TYPE_Action_T));

    result = RULE_OM_GetActionEntryByIndex(action_id, &action_entry);
    /* ASSERT(RULE_TYPE_OK == result); */

    //
    // --== Duplicated code start
    //
    if_entry_p = RULE_CTRL_Priv_GetIfEntry(interface_p);
    ASSERT(NULL != if_entry_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                              &if_class_obj);

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_POLICY_MAP;
    param.id = policy_map_index;

    policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                       RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                       &param);
    ASSERT(NULL != policy_map_inst_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(policy_map_inst_p,
                                                   &policy_map_inst_obj);

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_CLASS_MAP;
    param.id = class_map_index;

    class_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) policy_map_inst_p,
                                                                                      RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                      &param);

    ASSERT(NULL != class_map_inst_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_map_inst_p,
                                                   &class_map_inst_obj);
    //
    // --== End of duplicated code
    //

    ASSERT(NULL != policy_map_inst_p);
    ASSERT(policy_map_inst_p == policy_map_inst_obj.inst);
    ASSERT(NULL != class_map_inst_p);
    ASSERT(class_map_inst_p == class_map_inst_obj.inst);

    memset(&meter_entry, 0, sizeof(RULE_TYPE_TBParamEntry_T));

    is_meter_existed = (RULE_TYPE_OK == RULE_OM_GetMeterEntryByIndex(meter_id, &meter_entry));
    if (is_meter_existed)
    {
        p_meter_entry = &meter_entry;
    }

    if (FALSE == RULE_CTRL_GetFunctionInfoByAceTypeAndDirection(FALSE,
                                                                RULE_TYPE_INBOUND == interface_p->direction ? TRUE : FALSE,
                                                                acl_entry.acl_type,
                                                                &group_id,
                                                                &rule_pri))
    {
        return RULE_TYPE_INVALID_PARAMETER;
    }

    if (FALSE == RULE_CTRL_GetFunctionTypeForACLAndQoS(FALSE,
                                                       RULE_TYPE_INBOUND == interface_p->direction ? TRUE : FALSE,
                                                       acl_entry.acl_type,
                                                       &fun_type))
    {
        return RULE_TYPE_INVALID_PARAMETER;
    }

    res_p = RULE_CTRL_GetResourceInfo(interface_p->uport.unit, device_id, group_id);
    ASSERT(NULL != res_p);
    if (NULL == res_p)
    {
        return RULE_TYPE_INVALID_PARAMETER;
    }

    /* In current design, we do not configure aces of deny action on chip,
       so we count aces of permit action only.
     */
    result = RULE_OM_GetNumberOfPermitAcesByAclIndex(acl_id, &rule_nbr);
    if (RULE_TYPE_OK != result)
    {
        return result;
    }

    if (res_p->free_rule < rule_nbr)
    {
        LOG("<Error> Insufficient resource");
        return RULE_TYPE_INSUFFICIENT_RESOURCE;
    }

    if (FALSE == RULE_CTRL_RequestRuleByQuota(interface_p->uport.unit,
                                              device_id,
                                              fun_type,
                                              RULE_CTRL_REQUEST_RESOURCE_ALLOCATE_TEST,
                                              acl_entry.ace_count))
    {
        LOG("<Error> Quota is reached");
        return RULE_TYPE_INSUFFICIENT_RESOURCE;
    }

    /**
     * Create ACL instance
     */
    result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACL, &acl_inst_obj);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Failed to create ACL instance");
        goto undo;
    }

    acl_inst_p = acl_inst_obj.inst;

    ASSERT(NULL != acl_inst_p);

    acl_inst_p->acl_id = acl_id;
    acl_inst_p->fun_type = fun_type;
#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)
    acl_inst_p->remap_fun_type = fun_type;
#endif /* SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT */
//    acl_inst_p->mvl_pkt_type = RULE_TYPE_PACKET_NIL;

    /**
     * Add ACL instance into class-map
     */
    class_map_inst_obj.add_class_obj(&class_map_inst_obj, &acl_inst_obj);

    ace_index = 0;
    while (RULE_TYPE_OK == RULE_OM_GetNextAceByAcl(acl_id, &ace_type, &ace_index, &ace_entry))
    {
        RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p;
        RULE_TYPE_CLASS_INSTANCE_OBJECT_T ace_inst_obj;

        RULE_TYPE_RULE_INSTANCE_OBJECT_T rule_inst_obj;

        /* If SYS_CPNT_DIFFSERV_USE_DENY_ACE_IN_ACL is FALSE,
         *   we do not configure an ace with deny action to chip (for DiffServ).
         */
#if (SYS_CPNT_DIFFSERV_USE_DENY_ACE_IN_ACL != TRUE)
        /* In current design, we do not configure an ace of deny action to chip (for QoS).
         */
        if (RULE_TYPE_ACE_DENY == ace_entry.access)
        {
            continue;
        }
#endif /* #if (SYS_CPNT_DIFFSERV_USE_DENY_ACE_IN_ACL != TRUE) */

        /**
         * Create ACE instance
         */
        result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_ACE, &ace_inst_obj);
        if (RULE_TYPE_OK != result)
        {
            LOG("<Error> Failed to create MF/ACE instance");
            goto undo;
        }

        ace_inst_p = ace_inst_obj.inst;

        ASSERT(NULL != ace_inst_p);

        ace_inst_p->id = ace_index;
        ace_inst_p->fun_type = acl_inst_p->fun_type;
#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)
        ace_inst_p->remap_fun_type = acl_inst_p->fun_type;
#endif /* SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT */
//        ace_inst_p->mvl_pkt_type = remapped_pkt_type;

        acl_inst_obj.add_class_obj(&acl_inst_obj, &ace_inst_obj);

        result = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &rule_inst_obj);
        if (RULE_TYPE_OK != result)
        {
            LOG("<Error> Failed to create rule instance");
            goto undo;
        }

        rule_inst_obj.inst->ace_id = ace_index;

        rule_inst_obj.inst->dev_rule_info.unit = interface_p->uport.unit;
        rule_inst_obj.inst->dev_rule_info.device = device_id;
        rule_inst_obj.inst->dev_rule_info.group_id = group_id;
        rule_inst_obj.inst->dev_rule_info.fun_type = fun_type;
        rule_inst_obj.inst->dev_rule_info.priority = priority;
        memcpy(&rule_inst_obj.inst->dev_rule_info.interface, interface_p, sizeof(*interface_p));

        rule_inst_obj.inst->dev_rule_info.rule_id = 0;
        rule_inst_obj.inst->meter_id = meter_id;
        rule_inst_obj.inst->action_id = action_id;
        rule_inst_obj.inst->active = FALSE;
        ace_inst_obj.add_rule_obj(&ace_inst_obj, &rule_inst_obj);

        b_result = RULE_CTRL_RequestRuleByQuota(interface_p->uport.unit, device_id, fun_type,
                                                RULE_CTRL_REQUEST_RESOURCE_ALLOCATE,
                                                1);
        ASSERT(TRUE == b_result);

        b_result = RULE_CTRL_ALLOCATE_RULE(interface_p->uport.unit,
                                           interface_p->uport.port,
                                           rule_inst_obj.inst->dev_rule_info.device,
                                           rule_inst_obj.inst->dev_rule_info.group_id,
                                           rule_inst_obj.inst->dev_rule_info.fun_type,
                                           rule_inst_obj.inst->dev_rule_info.priority,
                                           &rule_index);
        if (FALSE == b_result)
        {
            result = RULE_TYPE_FAIL;
            LOG("<Error> Insufficient rule");
            goto undo;
        }

        rule_inst_obj.inst->dev_rule_info.rule_id = rule_index;
        rule_inst_obj.inst->active = TRUE;

        if (is_meter_existed)
        {
#if (SYS_CPNT_DIFFSERV_SEPARATE_METERS != TRUE)
            sm_rid = RULE_CTRL_LocalGetFirstDevRuleIDofOneClassMap(class_map_inst_obj.inst,
                                                                   rule_inst_obj.inst->dev_rule_info.unit,
                                                                   rule_inst_obj.inst->dev_rule_info.device);
            if (sm_rid == rule_inst_obj.inst->dev_rule_info.rule_id)
            {
                sm_rid = RULE_CTRL_NO_SHARE_METER_ENTRY_ID;
            }
#endif
        }

        b_result = RULE_CTRL_SetQoSAce2Dev(RULE_TYPE_INBOUND == interface_p->direction ? TRUE : FALSE,
                                           rule_inst_obj.inst->dev_rule_info.unit,
                                           interface_p->uport.port,
                                           rule_inst_obj.inst->dev_rule_info.group_id,
                                           rule_inst_obj.inst->dev_rule_info.rule_id,
                                           &ace_entry,
                                           p_meter_entry,
                                           &action_entry, sm_rid);
        if (FALSE == b_result)
        {
            result = RULE_TYPE_FAIL;
            LOG("<Error> Set rule");
            goto undo;
        }
    }

    return RULE_TYPE_OK;

undo:

    {
        RULE_TYPE_RETURN_TYPE_T temp_result;

        temp_result = RULE_CTRL_LocalRemoveQoSACL2DEV(interface_p,
                                                      policy_map_index,
                                                      class_map_index,
                                                      acl_id,
                                                      meter_id,
                                                      action_id);
        ASSERT(RULE_TYPE_OK == temp_result);
    }

    ASSERT(RULE_TYPE_OK != result);
    return result;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalRemoveQoSACL2DEV
 *------------------------------------------------------------------------------
 * PURPOSE  : Remove rule for ACL of class-map
 * INPUT    : interface_p - interface binding the policy-map
 *            policy_map_index - policy-map index
 *            class_map_index - class-map index
 *            acl_id - aggregate_acl_index
 *            meter_id - meter entry index
 *            action_id - action entry index
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK; error code
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalRemoveQoSACL2DEV(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p,
    UI32_T policy_map_index,
    UI32_T class_map_index,
    UI32_T acl_id,
    UI32_T meter_id,
    UI32_T action_id)
{
    RULE_TYPE_RETURN_TYPE_T result;

    //
    // --== Duplicated code start
    //
    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T policy_map_inst_obj;

    RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T class_map_inst_obj;

    RULE_CTRL_INSTANCE_TYPE_ID_T param;
    //
    // --== End of duplicated code
    //

    RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T acl_inst_obj;

    ASSERT(NULL != interface_p);
    ASSERT(RULE_TYPE_INTERFACE_UPORT == interface_p->type);
    ASSERT(RULE_TYPE_INBOUND == interface_p->direction ||
           RULE_TYPE_OUTBOUND == interface_p->direction);

    LOG_IF(*interface_p, "policyMapId = %lu, classMapId = %lu, aclId = %lu, meterId = %lu, actionId = %lu",
           policy_map_index,
           class_map_index,
           acl_id,
           meter_id,
           action_id);

    //
    // --== Duplicated code start
    //
    if_entry_p = RULE_CTRL_Priv_GetIfEntry(interface_p);
    ASSERT(NULL != if_entry_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                              &if_class_obj);

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_POLICY_MAP;
    param.id = policy_map_index;

    policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                       RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                       &param);
    ASSERT(NULL != policy_map_inst_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(policy_map_inst_p,
                                                   &policy_map_inst_obj);

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_CLASS_MAP;
    param.id = class_map_index;

    class_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) policy_map_inst_p,
                                                                                      RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                      &param);

    ASSERT(NULL != class_map_inst_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_map_inst_p,
                                                   &class_map_inst_obj);
    //
    // --== End of duplicated code
    //

    ASSERT(NULL != policy_map_inst_p);
    ASSERT(policy_map_inst_p == policy_map_inst_obj.inst);
    ASSERT(NULL != class_map_inst_p);
    ASSERT(class_map_inst_p == class_map_inst_obj.inst);

    param.type = RULE_TYPE_INST_ACL;
    param.id = acl_id;

    acl_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) class_map_inst_p,
                                                                                RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                &param);

    if (NULL != acl_inst_p)
    {
        result = RULE_CTRL_LocalFreeRulesByRuleGroup(acl_inst_p);
        ASSERT(RULE_TYPE_OK == result);
        if (RULE_TYPE_OK != result)
        {
            return result;
        }

        RULE_CTRL_IN_Priv_ConstructClassInstanceObject(acl_inst_p, &acl_inst_obj);

        class_map_inst_obj.remove_class_obj(&class_map_inst_obj, &acl_inst_obj);
        RULE_CTRL_IN_Priv_DestroyClassInstanceObject(&acl_inst_obj);

        acl_inst_p = NULL;
        acl_inst_obj.inst = NULL;
    }

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalSetMF2DEV
 *------------------------------------------------------------------------------
 * PURPOSE  : Add rule for MF ACE of class-map
 * INPUT    : interface_p - interface binding the policy-map
 *            policy_map_index - policy-map index
 *            class_map_index - class-map index
 *            mf_index - MF ACE index
 *            meter_id - meter entry index
 *            action_id - action entry index
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK; error code
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalSetMF2DEV(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p,
    UI32_T policy_map_index,
    UI32_T class_map_index,
    UI32_T mf_index,
    UI32_T meter_id,
    UI32_T action_id)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_FunctionType_T fun_type = RULE_TYPE_FUNCTION_TYPE_MAX;

    UI32_T module_id, device_id, phy_port;
    UI32_T rule_index = 0;
    UI32_T uport_index, sm_rid = RULE_CTRL_NO_SHARE_METER_ENTRY_ID;
    UI32_T group_id = 0;
    BOOL_T is_meter_existed;

    //
    // --== Duplicated code start
    //
    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T policy_map_inst_obj;

    RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T class_map_inst_obj;

    RULE_CTRL_INSTANCE_TYPE_ID_T param;
    //
    // --== End of duplicated code
    //

    RULE_TYPE_CLASS_INSTANCE_PTR_T mf_ace_inst_p = NULL;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T mf_ace_inst_obj;

    RULE_TYPE_RULE_INSTANCE_OBJECT_T rule_inst_obj;

    RULE_CTRL_ResourceInfo_T *res_p;
    RULE_TYPE_Ace_Entry_T ace_entry;

    int priority;
    int rule_pri;

    RULE_TYPE_TBParamEntry_T meter_entry, *p_meter_entry = NULL;
    RULE_TYPE_Action_T action_entry;

    ASSERT(NULL != interface_p);
    ASSERT(RULE_TYPE_INTERFACE_UPORT == interface_p->type);
    ASSERT(RULE_TYPE_INBOUND == interface_p->direction ||
           RULE_TYPE_OUTBOUND == interface_p->direction);

    LOG_IF(*interface_p, "policyMapId = %lu, classMapId = %lu, mfId = %lu, meterId = %lu, actionId = %lu",
           policy_map_index,
           class_map_index,
           mf_index,
           meter_id,
           action_id);

    policy_map_inst_p = RULE_CTRL_Priv_GetPolicyMapInstance(interface_p);
    if (NULL != policy_map_inst_p)
    {
        ASSERT(policy_map_inst_p->policy_map_id == policy_map_index);
        if (policy_map_index != policy_map_inst_p->policy_map_id)
        {
            ASSERT(0);
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }

    memset(&ace_entry, 0, sizeof(RULE_TYPE_Ace_Entry_T));

    result = RULE_OM_Get_AceEntryByID(mf_index, &ace_entry);
    if (RULE_TYPE_OK != result)
    {
        return result;
    }

    result = RULE_CTRL_Priv_GetClassMapElementPriorityInClassMap(policy_map_index,
                                                                 class_map_index,
                                                                 RULE_TYPE_CLASS_MF,
                                                                 mf_index,
                                                                 &priority);
    ASSERT(RULE_TYPE_OK == result);

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(interface_p->uport.unit,
                                                        interface_p->uport.port,
                                                        &module_id,
                                                        &device_id,
                                                        &phy_port))
    {
        return RULE_TYPE_INVALID_PARAMETER;
    }

    //
    // --== Duplicated code start
    //
    if_entry_p = RULE_CTRL_Priv_GetIfEntry(interface_p);
    ASSERT(NULL != if_entry_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                              &if_class_obj);

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_POLICY_MAP;
    param.id = policy_map_index;

    policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                       RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                       &param);
    ASSERT(NULL != policy_map_inst_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(policy_map_inst_p,
                                                   &policy_map_inst_obj);

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_CLASS_MAP;
    param.id = class_map_index;

    class_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) policy_map_inst_p,
                                                                                      RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                      &param);

    ASSERT(NULL != class_map_inst_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_map_inst_p,
                                                   &class_map_inst_obj);
    //
    // --== End of duplicated code
    //

    ASSERT(NULL != policy_map_inst_p);
    ASSERT(policy_map_inst_p == policy_map_inst_obj.inst);
    ASSERT(NULL != class_map_inst_p);
    ASSERT(class_map_inst_p == class_map_inst_obj.inst);

    /**
     * Create MF (class) instance
     */
    result = RULE_CTRL_IN_Priv_CreateClassInstanceObject(RULE_TYPE_INST_MF_ACE, &mf_ace_inst_obj);
    if (RULE_TYPE_OK != result)
    {
        LOG("<Error> Failed to create MF/ACE instance");
        goto undo;
    }

    mf_ace_inst_p = mf_ace_inst_obj.inst;

    ASSERT(NULL != mf_ace_inst_p);

    mf_ace_inst_p->id = mf_index;
//    mf_ace_inst_p->mvl_pkt_type = remapped_pkt_type;

    /**
     * Add MF (class) instance into class-map
     */
    class_map_inst_obj.add_class_obj(&class_map_inst_obj, &mf_ace_inst_obj);

    memset(&action_entry, 0, sizeof(RULE_TYPE_Action_T));
    memset(&meter_entry, 0, sizeof(RULE_TYPE_TBParamEntry_T));

    uport_index = STKTPLG_OM_UPORT_TO_IFINDEX(interface_p->uport.unit,
                                              interface_p->uport.port);

    RULE_OM_GetActionEntryByIndex(action_id, &action_entry);

    is_meter_existed = (RULE_TYPE_OK == RULE_OM_GetMeterEntryByIndex(meter_id, &meter_entry));
    if (is_meter_existed)
    {
        p_meter_entry = &meter_entry;
    }

    if (FALSE == RULE_CTRL_GetFunctionInfoByAceTypeAndDirection(FALSE,
                                                                RULE_TYPE_INBOUND == interface_p->direction ? TRUE : FALSE,
                                                                ace_entry.ace_type,
                                                                &group_id,
                                                                &rule_pri))
    {
        result = RULE_TYPE_INVALID_PARAMETER;
        LOG("<Error> Invalid parameter");
        goto undo;
    }

    if (FALSE == RULE_CTRL_GetFunctionTypeForACLAndQoS(FALSE,
                                                       RULE_TYPE_INBOUND == interface_p->direction ? TRUE : FALSE,
                                                       ace_entry.ace_type,
                                                       &fun_type))
    {
        result = RULE_TYPE_INVALID_PARAMETER;
        LOG("<Error> Invalid parameter");
        goto undo;
    }

    res_p = RULE_CTRL_GetResourceInfo(interface_p->uport.unit, device_id, group_id);
    if (NULL == res_p)
    {
        result = RULE_TYPE_INVALID_PARAMETER;
        LOG("<Error> Invalid parameter");
        goto undo;
    }

    if (res_p->free_rule < 1)
    {
        result = RULE_TYPE_INSUFFICIENT_RESOURCE;
        LOG("<Error> No free rule");
        goto undo;
    }

    if (FALSE == RULE_CTRL_RequestRuleByQuota(interface_p->uport.unit,
                                              device_id,
                                              fun_type,
                                              RULE_CTRL_REQUEST_RESOURCE_ALLOCATE_TEST,
                                              1))
    {
        result = RULE_TYPE_INSUFFICIENT_RESOURCE;
        LOG("<Error> Quota is reached");
        goto undo;
    }

    result = RULE_CTRL_IN_Priv_CreateRuleInstanceObject(RULE_TYPE_INST_RULE, &rule_inst_obj);
    if (RULE_TYPE_OK != result)
    {
        result = RULE_TYPE_INSUFFICIENT_RESOURCE;
        LOG("<Error> Insufficient resource");
        goto undo;
    }

    mf_ace_inst_obj.add_rule_obj(&mf_ace_inst_obj, &rule_inst_obj);

    rule_inst_obj.inst->ace_id = mf_index;

    rule_inst_obj.inst->dev_rule_info.unit = interface_p->uport.unit;
    rule_inst_obj.inst->dev_rule_info.device = device_id;
    rule_inst_obj.inst->dev_rule_info.group_id = group_id;
    rule_inst_obj.inst->dev_rule_info.fun_type = fun_type;

    rule_inst_obj.inst->dev_rule_info.rule_id = 0;
    rule_inst_obj.inst->meter_id = meter_id;
    rule_inst_obj.inst->action_id = action_id;
    rule_inst_obj.inst->active = FALSE;

    /*allocate rule set rule*/
    if(FALSE == RULE_CTRL_ALLOCATE_RULE(interface_p->uport.unit,
                                        interface_p->uport.port,
                                        device_id, group_id, fun_type, rule_pri, &rule_index))
    {
        result = RULE_TYPE_INSUFFICIENT_RESOURCE;
        LOG("<Error> Insufficient rule");
        goto undo;
    }

    rule_inst_obj.inst->dev_rule_info.rule_id = rule_index;
    rule_inst_obj.inst->active = TRUE;

    if (is_meter_existed)
    {
#if (SYS_CPNT_DIFFSERV_SEPARATE_METERS != TRUE)
        sm_rid = RULE_CTRL_LocalGetFirstDevRuleIDofOneClassMap(class_map_inst_obj.inst,
                                                               rule_inst_obj.inst->dev_rule_info.unit,
                                                               rule_inst_obj.inst->dev_rule_info.device);
        if (sm_rid == rule_inst_obj.inst->dev_rule_info.rule_id)
        {
            sm_rid = RULE_CTRL_NO_SHARE_METER_ENTRY_ID;
        }
#endif
    }

    if (FALSE == RULE_CTRL_SetQoSAce2Dev(RULE_TYPE_INBOUND == interface_p->direction ? TRUE : FALSE,
                                         rule_inst_obj.inst->dev_rule_info.unit,
                                         interface_p->uport.port,
                                         rule_inst_obj.inst->dev_rule_info.group_id,
                                         rule_inst_obj.inst->dev_rule_info.rule_id,
                                         &ace_entry,
                                         p_meter_entry,
                                         &action_entry, sm_rid))
    {
        result = RULE_TYPE_FAIL;
        LOG("<Error> Set rule");
        goto undo;
    }

    if (FALSE == RULE_CTRL_RequestRuleByQuota(interface_p->uport.unit,
                                              device_id,
                                              fun_type,
                                              RULE_CTRL_REQUEST_RESOURCE_ALLOCATE,
                                              1))
    {
        ASSERT(0);
    }

    return RULE_TYPE_OK;

undo:

    {
        RULE_TYPE_RETURN_TYPE_T temp_result;

        temp_result = RULE_CTRL_LocalRemoveMF2DEV(interface_p,
                                                  policy_map_index,
                                                  class_map_index,
                                                  mf_index,
                                                  meter_id,
                                                  action_id);
        ASSERT(RULE_TYPE_OK == temp_result);
    }

    ASSERT(RULE_TYPE_OK != result);
    return result;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalRemoveMF2DEV
 *------------------------------------------------------------------------------
 * PURPOSE  : Remove rule for MF ACE of class-map
 * INPUT    : interface_p - interface binding the policy-map
 *            policy_map_index - policy-map index
 *            class_map_index - class-map index
 *            mf_index - MF ACE index
 *            meter_id - meter entry index
 *            action_id - action entry index
 * OUTPUT   : None
 * RETURN   : RULE_TYPE_OK; error code
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalRemoveMF2DEV(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p,
    UI32_T policy_map_index,
    UI32_T class_map_index,
    UI32_T mf_index,
    UI32_T meter_id,
    UI32_T action_id)
{
    RULE_TYPE_RETURN_TYPE_T result;

    //
    // --== Duplicated code start
    //
    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T policy_map_inst_obj;

    RULE_TYPE_CLASS_INSTANCE_PTR_T class_map_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T class_map_inst_obj;

    RULE_CTRL_INSTANCE_TYPE_ID_T param;
    //
    // --== End of duplicated code
    //

    RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T ace_inst_obj;

    ASSERT(NULL != interface_p);
    ASSERT(RULE_TYPE_INTERFACE_UPORT == interface_p->type);
    ASSERT(RULE_TYPE_INBOUND == interface_p->direction ||
           RULE_TYPE_OUTBOUND == interface_p->direction);

    LOG_IF(*interface_p, "policyMapId = %lu, classMapId = %lu, mfId = %lu, meterId = %lu, actionId = %lu",
           policy_map_index,
           class_map_index,
           mf_index,
           meter_id,
           action_id);

    //
    // --== Duplicated code start
    //
    if_entry_p = RULE_CTRL_Priv_GetIfEntry(interface_p);
    ASSERT(NULL != if_entry_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                              &if_class_obj);

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_POLICY_MAP;
    param.id = policy_map_index;

    policy_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                       RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                       &param);
    ASSERT(NULL != policy_map_inst_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(policy_map_inst_p,
                                                   &policy_map_inst_obj);

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_CLASS_MAP;
    param.id = class_map_index;

    class_map_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) policy_map_inst_p,
                                                                                      RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                      &param);

    ASSERT(NULL != class_map_inst_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_map_inst_p,
                                                   &class_map_inst_obj);
    //
    // --== End of duplicated code
    //

    ASSERT(NULL != policy_map_inst_p);
    ASSERT(policy_map_inst_p == policy_map_inst_obj.inst);
    ASSERT(NULL != class_map_inst_p);
    ASSERT(class_map_inst_p == class_map_inst_obj.inst);

    param.type = RULE_TYPE_INST_MF_ACE;
    param.id = mf_index;

    ace_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_IN_Priv_FindIf((RULE_TYPE_INSTANCE_PTR_T)class_map_inst_p,
                                                                          RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                          &param);
    if (NULL != ace_inst_p)
    {
        result = RULE_CTRL_LocalFreeRulesByRuleGroup(ace_inst_p);
        ASSERT(RULE_TYPE_OK == result);
        if (RULE_TYPE_OK != result)
        {
            return result;
        }

        RULE_CTRL_IN_Priv_ConstructClassInstanceObject(ace_inst_p, &ace_inst_obj);

        class_map_inst_obj.remove_class_obj(&class_map_inst_obj, &ace_inst_obj);
        RULE_CTRL_IN_Priv_DestroyClassInstanceObject(&ace_inst_obj);

        ace_inst_p = NULL;
        ace_inst_obj.inst = NULL;
    }

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Update_PortBitMap
 *------------------------------------------------------------------------------
 * PURPOSE  : update IPBM field on chip by unit, port, acl
 * INPUT    : is_ingress, is_add, unit, port, acl_entry
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Update_PortBitMap(
    BOOL_T is_ingress,
    BOOL_T is_add,
    UI32_T unit,
    UI32_T port,
    const RULE_TYPE_Acl_T *acl_entry_p,
    const RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p)
{
    UI32_T module_id, update_device_id, update_phy_port;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T acl_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T ace_inst_iter;

    ASSERT(TRUE == is_ingress);
    ASSERT(NULL != acl_entry_p);
    ASSERT(NULL != acl_inst_p);

    ASSERT(1 <= acl_inst_p->ref_count);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(acl_inst_p, &acl_inst_obj);

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(unit, port, &module_id, &update_device_id, &update_phy_port))
    {
        return RULE_TYPE_INVALID_PARAMETER;
    }

    acl_inst_obj.get_element_iterator(&acl_inst_obj, &ace_inst_iter);

    for (ace_inst_iter.first(&ace_inst_iter);
         NULL != ace_inst_iter.get_instance(&ace_inst_iter);
         ace_inst_iter.next(&ace_inst_iter))
    {
        RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p;
        RULE_TYPE_CLASS_INSTANCE_OBJECT_T ace_inst_obj;
        RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T rule_inst_iter;

        ace_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T) ace_inst_iter.get_instance(&ace_inst_iter);

        RULE_CTRL_IN_Priv_ConstructClassInstanceObject(ace_inst_p, &ace_inst_obj);
        ace_inst_obj.get_element_iterator(&ace_inst_obj, &rule_inst_iter);

        for (rule_inst_iter.first(&rule_inst_iter);
             NULL != rule_inst_iter.get_instance(&rule_inst_iter);
             rule_inst_iter.next(&rule_inst_iter))
        {
            RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;

            rule_inst_p = (RULE_TYPE_RULE_INSTANCE_PTR_T) rule_inst_iter.get_instance(&rule_inst_iter);

            ASSERT(sizeof(rule_inst_p->dev_rule_info.port_bmp) == 16);

            if (is_add)
            {
                DEVRM_PBMP_PORT_ADD(rule_inst_p->dev_rule_info.port_bmp, update_phy_port);
            }
            else
            {
                DEVRM_PBMP_PORT_REMOVE(rule_inst_p->dev_rule_info.port_bmp, update_phy_port);
            }

            if (TRUE != rule_inst_p->active)
            {
                continue;
            }

            ASSERT(DEVRM_PBMP_NOT_NULL(rule_inst_p->dev_rule_info.port_bmp));

            {
                RULE_TYPE_Ace_Entry_T   ace_entry;
                DEVRM_AceEntry_T        dev_ace_entry;
                DEVRM_ActionEntry_T     action_entry[2];

                RULE_OM_Get_AceEntryByID(rule_inst_p->ace_id, &ace_entry);
                RULE_CTRL_ConvertAce2DevForAclPurpose(&ace_entry, &dev_ace_entry, action_entry);
                if (is_ingress)
                {
                    DEVRM_SHR_BITSET(dev_ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts);
                }
                else
                {
                    DEVRM_SHR_BITSET(dev_ace_entry.w, DEVRM_FIELD_QUALIFY_OutPorts);
                }

                DEVRM_PBMP_CLEAR(dev_ace_entry.inports_data);
                DEVRM_PBMP_OR(dev_ace_entry.inports_data, rule_inst_p->dev_rule_info.port_bmp);
                DEVRM_PBMP_ASSIGN(dev_ace_entry.inports_mask, shmem_data_p->dev_info[unit-1].port_bit_map.all_ports);

                //
                // FIXME: Not correct when interface isn't an user port and multiple devices case
                //
                if (FALSE == RULE_CTRL_UPDATE_RULE(unit, port, update_device_id, rule_inst_p->dev_rule_info.rule_id, &dev_ace_entry, NULL, action_entry))
                {
                    return RULE_TYPE_FAIL;
                }
            }
        }
    }

    return RULE_TYPE_OK;
}

#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_TakeSnapshot
 *------------------------------------------------------------------------------
 * PURPOSE:  Take snapshot
 * INPUT:    snapshot_p - Snapshot
 * OUTPUT:   None
 * RETURN:   None
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_Priv_TakeSnapshot(
    RULE_CTRL_Snapshot_T *snapshot_p)
{
    ASSERT(sizeof(snapshot_p->container_pool_buf) == sizeof(shmem_data_p->_container_pool_buf));
    ASSERT(sizeof(snapshot_p->class_inst_pool_buf) == sizeof(shmem_data_p->_class_inst_pool_buf));
    ASSERT(sizeof(snapshot_p->rule_inst_pool_buf) == sizeof(shmem_data_p->_rule_inst_pool_buf));

    ASSERT(sizeof(snapshot_p->if_table) == sizeof(shmem_data_p->if_table));

    ASSERT(sizeof(snapshot_p->resource_info) == sizeof(shmem_data_p->resource_info));
    ASSERT(sizeof(snapshot_p->quota_desc) == sizeof(shmem_data_p->quota_desc));
    ASSERT(sizeof(snapshot_p->av_fun_type_tbl) == sizeof(shmem_data_p->av_fun_type_tbl));

    memcpy(snapshot_p->container_pool_buf, shmem_data_p->_container_pool_buf,
                                        sizeof(snapshot_p->container_pool_buf));

    memcpy(snapshot_p->class_inst_pool_buf, shmem_data_p->_class_inst_pool_buf,
                                       sizeof(snapshot_p->class_inst_pool_buf));

    memcpy(snapshot_p->rule_inst_pool_buf, shmem_data_p->_rule_inst_pool_buf,
                                        sizeof(snapshot_p->rule_inst_pool_buf));

    memcpy(snapshot_p->if_table, shmem_data_p->if_table,
                                                  sizeof(snapshot_p->if_table));

    memcpy(&snapshot_p->resource_info, shmem_data_p->resource_info,
                                             sizeof(snapshot_p->resource_info));

    memcpy(&snapshot_p->quota_desc, &shmem_data_p->quota_desc,
                                                sizeof(snapshot_p->quota_desc));

    memcpy(&snapshot_p->av_fun_type_tbl, &shmem_data_p->av_fun_type_tbl,
                                           sizeof(snapshot_p->av_fun_type_tbl));

    RULE_OM_TakeSnapshot(&snapshot_p->om_part);

    snapshot_p->valid = TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_RevertToSnapshot
 *------------------------------------------------------------------------------
 * PURPOSE:  Revert to snapshot
 * INPUT:    snapshot_p - Snapshot
 * OUTPUT:   None
 * RETURN:   None
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_Priv_RevertToSnapshot(
    RULE_CTRL_Snapshot_T *snapshot_p)
{
    ASSERT(sizeof(snapshot_p->container_pool_buf) == sizeof(shmem_data_p->_container_pool_buf));
    ASSERT(sizeof(snapshot_p->class_inst_pool_buf) == sizeof(shmem_data_p->_class_inst_pool_buf));
    ASSERT(sizeof(snapshot_p->rule_inst_pool_buf) == sizeof(shmem_data_p->_rule_inst_pool_buf));

    ASSERT(sizeof(snapshot_p->if_table) == sizeof(shmem_data_p->if_table));

    ASSERT(sizeof(snapshot_p->resource_info) == sizeof(shmem_data_p->resource_info));
    ASSERT(sizeof(snapshot_p->quota_desc) == sizeof(shmem_data_p->quota_desc));
    ASSERT(sizeof(snapshot_p->av_fun_type_tbl) == sizeof(shmem_data_p->av_fun_type_tbl));

    ASSERT(TRUE == snapshot_p->valid);

    memcpy(shmem_data_p->_container_pool_buf, snapshot_p->container_pool_buf,
                                        sizeof(snapshot_p->container_pool_buf));

    memcpy(shmem_data_p->_class_inst_pool_buf, snapshot_p->class_inst_pool_buf,
                                       sizeof(snapshot_p->class_inst_pool_buf));

    memcpy(shmem_data_p->_rule_inst_pool_buf, snapshot_p->rule_inst_pool_buf,
                                        sizeof(snapshot_p->rule_inst_pool_buf));

    memcpy(shmem_data_p->if_table, snapshot_p->if_table,
                                                  sizeof(snapshot_p->if_table));

    memcpy(shmem_data_p->resource_info, &snapshot_p->resource_info,
                                             sizeof(snapshot_p->resource_info));

    memcpy(&shmem_data_p->quota_desc, &snapshot_p->quota_desc,
                                                sizeof(snapshot_p->quota_desc));

    memcpy(&shmem_data_p->av_fun_type_tbl, &snapshot_p->av_fun_type_tbl,
                                           sizeof(snapshot_p->av_fun_type_tbl));

    RULE_OM_RevertSnapshot(&snapshot_p->om_part);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_DeleteSnapshot
 *------------------------------------------------------------------------------
 * PURPOSE:  Delete snapshot
 * INPUT:    snapshot_p - Snapshot
 * OUTPUT:   None
 * RETURN:   None
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_Priv_DeleteSnapshot(
    RULE_CTRL_Snapshot_T *snapshot_p)
{
    snapshot_p->valid = FALSE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_InitFunTypeFreeTable
 *------------------------------------------------------------------------------
 * PURPOSE:  Initializes the free function type table
 * INPUT:    None
 * OUTPUT:   None
 * RETURN:   RULE_TYPE_OK ; Error code
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_InitFunTypeFreeTable()
{
    UI32_T i;

    for (i=0; i < _countof(rule_ctrl_av_fun_type_list); ++i)
    {
        shmem_data_p->av_fun_type_tbl.av_vector[i].fun_type = rule_ctrl_av_fun_type_list[i];
        shmem_data_p->av_fun_type_tbl.av_vector[i].used_by_fun_type = RULE_TYPE_FUNCTION_TYPE_MAX;
    }
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_GetFunTypeFreeEntry
 *------------------------------------------------------------------------------
 * PURPOSE:  Get free function type entry
 * INPUT:    fun_type   - function type
 * OUTPUT:   None
 * RETURN:   entry
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
static RULE_CTRL_FunTypeFreeEntry_T*
RULE_CTRL_Priv_GetFunTypeFreeEntry(
    RULE_TYPE_FunctionType_T fun_type)
{
    UI32_T i;

    for (i=0; i < _countof(shmem_data_p->av_fun_type_tbl.av_vector); ++i)
    {
        RULE_CTRL_FunTypeFreeEntry_T *free_emtry = &shmem_data_p->av_fun_type_tbl.av_vector[i];

        if (free_emtry->fun_type == fun_type)
        {
            return free_emtry;
        }
    }

    return NULL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_IsEnabledFuncTypeRemap
 *------------------------------------------------------------------------------
 * PURPOSE:  Does enable function type remap
 * INPUT:    fun_type       - function type
 *           remap_fun_type - remap to function type
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_Priv_IsEnabledFuncTypeRemap(
    RULE_TYPE_FunctionType_T fun_type,
    RULE_TYPE_FunctionType_T remap_fun_type)
{
    RULE_CTRL_FunTypeFreeEntry_T *free_entry;

    free_entry = RULE_CTRL_Priv_GetFunTypeFreeEntry(remap_fun_type);
    ASSERT(NULL != free_entry);

    return (free_entry->used_by_fun_type == fun_type) ? TRUE : FALSE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_EnableFuncTypeRemap
 *------------------------------------------------------------------------------
 * PURPOSE:  Enable function type remap
 * INPUT:    fun_type       - function type
 *           remap_fun_type - remap to function type
 * OUTPUT:   None
 * RETURN:   RULE_TYPE_OK ; Error code
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Priv_EnableFuncTypeRemap(
    RULE_TYPE_FunctionType_T fun_type,
    RULE_TYPE_FunctionType_T remap_fun_type)
{
    UI32_T i;

    for (i=0; i < _countof(shmem_data_p->av_fun_type_tbl.av_vector); ++i)
    {
        RULE_CTRL_FunTypeFreeEntry_T *free_emtry = &shmem_data_p->av_fun_type_tbl.av_vector[i];

        if (free_emtry->fun_type == remap_fun_type)
        {
            ASSERT(RULE_TYPE_FUNCTION_TYPE_MAX == free_emtry->used_by_fun_type ||
                   fun_type == free_emtry->used_by_fun_type);

            free_emtry->used_by_fun_type = fun_type;
            break;
        }
    }

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_DisableFuncTypeRemap
 *------------------------------------------------------------------------------
 * PURPOSE:  Disable function type remapping
 * INPUT:    fun_type       - function type
 *           remap_fun_type - remap to function type
 * OUTPUT:   None
 * RETURN:   RULE_TYPE_OK ; Error code
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Priv_DisableFuncTypeRemap(
    RULE_TYPE_FunctionType_T fun_type,
    RULE_TYPE_FunctionType_T remap_fun_type)
{
    UI32_T i;

    for (i=0; i < _countof(shmem_data_p->av_fun_type_tbl.av_vector); ++i)
    {
        RULE_CTRL_FunTypeFreeEntry_T *free_emtry = &shmem_data_p->av_fun_type_tbl.av_vector[i];

        if (free_emtry->fun_type == remap_fun_type)
        {
            ASSERT(fun_type == free_emtry->used_by_fun_type);

            free_emtry->used_by_fun_type = RULE_TYPE_FUNCTION_TYPE_MAX;
            break;
        }
    }

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_BuildRemapFunTypeList
 *------------------------------------------------------------------------------
 * PURPOSE  : Get used function type list
 * INPUT    : fun_type                      - function type
 *            enumber_of_entries_to_write   - max entries of list
 * OUTPUT   : list                          - function list
 *            number_of_entries_written     - how many entries be written
 * RETURN   : RULE_TYPE_OK ; Error code
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Priv_BuildRemapFunTypeList(
    RULE_TYPE_FunctionType_T fun_type,
    RULE_TYPE_FunctionType_T *list,
    UI32_T number_of_entries_to_write,
    UI32_T *number_of_entries_written)
{
    UI32_T i;

    *number_of_entries_written = 0;

    for (i=0; i < _countof(shmem_data_p->av_fun_type_tbl.av_vector); ++i)
    {
        RULE_CTRL_FunTypeFreeEntry_T *free_entry = &shmem_data_p->av_fun_type_tbl.av_vector[i];

        if (RULE_TYPE_FUNCTION_TYPE_MAX == free_entry->used_by_fun_type ||
            fun_type != free_entry->used_by_fun_type)
        {
            continue;
        }

        if (number_of_entries_to_write < (*number_of_entries_written)+1)
        {
            return RULE_TYPE_FAIL;
        }

        list[ (*number_of_entries_written) ++ ] = free_entry->fun_type;
    }

    return RULE_TYPE_OK;
}

static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Priv_LST_Set(
    UI32_T *acl_index_list,
    UI32_T count_of_acl_index_list,
    UI32_T *written_count_p,
    UI32_T new_acl_index)
{
    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T i;
    RULE_TYPE_Acl_T new_acl_entry;

    ASSERT(NULL != acl_index_list);
    ASSERT(0 < count_of_acl_index_list);
    ASSERT(NULL != written_count_p);

    for (i = 0; i < *written_count_p; ++ i)
    {
        if (acl_index_list[i] == new_acl_index)
        {
            return RULE_TYPE_OK;
        }
    }

    if ((count_of_acl_index_list - 1) < *written_count_p)
    {
        return RULE_TYPE_FAIL;
    }

    result = RULE_OM_GetAclByIndex(new_acl_index, &new_acl_entry);
    ASSERT(RULE_TYPE_OK == result);

    for (i = 0; i < *written_count_p; ++ i)
    {
        UI32_T inlist_acl_index = acl_index_list[i];
        RULE_TYPE_Acl_T inlist_acl_entry;

        result = RULE_OM_GetAclByIndex(inlist_acl_index, &inlist_acl_entry);
        ASSERT(RULE_TYPE_OK == result);

        if (inlist_acl_entry.ace_count < new_acl_entry.ace_count)
        {
            /* Add #5 into {#6, #3, #3}
             * The new list shall be {#6, #5, #3, #3}
             */
            memmove(&acl_index_list[i + 1], &acl_index_list[i], (*written_count_p - i) * sizeof(UI32_T));
            acl_index_list[i] = new_acl_index;
            (*written_count_p) ++;

            return RULE_TYPE_OK;
        }
    }

    acl_index_list[*written_count_p] = new_acl_index;
    (*written_count_p) ++;

    return RULE_TYPE_OK;
}

static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Priv_GetAclIdListUseSameFunctionType(
    RULE_TYPE_InOutDirection_T direction,
    UI32_T acl_id,
    UI32_T *acl_index_list,
    UI32_T count_of_acl_index_list,
    UI32_T *written_count_p)
{
    RULE_TYPE_RETURN_TYPE_T result;
    RULE_TYPE_FunctionType_T my_fun_type;
    RULE_TYPE_Acl_T acl_entry;

    RULE_TYPE_InOutDirection_T _dir = RULE_TYPE_INBOUND;

    UI32_T i;

    BOOL_T b_result;

    ASSERT(NULL != acl_index_list);
    ASSERT(NULL != written_count_p);

    result = RULE_OM_GetAclByIndex(acl_id, &acl_entry);
    ASSERT(RULE_TYPE_OK == result);

    *written_count_p = 0;

    if (RULE_TYPE_BOTH_DIRECTION == direction)
    {
        _dir = RULE_TYPE_INBOUND;
    }
    else if (RULE_TYPE_INBOUND == direction ||
             RULE_TYPE_OUTBOUND == direction)
    {
        _dir = direction;
    }
    else
    {
        ASSERT(0);
    }

next_dirction:

    b_result = RULE_CTRL_GetFunctionTypeForACLAndQoS(TRUE,
                                        RULE_TYPE_DIRECTION_TO_IS_INGRESS(_dir),
                                              acl_entry.acl_type, &my_fun_type);
    ASSERT(TRUE == b_result);

    for (i = 0; i < _countof(shmem_data_p->if_table); ++ i)
    {
        RULE_TYPE_INTERFACE_INFO_T interface;

        //
        // --== Duplicated code start
        //
        RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;

        RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

        RULE_TYPE_CONTAINER_PTR_T acl_container_p;
        RULE_TYPE_CONTAINER_OBJECT_T acl_container_obj;
        RULE_TYPE_CONTAINER_ELEMENT_ITERATOR_T acl_inst_iter;

        RULE_CTRL_INSTANCE_TYPE_ID_T param;
        //
        // --== End of duplicated code
        //

        RULE_CTRL_Priv_IfEntry_Index_To_Interface(i, &interface);

        if (interface.direction != _dir)
        {
            continue;
        }

        //
        // --== Duplicated code start
        //
        if_entry_p = RULE_CTRL_Priv_GetIfEntry(&interface);
        ASSERT(NULL != if_entry_p);

        RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                                  &if_class_obj);

        memset(&param, 0, sizeof(param));

        param.type = RULE_TYPE_INST_CONTAINER;
        param.id = RULE_TYPE_INST_ACL;

        acl_container_p = (RULE_TYPE_CONTAINER_PTR_T) RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                     RULE_CTRL_Priv_IsMatchTypeId,
                                                                                     &param);
        if (NULL == acl_container_p)
        {
            continue;
        }
        //
        // --== End of duplicated code
        //

        RULE_CTRL_IN_Priv_ConstructContainerObject(acl_container_p, &acl_container_obj);
        acl_container_obj.get_element_iterator(&acl_container_obj, &acl_inst_iter);

        for (acl_inst_iter.first(&acl_inst_iter);
             NULL != acl_inst_iter.get_instance(&acl_inst_iter);
             acl_inst_iter.next(&acl_inst_iter))
        {
            RULE_TYPE_CLASS_INSTANCE_PTR_T acl_inst_p;

            acl_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T) acl_inst_iter.get_instance(&acl_inst_iter);

            if (acl_inst_p->fun_type == my_fun_type)
            {
                acl_id = acl_inst_p->acl_id;

                result = RULE_CTRL_Priv_LST_Set(acl_index_list, count_of_acl_index_list, written_count_p, acl_id);
                ASSERT(RULE_TYPE_OK == result);
            }
        }
    }

    if (RULE_TYPE_BOTH_DIRECTION == direction &&  RULE_TYPE_INBOUND == _dir)
    {
        _dir = RULE_TYPE_OUTBOUND;
        goto next_dirction;
    }

    return RULE_TYPE_OK;
}

static RULE_TYPE_Acl_T *
RULE_CTRL_Priv_GetAclEntryFromSnapshot(
    UI32_T acl_index,
    RULE_CTRL_Snapshot_T *snapshot_p)
{
    ASSERT(NULL != snapshot_p);

    RULE_TYPE_Acl_T *acl_entry_p;

    ASSERT(acl_index <= _countof(snapshot_p->om_part.acl_table));
    acl_entry_p = &snapshot_p->om_part.acl_table[acl_index - 1];

#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
    if (RULE_TYPE_CLASS_ACL == acl_entry_p->owner.class_type &&
        0 != acl_entry_p->owner.class_id)
    {
        acl_entry_p = &snapshot_p->om_part.acl_table[acl_entry_p->owner.class_id - 1];
    }
#endif /* SYS_CPNT_ACL_AUTO_COMPRESS_ACE */

    return acl_entry_p;
}

static RULE_TYPE_AclMemento_T *
RULE_CTRL_Priv_GetAclBindingParametersFromSnapshot(
    UI32_T ifindex,
    RULE_TYPE_InOutDirection_T direction,
    UI32_T acl_index,
    RULE_CTRL_Snapshot_T *snapshot_p)
{
    ASSERT(RULE_TYPE_INBOUND == direction || RULE_TYPE_OUTBOUND == direction);
    ASSERT(NULL != snapshot_p);

    RULE_TYPE_Acl_T *acl_entry_p;
    RULE_TYPE_PortEntry_T *port_entry_p;

    RULE_TYPE_AclType_T port_acl_type;

    ASSERT(acl_index <= _countof(snapshot_p->om_part.acl_table));
    acl_entry_p = &snapshot_p->om_part.acl_table[acl_index - 1];

#if (SYS_CPNT_ACL_AUTO_COMPRESS_ACE == TRUE)
    if (RULE_TYPE_CLASS_ACL == acl_entry_p->owner.class_type &&
        0 != acl_entry_p->owner.class_id)
    {
        acl_index = acl_entry_p->owner.class_id;
        acl_entry_p = &snapshot_p->om_part.acl_table[acl_index - 1];
    }
#endif /* SYS_CPNT_ACL_AUTO_COMPRESS_ACE */

    if (RULE_TYPE_INBOUND == direction)
    {
        port_entry_p = &snapshot_p->om_part.rule_mgr_port_table[ifindex - 1];
    }
    else
    {
        port_entry_p = &snapshot_p->om_part.egress_port_table[ifindex - 1];
    }

    switch (acl_entry_p->acl_type)
    {
        case RULE_TYPE_MAC_ACL:
            port_acl_type = RULE_TYPE_MAC_ACL;
            break;

        case RULE_TYPE_IP_STD_ACL:
        case RULE_TYPE_IP_EXT_ACL:
            port_acl_type = RULE_TYPE_IP_ACL;
            break;

        case RULE_TYPE_IPV6_STD_ACL:
        case RULE_TYPE_IPV6_EXT_ACL:
            port_acl_type = RULE_TYPE_IPV6_ACL;
            break;

        default:
            ASSERT(0);
            break;
    }

    ASSERT(port_acl_type < _countof(port_entry_p->bind_acl));

    {
        RULE_TYPE_AclMemento_T *p = &port_entry_p->bind_acl[port_acl_type];

        ASSERT(p->acl_index == acl_index);
        p = NULL;
    }

    return &port_entry_p->bind_acl[port_acl_type];
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_DefragRule
 *------------------------------------------------------------------------------
 * PURPOSE:  Defrag rule
 * INPUT:    direction  - Which direction of rule need to defrag
 *           acl_id     - Additional ACL need to add during rule defraging
 *           fn_commit  - Commit function for add the additional ACL
 *           fn_remove  - Remove function for del the additional ACL
 *           cookie     - The parameter for fn_commit and fn_remove
 * OUTPUT:   None
 * RETURN:   RULE_TYPE_OK ; Error code
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Priv_DefragRule(
    RULE_TYPE_InOutDirection_T direction,
    UI32_T acl_id,
    RULE_TYPE_RETURN_TYPE_T (*fn_commit)(void *cookie),
    RULE_TYPE_RETURN_TYPE_T (*fn_remove)(void *cookie),
    void *cookie)
{
    typedef enum
    {
        _STATE_PREPARING,
        _STATE_TESTING,
        _STATE_DELETING,
        _STATE_SETTING,
    } _STATE_TYPE;

    RULE_TYPE_RETURN_TYPE_T result;

    UI32_T *acl_index_list;
    UI32_T written_acl_count;
    UI32_T i;

    _STATE_TYPE state;

    RULE_CTRL_Snapshot_T *snapshot_ptr = NULL;

    RULE_CTRL_OpTable_T *dflt_optable = RULE_CTRL_OPTABLE();
    RULE_CTRL_OpTable_T fake_optable =
    {
        .fn_allocate_rule       = RULE_CTRL_Nil_Allocate_Rule,
        .fn_destroy_rule        = RULE_CTRL_Nil_Destroy_Rule,
        .fn_set_rule            = RULE_CTRL_Nil_Set_Rule,
        .fn_update_rule         = RULE_CTRL_Nil_Update_Rule,

        .fn_create_meter        = RULE_CTRL_Nil_Create_Meter,
        .fn_destroy_meter       = RULE_CTRL_Nil_Destroy_Meter,
        .fn_share_meter         = RULE_CTRL_Nil_Share_Meter,
        .fn_update_meter        = RULE_CTRL_Nil_Update_Meter,

        .fn_set_action          = RULE_CTRL_Nil_Set_Action,

        .fn_set_group_qset      = RULE_CTRL_Nil_Set_Group_Qualify_Set,
        .fn_set_group_priority  = RULE_CTRL_Nil_Set_Group_Priority,
    };

    BOOL_T b_flag_set_additional_acl;

    acl_index_list = calloc(SYS_ADPT_MAX_NBRS_OF_ACL, sizeof(UI32_T));
    if (NULL == acl_index_list)
    {
        return RULE_TYPE_FAIL;
    }

    /*
     * Enter init state
     *
     */
    result = RULE_CTRL_Priv_GetAclIdListUseSameFunctionType(direction, acl_id,
                  acl_index_list, SYS_ADPT_MAX_NBRS_OF_ACL, &written_acl_count);
    ASSERT(RULE_TYPE_OK == result);

    if (written_acl_count < 2)
    {
        free(acl_index_list);
        return RULE_TYPE_FAIL;
    }

    result = RULE_CTRL_Priv_LST_Set(acl_index_list, SYS_ADPT_MAX_NBRS_OF_ACL,
                                                    &written_acl_count, acl_id);
    ASSERT(RULE_TYPE_OK == result);

    snapshot_ptr = malloc(sizeof(*snapshot_ptr));
    if (NULL == snapshot_ptr)
    {
        goto allocate_snapshot_mem_fail;
    }

    state = _STATE_PREPARING;
    b_flag_set_additional_acl = FALSE;

    RULE_CTRL_Priv_TakeSnapshot(snapshot_ptr);

    /*
     * Don't really delete rule from device on prepare and test step
     */
    RULE_CTRL_OPTABLE() = &fake_optable;

again:

    for (i = 0; i < written_acl_count; ++ i)
    {
        UI32_T acl_index = acl_index_list[i];

        UI32_T ifindex;

        RULE_TYPE_Acl_T *acl_entry_p;

        if (_STATE_TESTING == state || _STATE_SETTING == state)
        {
            if (FALSE == b_flag_set_additional_acl &&
                acl_id == acl_index && NULL != fn_commit && NULL != cookie)
            {
                result = fn_commit(cookie);
                if (RULE_TYPE_OK != result)
                {
                    if (_STATE_TESTING == state)
                    {
                        goto testing_fail;
                    }
                    else
                    {
                        goto commit_fail;
                    }
                }

                b_flag_set_additional_acl = TRUE;
            }
        }

        /** Snapshot keep all information and it shall not be clear during prepare
         * and testing state.
         */
        acl_entry_p = RULE_CTRL_Priv_GetAclEntryFromSnapshot(acl_index, snapshot_ptr);
        ASSERT(NULL != acl_entry_p);

        /*
         * FIXME: Implement ingress only NOW
         */
        ifindex = 0;
        while (TRUE == RULE_CTRL_Priv_GetNextPort(acl_entry_p->filtering_in_port_list, &ifindex))
        {
            RULE_TYPE_INTERFACE_INFO_T interface;
            RULE_TYPE_ACL_MEMENTO_PTR_T bind_acl_p;

            memset(&interface, 0, sizeof(interface));

            RULE_CTRL_Ifindex_To_Interface(ifindex, &interface);
            interface.direction  = RULE_TYPE_INBOUND;

            if (_STATE_TESTING == state ||
                _STATE_SETTING == state)
            {
                RULE_TYPE_Acl_T acl_entry_new;

                result = RULE_OM_GetAclByIndex(acl_index, &acl_entry_new);
                ASSERT(RULE_TYPE_OK == result);

                bind_acl_p = RULE_CTRL_Priv_GetAclBindingParametersFromSnapshot(ifindex, interface.direction,
                                                                                acl_index,
                                                                                snapshot_ptr);
                ASSERT(NULL != bind_acl_p);
                ASSERT(0 != bind_acl_p->acl_index);

                result = RULE_CTRL_LocalSetACL2DEV(&interface,
                                                   acl_index,
                                                   &acl_entry_new,
                                                   bind_acl_p->time_range_index,
                                                   bind_acl_p->counter_enable);
            }
            /* Preparing:
             *   Remove all rule --> release resource and quota
             */
            else if (_STATE_PREPARING == state ||
                     _STATE_DELETING == state)
            {
                RULE_TYPE_Acl_T acl_entry_new;

                result = RULE_OM_GetAclByIndex(acl_index, &acl_entry_new);
                ASSERT(RULE_TYPE_OK == result);

                result = RULE_CTRL_LocalRemoveACLFromDEV(&interface,
                                                         acl_index,
                                                         &acl_entry_new);
            }
            else
            {
                ASSERT(0);
            }

            if (RULE_TYPE_OK != result)
            {
                switch (state)
                {
                    case _STATE_PREPARING:
                        goto preparing_fail;

                    case _STATE_TESTING:
                        goto testing_fail;

                    case _STATE_DELETING:
                        goto deleting_fail;

                    case _STATE_SETTING:
                        goto setting_fail;

                    default:
                        ASSERT(0);
                        break;
                }
            }
        }
    }

    if (_STATE_PREPARING == state)
    {
        state = _STATE_TESTING;
        b_flag_set_additional_acl = FALSE;

        RULE_CTRL_OPTABLE() = &fake_optable;

        goto again;
    }
    else if (_STATE_TESTING == state)
    {
        state = _STATE_DELETING;

        RULE_CTRL_Priv_RevertToSnapshot(snapshot_ptr);
        RULE_CTRL_OPTABLE() = dflt_optable;

        goto again;
    }
    else if (_STATE_DELETING == state)
    {
        state = _STATE_SETTING;
        b_flag_set_additional_acl = FALSE;

        RULE_CTRL_OPTABLE() = dflt_optable;

        goto again;
    }

    ASSERT(_STATE_SETTING == state);
    ASSERT(RULE_CTRL_OPTABLE() == dflt_optable);

    RULE_CTRL_Priv_DeleteSnapshot(snapshot_ptr);
    free(snapshot_ptr);

    RULE_CTRL_OPTABLE() = dflt_optable;

    free(acl_index_list);

    return RULE_TYPE_OK;

commit_fail:


preparing_fail:
testing_fail:

    RULE_CTRL_Priv_RevertToSnapshot(snapshot_ptr);
    RULE_CTRL_Priv_DeleteSnapshot(snapshot_ptr);

deleting_fail:
setting_fail:

    free(snapshot_ptr);

    RULE_CTRL_OPTABLE() = dflt_optable;

allocate_snapshot_mem_fail:

    free(acl_index_list);

    ASSERT(RULE_CTRL_OPTABLE() == dflt_optable);
    return RULE_TYPE_FAIL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_Wrap_SetACL2DEV
 *------------------------------------------------------------------------------
 * PURPOSE:  The wrapped function for RULE_CTRL_Priv_DefragRule to set ACL to
 *           device
 * INPUT:    param_ptr  - An object pointer to RULE_CTRL_WRAP_FN_PARAM_T
 * OUTPUT:   None
 * RETURN:   RULE_TYPE_OK ; Error code
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Priv_Wrap_SetACL2DEV(
    void *param_ptr)
{
    RULE_CTRL_WRAP_FN_PARAM_T *param = (RULE_CTRL_WRAP_FN_PARAM_T *)param_ptr;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_INTERFACE_INFO_T interface;

    RULE_TYPE_Acl_T acl_entry;

    memset(&interface, 0, sizeof(interface));

    // TODO: Fill interface in param
    interface.type = RULE_TYPE_INTERFACE_UPORT;
    interface.uport.unit = param->unit;
    interface.uport.port = param->port;
    interface.direction  = param->is_ingress ? RULE_TYPE_INBOUND : RULE_TYPE_OUTBOUND;

    result = RULE_OM_GetAclByIndex(param->acl_id, &acl_entry);
    ASSERT(RULE_TYPE_OK == result);

    return RULE_CTRL_LocalSetACL2DEV(&interface,
                                     param->acl_id,
                                     &acl_entry,
                                     param->time_range_index,
                                     param->counter_enable);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_Wrap_RemoveACLFromDEV
 *------------------------------------------------------------------------------
 * PURPOSE:  The wrapped function for RULE_CTRL_Priv_DefragRule to remove ACL
 *           from device
 * INPUT:    param_ptr  - An object pointer to RULE_CTRL_WRAP_FN_PARAM_T
 * OUTPUT:   None
 * RETURN:   RULE_TYPE_OK ; Error code
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Priv_Wrap_RemoveACLFromDEV(
    void *param_ptr)
{
    RULE_CTRL_WRAP_FN_PARAM_T *param = (RULE_CTRL_WRAP_FN_PARAM_T *)param_ptr;

    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_INTERFACE_INFO_T interface;

    RULE_TYPE_Acl_T acl_entry;


    memset(&interface, 0, sizeof(interface));

    // TODO: Fill interface in param
    interface.type = RULE_TYPE_INTERFACE_UPORT;
    interface.uport.unit = param->unit;
    interface.uport.port = param->port;
    interface.direction  = param->is_ingress ? RULE_TYPE_INBOUND : RULE_TYPE_OUTBOUND;

    result = RULE_OM_GetAclByIndex(param->acl_id, &acl_entry);
    ASSERT(RULE_TYPE_OK == result);

    return RULE_CTRL_LocalRemoveACLFromDEV(&interface,
                                           param->acl_id,
                                           &acl_entry);
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_SetGroupProperty
 *------------------------------------------------------------------------------
 * PURPOSE:  Set group properties
 * INPUT:    fun_type       - original function type
 *           remap_fun_type - remapped function type
 * OUTPUT:   None
 * RETURN:   RULE_TYPE_OK ; Error code
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Priv_SetGroupProperty(
    RULE_TYPE_FunctionType_T fun_type,
    RULE_TYPE_FunctionType_T remap_fun_type)
{
    RULE_TYPE_RETURN_TYPE_T result;

    result = RULE_CTRL_Priv_ChangeGroupQualifySet(fun_type, remap_fun_type);

    ASSERT(RULE_TYPE_OK == result);

    if (RULE_TYPE_OK != result)
    {
        return result;
    }

    result = RULE_CTRL_Priv_ChangeGroupPriority(fun_type, remap_fun_type);

    ASSERT(RULE_TYPE_OK == result);

    if (RULE_TYPE_OK != result)
    {
        return result;
    }

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_ChangeGroupQualifySet
 *------------------------------------------------------------------------------
 * PURPOSE:  Set group qualify set
 * INPUT:    fun_type       - original function type
 *           remap_fun_type - remapped function type
 * OUTPUT:   None
 * RETURN:   RULE_TYPE_OK ; Error code
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Priv_ChangeGroupQualifySet(
    RULE_TYPE_FunctionType_T fun_type,
    RULE_TYPE_FunctionType_T remap_fun_type)
{
    FP_CONFIG_FunctionInfo_T    *fun_p;
    FP_CONFIG_GroupInfo_T       *grp_p;

    DEVRM_GroupEntry_T          rm_group;

    ASSERT(fun_type < RULE_TYPE_FUNCTION_TYPE_MAX);
    ASSERT(remap_fun_type < RULE_TYPE_FUNCTION_TYPE_MAX);
    ASSERT(0 == RULE_CTRL_Priv_GetFuncTypeRefCountFromRule(remap_fun_type));

    memset(&rm_group, 0, sizeof(rm_group));

    fun_p = FP_CONFIG_get_function_info_by_type(fun_type);
    grp_p = FP_CONFIG_get_group_info_by_id(fun_p->group_id);

    memcpy(rm_group.w, grp_p->w, sizeof(grp_p->w));

    fun_p = FP_CONFIG_get_function_info_by_type(remap_fun_type);
    grp_p = FP_CONFIG_get_group_info_by_id(fun_p->group_id);

    rm_group.group_id = grp_p->group_id;

    return (TRUE == RULE_CTRL_SET_GROUP_QUALIFY_SET(&rm_group)) ? RULE_TYPE_OK :
                                                        RULE_TYPE_HARDWARE_FAIL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_ChangeGroupPriority
 *------------------------------------------------------------------------------
 * PURPOSE:  Set group priority
 * INPUT:    fun_type       - original function type
 *           remap_fun_type - remapped function type
 * OUTPUT:   None
 * RETURN:   RULE_TYPE_OK ; Error code
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Priv_ChangeGroupPriority(
    RULE_TYPE_FunctionType_T fun_type,
    RULE_TYPE_FunctionType_T remap_fun_type)
{
    FP_CONFIG_FunctionInfo_T    *fun_p;
    FP_CONFIG_GroupInfo_T       *grp_p;

    UI32_T group_id;
    int priority;

    ASSERT(fun_type < RULE_TYPE_FUNCTION_TYPE_MAX);
    ASSERT(remap_fun_type < RULE_TYPE_FUNCTION_TYPE_MAX);
    ASSERT(0 == RULE_CTRL_Priv_GetFuncTypeRefCountFromRule(remap_fun_type));

    fun_p = FP_CONFIG_get_function_info_by_type(fun_type);
    grp_p = FP_CONFIG_get_group_info_by_id(fun_p->group_id);

    priority = grp_p->group_id + 1;

    fun_p = FP_CONFIG_get_function_info_by_type(remap_fun_type);
    grp_p = FP_CONFIG_get_group_info_by_id(fun_p->group_id);

    group_id = grp_p->group_id;

    return (TRUE == RULE_CTRL_SET_GROUP_PRIORITY(group_id, priority)) ?
                                         RULE_TYPE_OK : RULE_TYPE_HARDWARE_FAIL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_GetFuncTypeRefCountFromRule
 *------------------------------------------------------------------------------
 * PURPOSE  : Get the reference count of function type from rule
 * INPUT    : fun_type  - the function type
 * OUTPUT   : None
 * RETURN   : Reference count
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static UI32_T
RULE_CTRL_Priv_GetFuncTypeRefCountFromRule(
    RULE_TYPE_FunctionType_T fun_type)
{
    UI32_T unit;
    UI32_T device_id;
    UI32_T group_id;
    int rule_pri;
    UI32_T ref_count;
    BOOL_T b_result;

    ref_count = 0;

    for (unit = 1; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++unit)
    {
        b_result = RULE_CTRL_GetFunctionInfoByFunctionType(fun_type, &group_id,
                                                                     &rule_pri);

        if (FALSE == b_result)
        {
            ASSERT(0);
            continue;
        }

        for (device_id = 0; device_id < shmem_data_p->dev_info[unit-1].num_of_chips; ++device_id)
        {
            RULE_CTRL_ResourceInfo_T *res_p = RULE_CTRL_GetResourceInfo(unit,
                                                                      device_id,
                                                                      group_id);

            ASSERT(NULL != res_p);
            ASSERT(res_p->free_rule <= res_p->total_rule);

            ref_count += (res_p->total_rule - res_p->free_rule);
        }
    }

    return ref_count;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_GetFuncTypeRefCountFromAcl
 *------------------------------------------------------------------------------
 * PURPOSE  : Get the reference count of function type from ACL
 * INPUT    : fun_type  - the function type
 * OUTPUT   : None
 * RETURN   : Reference count
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
UI32_T
RULE_CTRL_Priv_GetFuncTypeRefCountFromAcl(
    RULE_TYPE_FunctionType_T fun_type)
{
    UI32_T acl_index;
    RULE_TYPE_Acl_T acl_entry;

    UI32_T ref_count;

    ref_count = 0;
    acl_index = 0;

    while (RULE_TYPE_OK == RULE_OM_GetNextAclByIndex(&acl_index, &acl_entry))
    {
        RULE_TYPE_InOutDirection_T  direction;
        RULE_TYPE_FunctionType_T    tmp_fun_type;

        for (direction = RULE_TYPE_INBOUND; direction <= RULE_TYPE_OUTBOUND; ++direction)
        {
            if (FALSE == RULE_CTRL_GetFunctionTypeForACLAndQoS(TRUE,
                                   RULE_TYPE_DIRECTION_TO_IS_INGRESS(direction),
                                                             acl_entry.acl_type,
                                                                 &tmp_fun_type))
            {
                /* Some ACL have not bind into hardware. E.g., ARP.
                 */
                continue;
            }

            if (fun_type == tmp_fun_type)
            {
                ++ ref_count;
            }
        }
    }

    return ref_count;
}

#endif /* SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT */

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_SyncGroupPropertyToSlaverUnit
 *------------------------------------------------------------------------------
 * PURPOSE:  Synchronizes the property of group(selector) to slaver unit
 * INPUT:    None
 * OUTPUT:   None
 * RETURN:   RULE_TYPE_OK ; Error code
 * NOTE:     Invoke this function when received hot insertion event
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Priv_SyncGroupPropertyToSlaverUnit()
{
#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)

    UI32_T i;

    for (i = 0; i < _countof(shmem_data_p->av_fun_type_tbl.av_vector); ++i)
    {
        RULE_TYPE_FunctionType_T fun_type;
        RULE_TYPE_FunctionType_T remap_fun_type;

        RULE_CTRL_FunTypeFreeEntry_T *free_entry = &shmem_data_p->av_fun_type_tbl.av_vector[i];

        ASSERT(NULL != free_entry);

        if (RULE_TYPE_FUNCTION_TYPE_MAX == free_entry->used_by_fun_type)
        {
            continue;
        }

        fun_type = free_entry->used_by_fun_type;
        remap_fun_type = free_entry->fun_type;

        RULE_CTRL_Priv_SetGroupProperty(fun_type, remap_fun_type);

    }
#endif /* SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT */

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_FindBestFitFunctionType
 *------------------------------------------------------------------------------
 * PURPOSE:  Find best-fit function type for binding an ACL to port
 * INPUT:    unit           - unit
 *           device_id      - device_id
 *           direction      - direction
 *           acl_entry_p    - ACL entry
 * OUTPUT:   fun_type_p     - function type
 * RETURN:   RULE_TYPE_OK ; Error code
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Priv_FindBestFitFunctionType(
    UI32_T unit,
    UI32_T device_id,
    RULE_TYPE_InOutDirection_T direction,
    const RULE_TYPE_Acl_T *acl_entry_p,
    RULE_TYPE_FunctionType_T *fun_type_p)
{
    UI32_T                      group_id = 0;
    RULE_CTRL_ResourceInfo_T    *res_p;
    int                         rule_pri;

    RULE_TYPE_FunctionType_T    av_fun_type_list[ RULE_TYPE_FUNCTION_TYPE_MAX ];
    UI32_T                      number_of_entries_written;
    UI32_T                      fun_stats_idx;
    RULE_TYPE_FunctionType_T    candidated_fun_type;

    RULE_TYPE_RETURN_TYPE_T     result;
    BOOL_T                      b_result;

    ASSERT(NULL != acl_entry_p);
    ASSERT(NULL != fun_type_p);

    *fun_type_p = RULE_TYPE_FUNCTION_TYPE_MAX;

    result = RULE_CTRL_Priv_GetAvailableFunctionTypeList(direction,
                                                  acl_entry_p, av_fun_type_list,
                                                     _countof(av_fun_type_list),
                                                    &number_of_entries_written);
    if (RULE_TYPE_OK != result)
    {
        return result;
    }

    if (0 == number_of_entries_written)
    {
        /*
         * Change this constant to RULE_TYPE_INSUFFICIENT_RESOURCE if want
         * to defrag all installed rule
         */
        return RULE_TYPE_E_HW_INSUFFICIENT_SELECTOR;
    }

    ASSERT(number_of_entries_written <= _countof(av_fun_type_list));

    if (1 < number_of_entries_written)
    {
        RULE_CTRL_Priv_SortByRuleCount(av_fun_type_list, number_of_entries_written,
                                       unit, device_id);
    }

    fun_stats_idx = 0;

use_next_fun_type:

    if (number_of_entries_written <= fun_stats_idx)
    {
        return RULE_TYPE_INSUFFICIENT_RESOURCE; /* condition for enabling defrag rule */
    }

    candidated_fun_type = av_fun_type_list[ fun_stats_idx ++ ];

    b_result = RULE_CTRL_GetFunctionInfoByFunctionType(candidated_fun_type,
                                                       &group_id, &rule_pri);
    ASSERT(TRUE == b_result);

    res_p = RULE_CTRL_GetResourceInfo(unit, device_id, group_id);
    ASSERT(NULL != res_p);

    if (res_p->free_rule < acl_entry_p->ace_count)
    {
        RULE_CTRL_LOG("Resource not enough, free_rule(%lu), need_rule(%lu)",
                      res_p->free_rule, acl_entry_p->ace_count);
        goto use_next_fun_type;
    }

    if (FALSE == RULE_CTRL_RequestRuleByQuota(unit, device_id, candidated_fun_type,
                                              RULE_CTRL_REQUEST_RESOURCE_ALLOCATE_TEST,
                                              acl_entry_p->ace_count))
    {
        RULE_CTRL_LOG("Quota is reached");
        goto use_next_fun_type;
    }

    *fun_type_p = candidated_fun_type;

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_SortByRuleCount
 *------------------------------------------------------------------------------
 * PURPOSE:  Sort the list of function type by rule counter. From min to max.
 * INPUT:    fun_type_list      - Function type list
 *           number_of_entries  - How many element in the list
 *           unit               - unit. Use for obtaining rule count
 *           device_id          - device ID. Used for obtaining rule count
 * OUTPUT:   None
 * RETURN:   RULE_TYPE_OK ; Error code
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
static void
RULE_CTRL_Priv_SortByRuleCount(
    RULE_TYPE_FunctionType_T *fun_type_list,
    UI32_T number_of_entries,
    UI32_T unit,
    UI32_T device_id)
{
    UI32_T i;
    UI32_T j;
    UI32_T min;

    /*
     * select sort
     */
    for (i = 0; i < number_of_entries; ++i)
    {
        RULE_TYPE_FunctionType_T tmp;

        min = i;

        for (j = i+1; j < number_of_entries; ++j)
        {
            if (RULE_CTRL_Priv_CompareFunctionTypeByRuleCount(fun_type_list[j],
                                                              fun_type_list[min],
                                                              unit, device_id) < 0)
            {
                min = j;
            }
        }

        /*
         * swap
         */
        tmp = fun_type_list[min];
        fun_type_list[min] = fun_type_list[i];
        fun_type_list[i] = tmp;
    }
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_CompareFunctionTypeByRuleCount
 *------------------------------------------------------------------------------
 * PURPOSE:  Compare two function type by rule count
 * INPUT:    fun_type_1         - Function type 1
 *           fun_type_2         - Function type 2
 *           unit               - unit. Use for obtaining rule count
 *           device_id          - device ID. Used for obtaining rule count
 * OUTPUT:   None
 * RETURN:   Return 1, if rule counter of fun_type_1 is greater than fun_type_2
 *           Return -1, if rule counter of fun_type_2 is greater than fun_type_1
 *           Return 0, if rule counter of fun_type_1 is equal fun_type_2
 * NOTE:
 *------------------------------------------------------------------------------
 */
static int
RULE_CTRL_Priv_CompareFunctionTypeByRuleCount(
    RULE_TYPE_FunctionType_T fun_type_1,
    RULE_TYPE_FunctionType_T fun_type_2,
    UI32_T unit,
    UI32_T device_id)
{
    RULE_CTRL_ResourceInfo_T    *res_1_p;
    RULE_CTRL_ResourceInfo_T    *res_2_p;

    UI32_T group_id_1;
    UI32_T group_id_2;

    int rule_pri_1;
    int rule_pri_2;

    BOOL_T b_result;

    b_result = RULE_CTRL_GetFunctionInfoByFunctionType(fun_type_1, &group_id_1, &rule_pri_1);
    ASSERT(TRUE == b_result);

    b_result = RULE_CTRL_GetFunctionInfoByFunctionType(fun_type_2, &group_id_2, &rule_pri_2);
    ASSERT(TRUE == b_result);

    res_1_p = RULE_CTRL_GetResourceInfo(unit, device_id, group_id_1);
    ASSERT(NULL != res_1_p);

    res_2_p = RULE_CTRL_GetResourceInfo(unit, device_id, group_id_2);
    ASSERT(NULL != res_2_p);

    if (res_2_p->free_rule < res_1_p->free_rule)
    {
        return 1;
    }
    else if (res_1_p->free_rule < res_2_p->free_rule)
    {
        return -1;
    }

    return 0;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_GetAvailableFunctionTypeList
 *------------------------------------------------------------------------------
 * PURPOSE  : Get available function type list
 * INPUT    : direction                     - direction
 *            acl_entry                     - ACL
 *            enumber_of_entries_to_write   - max entries of list
 * OUTPUT   : fun_tye_list                  - available function list for the
 *                                            input ACL
 *            number_of_entries_written     - how many entries be written
 * RETURN   : RULE_TYPE_OK ; Error code
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Priv_GetAvailableFunctionTypeList(
    RULE_TYPE_InOutDirection_T direction,
    const RULE_TYPE_Acl_T *acl_entry,
    RULE_TYPE_FunctionType_T *fun_type_list,
    UI32_T number_of_entries_to_write,
    UI32_T *number_of_entries_written)
{
#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)

    UI32_T i;
    RULE_TYPE_FunctionType_T my_fun_type;

    ASSERT(RULE_TYPE_INBOUND == direction || RULE_TYPE_OUTBOUND == direction);
    ASSERT(NULL != acl_entry);
    ASSERT(NULL != number_of_entries_written);

    *number_of_entries_written = 0;

    if (FALSE == RULE_CTRL_GetFunctionTypeForACLAndQoS(TRUE,
                                   RULE_TYPE_DIRECTION_TO_IS_INGRESS(direction),
                                                            acl_entry->acl_type,
                                                                  &my_fun_type))
    {
        ASSERT(0);
        return RULE_TYPE_FAIL;
    }

    /*** Not support dynamic selector assignment.
     * Because *MAYBE* we will change *ALL* implement for this feature.
     */
    if (RULE_TYPE_OUTBOUND == direction)
    {
        fun_type_list[0] = my_fun_type;
        *number_of_entries_written = 1;
        return RULE_TYPE_OK;
    }

    for (i=0; i < _countof(shmem_data_p->av_fun_type_tbl.av_vector); ++i)
    {
        RULE_CTRL_FunTypeFreeEntry_T *free_entry = &shmem_data_p->av_fun_type_tbl.av_vector[i];

        if (RULE_TYPE_FUNCTION_TYPE_MAX == free_entry->used_by_fun_type ||
            my_fun_type == free_entry->used_by_fun_type)
        {
            if (number_of_entries_to_write < ((*number_of_entries_written) + 1))
            {
                return RULE_TYPE_FAIL;
            }

            fun_type_list[ (*number_of_entries_written) ++ ] = free_entry->fun_type;
        }
    }

#else

    RULE_TYPE_FunctionType_T my_fun_type;

    ASSERT(RULE_TYPE_INBOUND == direction || RULE_TYPE_OUTBOUND == direction);
    ASSERT(NULL != acl_entry);
    ASSERT(NULL != number_of_entries_written);

    *number_of_entries_written = 0;

    if (FALSE == RULE_CTRL_GetFunctionTypeForACLAndQoS(TRUE,
                                   RULE_TYPE_DIRECTION_TO_IS_INGRESS(direction),
                                                            acl_entry->acl_type,
                                                                  &my_fun_type))
    {
        ASSERT(0);
        return RULE_TYPE_FAIL;
    }

    fun_type_list[0] = my_fun_type;
    *number_of_entries_written = 1;

#endif /* SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT */

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_SetupGroupByFunctionType
 *------------------------------------------------------------------------------
 * PURPOSE:  Setup group(seector) by function type
 * INPUT:    fun_type       - original function type
 *           remap_fun_type - remapped (really) function type
 * OUTPUT:   None
 * RETURN:   RULE_TYPE_OK ; Error code
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Priv_SetupGroupByFunctionType(
    RULE_TYPE_FunctionType_T fun_type,
    RULE_TYPE_FunctionType_T remap_fun_type)
{
#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)

    if (fun_type != remap_fun_type)
    {
        RULE_CTRL_FunTypeFreeEntry_T *free_entry;

        RULE_TYPE_RETURN_TYPE_T result;

        free_entry = RULE_CTRL_Priv_GetFunTypeFreeEntry(remap_fun_type);
        ASSERT(NULL != free_entry);

        if (RULE_TYPE_FUNCTION_TYPE_MAX == free_entry->used_by_fun_type)
        {
            result = RULE_CTRL_Priv_SetGroupProperty(fun_type, remap_fun_type);

            if (RULE_TYPE_OK != result)
            {
                return result;
            }

            result = RULE_CTRL_Priv_EnableFuncTypeRemap(fun_type, remap_fun_type);

            ASSERT(RULE_TYPE_OK == result);

            if (RULE_TYPE_OK != result)
            {
                return result;
            }
        }
    }
#else

    ASSERT(fun_type == remap_fun_type);

#endif

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_RecycleGroup
 *------------------------------------------------------------------------------
 * PURPOSE:  Recycle group(selector).
 * INPUT:    None
 * OUTPUT:   None
 * RETURN:   RULE_TYPE_OK ; Error code
 * NOTE:     None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Priv_RecycleGroup()
{
#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)

    UI32_T i;
    RULE_TYPE_RETURN_TYPE_T result;

    for (i=0; i < _countof(shmem_data_p->av_fun_type_tbl.av_vector); ++i)
    {
        RULE_TYPE_FunctionType_T remap_fun_type_tbl[ RULE_CTRL_TOTAL_NBR_OF_AV_REMAP_FUN_TYPE ];
        UI32_T number_of_remap_fun_type = 0;

        RULE_TYPE_FunctionType_T fun_type = shmem_data_p->av_fun_type_tbl.av_vector[i].fun_type;


        result = RULE_CTRL_Priv_BuildRemapFunTypeList(fun_type,
                                                      remap_fun_type_tbl,
                                                      _countof(remap_fun_type_tbl),
                                                      &number_of_remap_fun_type);
        ASSERT(RULE_TYPE_OK == result);
        ASSERT(number_of_remap_fun_type <= _countof(remap_fun_type_tbl));

        if (0 == number_of_remap_fun_type)
        {
            continue;
        }

        {
            UI32_T j;
            const UI32_T NUMBER_OF_REMAP_FUN_TYPE = number_of_remap_fun_type;

            for (j=0; j < NUMBER_OF_REMAP_FUN_TYPE; ++j)
            {
                RULE_TYPE_FunctionType_T remap_fun_type = remap_fun_type_tbl[j];
                UI32_T ref_count = 0xffffffff;

                if (1 < number_of_remap_fun_type)
                {
                    ref_count = RULE_CTRL_Priv_GetFuncTypeRefCountFromRule(remap_fun_type);
                }
                else if (1 == number_of_remap_fun_type)
                {
                    ref_count = RULE_CTRL_Priv_GetFuncTypeRefCountFromAcl(fun_type);

                    if (0 == ref_count)
                    {
                        ASSERT(0 == RULE_CTRL_Priv_GetFuncTypeRefCountFromRule(remap_fun_type));
                    }
                }

                ASSERT(0xffffffff != ref_count);

                if (0 == ref_count)
                {
                    result = RULE_CTRL_Priv_ChangeGroupQualifySet(remap_fun_type,
                                                                  remap_fun_type);
                    ASSERT(RULE_TYPE_OK == result);

                    result = RULE_CTRL_Priv_ChangeGroupPriority(remap_fun_type,
                                                                remap_fun_type);
                    ASSERT(RULE_TYPE_OK == result);

                    result = RULE_CTRL_Priv_DisableFuncTypeRemap(fun_type,
                                                                 remap_fun_type);
                    ASSERT(RULE_TYPE_OK == result);
                }
            }
        }
    }

#endif /* SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT */

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_UPortToDeviceId
 *------------------------------------------------------------------------------
 * PURPOSE  : Convert unit/port to device ID
 * INPUT    : unit  - unit
 *            port  - port
 * OUTPUT   : None
 * RETURN   : device ID
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static UI32_T
RULE_CTRL_Priv_UPortToDeviceId(
    UI32_T unit,
    UI32_T port)
{
    UI32_T module_id = 0xffffffff;
    UI32_T device_id = 0xffffffff;
    UI32_T phy_port  = 0xffffffff;

    BOOL_T b_result;

    b_result = DEV_SWDRV_PMGR_Logical2PhyDevicePortID(unit, port,
                                             &module_id, &device_id, &phy_port);
    ASSERT(TRUE == b_result);

    return device_id;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_GetNextPort
 *------------------------------------------------------------------------------
 * PURPOSE  : Get next port from a port list
 * INPUT    : port_list - port list
 * OUTPUT   : ifindex_p - ifindex. Pass this value to 0 to start
 * RETURN   : NULL -- failed
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
//
// FIXME: Check the caller
//
static BOOL_T
RULE_CTRL_Priv_GetNextPort(
    const UI8_T port_list[RULE_TYPE_TOTAL_NBR_OF_BYTE_FOR_1BIT_PORT_LIST],
    UI32_T *ifindex_p)
{
    //
    // FIXME: ifindex_p is support ether port only. It should be fix.
    //

    for (++(*ifindex_p);
         (*ifindex_p) <= RULE_TYPE_TOTAL_NBR_OF_PORT; //SYS_ADPT_TOTAL_NBR_OF_LPORT;
         ++(*ifindex_p))
    {
        if (RULE_CTRL_IS_BIT_ON(port_list, ((*ifindex_p)-1)))
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalGetFirstDevRuleIDofOneClassMap
 *------------------------------------------------------------------------------
 * PURPOSE  : get the first logical rule id of one class-map
 * INPUT    : ifindex, cmap_idx, ingress_flag
 * OUTPUT   : None
 * RETURN   : RULE_CTRL_NO_SHARE_METER_ENTRY_ID/
 *            Logical rule id of device
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static UI32_T
RULE_CTRL_LocalGetFirstDevRuleIDofOneClassMap(
    const RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    UI32_T unit,
    UI32_T device_id)
{
    RULE_CTRL_UNIT_DEVICE_T param;
    RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;

    memset(&param, 0, sizeof(param));
    param.unit = unit;
    param.device_id = device_id;

    rule_inst_p = (RULE_TYPE_RULE_INSTANCE_PTR_T)RULE_CTRL_IN_Priv_FindIf((RULE_TYPE_INSTANCE_PTR_T)class_inst_p,
                                                                          RULE_CTRL_Priv_IsRuleInstanceMatchUnitDevice,
                                                                          &param);
    if (NULL != rule_inst_p)
    {
        ASSERT(TRUE == RULE_CTRL_IS_RULE_INSTANCE_TYPE(rule_inst_p->super.type));
        return rule_inst_p->dev_rule_info.rule_id;
    }

    return RULE_CTRL_NO_SHARE_METER_ENTRY_ID;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_GetAclInstanceById
 *------------------------------------------------------------------------------
 * PURPOSE  : Get ACL instance
 * INPUT    : unit      - unit
 *            port      - port
 *            direction - direction
 * OUTPUT   : None
 * RETURN   : ACL instance; NULL
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_CLASS_INSTANCE_PTR_T
RULE_CTRL_Priv_GetAclInstanceById(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p,
    UI32_T acl_index)
{
    RULE_CTRL_IF_ENTRY_PTR_T if_entry_p;
    RULE_TYPE_CLASS_INSTANCE_OBJECT_T if_class_obj;

    RULE_TYPE_CONTAINER_PTR_T acl_container_p;

    RULE_CTRL_INSTANCE_TYPE_ID_T param;

    RULE_TYPE_CLASS_INSTANCE_PTR_T  acl_inst_p;

    ASSERT(NULL != interface_p);

    if_entry_p = RULE_CTRL_Priv_GetIfEntry(interface_p);
    ASSERT(NULL != if_entry_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObjectFromPointer(if_entry_p->class_inst_ptr,
                                                              &if_class_obj);

    memset(&param, 0, sizeof(param));

    param.type = RULE_TYPE_INST_CONTAINER;
    param.id = RULE_TYPE_INST_ACL;

    acl_container_p = (RULE_TYPE_CONTAINER_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) if_class_obj.inst,
                                                                                RULE_CTRL_Priv_IsMatchTypeId,
                                                                                &param);
    if (NULL == acl_container_p)
    {
        return NULL;
    }

    param.type = RULE_TYPE_INST_ACL;
    param.id = acl_index;

    acl_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)RULE_CTRL_Priv_GetFirstChildIf((RULE_TYPE_INSTANCE_PTR_T) acl_container_p,
                                                                                RULE_CTRL_Priv_IsClassInstanceMatchTypeId,
                                                                                &param);
    return acl_inst_p;
}

static RULE_TYPE_CLASS_INSTANCE_PTR_T
RULE_CTRL_Priv_GetSharingAclInstance_2(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p,
    UI32_T acl_id,
    const RULE_TYPE_Acl_T *acl_entry_p,
    UI32_T time_range_index,
    RULE_TYPE_COUNTER_ENABLE_T counter_enable)
{
    RULE_TYPE_CLASS_INSTANCE_PTR_T  acl_inst_p;

    UI32_T                          ifindex;
    UI32_T                          module_id, device_id, phy_port;

    BOOL_T                          b_result;

    ASSERT(NULL != interface_p);
    ASSERT(RULE_TYPE_INBOUND == interface_p->direction ||
           RULE_TYPE_OUTBOUND == interface_p->direction);
    ASSERT(NULL != acl_entry_p);

    if (RULE_TYPE_INTERFACE_UPORT != interface_p->type)
    {
        return NULL;
    }

    if (RULE_TYPE_COUNTER_ENABLE == counter_enable)
    {
        return NULL;
    }

    b_result = DEV_SWDRV_PMGR_Logical2PhyDevicePortID(interface_p->uport.unit,
                                                      interface_p->uport.port,
                                                      &module_id,
                                                      &device_id,
                                                      &phy_port);
    ASSERT(TRUE == b_result);

    for (ifindex = RULE_CTRL_UPORT_1_INDEX;
         ifindex < (RULE_CTRL_UPORT_1_INDEX + RULE_CTRL_TOTAL_NBR_OF_UPORT);
         ++ ifindex)
    {
        RULE_TYPE_INTERFACE_INFO_T temp_interface;

        memset(&temp_interface, 0, sizeof(temp_interface));

        RULE_CTRL_Ifindex_To_Interface(ifindex, &temp_interface);
        temp_interface.direction = interface_p->direction;

        acl_inst_p = RULE_CTRL_Priv_GetAclInstanceById(&temp_interface, acl_id);

        if (NULL != acl_inst_p)
        {
            UI32_T temp_unit, temp_port;
            UI32_T temp_module_id, temp_device_id, temp_phy_port;

            temp_unit = STKTPLG_OM_IFINDEX_TO_UNIT(ifindex);
            temp_port = STKTPLG_OM_IFINDEX_TO_PORT(ifindex);

            if (interface_p->uport.unit != temp_unit)
            {
                continue;
            }

            b_result = DEV_SWDRV_PMGR_Logical2PhyDevicePortID(temp_unit,
                                                              temp_port,
                                                              &temp_module_id,
                                                              &temp_device_id,
                                                              &temp_phy_port);
            ASSERT(TRUE == b_result);

            if (device_id != temp_device_id)
            {
                continue;
            }

#if (SYS_CPNT_TIME_BASED_ACL == TRUE)
            if (acl_inst_p->time_range_index != time_range_index)
            {
                continue;
            }
#endif /* SYS_CPNT_TIME_BASED_ACL */

#if (SYS_CPNT_ACL_COUNTER == TRUE)
            if (RULE_TYPE_COUNTER_ENABLE == acl_inst_p->counter_enable)
            {
                continue;
            }
#endif /* SYS_CPNT_ACL_COUNTER */

            return acl_inst_p;
        }
    }

    return NULL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_SetPolicyMapInstance
 *------------------------------------------------------------------------------
 * PURPOSE  : Set policy map instance
 * INPUT    : unit              - unit
 *            port              - port
 *            direction         - direction
 *            policy_map_inst_p - a pointer to policy map instance
 * OUTPUT   : None
 * RETURN   : policy map instance; NULL
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static UI32_T
RULE_CTRL_Priv_SetPolicyMapInstance(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p,
    RULE_TYPE_CLASS_INSTANCE_PTR_T policy_map_inst_p)
{
    RULE_TYPE_RETURN_TYPE_T result;
    UI32_T ifindex;

    ASSERT(NULL != interface_p);
    ASSERT(RULE_TYPE_INBOUND == interface_p->direction ||
           RULE_TYPE_OUTBOUND == interface_p->direction);

    ASSERT((NULL == policy_map_inst_p) ||
           (NULL != policy_map_inst_p && NULL == RULE_CTRL_Priv_GetPolicyMapInstance(interface_p)));

    result = RULE_CTRL_Interface_To_Ifindex(interface_p, &ifindex);
    ASSERT(RULE_TYPE_OK == result);

    RULE_OM_SetPolicyMapInstance(ifindex, interface_p->direction, policy_map_inst_p);
    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_GetPolicyMapInstance
 *------------------------------------------------------------------------------
 * PURPOSE  : Get policy map instance
 * INPUT    : unit      - unit
 *            port      - port
 *            direction - direction
 * OUTPUT   : None
 * RETURN   : policy map instance; NULL
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_CLASS_INSTANCE_PTR_T
RULE_CTRL_Priv_GetPolicyMapInstance(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_CLASS_INSTANCE_PTR_T  policy_map_inst_p;
    UI32_T  ifindex;

    ASSERT(NULL != interface_p);
    ASSERT(RULE_TYPE_INBOUND == interface_p->direction ||
           RULE_TYPE_OUTBOUND == interface_p->direction);

    result = RULE_CTRL_Interface_To_Ifindex(interface_p, &ifindex);
    ASSERT(RULE_TYPE_OK == result);

    policy_map_inst_p = RULE_OM_GetPolicyMapInstance(ifindex, interface_p->direction);

    ASSERT(NULL == policy_map_inst_p ||
           (NULL != policy_map_inst_p && RULE_TYPE_INST_POLICY_MAP == policy_map_inst_p->super.type));

    return policy_map_inst_p;
}

static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Priv_GetAcePriorityInAcl(
    UI32_T acl_index,
    UI32_T ace_index,
    int *priority_p)
{
    UI32_T _ace_index;
    RULE_TYPE_AclType_T ace_type;
    RULE_TYPE_Ace_Entry_T ace_entry;

    UI32_T seq_no;

    ASSERT(NULL != priority_p);

    *priority_p = -9999;

    for (seq_no = 0, _ace_index = 0;
         RULE_TYPE_OK == RULE_OM_GetNextAceByAcl(acl_index, &ace_type, &_ace_index, &ace_entry);
         ++ seq_no)
    {
        if (ace_index == _ace_index)
        {
            *priority_p = (-1) * seq_no;
            return RULE_TYPE_OK;
        }
    }

    ASSERT(0);
    return RULE_TYPE_INVALID_PARAMETER;
}

static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Priv_GetClassMapElementPriorityInClassMap(
    UI32_T policy_map_index,
    UI32_T class_map_index,
    RULE_TYPE_ClassType_T class_type,
    UI16_T class_id,
    int *priority_p)
{
    RULE_TYPE_RETURN_TYPE_T result;

    RULE_TYPE_PolicyMap_T policy_map;

    UI32_T cx;
    UI32_T px;

    ASSERT(NULL != priority_p);

    *priority_p = -9999;

    result = RULE_OM_GetPolicyMap(policy_map_index, &policy_map);
    ASSERT(RULE_TYPE_OK == result);

    for (px = 0; px < policy_map.element_count; ++ px)
    {
        UI32_T policy_element_index = policy_map.policy_map_element_index_list[px];
        RULE_TYPE_PolicyElement_T policy_element;

        result = RULE_OM_GetPolicyMapElement(policy_element_index, &policy_element);
        ASSERT(RULE_TYPE_OK == result);

        if (policy_element.class_map_index == class_map_index)
        {
            RULE_TYPE_ClassMap_T class_map;

            result = RULE_OM_GetClassMap(class_map_index, &class_map);
            ASSERT(RULE_TYPE_OK == result);

            if (RULE_TYPE_CLASS_MAP_MATCH_ANY == class_map.class_map_match_type)
            {
                for (cx = 0; cx < class_map.class_element_count; ++ cx)
                {
                    if (class_map.class_type[cx] == class_type &&
                        class_map.class_index_list[cx] == class_id)
                    {
                        *priority_p = -1 * ((SYS_ADPT_DIFFSERV_MAX_CLASS_MAP_NBR_OF_POLICY_MAP * px) + cx);
                        return RULE_TYPE_OK;
                    }
                }
            }
            else if (RULE_TYPE_CLASS_MAP_MATCH_ALL == class_map.class_map_match_type)
            {
                *priority_p = -1 * ((SYS_ADPT_DIFFSERV_MAX_CLASS_MAP_NBR_OF_POLICY_MAP * px) + 0);
                return RULE_TYPE_OK;
            }
            else
            {
                ASSERT(0);
            }

            ASSERT(0);
            return RULE_TYPE_INVALID_PARAMETER;
        }
    }

    ASSERT(0);
    return RULE_TYPE_INVALID_PARAMETER;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalFreeRulesByRuleGroup
 *------------------------------------------------------------------------------
 * PURPOSE  : free rules from chip and selector_info
 * INPUT    : unit, port, class_instance, acl_type, is_qos
 * OUTPUT   : None
 * RETURN   : TRUE -- succeeded / FALS -- failed
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalFreeRulesByRuleGroup(
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p)
{
    RULE_TYPE_RETURN_TYPE_T             result;

    RULE_TYPE_CLASS_INSTANCE_OBJECT_T   class_inst_obj;
    RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T rule_inst_iter;
    RULE_TYPE_RULE_INSTANCE_PTR_T       rule_inst_p;

    ASSERT(NULL != class_inst_p);

    RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_inst_p, &class_inst_obj);
    class_inst_obj.get_element_iterator(&class_inst_obj, &rule_inst_iter);

    for (rule_inst_iter.last(&rule_inst_iter);
         NULL != rule_inst_iter.get_instance(&rule_inst_iter);
         rule_inst_iter.last(&rule_inst_iter))
    {
        rule_inst_p = (RULE_TYPE_RULE_INSTANCE_PTR_T) rule_inst_iter.get_instance(&rule_inst_iter);
        ASSERT(NULL != rule_inst_p);

        if (RULE_CTRL_IS_CLASS_INSTANCE_TYPE(rule_inst_p->super.type))
        {
            RULE_TYPE_CLASS_INSTANCE_PTR_T class_rule_inst_p;
            RULE_TYPE_CLASS_INSTANCE_OBJECT_T class_rule_inst_obj;

            class_rule_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)rule_inst_p;

            result = RULE_CTRL_LocalFreeRulesByRuleGroup(class_rule_inst_p);
            ASSERT(RULE_TYPE_OK == result);
            if (RULE_TYPE_OK != result)
            {
                return result;
            }

            RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_rule_inst_p,
                                                           &class_rule_inst_obj);

            class_inst_obj.remove_class_obj(&class_inst_obj, &class_rule_inst_obj);
            RULE_CTRL_IN_Priv_DestroyClassInstanceObject(&class_rule_inst_obj);
        }
        else if (RULE_CTRL_IS_RULE_INSTANCE_TYPE(rule_inst_p->super.type))
        {
            result = RULE_CTRL_LocalFreeRuleInRuleGroup(class_inst_p, rule_inst_p);
            ASSERT(RULE_TYPE_OK == result);
        }
        else
        {
            ASSERT(0);
        }
    }

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_LocalFreeRuleInRuleGroup
 *------------------------------------------------------------------------------
 * PURPOSE  : free a rule from chip and selector_info
 * INPUT    : unit, device_id, class_instance, dev_rule_id, ace_index, acl_type, is_qos
 * OUTPUT   : None
 * RETURN   : TRUE -- succeeded / FALSE -- failed
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_LocalFreeRuleInRuleGroup(
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p)
{
    BOOL_T b_result;

    ASSERT(NULL != class_inst_p);
    ASSERT(NULL != rule_inst_p);

    if (TRUE == rule_inst_p->active)
    {
        ASSERT(0 != rule_inst_p->dev_rule_info.unit && rule_inst_p->dev_rule_info.unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK);
        ASSERT(rule_inst_p->dev_rule_info.device < SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT);

        b_result = RULE_CTRL_DESTROY_RULE(rule_inst_p->dev_rule_info.unit,
                                          1,
                                          rule_inst_p->dev_rule_info.device,
                                          rule_inst_p->dev_rule_info.group_id,
                                          rule_inst_p->dev_rule_info.fun_type,
                                          rule_inst_p->dev_rule_info.rule_id);
        if (TRUE != b_result)
        {
            ASSERT(0);
            return RULE_TYPE_FAIL;
        }
    }

    b_result = RULE_CTRL_FreeResourceInfo(rule_inst_p->dev_rule_info.unit,
                                          rule_inst_p->dev_rule_info.device,
                                          rule_inst_p->dev_rule_info.group_id);
    if (TRUE != b_result)
    {
        ASSERT(0);
        return RULE_TYPE_FAIL;
    }

    b_result = RULE_CTRL_RequestRuleByQuota(rule_inst_p->dev_rule_info.unit,
                                            rule_inst_p->dev_rule_info.device,
                                            rule_inst_p->dev_rule_info.fun_type,
                                            RULE_CTRL_REQUEST_RESOURCE_FREE,
                                            1);
    ASSERT(TRUE == b_result);

    {
        RULE_TYPE_CLASS_INSTANCE_OBJECT_T   class_inst_obj;
        RULE_TYPE_RULE_INSTANCE_OBJECT_T    rule_inst_obj;

        RULE_CTRL_IN_Priv_ConstructClassInstanceObject(class_inst_p, &class_inst_obj);
        RULE_CTRL_IN_Priv_ConstructRuleInstanceObject(rule_inst_p, &rule_inst_obj);

        class_inst_obj.remove_rule_obj(&class_inst_obj, &rule_inst_obj);
        RULE_CTRL_IN_Priv_DestroyRuleInstanceObject(&rule_inst_obj);
    }

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_GetResourceInfo
 *------------------------------------------------------------------------------
 * PURPOSE  : get selector resource info
 * INPUT    : unit, device_id, selector_id
 * OUTPUT   : None
 * RETURN   : NULL -- failed
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static RULE_CTRL_ResourceInfo_T*
RULE_CTRL_GetResourceInfo(
    UI32_T unit,
    UI32_T device_id,
    UI32_T group_id)
{
    if ((0 >= unit) || (SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK < unit))
        return NULL; /* unit is 1-based */

    if (SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT <= device_id)
        return NULL; /* device_id is zero-based */

    if (SYS_ADPT_FP_MAX_NBR_OF_GROUP_PER_CHIP <= group_id)
        return NULL; /* selector is zero-based */

    return &shmem_data_p->resource_info[unit - 1][device_id][group_id];
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_GetRuleQuota
 *------------------------------------------------------------------------------
 * PURPOSE:  Get rule quota by function type
 * INPUT:    func_type - Function type
 * OUTPUT:   None
 * RETURN:   Succeeded - Quota object pointer/Failed - NULL
 * NOTE:
 *------------------------------------------------------------------------------
 */
static RULE_CTRL_RuleQuota_T*
RULE_CTRL_GetRuleQuota(
    UI32_T                          unit,
    UI32_T                          device_id,
    RULE_TYPE_FunctionType_T        func_type)
{
    if (0 == unit ||
        SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK < unit ||
        SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT <= device_id ||
        RULE_TYPE_FUNCTION_TYPE_MAX <= func_type)
    {
        return NULL;
    }

    return &shmem_data_p->quota_desc.vec[unit-1][device_id].rq[func_type];
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_CheckGroupResourceForAddRuleQuota
 *------------------------------------------------------------------------------
 * PURPOSE:  Check hware resource when add rule quota(function type) into a
 *           group
 * INPUT:    group_id         - Add rule quota into group
 *           group_total_rule - How many rule in the group
 *           func_type        - Function type
 *           rule_quota       - How many rule need for the function type
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_CheckGroupResourceForAddRuleQuota(
    UI32_T                          unit,
    UI32_T                          device_id,
    UI32_T                          group_id,
    UI32_T                          group_total_rule,
    RULE_TYPE_FunctionType_T        fun_type,
    UI32_T                          rule_quota)
{
    return (rule_quota <= group_total_rule) ? TRUE : FALSE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_AddRuleQuota
 *------------------------------------------------------------------------------
 * PURPOSE:  Add rule quota(function type) into a group
 * INPUT:    group_id         - Add rule quota into group
 *           group_total_rule - How many rule in the group
 *           func_type        - Function type
 *           rule_quota       - How many rule need for the function type
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_AddRuleQuota(
    UI32_T                          unit,
    UI32_T                          device_id,
    UI32_T                          group_id,
    UI32_T                          group_total_rule,
    RULE_TYPE_FunctionType_T        fun_type,
    UI32_T                          rule_quota)
{
    RULE_CTRL_RuleQuota_T   *rule_quota_p = NULL;

    rule_quota_p = RULE_CTRL_GetRuleQuota(unit, device_id, fun_type);
    if (NULL == rule_quota_p)
    {
        RULE_CTRL_PRINT("Error ! RULE_CTRL_GetRuleQuota(). fun_type=%d, rule_quota=%lu",
            fun_type, rule_quota);
        return FALSE;
    }

    if (rule_quota_p->used)
    {
        return TRUE;
    }

    if (FALSE == RULE_CTRL_CheckGroupResourceForAddRuleQuota(unit, device_id,
                                                             group_id,
                                                             group_total_rule,
                                                             fun_type,
                                                             rule_quota))
    {
        RULE_CTRL_PRINT("Error ! RULE_CTRL_CheckRuleQuotaFromGroupResourceInfo(fun_type=%d, rule_quota=%lu)",
            fun_type, rule_quota);
        return FALSE;
    }

    rule_quota_p->used          = TRUE;
    rule_quota_p->fun_type      = fun_type;
    rule_quota_p->group_id      = group_id;
    rule_quota_p->total_rule    = rule_quota;
    rule_quota_p->free_rule     = rule_quota;
    rule_quota_p->rule_cnt      = 0;

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_RequestRuleByQuota
 *------------------------------------------------------------------------------
 * PURPOSE:  Request rule from the specified function type
 * INPUT:    func_type        - Function type
 *           allocate         - Request type
 *           rule_count       - How many rule need
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_RequestRuleByQuota(
    UI32_T                              unit,
    UI32_T                              device_id,
    RULE_TYPE_FunctionType_T            fun_type,
    RULE_CTRL_RequestResourceType_T     request_type,
    UI32_T                              rule_count)
{
    RULE_CTRL_RuleQuota_T   *rule_quota_p = NULL;

    rule_quota_p = RULE_CTRL_GetRuleQuota(unit, device_id, fun_type);

    ASSERT(NULL != rule_quota_p);

    if (NULL == rule_quota_p)
    {
        return FALSE;
    }

    switch (request_type)
    {
        case RULE_CTRL_REQUEST_RESOURCE_ALLOCATE_TEST:
            /* quota check
             */
            if (0 != rule_quota_p->total_rule)
            {
                if (rule_quota_p->free_rule < rule_count)
                {
                    RULE_CTRL_LOG("Allocate test failure. fun_type=%d, free_rule=%lu, rule_count=%lu",
                                  fun_type, rule_quota_p->free_rule, rule_count);
                    return FALSE;
                }
            }

            break;

        case RULE_CTRL_REQUEST_RESOURCE_ALLOCATE:

            if (FALSE == RULE_CTRL_RequestRuleByQuota(unit, device_id, fun_type,
                                                      RULE_CTRL_REQUEST_RESOURCE_ALLOCATE_TEST,
                                                      rule_count))
            {
                return FALSE;
            }

            if (0 != rule_quota_p->total_rule)
            {
                ASSERT(rule_count <= rule_quota_p->free_rule);

                rule_quota_p->free_rule -= rule_count;
            }

            rule_quota_p->rule_cnt++;
            break;

        case RULE_CTRL_REQUEST_RESOURCE_FREE:

            if (0 != rule_quota_p->total_rule)
            {
                ASSERT( (rule_quota_p->free_rule + rule_count) <= rule_quota_p->total_rule );

                rule_quota_p->free_rule += rule_count;
            }

            rule_quota_p->rule_cnt--;
            break;

        default:
            RULE_CTRL_LOG("Error ! Invalid parameter. request_type=%d is wrong",
                          request_type);
            ASSERT(0);
            return FALSE;
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_GetCpuRule
 *------------------------------------------------------------------------------
 * PURPOSE  : get status of cpu rule
 * INPUT    : rule_type
 * OUTPUT   : is_enabled, dev_rule_id
 * RETURN   : NULL -- failed
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_GetCpuRule(UI32_T device_id, UI32_T rule_type, BOOL_T *is_enabled, UI32_T *dev_rule_id)
{
    if(NULL == is_enabled || NULL == dev_rule_id)
        return FALSE;

    if (SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT <= device_id)
        return FALSE;/* device_id is zero-based */

    if (RULE_TYPE_Pkt2CpuRule_MAX < rule_type)
        return FALSE;

    *is_enabled = shmem_data_p->cpu_rule[device_id][rule_type].is_enabled;
    *dev_rule_id = shmem_data_p->cpu_rule[device_id][rule_type].dev_rule_id;

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetCpuRule
 *------------------------------------------------------------------------------
 * PURPOSE  : get status of cpu rule
 * INPUT    : device_id, rule_type
 * OUTPUT   : enable, dev_rule_id
 * RETURN   : NULL -- failed
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_SetCpuRule(UI32_T device_id, UI32_T rule_type, BOOL_T enable, UI32_T dev_rule_id)
{
    if (SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT <= device_id)
        return FALSE;/* device_id is zero-based */

    if (RULE_TYPE_Pkt2CpuRule_MAX < rule_type)
        return FALSE;

    if(enable)
    {
        shmem_data_p->cpu_rule[device_id][rule_type].is_enabled = TRUE;
        shmem_data_p->cpu_rule[device_id][rule_type].dev_rule_id = dev_rule_id;
    }
    else
    {
        shmem_data_p->cpu_rule[device_id][rule_type].is_enabled = FALSE;
        shmem_data_p->cpu_rule[device_id][rule_type].dev_rule_id = 0;
    }

    return TRUE;
}

/* 2008-07-22, Jinfeng Chen:
    may use it later, hide it to remove warning when compiling
 */
#if 0
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_GetDhcpRule
 *------------------------------------------------------------------------------
 * PURPOSE  : get status of DHCP snooping rule
 * INPUT    : device_id, vid
 * OUTPUT   : client_rule_id, server_rule_id
 * RETURN   : NULL -- failed
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_GetDhcpSnoopingRule(UI32_T device_id, UI32_T vid, BOOL_T is_client, UI32_T *dev_rule_id)
{
    if(NULL == dev_rule_id)
        return FALSE;

    if (SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT <= device_id)
        return FALSE;/* device_id is zero-based */

    if (SYS_ADPT_MAX_NBR_OF_VLAN < vid)
        return FALSE;

    if(is_client)
        *dev_rule_id = shmem_data_p->dhcp_rule[device_id][vid].client_rule_id;
    else
        *dev_rule_id = shmem_data_p->dhcp_rule[device_id][vid].server_rule_id;

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetDhcpRule
 *------------------------------------------------------------------------------
 * PURPOSE  : set status of cpu rule
 * INPUT    : device_id, vid
 * OUTPUT   : client_rule_id, server_rule_id
 * RETURN   : NULL -- failed
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_SetDhcpSnoopingRule(UI32_T device_id, UI32_T vid, BOOL_T is_client, UI32_T dev_rule_id)
{
    if (SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT <= device_id)
        return FALSE;/* device_id is zero-based */

    if (SYS_ADPT_MAX_NBR_OF_VLAN < vid)
        return FALSE;

    if(is_client)
        shmem_data_p->dhcp_rule[device_id][vid].client_rule_id = dev_rule_id;
    else
        shmem_data_p->dhcp_rule[device_id][vid].server_rule_id = dev_rule_id;

    return TRUE;
}
#endif

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_GetSlfRule
 *------------------------------------------------------------------------------
 * PURPOSE  : get status of slf rule
 * INPUT    : device_id, vid
 * OUTPUT   : is_enabled, action, server_rule_id
 * RETURN   : NULL -- failed
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_GetSlfRule(UI32_T device_id, UI32_T vid, BOOL_T *is_enabled, UI8_T *slf_action, UI32_T *dev_rule_id)
{
    if(NULL == dev_rule_id || NULL == is_enabled || NULL == slf_action)
        return FALSE;

    if (SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT <= device_id)
        return FALSE;/* device_id is zero-based */

    if (SYS_ADPT_MAX_NBR_OF_VLAN < vid)
        return FALSE;

    *is_enabled = shmem_data_p->slf_rule[device_id][vid].is_enabled;
    *slf_action = shmem_data_p->slf_rule[device_id][vid].slf_action;
    *dev_rule_id = shmem_data_p->slf_rule[device_id][vid].dev_rule_id;

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetSlfRule
 *------------------------------------------------------------------------------
 * PURPOSE  : set status of slf rule
 * INPUT    : device_id, vid, enable, action, dev_rule_id
 * OUTPUT   :
 * RETURN   : NULL -- failed
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_SetSlfRule(UI32_T device_id, UI32_T vid, BOOL_T enable, UI8_T slf_action, UI32_T dev_rule_id)
{
    if (SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT <= device_id)
        return FALSE;/* device_id is zero-based */

    if (SYS_ADPT_MAX_NBR_OF_VLAN < vid)
        return FALSE;

    if(enable)
    {
        shmem_data_p->slf_rule[device_id][vid].is_enabled = TRUE;
        shmem_data_p->slf_rule[device_id][vid].slf_action = slf_action;
        shmem_data_p->slf_rule[device_id][vid].dev_rule_id = dev_rule_id;
    }
    else
    {
        shmem_data_p->slf_rule[device_id][vid].is_enabled = FALSE;
        shmem_data_p->slf_rule[device_id][vid].slf_action = SLF_NO_ACTION;
        shmem_data_p->slf_rule[device_id][vid].dev_rule_id = 0;
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_IsNullMac
 *------------------------------------------------------------------------------
 * PURPOSE  : check whether mac is all zero
 * INPUT    : mac
 * OUTPUT   : None
 * RETURN   : TRUE/FALSE.
 * NOTE     : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_IsNullMac(const UI8_T *mac)
{
    return (CHECK_MAC_IS_NULL(mac));
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Convert_Action2DEV
 *------------------------------------------------------------------------------
 * PURPOSE  : Convert action to action list
 * INPUT    : action_entry, is_ingress
 * OUTPUT   : None
 * RETURN   : NULL -- failed
 * NOTE     : caller SHOULD free returned DEVRM_ActionEntry_T* memory
 *------------------------------------------------------------------------------
 */
static DEVRM_ActionEntry_T*
RULE_CTRL_Convert_Action2DEV(
    UI32_T lport,
    BOOL_T is_ingress,
    const RULE_TYPE_Action_T *action_entry)
{
#define RULE_CTRL_CREATE_NEXT_ACTION_IF_NEED(action_p)  \
        if (RULE_CTRL_NO_ACTION != action_p->action) \
        { \
            action_p->next_action = (DEVRM_ActionEntry_T*)L_MM_Malloc(sizeof(DEVRM_ActionEntry_T), L_MM_USER_ID2(SYS_MODULE_RULE_CTRL, 0)); \
            action_p = action_p->next_action; \
            if (NULL == action_p) \
            { \
                RULE_CTRL_FreeDevActionListMemory(dev_action_head_p); \
                return NULL; \
            } \
            RULE_CTRL_INITIALIZE_ACTION_ENTRY(action_p); \
        }
#if (SYS_CPNT_COS_INTER_DSCP == TRUE)
#define RULE_CTRL_REMAP_BY_DSCP_LOOKUP     FALSE
#else
#define RULE_CTRL_REMAP_BY_DSCP_LOOKUP     TRUE
#endif


    DEVRM_ActionEntry_T     *dev_action_head_p, *current_dev_action_p;

    current_dev_action_p = (DEVRM_ActionEntry_T*)L_MM_Malloc(sizeof(DEVRM_ActionEntry_T), L_MM_USER_ID2(SYS_MODULE_RULE_CTRL, 0));
    if (NULL == current_dev_action_p)
    {
        LOG("<Error> Out of memory for action");
        return NULL;
    }

    dev_action_head_p = current_dev_action_p; /* keep the first action */

    RULE_CTRL_INITIALIZE_ACTION_ENTRY(current_dev_action_p);

    if (action_entry->action_bitmap & RULE_TYPE_ACTION_PKT_NEW_PRI)
    {
        LOG("Pkt-New-Priority\r\n"
            "    Data %lu", action_entry->pkt_new_pri);

        RULE_CTRL_CREATE_NEXT_ACTION_IF_NEED(current_dev_action_p);

        if (TRUE == is_ingress)
        {
            /*current_dev_action_p->action = bcmFieldActionPrioPktNew;*/
            current_dev_action_p->action = bcmFieldActionPrioPktAndIntNew;/*change both priority*/
        }
        else
        {
            current_dev_action_p->action = bcmFieldActionOuterVlanPrioNew;
        }

        current_dev_action_p->param0 = action_entry->pkt_new_pri;
    }

    if (action_entry->action_bitmap & RULE_TYPE_ACTION_PKT_NEW_PHB)
    {
        LOG("Pkt-New-PHB\r\n"
            "    Data %lu", action_entry->pkt_new_phb);

        RULE_CTRL_CREATE_NEXT_ACTION_IF_NEED(current_dev_action_p);
        current_dev_action_p->action = bcmFieldActionPrioIntNew;
        current_dev_action_p->param0 = action_entry->pkt_new_phb;
    }

    /* TOS:8 bits, DSCP:6 bits, packet_pri:3 bits. packet_pri for QoS mapping has top-priority. */
    if (action_entry->action_bitmap & RULE_TYPE_ACTION_PKT_NEW_TOS)
    {
#if (RULE_CTRL_REMAP_BY_DSCP_LOOKUP == TRUE)
        UI8_T   cos;
#endif

        LOG("Pkt-New-TOS\r\n"
            "    Data %lu", action_entry->pkt_new_tos);

        RULE_CTRL_CREATE_NEXT_ACTION_IF_NEED(current_dev_action_p);
        current_dev_action_p->action = bcmFieldActionTosNew;
        current_dev_action_p->param0 = action_entry->pkt_new_tos;

#if RULE_CTRL_REMAP_BY_DSCP_LOOKUP
        /* get ip precedence to cos value then set new-priority action */
        RULE_CTRL_CREATE_NEXT_ACTION_IF_NEED(current_dev_action_p);
        if (FALSE == COS_OM_GetIpPrecedence2CosValueByLport(lport, action_entry->pkt_new_tos, &cos))
        {
            RULE_CTRL_FreeDevActionListMemory(dev_action_head_p);
            return NULL;
        }
        current_dev_action_p->action = bcmFieldActionPrioPktAndIntNew;
        current_dev_action_p->param0 = cos;
#endif /* RULE_CTRL_REMAP_BY_DSCP_LOOKUP */
    }

    if (action_entry->action_bitmap & RULE_TYPE_ACTION_PKT_NEW_DSCP)
    {
#if (RULE_CTRL_REMAP_BY_DSCP_LOOKUP == TRUE)
        UI8_T   cos;
#endif

        LOG("Pkt-New-DSCP\r\n"
            "    Data %lu", action_entry->pkt_new_dscp);

        RULE_CTRL_CREATE_NEXT_ACTION_IF_NEED(current_dev_action_p);

        current_dev_action_p->action = bcmFieldActionGpDscpNew;

        current_dev_action_p->param0 = action_entry->pkt_new_dscp;
#if (RULE_CTRL_REMAP_BY_DSCP_LOOKUP == TRUE)
        /* get ip dscp to cos value then set new-priority action */
        RULE_CTRL_CREATE_NEXT_ACTION_IF_NEED(current_dev_action_p);
        if (FALSE == COS_OM_GetIpDscp2CosValueByLport(lport, action_entry->pkt_new_dscp, &cos))
        {
            RULE_CTRL_FreeDevActionListMemory(dev_action_head_p);
            return NULL;
        }
        current_dev_action_p->action = bcmFieldActionPrioPktAndIntNew;
        current_dev_action_p->param0 = cos;
#endif /* RULE_CTRL_REMAP_BY_DSCP_LOOKUP */
    }

    if (action_entry->action_bitmap & RULE_TYPE_ACTION_GREEN_PKT_NEW_DSCP)
    {
#if (RULE_CTRL_REMAP_BY_DSCP_LOOKUP == TRUE)
        UI8_T   cos;
#endif

        LOG("Green-New-DSCP\r\n"
            "    Data %lu", action_entry->pkt_new_dscp);

        RULE_CTRL_CREATE_NEXT_ACTION_IF_NEED(current_dev_action_p);

        current_dev_action_p->action = bcmFieldActionGpDscpNew;

        current_dev_action_p->param0 = action_entry->green_pkt_new_dscp;
#if (RULE_CTRL_REMAP_BY_DSCP_LOOKUP == TRUE)
        /* get ip dscp to cos value then set new-priority action */
        RULE_CTRL_CREATE_NEXT_ACTION_IF_NEED(current_dev_action_p);
        if (FALSE == COS_OM_GetIpDscp2CosValueByLport(lport, action_entry->green_pkt_new_dscp, &cos))
        {
            RULE_CTRL_FreeDevActionListMemory(dev_action_head_p);
            return NULL;
        }
        current_dev_action_p->action = bcmFieldActionPrioPktAndIntNew;
        current_dev_action_p->param0 = cos;
#endif /* RULE_CTRL_REMAP_BY_DSCP_LOOKUP */
    }

    if (action_entry->action_bitmap & RULE_TYPE_ACTION_DROP)
    {
        LOG("Drop");

        RULE_CTRL_CREATE_NEXT_ACTION_IF_NEED(current_dev_action_p);
        current_dev_action_p->action = bcmFieldActionGpDrop;
    }

    if (action_entry->action_bitmap & RULE_TYPE_ACTION_DROP_PRECEDENCE)
    {
        if (TRUE == is_ingress)
        {
            LOG("Drop-Precedence\r\n"
                "    Data %lu", action_entry->drop_precedence);

            RULE_CTRL_CREATE_NEXT_ACTION_IF_NEED(current_dev_action_p);
            current_dev_action_p->action = bcmFieldActionGpDropPrecedence;
            current_dev_action_p->param0 = BCM_FIELD_COLOR_GREEN;
        }
    }

    if (action_entry->action_bitmap & RULE_TYPE_ACTION_RED_DROP)
    {
        LOG("Red-Drop");

        RULE_CTRL_CREATE_NEXT_ACTION_IF_NEED(current_dev_action_p);
        current_dev_action_p->action = bcmFieldActionRpDrop;
    }

    if (action_entry->action_bitmap & RULE_TYPE_ACTION_RED_DROP_PRECEDENCE)
    {
        if (TRUE == is_ingress)
        {
            LOG("Red-Precedence\r\n"
                "    Data %lu", action_entry->red_drop_precedence);

            RULE_CTRL_CREATE_NEXT_ACTION_IF_NEED(current_dev_action_p);
            current_dev_action_p->action = bcmFieldActionRpDropPrecedence;
            current_dev_action_p->param0 = BCM_FIELD_COLOR_RED;
        }
    }

    if (action_entry->action_bitmap & RULE_TYPE_ACTION_RED_PKT_NEW_DSCP)
    {
        LOG("Red-New-DSCP\r\n"
            "    Data %lu", action_entry->red_pkt_new_dscp);

        RULE_CTRL_CREATE_NEXT_ACTION_IF_NEED(current_dev_action_p);
        current_dev_action_p->action = bcmFieldActionRpDscpNew;
        current_dev_action_p->param0 = action_entry->red_pkt_new_dscp;
    }

    if (action_entry->action_bitmap & RULE_TYPE_ACTION_YELLOW_DROP)
    {
        LOG("Yellow-Drop");

        RULE_CTRL_CREATE_NEXT_ACTION_IF_NEED(current_dev_action_p);
        current_dev_action_p->action = bcmFieldActionYpDrop;
    }

    if (action_entry->action_bitmap & RULE_TYPE_ACTION_YELLOW_DROP_PRECEDENCE)
    {
        if (TRUE == is_ingress)
        {
            LOG("Yellow-Drop-Precedence\r\n"
                "    Data %lu", action_entry->yellow_drop_precedence);

            RULE_CTRL_CREATE_NEXT_ACTION_IF_NEED(current_dev_action_p);
            current_dev_action_p->action = bcmFieldActionYpDropPrecedence;
            current_dev_action_p->param0 = BCM_FIELD_COLOR_YELLOW;
        }
    }

    if (action_entry->action_bitmap & RULE_TYPE_ACTION_YELLOW_PKT_NEW_DSCP)
    {
        LOG("Yellow-New-DSCP\r\n"
            "    Data %lu", action_entry->yellow_pkt_new_dscp);

        RULE_CTRL_CREATE_NEXT_ACTION_IF_NEED(current_dev_action_p);
        current_dev_action_p->action = bcmFieldActionYpDscpNew;
        current_dev_action_p->param0 = action_entry->yellow_pkt_new_dscp;
    }

    return dev_action_head_p;

#undef RULE_CTRL_REMAP_BY_DSCP_LOOKUP
}

/*------------------------------------------------------------------------------
 * Function : RULE_CTRL_FreeDevActionListMemory
 *------------------------------------------------------------------------------
 * Purpose  : free dev_action memory
 * INPUT    : dev_action
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : free RULE_CTRL_Convert_Action2DEV() allocated memory
 *------------------------------------------------------------------------------
 */
static void RULE_CTRL_FreeDevActionListMemory(DEVRM_ActionEntry_T *dev_action)
{
    DEVRM_ActionEntry_T     *action_iter_p, *next_action_p;

    for (action_iter_p = dev_action; NULL != action_iter_p; action_iter_p = next_action_p)
    {
        next_action_p = action_iter_p->next_action;
        L_MM_Free(action_iter_p);
    }
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_IfEntry_Index_To_Interface
 *------------------------------------------------------------------------------
 * PURPOSE  : Converts index of ifEntry to interface object
 * INPUT    : idx - index of ifEntry
 * OUTPUT   : interface_p - interface object
 * RETURN   : RULE_TYPE_OK; error code
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_Priv_IfEntry_Index_To_Interface(
    UI32_T idx,
    RULE_TYPE_INTERFACE_INFO_PTR_T interface_p)
{
    ASSERT(idx < _countof(shmem_data_p->if_table));
    ASSERT(NULL != interface_p);

    if (_countof(shmem_data_p->if_table) <= idx)
    {
        return RULE_TYPE_INVALID_PARAMETER;
    }

    memset(interface_p, 0, sizeof(*interface_p));

    if (idx < RULE_CTRL_TOTAL_NBR_OF_IF_ENTRY_PER_DIRECTION)
    {
        interface_p->direction = RULE_TYPE_INBOUND;
    }
    else
    {
        interface_p->direction = RULE_TYPE_OUTBOUND;
    }

    if (RULE_CTRL_TOTAL_NBR_OF_IF_ENTRY_PER_DIRECTION <= idx)
    {
        idx -= RULE_CTRL_TOTAL_NBR_OF_IF_ENTRY_PER_DIRECTION;
    }

    if (RULE_CTRL_UNIT_1_INDEX == idx)
    {
        interface_p->type = RULE_TYPE_INTERFACE_ALL_UNIT;
    }
    else if (RULE_CTRL_UPORT_1_INDEX <= idx && idx < (RULE_CTRL_UPORT_1_INDEX +
                                                      RULE_CTRL_TOTAL_NBR_OF_UPORT))
    {
        interface_p->type = RULE_TYPE_INTERFACE_UPORT;
        interface_p->uport.unit = STKTPLG_OM_IFINDEX_TO_UNIT((idx - RULE_CTRL_UPORT_1_INDEX + 1));
        interface_p->uport.port = STKTPLG_OM_IFINDEX_TO_PORT((idx - RULE_CTRL_UPORT_1_INDEX + 1));
    }
    else if (RULE_CTRL_TRUNK_PORT_1_INDEX <= idx && idx < (RULE_CTRL_TRUNK_PORT_1_INDEX +
                                                           RULE_CTRL_TOTAL_NBR_OF_TRUNK_PORT))
    {
        interface_p->type = RULE_TYPE_INTERFACE_TRUNK;
        interface_p->trunk_id = idx - RULE_CTRL_TRUNK_PORT_1_INDEX + 1;
    }
    else if (RULE_CTRL_CRAFT_PORT_1_INDEX <= idx && idx < (RULE_CTRL_CRAFT_PORT_1_INDEX +
                                                           RULE_CTRL_TOTAL_NBR_OF_CRAFT_PORT))
    {
        interface_p->type = RULE_TYPE_INTERFACE_CRAFT_PORT;
    }
    else if (RULE_CTRL_CPU_PORT_1_INDEX <= idx && idx < (RULE_CTRL_CPU_PORT_1_INDEX +
                                                         RULE_CTRL_TOTAL_NBR_OF_CPU_PORT))
    {
        interface_p->type = RULE_TYPE_INTERFACE_CPU_PORT;
    }

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Priv_GetIfEntry
 *------------------------------------------------------------------------------
 * PURPOSE  : Get an ifEntry by interface
 * INPUT    : interface_p - interface
 * OUTPUT   : None
 * RETURN   : Pointer of ifEntry
 * NOTES    : None
 *------------------------------------------------------------------------------
 */
static RULE_CTRL_IF_ENTRY_PTR_T
RULE_CTRL_Priv_GetIfEntry(
    const RULE_TYPE_INTERFACE_INFO_T *interface_p)
{
    UI32_T idx = 0xffffffff;

    ASSERT(NULL != interface_p);
    ASSERT(RULE_TYPE_INBOUND == interface_p->direction ||
           RULE_TYPE_OUTBOUND == interface_p->direction);

    switch (interface_p->type)
    {
        case RULE_TYPE_INTERFACE_ALL_UNIT:
        case RULE_TYPE_INTERFACE_UNIT:
            idx = RULE_CTRL_UNIT_1_INDEX;
            break;

        case RULE_TYPE_INTERFACE_UPORT:
            idx = STKTPLG_OM_UPORT_TO_IFINDEX(interface_p->uport.unit,
                                              interface_p->uport.port);
            idx -= SYS_ADPT_ETHER_1_IF_INDEX_NUMBER;
            idx += RULE_CTRL_UPORT_1_INDEX;
            break;

        case RULE_TYPE_INTERFACE_TRUNK:
            idx = STKTPLG_OM_TRUNKID_TO_IFINDEX(interface_p->trunk_id);
            idx -= SYS_ADPT_TRUNK_1_IF_INDEX_NUMBER;
            idx += RULE_CTRL_TRUNK_PORT_1_INDEX;
            break;

        case RULE_TYPE_INTERFACE_CRAFT_PORT:
            idx = RULE_CTRL_CRAFT_PORT_1_INDEX;
            break;

        case RULE_TYPE_INTERFACE_CPU_PORT:
            idx = RULE_CTRL_CPU_PORT_1_INDEX;
            break;

        default:
            ASSERT(0);
            return NULL;
    }

    idx += (RULE_TYPE_OUTBOUND == interface_p->direction) ?
                              RULE_CTRL_TOTAL_NBR_OF_IF_ENTRY_PER_DIRECTION : 0;

    ASSERT(idx < _countof(shmem_data_p->if_table));

    return &shmem_data_p->if_table[idx];
}

RULE_CTRL_RULE_ENTRY_PTR_T
RULE_CTRL_Priv_GetRuleEntryOfRule(
    const RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p)
{
    ASSERT(NULL != rule_inst_p);

    ASSERT(rule_inst_p->mvl_rule_index < _countof(shmem_data_p->rule_table));

    if (_countof(shmem_data_p->rule_table) <= rule_inst_p->mvl_rule_index)
    {
        return NULL;
    }

    return &shmem_data_p->rule_table[rule_inst_p->mvl_rule_index];
}

BOOL_T
RULE_CTRL_Priv_IsRuleInstanceMatchUnitDevice(
    RULE_TYPE_INSTANCE_PTR_T in,
    void *cookie)
{
    if (TRUE == RULE_CTRL_IS_RULE_INSTANCE_TYPE(in->type))
    {
        RULE_TYPE_RULE_INSTANCE_PTR_T rule_inst_p;
        RULE_CTRL_UNIT_DEVICE_PTR_T param_p;

        rule_inst_p = (RULE_TYPE_RULE_INSTANCE_PTR_T)in;
        param_p = (RULE_CTRL_UNIT_DEVICE_PTR_T)cookie;

        if (rule_inst_p->dev_rule_info.unit == param_p->unit &&
            rule_inst_p->dev_rule_info.device == param_p->device_id)
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL_T
RULE_CTRL_Priv_IsClassInstanceMatchId(
    RULE_TYPE_INSTANCE_PTR_T in,
    void *cookie)
{
    if (TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(in->type))
    {
        RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;
        UI32_T *id_p = cookie;

        class_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)in;

        if (class_inst_p->id == *id_p)
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL_T
RULE_CTRL_Priv_IsClassInstanceMatchTypeId(
    RULE_TYPE_INSTANCE_PTR_T in,
    void *cookie)
{
    if (TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(in->type))
    {
        RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;
        RULE_CTRL_INSTANCE_TYPE_ID_PTR_T param_p;

        param_p = (RULE_CTRL_INSTANCE_TYPE_ID_PTR_T)cookie;

        class_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)in;

        if (class_inst_p->super.type == param_p->type &&
            class_inst_p->id == param_p->id)
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL_T
RULE_CTRL_Priv_IsClassInstanceMatchType(
    RULE_TYPE_INSTANCE_PTR_T in,
    void *cookie)
{
    if (TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(in->type))
    {
        RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p;
        RULE_CTRL_INSTANCE_TYPE_ID_PTR_T param_p;

        param_p = (RULE_CTRL_INSTANCE_TYPE_ID_PTR_T)cookie;

        class_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)in;

        if (class_inst_p->super.type == param_p->type)
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL_T
RULE_CTRL_Priv_IsMatchTypeId(
    RULE_TYPE_INSTANCE_PTR_T in,
    void *cookie)
{
    UI32_T id;

    RULE_CTRL_INSTANCE_TYPE_ID_PTR_T param_p;

    param_p = (RULE_CTRL_INSTANCE_TYPE_ID_PTR_T)cookie;

    if (TRUE == RULE_CTRL_IS_CONTAINER_TYPE(in->type))
    {
        id = ((RULE_TYPE_CONTAINER_PTR_T) in)->id;
    }
    else if (TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(in->type))
    {
        id = ((RULE_TYPE_CLASS_INSTANCE_PTR_T) in)->id;
    }
    else if (TRUE == RULE_CTRL_IS_RULE_INSTANCE_TYPE(in->type))
    {
        id = ((RULE_TYPE_RULE_INSTANCE_PTR_T) in)->id;
    }
    else
    {
        ASSERT(0);
    }

    return id == param_p->id ? TRUE : FALSE;
}

BOOL_T
RULE_CTRL_Priv_IsAceInstanceWithId(
    RULE_TYPE_INSTANCE_PTR_T in,
    void *cookie)
{
    if (TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(in->type))
    {
        RULE_TYPE_CLASS_INSTANCE_PTR_T ace_inst_p;
        UI32_T *id_p = (UI32_T *)cookie;

        ace_inst_p = (RULE_TYPE_CLASS_INSTANCE_PTR_T)in;

        if ((RULE_TYPE_INST_ACE == in->type ||
             RULE_TYPE_INST_MF_ACE == in->type) &&
            ace_inst_p->mvl_pkt_type == *id_p)
        {
            return TRUE;
        }
    }

    return FALSE;
}

static UI32_T
RULE_CTRL_Priv_CountOfAceInstance(
    RULE_TYPE_CLASS_INSTANCE_PTR_T class_inst_p,
    UI32_T id)
{
    return RULE_CTRL_IN_Priv_CountIf((RULE_TYPE_INSTANCE_PTR_T)class_inst_p,
                                     RULE_CTRL_Priv_IsAceInstanceWithId, &id);
}

static RULE_TYPE_INSTANCE_PTR_T
RULE_CTRL_Priv_GetFirstChildIf(
    RULE_TYPE_INSTANCE_PTR_T in,
    BOOL_T (*fn)(RULE_TYPE_INSTANCE_PTR_T, void*),
    void *cookie)
{
    ASSERT(NULL != in);
    ASSERT(TRUE == RULE_CTRL_IS_CONTAINER_TYPE(in->type) ||
           TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(in->type));

    if (TRUE == RULE_CTRL_IS_CONTAINER_TYPE(in->type))
    {
        RULE_TYPE_CONTAINER_OBJECT_T obj;
        RULE_TYPE_CONTAINER_ELEMENT_ITERATOR_T iter;

        RULE_CTRL_IN_Priv_ConstructContainerObject((RULE_TYPE_CONTAINER_PTR_T) in, &obj);
        obj.get_element_iterator(&obj, &iter);

        for (iter.first(&iter); NULL != iter.get_instance(&iter); iter.next(&iter))
        {
            if (TRUE == fn(iter.get_instance(&iter), cookie))
            {
                return iter.get_instance(&iter);
            }
        }
    }
    else if(TRUE == RULE_CTRL_IS_CLASS_INSTANCE_TYPE(in->type))
    {
        RULE_TYPE_CLASS_INSTANCE_OBJECT_T obj;
        RULE_TYPE_CLASS_INSTANCE_ELEMENT_ITERATOR_T iter;

        RULE_CTRL_IN_Priv_ConstructClassInstanceObject((RULE_TYPE_CLASS_INSTANCE_PTR_T) in, &obj);
        obj.get_element_iterator(&obj, &iter);

        for (iter.first(&iter); NULL != iter.get_instance(&iter); iter.next(&iter))
        {
            if (TRUE == fn(iter.get_instance(&iter), cookie))
            {
                return iter.get_instance(&iter);
            }
        }
    }

    return NULL;
}

static RULE_TYPE_INSTANCE_PTR_T
RULE_CTRL_Priv_GetNextSiblingIf(
    RULE_TYPE_INSTANCE_PTR_T in,
    BOOL_T (*fn)(RULE_TYPE_INSTANCE_PTR_T, void*),
    void *cookie)
{
    ASSERT(NULL != in);

    if (TRUE == RULE_CTRL_IS_CONTAINER_TYPE(in->links.parent.type))
    {
        RULE_TYPE_CONTAINER_OBJECT_T parent;
        RULE_TYPE_CONTAINER_ELEMENT_ITERATOR_T iter;

        RULE_CTRL_IN_Priv_ConstructContainerObjectFromPointer(in->links.parent, &parent);
        parent.get_element_iterator(&parent, &iter);

        /* This is an inefficiency way to get the iterator for scaning
         * the whole container.
         * iter = iter.indexof(in)
         */
        for (iter.first(&iter); NULL != iter.get_instance(&iter); iter.next(&iter))
        {
            if (in == iter.get_instance(&iter))
            {
                iter.next(&iter);
                break;
            }
        }

        for (; NULL != iter.get_instance(&iter); iter.next(&iter))
        {
            if (TRUE == fn(iter.get_instance(&iter), cookie))
            {
                return iter.get_instance(&iter);
            }
        }
    }
    else
    {
        RULE_TYPE_INSTANCE_PTR_T next;

        next = in;

        while (NULL != (next = RULE_CTRL_IN_Ptr2Instance(next->links.next)))
        {
            if (TRUE == fn(next, cookie))
            {
                return next;
            }
        }
    }

    return NULL;
}

#if (SYS_CPNT_STACKING == TRUE)
/*------------------------------------------------------------------------------
 * Function : RULE_CTRL_ISC_Handler
 *------------------------------------------------------------------------------
 * Purpose  : This function will manipulte all of RULE_CTRL via ISC
 * INPUT    : *key      -- key of ISC
 *            *mref_handle_p  -- transfer data
 * OUTPUT   : None
 * RETURN   : None
 * NOTE     : called by ISC Agent
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_ISC_Handler(ISC_Key_T *key, L_MM_Mref_Handle_T *mref_handle_p)
{
    RULE_CTRL_IscBuf_T *buf_p;
    BOOL_T  ret = FALSE;
    UI32_T  service;

    buf_p = (RULE_CTRL_IscBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &service); /* service is used as dummy here */
    if(buf_p==NULL)
    {
        SYSFUN_Debug_Printf("\r\n%s():L_MM_Mref_GetPdu() fails", __FUNCTION__);
        return FALSE;
    }

    service = buf_p->ServiceID;

    /*
     * Check to abort operation if callback service id(opcode) is more then
     * number of callback service on this drive.
     */
    if (service >= RULE_CTRL_NBR_OF_SERVICE_ID || RULE_CTRL_func_tab[service]==NULL)
    {
        PRINTF("\r\nRULE CTRL: Service ID is invalid!\r\n");
    }
    else
    {
        ret = RULE_CTRL_func_tab[service](key,buf_p);
    }

    L_MM_Mref_Release(&mref_handle_p);

    return ret;
}
#endif /* #if (SYS_CPNT_STACKING == TRUE) */

static BOOL_T
RULE_CTRL_Allocate_Rule(
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T group_id,
    UI32_T fun_type,
    int rule_pri,
    UI32_T *dev_rule_id)
{
#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    RULE_CTRL_IscBuf_T* isc_buf_p;
    L_MM_Mref_Handle_T* mref_handle_p;
    UI32_T              pdu_len;
    UI32_T              rule_id;
#endif

    UI16_T              dst_bmp = 0;
    UI32_T              drv_unit;

    *dev_rule_id = 0;

    if (STKTPLG_POM_IsLocalUnit(unit, port, &drv_unit) == FALSE)
    {
        dst_bmp |= BIT_VALUE(drv_unit - 1);
    }

    {
        RULE_CTRL_ResourceInfo_T *res_info_p;

        res_info_p = RULE_CTRL_GetResourceInfo(unit, device_id, group_id);
        if (res_info_p)
        {
            if (res_info_p->free_rule == 0)
            {
                return FALSE;
            }

            ASSERT(RULE_TYPE_IS_BIT_ON(res_info_p->func_type_bmp, fun_type));
            --res_info_p->free_rule;
        }
    }

#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    if (dst_bmp != 0)
    {
        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(RULE_CTRL_IscBuf_T),
                                              L_MM_USER_ID2(SYS_MODULE_RULE_CTRL, RULE_CTRL_SID_DEVRM_ALLOCATERULE));

        if (NULL == mref_handle_p)
        {
            RULE_CTRL_LOG("L_MM_AllocateTxBuffer failed");
            return FALSE;
        }

        isc_buf_p = (RULE_CTRL_IscBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
        if(isc_buf_p==NULL)
        {
            RULE_CTRL_LOG("L_MM_Mref_GetPdu failed");
            return FALSE;
        }

        isc_buf_p->ServiceID = RULE_CTRL_SID_DEVRM_ALLOCATERULE;
        isc_buf_p->unit = unit;
        isc_buf_p->port = port;
        isc_buf_p->RULECTRLINFO.device_id = device_id;
        isc_buf_p->RULECTRLINFO.group_id = group_id;
        isc_buf_p->RULECTRLINFO.fun_type = fun_type;
        isc_buf_p->RULECTRLINFO.rule_pri = rule_pri;

        if (ISC_RemoteCall((UI8_T)drv_unit,
                           ISC_RULE_CTRL_SID,
                           mref_handle_p,
                           SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                           (UI16_T)sizeof(rule_id),
                           (UI8_T *)&rule_id,
                           RULE_CTRL_TRY_TIMES,
                           RULE_CTRL_TIME_OUT))
        {
            *dev_rule_id = rule_id;

            RULE_CTRL_LOG("Allocate rule id=%lu from unit=%lu device_id=%lu",
                          *dev_rule_id, unit, device_id);

            return TRUE;
        }
        else
        {
            RULE_CTRL_LOG("ISC_RemoteCall(drv_unit=%lu) failed", drv_unit);
            return FALSE;
        }
    }
    else
#endif /* ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE)) */
    {
        if (RULE_CTRL_Local_Allocate_Rule(device_id, group_id, fun_type, rule_pri, dev_rule_id))
        {
            RULE_CTRL_LOG("Allocate rule id=%lu from unit=%lu device_id=%lu, group_id=%lu, fun_type=%lu",
                          *dev_rule_id, unit, device_id, group_id, fun_type);

            return TRUE;
        }
    }
    return FALSE;
}

static BOOL_T
RULE_CTRL_Set_Rule(
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T group_id,
    UI32_T dev_rule_id,
    DEVRM_AceEntry_T *ace_entry,
    DEVRM_MeterEntry_T *meter_entry,
    DEVRM_ActionEntry_T *action_entry,
    RULE_TYPE_COUNTER_ENABLE_T counter_enable)
{
#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    RULE_CTRL_IscBuf_T* isc_buf_p;
    L_MM_Mref_Handle_T* mref_handle_p;
    UI32_T              pdu_len;
    UI16_T              isc_ret_val;
#endif
    UI16_T              dst_bmp = 0;
    UI32_T              drv_unit;

    if (STKTPLG_POM_IsLocalUnit(unit, port, &drv_unit) == FALSE)
    {
        dst_bmp |= BIT_VALUE(drv_unit - 1);
    }

#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    if (dst_bmp != 0)
    {
        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(RULE_CTRL_IscBuf_T), L_MM_USER_ID2(SYS_MODULE_RULE_CTRL, RULE_CTRL_SID_DEVRM_SETRULE));
        isc_buf_p = (RULE_CTRL_IscBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
        if(isc_buf_p==NULL)
        {
            SYSFUN_Debug_Printf("\r\n%s():L_MM_Mref_GetPdu() fails", __FUNCTION__);
            return FALSE;
        }

        isc_buf_p->ServiceID = RULE_CTRL_SID_DEVRM_SETRULE;
        isc_buf_p->unit = unit;
        isc_buf_p->port = port;
        isc_buf_p->RULECTRLINFO.device_id = device_id;
        isc_buf_p->RULECTRLINFO.group_id = group_id;
        isc_buf_p->RULECTRLINFO.dev_rule_id = dev_rule_id;
        isc_buf_p->RULECTRLINFO.counter_enable = counter_enable;

        memcpy (&(isc_buf_p->RULECTRLINFO.ace_entry), ace_entry, sizeof(DEVRM_AceEntry_T));
        if (NULL == meter_entry)
        {
            isc_buf_p->RULECTRLINFO.is_meter_exist = FALSE;
        }
        else
        {
            isc_buf_p->RULECTRLINFO.is_meter_exist = TRUE;
            memcpy (&isc_buf_p->RULECTRLINFO.meter_entry, meter_entry, sizeof(DEVRM_MeterEntry_T));
        }

        if (NULL == action_entry)
        {
            isc_buf_p->RULECTRLINFO.action_nbr = 0;
        }
        else
        {
            if (FALSE == RULE_CTRL_ConvertDev2IscAction(action_entry, isc_buf_p))
            {
                L_MM_Mref_Release(&mref_handle_p);
                return FALSE;
            }

        }

        isc_ret_val=ISC_SendMcastReliable(dst_bmp, ISC_RULE_CTRL_SID,
                                          mref_handle_p, SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                          RULE_CTRL_TRY_TIMES, RULE_CTRL_TIME_OUT, FALSE);
        if(isc_ret_val!=0)
        {
            SYSFUN_Debug_Printf("\r\n%s():ISC_SendMcastReliable() fails(ret_val=0x%x)", __FUNCTION__, isc_ret_val);
            return FALSE;   /* can't control remote unit */
        }
    }
    else
#endif /* (SWDRV_FIX_STANDALONE_TYPE == FALSE && SYS_CPNT_STACKING == TRUE) */
    {
        return RULE_CTRL_Local_Set_Rule(device_id, group_id, dev_rule_id,
                    ace_entry, meter_entry, action_entry, counter_enable);

    }
    return TRUE;
}

static BOOL_T
RULE_CTRL_Destroy_Rule(
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T group_id,
    UI32_T fun_type,
    UI32_T dev_rule_id)
{
#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    RULE_CTRL_IscBuf_T* isc_buf_p;
    L_MM_Mref_Handle_T* mref_handle_p;
    UI32_T              pdu_len;
    UI16_T              isc_ret_val;
#endif
    UI16_T              dst_bmp = 0;
    UI32_T              drv_unit;

    if (STKTPLG_POM_IsLocalUnit(unit, port, &drv_unit) == FALSE)
    {
        dst_bmp |= BIT_VALUE(drv_unit - 1);
    }

    {
        RULE_CTRL_ResourceInfo_T *res_info_p;

        res_info_p = RULE_CTRL_GetResourceInfo(unit, device_id, group_id);
        if (res_info_p)
        {
            if  (res_info_p->total_rule <= res_info_p->free_rule)
            {
                ASSERT(0);
                return FALSE;
            }

            ASSERT(RULE_TYPE_IS_BIT_ON(res_info_p->func_type_bmp, fun_type));
            ++res_info_p->free_rule;
        }
    }

#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))

    if (dst_bmp != 0)
    {
        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(RULE_CTRL_IscBuf_T), L_MM_USER_ID2(SYS_MODULE_RULE_CTRL, RULE_CTRL_SID_DEVRM_DESTROYRULE));
        isc_buf_p = (RULE_CTRL_IscBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
        if(isc_buf_p==NULL)
        {
            SYSFUN_Debug_Printf("\r\n%s():L_MM_Mref_GetPdu() fails", __FUNCTION__);
            return FALSE;
        }

        isc_buf_p->ServiceID = RULE_CTRL_SID_DEVRM_DESTROYRULE;
        isc_buf_p->unit = unit;
        isc_buf_p->port = port;
        isc_buf_p->RULECTRLINFO.device_id = device_id;
        isc_buf_p->RULECTRLINFO.group_id  = group_id;
        isc_buf_p->RULECTRLINFO.fun_type  = fun_type;
        isc_buf_p->RULECTRLINFO.dev_rule_id = dev_rule_id;

        isc_ret_val=ISC_SendMcastReliable(dst_bmp, ISC_RULE_CTRL_SID,
                                          mref_handle_p, SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                          RULE_CTRL_TRY_TIMES, RULE_CTRL_TIME_OUT, FALSE);
        if(isc_ret_val!=0)
        {
            SYSFUN_Debug_Printf("\r\n%s():ISC_SendMcastReliable() fails(ret_val=0x%x)", __FUNCTION__, isc_ret_val);
            return FALSE;   /* can't control remote unit */
        }
    }
    else
    {
#endif
        return RULE_CTRL_Local_Destroy_Rule(device_id, group_id, fun_type, dev_rule_id);
#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    }
#endif
    return TRUE;
}



static BOOL_T
RULE_CTRL_Create_Meter(
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T dev_rule_id,
    DEVRM_MeterEntry_T *meter_entry)
{
#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    RULE_CTRL_IscBuf_T* isc_buf_p;
    L_MM_Mref_Handle_T* mref_handle_p;
    UI32_T              pdu_len;
    UI16_T              isc_ret_val;
#endif
    UI16_T              dst_bmp = 0;
    UI32_T               drv_unit;

    if (STKTPLG_POM_IsLocalUnit(unit, port, &drv_unit) == FALSE)
    {
        dst_bmp |= BIT_VALUE(drv_unit - 1);
    }

#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    if (dst_bmp != 0)
    {
        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(RULE_CTRL_IscBuf_T), L_MM_USER_ID2(SYS_MODULE_RULE_CTRL, RULE_CTRL_SID_DEVRM_CREATEMETER));
        isc_buf_p = (RULE_CTRL_IscBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
        if(isc_buf_p==NULL)
        {
            SYSFUN_Debug_Printf("\r\n%s():L_MM_Mref_GetPdu() fails", __FUNCTION__);
            return FALSE;
        }
        isc_buf_p->ServiceID = RULE_CTRL_SID_DEVRM_CREATEMETER;
        isc_buf_p->unit = unit;
        isc_buf_p->port = port;
        isc_buf_p->RULECTRLINFO.device_id = device_id;
        isc_buf_p->RULECTRLINFO.dev_rule_id = dev_rule_id;
        if (NULL == meter_entry)
        {
            isc_buf_p->RULECTRLINFO.is_meter_exist = FALSE;
        }
        else
        {
            isc_buf_p->RULECTRLINFO.is_meter_exist = TRUE;
            memcpy (&isc_buf_p->RULECTRLINFO.meter_entry, meter_entry, sizeof(DEVRM_MeterEntry_T));
        }

        isc_ret_val=ISC_SendMcastReliable(dst_bmp, ISC_RULE_CTRL_SID,
                                          mref_handle_p, SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                          RULE_CTRL_TRY_TIMES, RULE_CTRL_TIME_OUT, FALSE);
        if(isc_ret_val!=0)
        {
            SYSFUN_Debug_Printf("\r\n%s():ISC_SendMcastReliable() fails(ret_val=0x%x)", __FUNCTION__, isc_ret_val);
            return FALSE;   /* can't control remote unit */
        }
    }
    else
#endif /* ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE)) */
    {
        return RULE_CTRL_Local_Create_Meter(device_id, dev_rule_id, meter_entry);
    }
    return TRUE;
}


static BOOL_T
RULE_CTRL_Update_Meter(
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T dev_rule_id,
    DEVRM_MeterEntry_T *meter_entry)
{
#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    RULE_CTRL_IscBuf_T* isc_buf_p;
    L_MM_Mref_Handle_T* mref_handle_p;
    UI32_T              pdu_len;
    UI16_T              isc_ret_val;
#endif
    UI16_T              dst_bmp = 0;
    UI32_T              drv_unit;

    if (STKTPLG_POM_IsLocalUnit(unit, port, &drv_unit) == FALSE)
    {
        dst_bmp |= BIT_VALUE(drv_unit - 1);
    }

#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    if (dst_bmp != 0)
    {
        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(RULE_CTRL_IscBuf_T), L_MM_USER_ID2(SYS_MODULE_RULE_CTRL, RULE_CTRL_SID_DEVRM_UPDATEMETER));
        isc_buf_p = (RULE_CTRL_IscBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
        if(isc_buf_p==NULL)
        {
            SYSFUN_Debug_Printf("\r\n%s():L_MM_Mref_GetPdu() fails", __FUNCTION__);
            return FALSE;
        }

        isc_buf_p->ServiceID = RULE_CTRL_SID_DEVRM_UPDATEMETER;
        isc_buf_p->unit = unit;
        isc_buf_p->port = port;
        isc_buf_p->RULECTRLINFO.device_id = device_id;
        isc_buf_p->RULECTRLINFO.dev_rule_id = dev_rule_id;
        if (NULL == meter_entry)
        {
            isc_buf_p->RULECTRLINFO.is_meter_exist = FALSE;
        }
        else
        {
            isc_buf_p->RULECTRLINFO.is_meter_exist = TRUE;
            memcpy (&isc_buf_p->RULECTRLINFO.meter_entry, meter_entry, sizeof(DEVRM_MeterEntry_T));
        }

        isc_ret_val=ISC_SendMcastReliable(dst_bmp, ISC_RULE_CTRL_SID,
                                          mref_handle_p, SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                          RULE_CTRL_TRY_TIMES, RULE_CTRL_TIME_OUT, FALSE);
        if(isc_ret_val!=0)
        {
            SYSFUN_Debug_Printf("\r\n%s():ISC_SendMcastReliable() fails(ret_val=0x%x)", __FUNCTION__, isc_ret_val);
            return FALSE;   /* can't control remote unit */
        }
    }
    else
#endif  /* ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE)) */
    {
        return RULE_CTRL_Local_Update_Meter(device_id, dev_rule_id, meter_entry);
    }

    return TRUE;
}

/*src*/
static BOOL_T
RULE_CTRL_Share_Meter(
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T src_dev_rule_id,
    UI32_T dev_rule_id)
{
#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    RULE_CTRL_IscBuf_T* isc_buf_p;
    L_MM_Mref_Handle_T* mref_handle_p;
    UI32_T              pdu_len;
    UI16_T              isc_ret_val;
#endif
    UI16_T              dst_bmp = 0;
    UI32_T              drv_unit;

    if (STKTPLG_POM_IsLocalUnit(unit, port, &drv_unit) == FALSE)
    {
        dst_bmp |= BIT_VALUE(drv_unit - 1);
    }

#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    if (dst_bmp != 0)
    {
        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(RULE_CTRL_IscBuf_T), L_MM_USER_ID2(SYS_MODULE_RULE_CTRL, RULE_CTRL_SID_DEVRM_SHAREMETER));
        isc_buf_p = (RULE_CTRL_IscBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
        if(isc_buf_p==NULL)
        {
            SYSFUN_Debug_Printf("\r\n%s():L_MM_Mref_GetPdu() fails", __FUNCTION__);
            return FALSE;
        }

        isc_buf_p->ServiceID = RULE_CTRL_SID_DEVRM_SHAREMETER;
        isc_buf_p->unit = unit;
        isc_buf_p->port = port;
        isc_buf_p->RULECTRLINFO.device_id = device_id;
        isc_buf_p->RULECTRLINFO.dev_rule_id = dev_rule_id;
        isc_buf_p->RULECTRLINFO.src_dev_rule_id = src_dev_rule_id;

        isc_ret_val=ISC_SendMcastReliable(dst_bmp, ISC_RULE_CTRL_SID,
                                          mref_handle_p, SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                          RULE_CTRL_TRY_TIMES, RULE_CTRL_TIME_OUT, FALSE);
        if(isc_ret_val!=0)
        {
            SYSFUN_Debug_Printf("\r\n%s():ISC_SendMcastReliable() fails(ret_val=0x%x)", __FUNCTION__, isc_ret_val);
            return FALSE;   /* can't control remote unit */
        }
    }
    else
    {
#endif
        return RULE_CTRL_Local_Share_Meter(device_id, src_dev_rule_id, dev_rule_id);
#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    }
#endif
    return TRUE;
}

static BOOL_T
RULE_CTRL_Destroy_Meter(
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T dev_rule_id)
{
#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    RULE_CTRL_IscBuf_T* isc_buf_p;
    L_MM_Mref_Handle_T* mref_handle_p;
    UI32_T              pdu_len;
    UI16_T              isc_ret_val;
#endif
    UI16_T              dst_bmp = 0;
    UI32_T              drv_unit;

    if (STKTPLG_POM_IsLocalUnit(unit, port, &drv_unit) == FALSE)
    {
        dst_bmp |= BIT_VALUE(drv_unit - 1);
    }

#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    if (dst_bmp != 0)
    {
        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(RULE_CTRL_IscBuf_T), L_MM_USER_ID2(SYS_MODULE_RULE_CTRL, RULE_CTRL_SID_DEVRM_DESTROYMETER));
        isc_buf_p = (RULE_CTRL_IscBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
        if(isc_buf_p==NULL)
        {
            SYSFUN_Debug_Printf("\r\n%s():L_MM_Mref_GetPdu() fails", __FUNCTION__);
            return FALSE;
        }

        isc_buf_p->ServiceID = RULE_CTRL_SID_DEVRM_DESTROYMETER;
        isc_buf_p->unit = unit;
        isc_buf_p->port = port;
        isc_buf_p->RULECTRLINFO.device_id = device_id;
        isc_buf_p->RULECTRLINFO.dev_rule_id = dev_rule_id;

        isc_ret_val=ISC_SendMcastReliable(dst_bmp, ISC_RULE_CTRL_SID,
                                          mref_handle_p, SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                          RULE_CTRL_TRY_TIMES, RULE_CTRL_TIME_OUT, FALSE);
        if(isc_ret_val!=0)
        {
            SYSFUN_Debug_Printf("\r\n%s():ISC_SendMcastReliable() fails(ret_val=0x%x)", __FUNCTION__, isc_ret_val);
            return FALSE;   /* can't control remote unit */
        }
    }
    else
    {
#endif
        return RULE_CTRL_Local_Destroy_Meter(device_id, dev_rule_id);
#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    }
#endif
    return TRUE;
}

static BOOL_T
RULE_CTRL_Set_Action(
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T rule_id,
    DEVRM_ActionEntry_T *action_entry)
{
#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    RULE_CTRL_IscBuf_T* isc_buf_p;
    L_MM_Mref_Handle_T* mref_handle_p;
    UI32_T              pdu_len;
    UI16_T              isc_ret_val;
#endif
    UI32_T               drv_unit;
    UI16_T              dst_bmp = 0;

    if (NULL == action_entry)
        return FALSE;

    if (STKTPLG_POM_IsLocalUnit(unit, port, &drv_unit) == FALSE)
    {
        dst_bmp |= BIT_VALUE(drv_unit - 1);
    }

#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    if (dst_bmp != 0)
    {
        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(RULE_CTRL_IscBuf_T), L_MM_USER_ID2(SYS_MODULE_RULE_CTRL, RULE_CTRL_SID_DEVRM_SETACTION));
        isc_buf_p = (RULE_CTRL_IscBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
        if(isc_buf_p==NULL)
        {
            SYSFUN_Debug_Printf("\r\n%s():L_MM_Mref_GetPdu() fails", __FUNCTION__);
            return FALSE;
        }

        isc_buf_p->ServiceID = RULE_CTRL_SID_DEVRM_SETACTION;
        isc_buf_p->unit = unit;
        isc_buf_p->port = port;
        isc_buf_p->RULECTRLINFO.device_id = device_id;
        isc_buf_p->RULECTRLINFO.dev_rule_id = rule_id;

        if (FALSE == RULE_CTRL_ConvertDev2IscAction(action_entry, isc_buf_p))
        {
            L_MM_Mref_Release(&mref_handle_p);
            return FALSE;
        }

        isc_ret_val=ISC_SendMcastReliable(dst_bmp, ISC_RULE_CTRL_SID,
                                          mref_handle_p, SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                          RULE_CTRL_TRY_TIMES, RULE_CTRL_TIME_OUT, FALSE);
        if(isc_ret_val!=0)
        {
            SYSFUN_Debug_Printf("\r\n%s():ISC_SendMcastReliable() fails(ret_val=0x%x)", __FUNCTION__, isc_ret_val);
            return FALSE;   /* can't control remote unit */
        }
    }
    else
#endif /* ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE)) */
    {
        return RULE_CTRL_Local_Set_Action(device_id, rule_id, action_entry);
    }

    return TRUE;
}


static BOOL_T
RULE_CTRL_Update_Rule(
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T dev_rule_id,
    DEVRM_AceEntry_T *ace_entry,
    DEVRM_MeterEntry_T *meter_entry,
    DEVRM_ActionEntry_T *action_entry)
{
#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    RULE_CTRL_IscBuf_T* isc_buf_p;
    L_MM_Mref_Handle_T* mref_handle_p;
    UI32_T              pdu_len;
    UI16_T              isc_ret_val;
#endif
    UI32_T              drv_unit;
    UI16_T              dst_bmp = 0;

    if (STKTPLG_POM_IsLocalUnit(unit, port, &drv_unit) == FALSE)
    {
        dst_bmp |= BIT_VALUE(drv_unit - 1);
    }

#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    if (dst_bmp != 0)
    {
        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(RULE_CTRL_IscBuf_T), L_MM_USER_ID2(SYS_MODULE_RULE_CTRL, RULE_CTRL_SID_DEVRM_UPDATERULE));
        isc_buf_p = (RULE_CTRL_IscBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
        if(isc_buf_p==NULL)
        {
            SYSFUN_Debug_Printf("\r\n%s():L_MM_Mref_GetPdu() fails", __FUNCTION__);
            return FALSE;
        }

        isc_buf_p->ServiceID = RULE_CTRL_SID_DEVRM_UPDATERULE;
        isc_buf_p->unit = unit;
        isc_buf_p->port = port;
        isc_buf_p->RULECTRLINFO.device_id = device_id;
        isc_buf_p->RULECTRLINFO.dev_rule_id = dev_rule_id;
        memcpy (&(isc_buf_p->RULECTRLINFO.ace_entry), ace_entry, sizeof(DEVRM_AceEntry_T));
        if (NULL == meter_entry)
        {
            isc_buf_p->RULECTRLINFO.is_meter_exist = FALSE;
        }
        else
        {
            isc_buf_p->RULECTRLINFO.is_meter_exist = TRUE;
            memcpy (&isc_buf_p->RULECTRLINFO.meter_entry, meter_entry, sizeof(DEVRM_MeterEntry_T));
        }

        if (NULL == action_entry)
        {
            isc_buf_p->RULECTRLINFO.action_nbr = 0;
        }
        else
        {
            if (FALSE == RULE_CTRL_ConvertDev2IscAction(action_entry, isc_buf_p))
            {
                L_MM_Mref_Release(&mref_handle_p);
                return FALSE;
            }
        }

        isc_ret_val=ISC_SendMcastReliable(dst_bmp, ISC_RULE_CTRL_SID,
                                          mref_handle_p, SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                          RULE_CTRL_TRY_TIMES, RULE_CTRL_TIME_OUT, FALSE);
        if(isc_ret_val!=0)
        {
            SYSFUN_Debug_Printf("\r\n%s():ISC_SendMcastReliable() fails(ret_val=0x%x)", __FUNCTION__, isc_ret_val);
            return FALSE;   /* can't control remote unit */
        }
    }
    else
#endif /* SWDRV_FIX_STANDALONE_TYPE == FALSE && SYS_CPNT_STACKING == TRUE */
    {
        return RULE_CTRL_Local_Update_Rule(device_id, dev_rule_id, ace_entry, meter_entry, action_entry);
    }

    return TRUE;
}

static BOOL_T RULE_CTRL_GetDevInfo(
    UI32_T unit,
    DEVRM_DevInfo_T *dev_info_p)
{
#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    RULE_CTRL_IscBuf_T* isc_buf_p;
    L_MM_Mref_Handle_T* mref_handle_p;
    UI32_T              pdu_len;
#endif

    UI16_T              dst_bmp = 0;
    UI32_T              drv_unit;

    memset(dev_info_p, 0, sizeof(*dev_info_p));

    if (STKTPLG_POM_IsLocalUnit(unit, 1, &drv_unit) == FALSE)
    {
        dst_bmp |= BIT_VALUE(drv_unit - 1);
    }

#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))

    if (dst_bmp != 0)
    {
        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(RULE_CTRL_IscBuf_T),
                                              L_MM_USER_ID2(SYS_MODULE_RULE_CTRL, RULE_CTRL_SID_GET_DEV_INFO));

        if (NULL == mref_handle_p)
        {
            RULE_CTRL_LOG("L_MM_AllocateTxBuffer failed");
            return FALSE;
        }

        isc_buf_p = (RULE_CTRL_IscBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
        if(isc_buf_p==NULL)
        {
            RULE_CTRL_LOG("L_MM_Mref_GetPdu failed");
            return FALSE;
        }

        isc_buf_p->ServiceID = RULE_CTRL_SID_GET_DEV_INFO;
        isc_buf_p->unit = unit;

        if (ISC_RemoteCall((UI8_T)drv_unit,
                           ISC_RULE_CTRL_SID,
                           mref_handle_p,
                           SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                           (UI16_T)sizeof(*dev_info_p),
                           (UI8_T *)dev_info_p,
                           RULE_CTRL_TRY_TIMES,
                           RULE_CTRL_TIME_OUT))
        {
            RULE_CTRL_LOG("Get Device Info, unit=%lu num_of_chips=%lu",
                          unit, dev_info_p->num_of_chips);

            return TRUE;
        }
        else
        {
            RULE_CTRL_LOG("ISC_RemoteCall(drv_unit=%lu) failed", drv_unit);
            return FALSE;
        }
    }
    else
    {
#endif
        if (RULE_CTRL_Local_GetDevInfo(dev_info_p))
        {
            RULE_CTRL_LOG("Get Device Info, unit=%lu num_of_chips=%lu",
                          unit, dev_info_p->num_of_chips);

            return TRUE;
        }
#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    }
#endif
    return FALSE;
}

static BOOL_T
RULE_CTRL_GetRuleCounter(
    UI32_T unit,
    UI32_T device_id,
    UI32_T dev_rule_id,
    RULE_TYPE_CounterRec_T *counter_p)
{
#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    UI32_T              drv_unit;

    if (STKTPLG_POM_IsLocalUnit(unit, 1, &drv_unit) == FALSE)
    {
        RULE_CTRL_IscBuf_T* isc_buf_p;
        RULE_CTRL_IscReplyBuf_T isc_reply;
        L_MM_Mref_Handle_T* mref_handle_p;
        UI32_T              pdu_len;

        RULE_CTRL_LOG("Remote unit=%lu, device_id=%lu, dev_rule_id=%lu",
                       unit, device_id, dev_rule_id);

        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(RULE_CTRL_IscBuf_T),
                                              L_MM_USER_ID2(SYS_MODULE_RULE_CTRL,
                                                            RULE_CTRL_SID_GET_RULE_COUNTER));

        if (NULL == mref_handle_p)
        {
            RULE_CTRL_LOG("L_MM_AllocateTxBuffer failed");
            return FALSE;
        }

        isc_buf_p = (RULE_CTRL_IscBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
        if(isc_buf_p==NULL)
        {
            RULE_CTRL_LOG("L_MM_Mref_GetPdu failed");
            return FALSE;
        }

        isc_buf_p->ServiceID = RULE_CTRL_SID_GET_RULE_COUNTER;
        isc_buf_p->unit = unit;
        isc_buf_p->RULECTRLINFO.device_id = device_id;
        isc_buf_p->RULECTRLINFO.dev_rule_id = dev_rule_id;

        if (!ISC_RemoteCall((UI8_T)drv_unit,
                            ISC_RULE_CTRL_SID,
                            mref_handle_p,
                            SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                            (UI16_T)sizeof(isc_reply),
                            (UI8_T *)&isc_reply,
                            RULE_CTRL_TRY_TIMES,
                            RULE_CTRL_TIME_OUT))
        {
            return TRUE;
        }

        if (TRUE == isc_reply.return_value.b_result)
        {
            memcpy(counter_p, &isc_reply.data.counter, sizeof(*counter_p));
            return TRUE;
        }
    }
    else
#endif /* ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE)) */
    {
        RULE_CTRL_LOG("Local device_id=%lu, dev_rule_id=%lu",
                       device_id, dev_rule_id);

        if (RULE_CTRL_Local_GetRuleCounter(device_id, dev_rule_id, counter_p))
        {
            return TRUE;
        }
    }

    return FALSE;
}

static BOOL_T
RULE_CTRL_ClearRuleCounter(
    UI32_T unit,
    UI32_T device_id,
    UI32_T dev_rule_id)
{
#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    UI32_T              drv_unit;

    if (STKTPLG_POM_IsLocalUnit(unit, 1, &drv_unit) == FALSE)
    {
        RULE_CTRL_IscBuf_T* isc_buf_p;
        L_MM_Mref_Handle_T* mref_handle_p;
        UI32_T              pdu_len;
        UI16_T              isc_ret_val;
        UI16_T              dst_bmp = 0;

        RULE_CTRL_LOG("Remote unit=%lu, device_id=%lu, dev_rule_id=%lu",
                       unit, device_id, dev_rule_id);

        dst_bmp |= BIT_VALUE(drv_unit - 1);

        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(RULE_CTRL_IscBuf_T),
                                              L_MM_USER_ID2(SYS_MODULE_RULE_CTRL,
                                                            RULE_CTRL_SID_CLEAR_RULE_COUNTER));

        if (NULL == mref_handle_p)
        {
            RULE_CTRL_LOG("L_MM_AllocateTxBuffer failed");
            return FALSE;
        }

        isc_buf_p = (RULE_CTRL_IscBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
        if(isc_buf_p==NULL)
        {
            RULE_CTRL_LOG("L_MM_Mref_GetPdu failed");
            return FALSE;
        }

        isc_buf_p->ServiceID = RULE_CTRL_SID_CLEAR_RULE_COUNTER;
        isc_buf_p->unit = unit;
        isc_buf_p->RULECTRLINFO.device_id = device_id;
        isc_buf_p->RULECTRLINFO.dev_rule_id = dev_rule_id;

        isc_ret_val=ISC_SendMcastReliable(dst_bmp,
                                          ISC_RULE_CTRL_SID,
                                          mref_handle_p,
                                          SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                          RULE_CTRL_TRY_TIMES,
                                          RULE_CTRL_TIME_OUT,
                                          FALSE);

        if(isc_ret_val!=0)
        {
            SYSFUN_Debug_Printf("\r\n%s():ISC_SendMcastReliable() fails(ret_val=0x%x)", __FUNCTION__, isc_ret_val);
            return FALSE;   /* can't control remote unit */
        }
    }
    else
#endif /* ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE)) */
    {
        RULE_CTRL_LOG("Local device_id=%lu, dev_rule_id=%lu",
                       device_id, dev_rule_id);

        if (RULE_CTRL_Local_ClearRuleCounter(device_id, dev_rule_id))
        {
            return TRUE;
        }
    }

    return FALSE;
}

/* FIXEME: remove  RULE_CTRL_temp_Allocate_Rule & RULE_CTRL_temp_Destroy_Rule
 *   Old style: (stacking handle by RULE_CTRL_TrapPacket2Cpu, master on is incorrect)
 *       create : RULE_CTRL_temp_Destroy_Rule + RULE_CTRL_temp_Allocate_Rule + DEVRM_PMGR_SetRule
 *       destroy: DEVRM_PMGR_SetRule
 *   New style:
 *       _rule_ctrl_set_rule or RULE_CTRL_SetSharedPortRule
 */
static BOOL_T RULE_CTRL_temp_Allocate_Rule(
    UI32_T device_id,
    UI32_T group_id,
    UI32_T fun_type,
    int rule_pri,
    UI32_T *dev_rule_id)
{
    RULE_CTRL_ResourceInfo_T *res_info_p;
    UI32_T unit = 1; /* not support stack */

    if (FALSE == RULE_CTRL_RequestRuleByQuota(unit, device_id, fun_type,
                     RULE_CTRL_REQUEST_RESOURCE_ALLOCATE, 1))
    {
        LOG("RULE_CTRL_RequestRuleByQuota fail!");
        return FALSE;
    }

    res_info_p = RULE_CTRL_GetResourceInfo(1, device_id, group_id);
    if (res_info_p)
    {
        ASSERT(RULE_TYPE_IS_BIT_ON(res_info_p->func_type_bmp, fun_type));
        ASSERT(0 < res_info_p->free_rule);
        --res_info_p->free_rule;
    }

    return DEVRM_PMGR_AllocateRule(device_id, group_id, fun_type, rule_pri, dev_rule_id);
}

static BOOL_T RULE_CTRL_temp_Destroy_Rule(
    UI32_T device_id,
    UI32_T group_id,
    UI32_T fun_type,
    UI32_T dev_rule_id)
{
    RULE_CTRL_ResourceInfo_T *res_info_p;
    UI32_T unit = 1;  /* not support stack */

    if (FALSE == RULE_CTRL_RequestRuleByQuota(unit, device_id, fun_type,
                                              RULE_CTRL_REQUEST_RESOURCE_FREE, 1))
    {
        LOG("RULE_CTRL_RequestRuleByQuota fail!");
        return FALSE;
    }

    res_info_p = RULE_CTRL_GetResourceInfo(unit, device_id, group_id);
    if (res_info_p)
    {
        ASSERT(RULE_TYPE_IS_BIT_ON(res_info_p->func_type_bmp, fun_type));
        ASSERT(res_info_p->free_rule < res_info_p->total_rule);
        ++res_info_p->free_rule;
    }

    return DEVRM_PMGR_DestroyRule(device_id, fun_type, dev_rule_id);
}

static BOOL_T RULE_CTRL_Local_Allocate_Rule(
    UI32_T device_id,
    UI32_T group_id,
    UI32_T fun_type,
    int rule_pri,
    UI32_T *dev_rule_id)
{
    return DEVRM_PMGR_AllocateRule(device_id, group_id, fun_type, rule_pri, dev_rule_id);
}

static BOOL_T
RULE_CTRL_Local_Set_Rule(
    UI32_T device_id,
    UI32_T group_id,
    UI32_T dev_rule_id,
    DEVRM_AceEntry_T *ace_entry,
    DEVRM_MeterEntry_T *meter_entry,
    DEVRM_ActionEntry_T *action_entry,
    RULE_TYPE_COUNTER_ENABLE_T counter_enable)
{
    BOOL_T with_counter = (counter_enable == RULE_TYPE_COUNTER_ENABLE) ? TRUE : FALSE;

    RULE_CTRL_CHECK_THEN_SET_NO_ACTION(action_entry);

    return DEVRM_PMGR_SetRule(device_id, group_id, dev_rule_id, ace_entry,
                              meter_entry, action_entry, with_counter);
}

static BOOL_T RULE_CTRL_Local_Destroy_Rule(
    UI32_T device_id,
    UI32_T group_id,
    UI32_T fun_type,
    UI32_T dev_rule_id)
{
    return DEVRM_PMGR_DestroyRule(device_id, fun_type, dev_rule_id);
}

static BOOL_T RULE_CTRL_Local_Create_Meter(UI32_T device_id,UI32_T dev_rule_id, DEVRM_MeterEntry_T *meter_entry)
{
    return DEVRM_PMGR_CreateMeter(device_id, dev_rule_id, meter_entry, TRUE);
}

static BOOL_T RULE_CTRL_Local_Update_Meter(UI32_T device_id,UI32_T dev_rule_id, DEVRM_MeterEntry_T *meter_entry)
{
    return DEVRM_PMGR_UpdateMeter(device_id, dev_rule_id, meter_entry);
}

static BOOL_T RULE_CTRL_Local_Share_Meter(UI32_T device_id, UI32_T src_dev_rule_id, UI32_T dev_rule_id)
{
    return DEVRM_PMGR_ShareMeter(device_id, src_dev_rule_id, dev_rule_id);
}


static BOOL_T RULE_CTRL_Local_Destroy_Meter(UI32_T device_id, UI32_T dev_rule_id)
{
    return DEVRM_PMGR_DestroyMeter(device_id, dev_rule_id);
}

static BOOL_T RULE_CTRL_Local_Set_Action(UI32_T device_id, UI32_T rule_id, DEVRM_ActionEntry_T *action_entry)
{
    RULE_CTRL_CHECK_THEN_SET_NO_ACTION(action_entry);

    return DEVRM_PMGR_SetAction(device_id, rule_id, action_entry);
}

static BOOL_T RULE_CTRL_Local_Destroy_Action(UI32_T unit, UI32_T action_id)
{
    if (TRUE == (DEVRM_PMGR_DestroyAction(unit, action_id)))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

static BOOL_T RULE_CTRL_Local_Update_Rule(UI32_T device_id, UI32_T dev_rule_id, DEVRM_AceEntry_T *ace_entry, DEVRM_MeterEntry_T *meter_entry, DEVRM_ActionEntry_T *action_entry)
{
    RULE_CTRL_CHECK_THEN_SET_NO_ACTION(action_entry);

    return DEVRM_PMGR_UpdateRule(device_id, dev_rule_id, ace_entry, meter_entry, action_entry);
}

static BOOL_T
RULE_CTRL_Local_GetDevInfo(
    DEVRM_DevInfo_T *dev_info_p)
{
    memset(dev_info_p, 0, sizeof(*dev_info_p));

    return DEVRM_PMGR_GetDeviceInfo(dev_info_p);
}

static BOOL_T
RULE_CTRL_Local_GetRuleCounter(
    UI32_T device_id,
    UI32_T dev_rule_id,
    RULE_TYPE_CounterRec_T *counter_p)
{
    memset(counter_p, 0, sizeof(*counter_p));
    return DEVRM_PMGR_GetCounter(device_id, dev_rule_id, &counter_p->total_packets);
}

static BOOL_T
RULE_CTRL_Local_ClearRuleCounter(
    UI32_T device_id,
    UI32_T dev_rule_id)
{
    return DEVRM_PMGR_ClearCounter(device_id, dev_rule_id);
}

#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
static BOOL_T RULE_CTRL_Slave_GetDevInfo(ISC_Key_T *key, RULE_CTRL_IscBuf_T *ptr)
{
    L_MM_Mref_Handle_T  *mref_handle_p;
    DEVRM_DevInfo_T *isc_buf_p;
    UI32_T              pdu_len;

     mref_handle_p = L_MM_AllocateTxBuffer(sizeof(*isc_buf_p),
                                           L_MM_USER_ID2(SYS_MODULE_RULE_CTRL, RULE_CTRL_SID_GET_DEV_INFO));
    if (NULL == mref_handle_p)
    {
        SYSFUN_Debug_Printf("\r\n%s():L_MM_AllocateTxBuffer() fails", __FUNCTION__);
        return FALSE;
    }

    isc_buf_p = (DEVRM_DevInfo_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
    if (NULL == isc_buf_p)
    {
        SYSFUN_Debug_Printf("\r\n%s():L_MM_Mref_GetPdu() fails", __FUNCTION__);
        L_MM_Mref_Release(&mref_handle_p);
        return FALSE;
    }

    if (TRUE == RULE_CTRL_Local_GetDevInfo(isc_buf_p))
    {
        if (ISC_RemoteReply(mref_handle_p, key))
        {
            return TRUE;
        }
    }
    else
    {
        L_MM_Mref_Release(&mref_handle_p);
    }

    /* return FALSE, ISC will auto reply NAK
     */
    return FALSE;
}

static BOOL_T RULE_CTRL_Slave_Allocate_Rule(ISC_Key_T *key, RULE_CTRL_IscBuf_T *ptr)
{
    L_MM_Mref_Handle_T  *mref_handle_p;
    UI32_T              *isc_buf_p;
    UI32_T              pdu_len;

     mref_handle_p = L_MM_AllocateTxBuffer(sizeof(UI32_T),
                                           L_MM_USER_ID2(SYS_MODULE_RULE_CTRL, RULE_CTRL_SID_DEVRM_SETALLOCATEDRULE));
    if (NULL == mref_handle_p)
    {
        SYSFUN_Debug_Printf("\r\n%s():L_MM_AllocateTxBuffer() fails", __FUNCTION__);
        return FALSE;
    }

    isc_buf_p = (UI32_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
    if (NULL == isc_buf_p)
    {
        SYSFUN_Debug_Printf("\r\n%s():L_MM_Mref_GetPdu() fails", __FUNCTION__);
        L_MM_Mref_Release(&mref_handle_p);
        return FALSE;
    }

    if (TRUE == RULE_CTRL_Local_Allocate_Rule(ptr->RULECTRLINFO.device_id,
                                              ptr->RULECTRLINFO.group_id,
                                              ptr->RULECTRLINFO.fun_type,
                                              ptr->RULECTRLINFO.rule_pri,
                                              isc_buf_p))
    {
        if (ISC_RemoteReply( mref_handle_p, key))
        {
            return TRUE;
        }
    }
    else
    {
        L_MM_Mref_Release(&mref_handle_p);
    }

    /* return FALSE, ISC will auto reply NAK
     */
    return FALSE;
}

static BOOL_T RULE_CTRL_Slave_Set_Rule(ISC_Key_T *key, RULE_CTRL_IscBuf_T *buf_p)
{
    BOOL_T status = TRUE;
    DEVRM_ActionEntry_T *dev_action_p = NULL;
    DEVRM_MeterEntry_T  *dev_meter_p = NULL;

    if (TRUE == buf_p->RULECTRLINFO.is_meter_exist)
        dev_meter_p = &(buf_p->RULECTRLINFO.meter_entry);

    if (0 < buf_p->RULECTRLINFO.action_nbr)
    {
        if (FALSE == RULE_CTRL_ConvertIsc2DevAction(buf_p))
            return FALSE;

        dev_action_p = buf_p->RULECTRLINFO.action_entry;
    }

    if(FALSE == RULE_CTRL_Local_Set_Rule(buf_p->RULECTRLINFO.device_id,
                                         buf_p->RULECTRLINFO.group_id,
                                         buf_p->RULECTRLINFO.dev_rule_id,
                                         &(buf_p->RULECTRLINFO.ace_entry),
                                         dev_meter_p,
                                         dev_action_p,
                                         buf_p->RULECTRLINFO.counter_enable))
    {
        status = FALSE;
        SYSFUN_Debug_Printf("\r\b%s():RULE_CTRL_Slave_Set_Rule fails", __FUNCTION__);
    }

    return status;
}


static BOOL_T RULE_CTRL_Slave_Destroy_Rule(ISC_Key_T *key, RULE_CTRL_IscBuf_T *ptr)
{
    BOOL_T status = TRUE;
    if(FALSE == RULE_CTRL_Local_Destroy_Rule(
            ptr->RULECTRLINFO.device_id,
            ptr->RULECTRLINFO.group_id,
            ptr->RULECTRLINFO.fun_type,
            ptr->RULECTRLINFO.dev_rule_id))
    {
        status = FALSE;
        SYSFUN_Debug_Printf("\r\b%s():RULE_CTRL_Local_Destroy_Rule fails", __FUNCTION__);
    }

    return status;
}

static BOOL_T RULE_CTRL_Slave_Create_Meter(ISC_Key_T *key, RULE_CTRL_IscBuf_T *ptr)
{
    BOOL_T status = TRUE;

    if(FALSE == RULE_CTRL_Local_Create_Meter(ptr->RULECTRLINFO.device_id, ptr->RULECTRLINFO.dev_rule_id, &(ptr->RULECTRLINFO.meter_entry)))
    {
        status = FALSE;
        SYSFUN_Debug_Printf("\r\b%s():RULE_CTRL_Local_Create_Meter fails", __FUNCTION__);
    }

    return status;
}

static BOOL_T RULE_CTRL_Slave_Update_Meter(ISC_Key_T *key, RULE_CTRL_IscBuf_T *ptr)
{
    BOOL_T status = TRUE;

    if(FALSE == RULE_CTRL_Local_Update_Meter(ptr->RULECTRLINFO.device_id, ptr->RULECTRLINFO.dev_rule_id, &(ptr->RULECTRLINFO.meter_entry)))
    {
        status = FALSE;
        SYSFUN_Debug_Printf("\r\b%s():RULE_CTRL_Local_Update_Meter fails", __FUNCTION__);
    }

    return status;
}


static BOOL_T RULE_CTRL_Slave_Share_Meter(ISC_Key_T *key, RULE_CTRL_IscBuf_T *ptr)
{
    BOOL_T status = TRUE;

    if(FALSE == RULE_CTRL_Local_Share_Meter(ptr->RULECTRLINFO.device_id, ptr->RULECTRLINFO.src_dev_rule_id, ptr->RULECTRLINFO.dev_rule_id))
    {
        status = FALSE;
        SYSFUN_Debug_Printf("\r\b%s():RULE_CTRL_Local_Share_Meter fails", __FUNCTION__);
    }

    return status;
}



static BOOL_T RULE_CTRL_Slave_Destroy_Meter(ISC_Key_T *key, RULE_CTRL_IscBuf_T *ptr)
{
    BOOL_T status = TRUE;

    if(FALSE == RULE_CTRL_Local_Destroy_Meter(ptr->RULECTRLINFO.device_id, ptr->RULECTRLINFO.dev_rule_id))
    {
        status = FALSE;
        SYSFUN_Debug_Printf("\r\b%s():RULE_CTRL_Local_Destroy_Meter fails", __FUNCTION__);
    }

    return status;
}


static BOOL_T RULE_CTRL_Slave_Set_Action(ISC_Key_T *key, RULE_CTRL_IscBuf_T *ptr)
{
    BOOL_T status = TRUE;

    if (FALSE == RULE_CTRL_ConvertIsc2DevAction(ptr))
    {
        SYSFUN_Debug_Printf("\r\b%s():RULE_CTRL_ConvertIsc2DevAction fails", __FUNCTION__);
        status = FALSE;
    }

    if(FALSE == RULE_CTRL_Local_Set_Action(ptr->RULECTRLINFO.device_id, ptr->RULECTRLINFO.dev_rule_id, ptr->RULECTRLINFO.action_entry))
    {
        status = FALSE;
        SYSFUN_Debug_Printf("\r\b%s():RULE_CTRL_Local_Set_Action fails", __FUNCTION__);
    }

    return status;
}

static BOOL_T RULE_CTRL_Slave_Destroy_Action(ISC_Key_T *key, RULE_CTRL_IscBuf_T *ptr)
{
    BOOL_T status = TRUE;

    if(FALSE == RULE_CTRL_Local_Destroy_Action(ptr->unit, ptr->RULECTRLINFO.action_id))
    {
        status = FALSE;
        SYSFUN_Debug_Printf("\r\b%s():RULE_CTRL_Local_Destroy_Action fails", __FUNCTION__);
    }

    return status;
}

static BOOL_T RULE_CTRL_Slave_Update_Rule(ISC_Key_T *key, RULE_CTRL_IscBuf_T *ptr)
{
    DEVRM_ActionEntry_T *dev_action_p = NULL;
    DEVRM_MeterEntry_T  *dev_meter_p = NULL;
    BOOL_T               status = TRUE;

    if (TRUE == ptr->RULECTRLINFO.is_meter_exist)
        dev_meter_p = &(ptr->RULECTRLINFO.meter_entry);

    if (0 < ptr->RULECTRLINFO.action_nbr)
    {
        if (FALSE == RULE_CTRL_ConvertIsc2DevAction(ptr))
        {
            SYSFUN_Debug_Printf("\r\b%s():RULE_CTRL_ConvertIsc2DevAction fails", __FUNCTION__);
            return FALSE;
        }

        dev_action_p = ptr->RULECTRLINFO.action_entry;
    }

    if(FALSE == RULE_CTRL_Local_Update_Rule(ptr->RULECTRLINFO.device_id, ptr->RULECTRLINFO.dev_rule_id,
                    &(ptr->RULECTRLINFO.ace_entry), dev_meter_p, dev_action_p))
    {
        status = FALSE;
        SYSFUN_Debug_Printf("\r\b%s():RULE_CTRL_Local_Update_Rule fails", __FUNCTION__);
    }

    return status;
}

static BOOL_T RULE_CTRL_Slave_GetRuleCounter(ISC_Key_T *key, RULE_CTRL_IscBuf_T *ptr)
{
    UI32_T                   pdu_len;
    L_MM_Mref_Handle_T      *mref_handle_p;
    RULE_CTRL_IscReplyBuf_T *isc_reply_p;

    mref_handle_p = L_MM_AllocateTxBuffer(sizeof(RULE_CTRL_IscReplyBuf_T),
                                          L_MM_USER_ID2(SYS_MODULE_RULE_CTRL, RULE_CTRL_SID_GET_RULE_COUNTER));

    if (NULL == mref_handle_p)
    {
        SYSFUN_Debug_Printf("\r\n%s():L_MM_AllocateTxBuffer() fails", __FUNCTION__);
        return FALSE;
    }

    isc_reply_p = (RULE_CTRL_IscReplyBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
    if (isc_reply_p == NULL)
    {
        SYSFUN_Debug_Printf("\r\n%s():L_MM_Mref_GetPdu() fails", __FUNCTION__);
        return FALSE;
    }

    isc_reply_p->return_value.b_result = RULE_CTRL_Local_GetRuleCounter(ptr->RULECTRLINFO.device_id ,
                                                                        ptr->RULECTRLINFO.dev_rule_id,
                                                                        &isc_reply_p->data.counter);

    if (TRUE == isc_reply_p->return_value.b_result)
    {
        if (ISC_RemoteReply(mref_handle_p, key))
        {
            return TRUE;
        }
    }
    else
    {
        L_MM_Mref_Release(&mref_handle_p);
    }

    /* return FALSE, ISC will auto reply NAK
     */
    return FALSE;
}

static BOOL_T RULE_CTRL_Slave_ClearRuleCounter(ISC_Key_T *key, RULE_CTRL_IscBuf_T *ptr)
{
    BOOL_T status = TRUE;

    status = RULE_CTRL_Local_ClearRuleCounter(ptr->RULECTRLINFO.device_id,
                                              ptr->RULECTRLINFO.dev_rule_id);

    if(FALSE == status)
    {
        SYSFUN_Debug_Printf("\r\b%s():RULE_CTRL_Local_ClearCounter fails", __FUNCTION__);
    }

    return status;
}
#endif /* #if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE)) */

static BOOL_T RULE_CTRL_Master_Set_Allocated_Rule(ISC_Key_T *key, RULE_CTRL_IscBuf_T *ptr)
{
    BOOL_T status = TRUE;
    UI32_T debug_flag = RULE_OM_GetDebugFlag();

    if (RULE_CTRL_IS_DEBUG_ERROR_ON(debug_flag))
    {
        LOG("Enter RULE_CTRL_Master_Set_Allocated_Rule\r\n"
            "    dev_rule_id = %lu, unit = %d, tick = %lu",
            ptr->RULECTRLINFO.dev_rule_id,
            key->unit,
            SYSFUN_GetSysTick());
    }

    if (SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK < key->unit)
        return FALSE;/* device_id is zero-based */

    if (SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT <= ptr->RULECTRLINFO.device_id)
        return FALSE;/* device_id is zero-based */

    if (0 == ptr->RULECTRLINFO.dev_rule_id)
        return FALSE;

    shmem_data_p->allocated_rule[key->unit][ptr->RULECTRLINFO.device_id].dev_rule_id = ptr->RULECTRLINFO.dev_rule_id;

    LOG("Leave RULE_CTRL_Master_Set_Allocated_Rule");

    return status;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Set_Group_Qualify_Set
 *------------------------------------------------------------------------------
 * PURPOSE:  ISC function for set qualify set of group
 * INPUT:    unit       - unit
 *           device_id  - device_id
 *           group      - group
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_Set_Group_Qualify_Set(
    DEVRM_GroupEntry_T *group_p)
{
    UI32_T              my_unit;

#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    UI32_T              drv_unit;
    UI16_T              dst_bmp;
#endif /* #if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE)) */

    STKTPLG_POM_GetMyUnitID(&my_unit);

#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    dst_bmp = 0;
    drv_unit = 0;
    while (TRUE == STKTPLG_POM_GetNextDriverUnit(&drv_unit))
    {
        if (drv_unit != my_unit)
        {
            dst_bmp |= BIT_VALUE(drv_unit - 1);
        }
    }

    if (dst_bmp != 0)
    {
        RULE_CTRL_IscBuf_T* isc_buf_p;
        L_MM_Mref_Handle_T* mref_handle_p;
        UI32_T              pdu_len;

        UI16_T              isc_ret_val;

        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(RULE_CTRL_IscBuf_T),
                                L_MM_USER_ID2(SYS_MODULE_RULE_CTRL,
                                              RULE_CTRL_SID_SET_GROUP_QUALIFY_SET));

        if (NULL == mref_handle_p)
        {
            RULE_CTRL_LOG("L_MM_AllocateTxBuffer failed");
            return FALSE;
        }

        isc_buf_p = (RULE_CTRL_IscBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
        if(isc_buf_p==NULL)
        {
            RULE_CTRL_LOG("L_MM_Mref_GetPdu failed");
            return FALSE;
        }

        isc_buf_p->ServiceID = RULE_CTRL_SID_SET_GROUP_QUALIFY_SET;
        memcpy(&isc_buf_p->RULECTRLINFO.group_entry, group_p, sizeof(isc_buf_p->RULECTRLINFO.group_entry));

        isc_ret_val = ISC_SendMcastReliable(dst_bmp, ISC_RULE_CTRL_SID,
                                            mref_handle_p, SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                            RULE_CTRL_TRY_TIMES, RULE_CTRL_TIME_OUT, FALSE);
        if (isc_ret_val != 0)
        {
            SYSFUN_Debug_Printf("\r\n%s():ISC_SendMcastReliable() fails(ret_val=0x%x)", __FUNCTION__, isc_ret_val);
            return FALSE;
        }
    }
#endif /* #if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE)) */

    if (FALSE == RULE_CTRL_Local_Set_Group_Qualify_Set(group_p))
    {
        RULE_CTRL_LOG("Set group qualify set, unit=%lu", my_unit);

        return FALSE;
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Local_Set_Group_Qualify_Set
 *------------------------------------------------------------------------------
 * PURPOSE:  ISC function for set qualify set of group on local side
 * INPUT:    device_id  - device ID
 *           group      - group
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_Local_Set_Group_Qualify_Set(
    DEVRM_GroupEntry_T *group_p)
{
    UI32_T soc_ndev;
    UI32_T device_id;
    BOOL_T result;

    soc_ndev = DEVRM_PMGR_GetNumberOfChips();

    for (device_id = 0; device_id < soc_ndev; ++device_id)
    {
        result = DEVRM_PMGR_SetGroupQualifySet(device_id, group_p);
        if (FALSE == result)
        {
            RULE_CTRL_LOG("set group qset failed, devId=%lu, grpId=%lu",
                          device_id, group_p->group_id);
            return FALSE;
        }
    }

    return TRUE;
}

#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Slave_Set_Group_Qualify_Set
 *------------------------------------------------------------------------------
 * PURPOSE:  Callback function for ISC function to set the qualify set of group
 * INPUT:    key        - ISC key
 *           ptr        - payload
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_Slave_Set_Group_Qualify_Set(
    ISC_Key_T *key,
    RULE_CTRL_IscBuf_T *ptr)
{
    return RULE_CTRL_Local_Set_Group_Qualify_Set(&ptr->RULECTRLINFO.group_entry);
}
#endif /* #if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE)) */

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Set_Group_Priority
 *------------------------------------------------------------------------------
 * PURPOSE:  ISC function for set priority of group
 * INPUT:    unit       - unit
 *           device_id  - device ID
 *           group_id   - group ID
 *           priority   - priority value
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_Set_Group_Priority(
    UI32_T group_id,
    int priority)
{
    UI32_T              my_unit;

#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    UI32_T              drv_unit;
    UI16_T              dst_bmp;
#endif /* #if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE)) */

    STKTPLG_POM_GetMyUnitID(&my_unit);

#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
    dst_bmp = 0;
    drv_unit = 0;
    while (TRUE == STKTPLG_POM_GetNextDriverUnit(&drv_unit))
    {
        if (drv_unit != my_unit)
        {
            dst_bmp |= BIT_VALUE(drv_unit - 1);
        }
    }

    if (dst_bmp != 0)
    {
        RULE_CTRL_IscBuf_T* isc_buf_p;
        L_MM_Mref_Handle_T* mref_handle_p;
        UI32_T              pdu_len;

        UI16_T              isc_ret_val;

        mref_handle_p = L_MM_AllocateTxBuffer(sizeof(RULE_CTRL_IscBuf_T),
                                              L_MM_USER_ID2(SYS_MODULE_RULE_CTRL,
                                                            RULE_CTRL_SID_SET_GROUP_PRIORITY));

        if (NULL == mref_handle_p)
        {
            RULE_CTRL_LOG("L_MM_AllocateTxBuffer failed");
            return FALSE;
        }

        isc_buf_p = (RULE_CTRL_IscBuf_T*)L_MM_Mref_GetPdu(mref_handle_p, &pdu_len);
        if(isc_buf_p==NULL)
        {
            RULE_CTRL_LOG("L_MM_Mref_GetPdu failed");
            return FALSE;
        }

        //#######################
        isc_buf_p->ServiceID = RULE_CTRL_SID_SET_GROUP_PRIORITY;
        isc_buf_p->RULECTRLINFO.group_id = group_id;
        isc_buf_p->RULECTRLINFO.rule_pri = priority;
        //#######################

        isc_ret_val = ISC_SendMcastReliable(dst_bmp, ISC_RULE_CTRL_SID,
                                            mref_handle_p, SYS_DFLT_STK_MGMT_PACKET_TO_CPU_PRIORITY,
                                            RULE_CTRL_TRY_TIMES, RULE_CTRL_TIME_OUT, FALSE);
        if (isc_ret_val != 0)
        {
            SYSFUN_Debug_Printf("\r\n%s():ISC_SendMcastReliable() fails(ret_val=0x%x)", __FUNCTION__, isc_ret_val);
            return FALSE;
        }
    }
#endif /* #if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE)) */

    //#######################
    if (FALSE == RULE_CTRL_Local_Set_Group_Priority(group_id, priority))
    {
        RULE_CTRL_LOG("Set group qualify set, unit=%lu", my_unit);

        return FALSE;
    }
    //#######################

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Local_Set_Group_Priority
 *------------------------------------------------------------------------------
 * PURPOSE:  ISC function for set priority of group on local side
 * INPUT:    device_id  - device ID
 *           group_id   - group ID
 *           priority   - priority value
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_Local_Set_Group_Priority(
    UI32_T group_id,
    int priority)
{
    UI32_T soc_ndev;
    UI32_T device_id;
    BOOL_T result;

    soc_ndev = DEVRM_PMGR_GetNumberOfChips();

    for (device_id = 0; device_id < soc_ndev; ++device_id)
    {
        result = DEVRM_PMGR_SetGroupPriority(device_id, group_id, priority);
        if (FALSE == result)
        {
            RULE_CTRL_LOG("set group priority failed, devId=%lu, grpId=%lu, prio=%d",
                          device_id, group_id, priority);
            return FALSE;
        }
    }

    return TRUE;
}

#if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE))
/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_Slave_Set_Group_Priority
 *------------------------------------------------------------------------------
 * PURPOSE:  Callback function for ISC function to set the group priority
 * INPUT:    key        - ISC key
 *           ptr        - payload
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T
RULE_CTRL_Slave_Set_Group_Priority(
    ISC_Key_T *key,
    RULE_CTRL_IscBuf_T *ptr)
{
    return RULE_CTRL_Local_Set_Group_Priority(ptr->RULECTRLINFO.group_id,
                                              ptr->RULECTRLINFO.rule_pri);
}
#endif /* #if ((SWDRV_FIX_STANDALONE_TYPE == FALSE) && (SYS_CPNT_STACKING == TRUE)) */

#if (SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT == TRUE)
static BOOL_T
RULE_CTRL_Nil_Allocate_Rule(
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T group_id,
    UI32_T fun_type,
    int rule_pri,
    UI32_T *dev_rule_id)
{
    static UI32_T s_dev_rle_id = 0;

    *dev_rule_id = ++s_dev_rle_id;
    return TRUE;
}

static BOOL_T
RULE_CTRL_Nil_Destroy_Rule(
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T group_id,
    UI32_T fun_type,
    UI32_T dev_rule_id)
{
    return TRUE;
}

static BOOL_T
RULE_CTRL_Nil_Set_Rule(
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T group_id,
    UI32_T dev_rule_id,
    DEVRM_AceEntry_T *ace_entry,
    DEVRM_MeterEntry_T *meter_entry,
    DEVRM_ActionEntry_T *action_entry)
{
    return TRUE;
}

static BOOL_T
RULE_CTRL_Nil_Update_Rule(
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T dev_rule_id,
    DEVRM_AceEntry_T *ace_entry,
    DEVRM_MeterEntry_T *meter_entry,
    DEVRM_ActionEntry_T *action_entry)
{
    return TRUE;
}

static BOOL_T
RULE_CTRL_Nil_Create_Meter(
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T dev_rule_id,
    DEVRM_MeterEntry_T *meter_entry)
{
    return TRUE;
}

static BOOL_T
RULE_CTRL_Nil_Destroy_Meter(
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T dev_rule_id)
{
    return TRUE;
}

static BOOL_T
RULE_CTRL_Nil_Share_Meter(
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T src_dev_rule_id,
    UI32_T dev_rule_id)
{
    return TRUE;
}

static BOOL_T
RULE_CTRL_Nil_Update_Meter(
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T dev_rule_id,
    DEVRM_MeterEntry_T *meter_entry)
{
    return TRUE;
}

static BOOL_T
RULE_CTRL_Nil_Set_Action(
    UI32_T unit,
    UI32_T port,
    UI32_T device_id,
    UI32_T rule_id,
    DEVRM_ActionEntry_T *action_entry)
{
    return TRUE;
}

static BOOL_T
RULE_CTRL_Nil_Set_Group_Qualify_Set(
    DEVRM_GroupEntry_T *group_p)
{
    return TRUE;
}

static BOOL_T
RULE_CTRL_Nil_Set_Group_Priority(
    UI32_T group_id,
    int priority)
{
    return TRUE;
}
#endif /* SYS_CPNT_ACL_DYNAMIC_SELECTOR_ASSIGNMENT */

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_GetTCAMUtilization
 *------------------------------------------------------------------------------
 * PURPOSE  : get tcam utilization
 * INPUT    : None
 * OUTPUT   : tcam_util_p
 * RETURN   : TRUE/FALSE.
 * NOTE     : None
 *------------------------------------------------------------------------------*/
BOOL_T RULE_CTRL_GetTCAMUtilization(RULE_TYPE_TCAMUtilization_T *tcam_util_p)
{
    UI32_T device_id;
    UI32_T group_id;
    RULE_CTRL_ResourceInfo_T *res_info;
    UI32_T used;

    memset(tcam_util_p, 0, sizeof(RULE_TYPE_TCAMUtilization_T));

    RULE_CTRL_EnterCriticalSection();

    for (device_id = 0; device_id < SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT; device_id++)
    {
        for (group_id = 0; group_id < SYS_ADPT_FP_MAX_NBR_OF_GROUP_PER_CHIP; group_id++)
        {
            res_info = RULE_CTRL_GetResourceInfo(1, device_id, group_id);
            if (NULL == res_info)
                continue;

            tcam_util_p->pce_total += res_info->total_rule;
            used = res_info->total_rule - res_info->free_rule;
            tcam_util_p->pce_used += used;

            if (RULE_CTRL_IS_USER_RULE(res_info->func_type))
            {
                tcam_util_p->pce_used_by_user += used;
                tcam_util_p->pce_free += res_info->free_rule;
            }
            else
            {
                tcam_util_p->pce_used_by_system += used;
            }
        }
    }

    tcam_util_p->pce_utility_rate = (tcam_util_p->pce_used * 100) / (float)tcam_util_p->pce_total;

    RULE_CTRL_LeaveCriticalSection();

    return TRUE;
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_GetTcamEntry
 *------------------------------------------------------------------------------
 * PURPOSE  : Get tcam entry
 * INPUT    : tcam_entry_p->unit
 *            tcam_entry_p->device_id
 *            tcam_entry_p->pool_id
 * OUTPUT   : tcam_util_p
 * RETURN   : OK/FAIL
 * NOTE     : none
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_GetTcamEntry(
    RULE_TYPE_TCAM_ENTRY_T *tcam_entry_p)
{
    UI32_T unit, device_id, group_id;
    RULE_CTRL_ResourceInfo_T *res_info;

    if (NULL == tcam_entry_p)
    {
        ASSERT(0);
        return RULE_TYPE_INVALID_PARAMETER;
    }

    unit = tcam_entry_p->unit;
    device_id = tcam_entry_p->device_id;
    group_id = tcam_entry_p->pool_id;

    RULE_CTRL_EnterCriticalSection();

    res_info = RULE_CTRL_GetResourceInfo(unit, device_id, group_id);
    if (NULL == res_info)
    {
        LOG("Get resource info fail");
        return RULE_TYPE_FAIL;
    }

    RULE_CTRL_GetTcamPoolCapabilityBitMap(group_id, &tcam_entry_p->cap_bitmap);

#define IS_USER_TCAM_CAPABILITY(cap) \
    RULE_CTRL_IS_BIT_ON(tcam_entry_p->cap_bitmap.bits, cap) ||

    if (RULE_CTRL_USER_TCAM_CAPABILITY_LIST(IS_USER_TCAM_CAPABILITY) 0)
    {
        tcam_entry_p->total = res_info->total_rule;
        tcam_entry_p->free = res_info->free_rule;
        tcam_entry_p->used =  res_info->total_rule - res_info->free_rule;
    }
    else
    {
        tcam_entry_p->total = res_info->total_rule;
        tcam_entry_p->free = 0;
        tcam_entry_p->used = res_info->total_rule;
    }

    RULE_CTRL_LeaveCriticalSection();

    return RULE_TYPE_OK;

#undef IS_USER_TCAM_CAPABILITY
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_GetNextTcamEntry
 *------------------------------------------------------------------------------
 * PURPOSE  : Get next tcam entry
 * INPUT    : tcam_entry_p->unit
 *            tcam_entry_p->device_id
 *            tcam_entry_p->pool_id
 * OUTPUT   : tcam_util_p
 * RETURN   : OK/FAIL
 * NOTE     : For get first entry,
 *            use index with tcam_entry_p->unit = 0
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_GetNextTcamEntry(
    RULE_TYPE_TCAM_ENTRY_T *tcam_entry_p)
{
    UI32_T total_device;
    UI32_T total_pool = FP_CONFIG_NumberOfGroup();

    UI32_T unit, device_id, pool_id;

    RULE_TYPE_RETURN_TYPE_T result;

    LOG("unit:%lu, device: %lu, pool %lu",
        tcam_entry_p->unit, tcam_entry_p->device_id, tcam_entry_p->pool_id);

    if (NULL == tcam_entry_p)
    {
        ASSERT(0);
        return RULE_TYPE_FAIL;
    }

    /* Initial the input index to get next entry
     */
    if (tcam_entry_p->unit == 0)
    {
        unit = STKTPLG_POM_GetNextUnit(&unit);
        device_id = 0;
        pool_id = 0;
    }
    else
    {
        unit = tcam_entry_p->unit;

        if (tcam_entry_p->device_id == RULE_TYPE_UNDEF_DEVICE_ID)
        {
            device_id = 0;
            pool_id = 0;
        }
        else
        {
            device_id = tcam_entry_p->device_id;
            pool_id = (tcam_entry_p->pool_id == RULE_TYPE_UNDEF_POOL_ID)
                      ? 0 : tcam_entry_p->pool_id + 1;
        }
    }

    for (; unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; ++unit)
    {
        if (TRUE != STKTPLG_OM_UnitExist(unit))
        {
            device_id = 0;
            pool_id = 0;
            continue;
        }

        total_device = shmem_data_p->dev_info[unit-1].num_of_chips;

        for (; device_id < total_device; ++device_id)
        {
            for (; pool_id < total_pool; ++pool_id)
            {
                tcam_entry_p->unit = unit;
                tcam_entry_p->device_id = device_id;
                tcam_entry_p->pool_id = pool_id;

                result = RULE_CTRL_GetTcamEntry(tcam_entry_p);
                ASSERT(result == RULE_TYPE_OK);

                return result;
            }
            pool_id = 0;
        }

        device_id = 0;
    }

    return RULE_TYPE_FAIL;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_GetSupportedTcamCapabilityBitMap
 *------------------------------------------------------------------------------
 * PURPOSE  : Gets TCAM all supporting capability
 * INPUT    :
 * OUTPUT   : bit_map_p
 * RETURN   : Error code.
 * NOTE     :
 *------------------------------------------------------------------------------
 */
RULE_TYPE_RETURN_TYPE_T
RULE_CTRL_GetSupportedTcamCapabilityBitMap(
    RULE_TYPE_TCAM_CAP_BITMAP_T *bit_map_p)
{
    RULE_TYPE_TCAM_Capability_T function_type_to_tcam_cap[] =
    {
#define RULE_TYPE_FUNCTION_TYPE_CAP_MAPING(name, string, tcam_cap) tcam_cap,
        RULE_TYPE_FUNCTION_TYPE_LIST(RULE_TYPE_FUNCTION_TYPE_CAP_MAPING)
#undef RULE_TYPE_FUNCTION_TYPE_CAP_MAPING
    };

    UI32_T idx;

    ASSERT(bit_map_p != NULL);

    memset(bit_map_p, 0, sizeof(*bit_map_p));

    for (idx = 0; idx < FP_CONFIG_NumberOfFunctionType(); idx++)
    {
        FP_CONFIG_FunctionInfo_T    *fun_info_p = FP_CONFIG_GetFunctionInfo(idx);
        RULE_TYPE_TCAM_Capability_T tcam_cap;

        if(NULL == fun_info_p)
        {
            continue;
        }

        tcam_cap = function_type_to_tcam_cap[fun_info_p->function_type];

        if (tcam_cap != RULE_TYPE_TCAM_CAP_RESERVED)
        {
            RULE_CTRL_SET_BIT_ON(bit_map_p->bits, tcam_cap);
        }
    }

    return RULE_TYPE_OK;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_InitParam
 *------------------------------------------------------------------------------
 * PURPOSE:  This function is used to set a global rule(the rule will be set
 *           for all devices).
 * INPUT:    param_p    - param
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_InitParam(
    RULE_CTRL_PARAM_PTR param_p)
{
    memset(param_p, 0, sizeof(*param_p));

    param_p->func_type  = RULE_TYPE_FUNCTION_TYPE_MAX;
    param_p->unit       = RULE_CTRL_INVALID;
    param_p->port       = RULE_CTRL_INVALID;

    param_p->query.unit = RULE_CTRL_INVALID;
    param_p->query.port = RULE_CTRL_INVALID;
    param_p->query.device_id= RULE_CTRL_INVALID;
    param_p->query.group_id = RULE_CTRL_INVALID;
    param_p->query.rule_id  = RULE_CTRL_INVALID;

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_MakeParamTag
 *------------------------------------------------------------------------------
 * PURPOSE:  Set name of param
 * INPUT:    param_p    - param
 *           str1       - tag 1
 *           str2       - tag 2
 *           str3       - tag 3
 *           str4       - tag 4
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_MakeParamTag(
    RULE_CTRL_PARAM_PTR param_p,
    char *str1,
    char *str2,
    char *str3,
    char *str4)
{
    UI32_T  i;

    if (NULL == param_p)
    {
        return FALSE;
    }

    memset(&param_p->name, 0, sizeof(param_p->name));

    i = 0;
    if (str1)
    {
        strncpy(param_p->name.tag[i++], str1, RULE_CTRL_PARAM_MAX_TAG_NAME_STR_LEN);
    }

    if (str2)
    {
        strncpy(param_p->name.tag[i++], str2, RULE_CTRL_PARAM_MAX_TAG_NAME_STR_LEN);
    }

    if (str3)
    {
        strncpy(param_p->name.tag[i++], str3, RULE_CTRL_PARAM_MAX_TAG_NAME_STR_LEN);
    }

    if (str4)
    {
        strncpy(param_p->name.tag[i++], str4, RULE_CTRL_PARAM_MAX_TAG_NAME_STR_LEN);
    }

    return TRUE;
}

static char * RULE_CTRL_GetLastTag(
    RULE_CTRL_PARAM_PTR param_p)
{
    int i;

    for (i = _countof(param_p->name.tag)-1; 0 <= i ; i--)
    {
        if ('\0' != param_p->name.tag[i][0])
        {
            return param_p->name.tag[i];
        }
    }

    return NULL;
}

static BOOL_T RULE_CTRL_IsTagMatch(
    RULE_CTRL_PARAM_PTR param_p,
    char *tag)
{
    UI32_T  i;

    if (NULL == param_p)
    {
        return FALSE;
    }

    for (i = 0; i < RULE_CTRL_PARAM_MAX_TAG; i++)
    {
        if (0 == strcmp(param_p->name.tag[i], tag))
        {
            return TRUE;
        }
    }

    return FALSE;
}

static BOOL_T RULE_CTRL_GetParamFromLookupEntry(
    const RULE_CTRL_RuleLookupEntry_T *rl_p,
    RULE_CTRL_PARAM_PTR param_p)
{
    if (NULL == rl_p ||
        0 == rl_p->code.valid)
    {
        return FALSE;
    }

    RULE_CTRL_InitParam(param_p);

    switch (rl_p->code.type)
    {
    case RULE_CTRL_RT_GLOBAL_RULE:
        {
            param_p->query.unit = rl_p->GR.unit;
            param_p->query.device_id = rl_p->GR.device;
            param_p->query.rule_id = rl_p->rule_id;

            param_p->flags |= RULE_CTRL_OPT_QUERY_BY_RULE_ID;

            rl_p->GR.do_handler(param_p);

            if (NULL == param_p->sys_rule_storage_p)
            {
                RULE_CTRL_LOG("Invalid unit=%lu, device_id=%lu or Implement RULE_CTRL_OPT_QUERY_BY_RULE_ID failed",
                              param_p->query.unit, param_p->query.device_id);
                return FALSE;
            }
        }

        break;

    case RULE_CTRL_RT_SHARED_PORT_RULE:
        {
            RULE_CTRL_SPRRuleStorage_T *rs_p;

            param_p->unit = rl_p->SPR.unit;
            param_p->port = rl_p->SPR.port;
            param_p->query.unit = rl_p->SPR.unit;
            param_p->query.port = rl_p->SPR.port;

            param_p->flags |= (RULE_CTRL_OPT_QUERY | RULE_CTRL_OPT_QUERY_BY_RULE_ID);

            rs_p = rl_p->SPR.get_om_handler(param_p);

            if (NULL == rs_p)
            {
                RULE_CTRL_LOG("Invalid unit(%hu) port(%hu)", rl_p->SPR.unit, rl_p->SPR.port);
                return FALSE;
            }

            param_p->rule_storage_p = &rs_p->rule_storage;

            rl_p->SPR.set_rule_handler(param_p, rs_p->pbmp);
        }

        break;

    case RULE_CTRL_RT_PORT_RULE:
        {
            param_p->unit = rl_p->PR.unit;
            param_p->port = rl_p->PR.port;
            param_p->query.unit    = rl_p->PR.unit;
            param_p->query.port    = rl_p->PR.port;
            param_p->query.rule_id = rl_p->rule_id;

            param_p->flags |= RULE_CTRL_OPT_QUERY_BY_RULE_ID;

            rl_p->PR.do_handler(param_p);

            if (NULL == param_p->rule_storage_p)
            {
                RULE_CTRL_LOG("Invalid unit=%lu, port=%lu or Implement RULE_CTRL_OPT_QUERY_BY_RULE_ID failed",
                              param_p->query.unit, param_p->query.port);
                return FALSE;
            }
        }

        break;

    default:
        RULE_CTRL_LOG("Invalid Function Code (%u)", rl_p->code.type);
        return FALSE;
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_DO_SetSharedPortRule_CallBack
 *------------------------------------------------------------------------------
* PURPOSE:  Set single rule to port bitmap
 * INPUT:    param_p - General parameter
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_DO_SetSharedPortRule_CallBack(
    RULE_CTRL_PARAM_PTR param_p)
{
    RULE_CTRL_SPRRuleStorage_T *rs_p;

    rs_p = (RULE_CTRL_SPRRuleStorage_T*)param_p->rule_storage_p;

    if (param_p->flags & RULE_CTRL_OPT_RES_SUCCEEDED)
    {
        DEVRM_PBMP_ASSIGN(rs_p->pbmp, param_p->ace_entry.inports_data);
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_DO_SetSharedPortRule
 *------------------------------------------------------------------------------
 * PURPOSE:  Set single rule to port bitmap
 * INPUT:    param_p - General parameter
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_DO_SetSharedPortRule(
    RULE_CTRL_PARAM_PTR param_p)
{
    UI32_T                          module_id, device_id, phy_port;
    RULE_CTRL_SPRRuleStorage_T     *rs_p = NULL;
    DEVRM_PBMP_T                      new_pbmp;
    BOOL_T                          renew_rule_on_remove_port = FALSE;

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit, param_p->port,
                                                        &module_id, &device_id, &phy_port))
    {
        RULE_CTRL_LOG("Invalid unit(%lu), port(%lu)", param_p->unit, param_p->port);
        return FALSE;
    }

    if (NULL == param_p->SPR.get_om_handler)
    {
        RULE_CTRL_LOG("MUST set get_om_handler function");
        return FALSE;
    }

    rs_p = param_p->SPR.get_om_handler(param_p);

    if (NULL == rs_p)
    {
        RULE_CTRL_LOG("rs_p == NULL");
        return FALSE;
    }

    DEVRM_PBMP_ASSIGN(new_pbmp, rs_p->pbmp);

    if (param_p->flags & RULE_CTRL_OPT_QUERY ||
        param_p->flags & RULE_CTRL_OPT_QUERY_BY_RULE_ID)
    {
        /* assign rule_storage_p if only this port is enabled
         */
        if ((rs_p->rule_storage.is_enable) &&
            (DEVRM_PBMP_MEMBER(rs_p->pbmp, phy_port)) )
        {
            param_p->rule_storage_p = &rs_p->rule_storage;
        }
    }
    else /* RULE_CTRL_OPT_INSTALL or UnInstall */
    {
        param_p->rule_storage_p = &rs_p->rule_storage;

        if (param_p->flags & RULE_CTRL_OPT_INSTALL)
        {
            DEVRM_PBMP_PORT_ADD(new_pbmp, phy_port);
        }
        else
        {
            DEVRM_PBMP_PORT_REMOVE(new_pbmp, phy_port);

            /* If port bitmap is not NULL, then destroy old rule and new one.
             * This change for param_p->flags SHOULD after invoking cfg_rule_handler.
             * Because the cfg_rule_handler will do some action based on param_p->flags.
             */
            if (DEVRM_PBMP_NOT_NULL(new_pbmp))
            {
                renew_rule_on_remove_port = TRUE;
                /*param_p->flags |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);*/
            }
        }

        if (DEVRM_PBMP_EQ(new_pbmp, rs_p->pbmp)
            && !(param_p->flags & RULE_CTRL_OPT_FORCE_INSTALL))
        {
            param_p->flags |= RULE_CTRL_OPT_ABORT;
            return TRUE;
        }
    }

    if (NULL == param_p->SPR.cfg_rule_handler)
    {
        RULE_CTRL_LOG("MUST set cfg_rule_handler function");
        return FALSE;
    }

    if (FALSE == param_p->SPR.cfg_rule_handler(param_p, new_pbmp))
    {
        RULE_CTRL_LOG("cfg_rule_handler failed with func_type=%d", param_p->func_type);
        return FALSE;
    }

    param_p->callback   = (RULE_CTRL_CALLBACK_PTR)RULE_CTRL_DO_SetSharedPortRule_CallBack;

    if (renew_rule_on_remove_port)
    {
        param_p->flags |= (RULE_CTRL_OPT_INSTALL | RULE_CTRL_OPT_FORCE_INSTALL);
    }

    return TRUE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - RULE_CTRL_SetSharedPortRule
 *------------------------------------------------------------------------------
 * PURPOSE:  Wrapped function for Shared Port Rule to set rule to device
 * INPUT:    param_p,
 *           get_om_ptr_handler,
 *           cfg_rule_handler
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_SetSharedPortRule(
    RULE_CTRL_PARAM_PTR             param_p,
    RULE_CTRL_SPR_GET_OM_HANDLER    get_om_ptr_handler,
    RULE_CTRL_SPR_SET_RULE_HANDLER  cfg_rule_handler)
{
    if (RULE_CTRL_INVALID == param_p->unit && RULE_CTRL_INVALID == param_p->port)
    {
        return FALSE;
    }

    if (param_p->flags & RULE_CTRL_OPT_ALL_DEVICES)
    {
        return FALSE;
    }

    param_p->SPR.get_om_handler    = get_om_ptr_handler;
    param_p->SPR.cfg_rule_handler  = cfg_rule_handler;

    return _rule_ctrl_set_rule(param_p, RULE_CTRL_DO_SetSharedPortRule);
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_DumpParam
 *------------------------------------------------------------------------------
 * PURPOSE : Dump rule information
 * INPUT   : param_p     - rule information
 *           rule_printf - callback function for print
 * OUTPUT  : None
 * RETURN  : True: Successfully, FALSE: Failed
 * NOTE    : None
 *------------------------------------------------------------------------------
 */
static BOOL_T RULE_CTRL_DumpParam(
    RULE_CTRL_PARAM_PTR param_p,
    BOOL_T (*rule_printf)(char*, ...))
{
    if (0 == param_p ||
        NULL == rule_printf)
    {
        return FALSE;
    }

    if (DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPort))
    {
        rule_printf("Inport\n");
        rule_printf("    DATA = %08lx\n", param_p->ace_entry.inport_data);
        rule_printf("    MASK = %08lx\n", param_p->ace_entry.inport_mask);
    }

    if (DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_OutPort))
    {
        rule_printf("Outport\n");
        rule_printf("    DATA = %08lx\n", param_p->ace_entry.outport_data);
        rule_printf("    MASK = %08lx\n", param_p->ace_entry.outport_mask);
    }

    if (DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InPorts))
    {
        rule_printf("Inports\n");
        rule_printf("    DATA = %08lx %08lx\n",
            param_p->ace_entry.inports_data.pbits[1],
            param_p->ace_entry.inports_data.pbits[0]);
        rule_printf("    MASK = %08lx %08lx\n",
            param_p->ace_entry.inports_mask.pbits[1],
            param_p->ace_entry.inports_mask.pbits[0]);
    }

    if (DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_OutPorts))
    {
        rule_printf("Outports\n");
        rule_printf("    DATA = %08lx %08lx\n",
            param_p->ace_entry.outports_data.pbits[1],
            param_p->ace_entry.outports_data.pbits[0]);
        rule_printf("    MASK = %08lx %08lx\n",
            param_p->ace_entry.outports_mask.pbits[1],
            param_p->ace_entry.outports_mask.pbits[0]);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_SrcModid))
    {
        rule_printf("SrcModID\n");
        rule_printf("    DATA = %08lx\n",
            param_p->ace_entry.srcmodid_data);
        rule_printf("    MASK = %08lx\n",
            param_p->ace_entry.srcmodid_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_SrcPortTgid))
    {
        rule_printf("SrcPortTGID\n");
        rule_printf("    DATA = %08lx\n",
            param_p->ace_entry.srcporttgid_data);
        rule_printf("    MASK = %08lx\n",
            param_p->ace_entry.srcporttgid_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstModid))
    {
        rule_printf("DstModID\n");
        rule_printf("    DATA = %08lx\n",
            param_p->ace_entry.dstmodid_data);
        rule_printf("    MASK = %08lx\n",
            param_p->ace_entry.dstmodid_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstPortTgid))
    {
        rule_printf("DstPortTGID\n");
        rule_printf("    DATA = %08lx\n",
            param_p->ace_entry.dstporttgid_data);
        rule_printf("    MASK = %08lx\n",
            param_p->ace_entry.dstporttgid_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_L4SrcPort))
    {
        rule_printf("L4SrcPort\n");
        rule_printf("    DATA = %08lx(%lu)\n",
            param_p->ace_entry.l4_srcport_data,
            param_p->ace_entry.l4_srcport_data);
        rule_printf("    MASK = %08lx(%lu)\n",
            param_p->ace_entry.l4_srcport_mask,
            param_p->ace_entry.l4_srcport_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_L4DstPort))
    {
        rule_printf("L4DstPort\n");
        rule_printf("    DATA = %08lx(%lu)\n",
            param_p->ace_entry.l4_dstport_data,
            param_p->ace_entry.l4_dstport_data);
        rule_printf("    MASK = %08lx(%lu)\n",
            param_p->ace_entry.l4_dstport_mask,
            param_p->ace_entry.l4_dstport_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_OuterVlan))
    {
        rule_printf("OuterVLAN\n");
        rule_printf("    DATA = %04hx(%hu)\n",
            param_p->ace_entry.outvlan_data,
            param_p->ace_entry.outvlan_data);
        rule_printf("    MASK = %04hx(%hu)\n",
            param_p->ace_entry.outvlan_mask,
            param_p->ace_entry.outvlan_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_InnerVlan))
    {
        rule_printf("InnerVLAN\n");
        rule_printf("    DATA = %04hx(%hu)\n",
            param_p->ace_entry.invlan_data,
            param_p->ace_entry.invlan_data);
        rule_printf("    MASK = %04hx(%hu)\n",
            param_p->ace_entry.invlan_mask,
            param_p->ace_entry.invlan_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_EtherType))
    {
        rule_printf("EtherType\n");
        rule_printf("    DATA = %08lx\n",
            param_p->ace_entry.ethertype_data);
        rule_printf("    MASK = %08lx\n",
            param_p->ace_entry.ethertype_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpProtocol))
    {
        rule_printf("IpProtocol\n");
        rule_printf("    DATA = %02x\n",
            param_p->ace_entry.ipprotocol_data);
        rule_printf("    MASK = %02x\n",
            param_p->ace_entry.ipprotocol_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpType))
    {
        char *iptype_strings[] = BCM_FIELD_IPTYPE_STRINGS;

        rule_printf("IpType\n");
        rule_printf("    DATA = %08lx(%s)\n",
            param_p->ace_entry.iptype,
            iptype_strings[param_p->ace_entry.iptype]);
    }

#if 0 /* obsolete by BCM SDK 6, use IngressStpState, L2SrcHit, L2DestHit, L3Routable, L3DestHostHit, ... instead. */
    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_LookupStatus))
    {
        rule_printf("LookupStatus\n");
        rule_printf("    DATA = %08lx\n",
            param_p->ace_entry.lookupstatus_data);
        rule_printf("    MASK = %08lx\n",
            param_p->ace_entry.lookupstatus_mask);
    }
#endif

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IngressStpState))
    {
        rule_printf("IngressStpState\n");
        rule_printf("    DATA = %02x\n",
            param_p->ace_entry.stpstate);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_L2SrcHit))
    {
        rule_printf("L2SrcHit\n");
        rule_printf("    DATA = %02x\n",
            param_p->ace_entry.l2srchit_data);
        rule_printf("    MASK = %02x\n",
            param_p->ace_entry.l2srchit_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_L2DestHit))
    {
        rule_printf("L2DestHit\n");
        rule_printf("    DATA = %02x\n",
            param_p->ace_entry.l2dsthit_data);
        rule_printf("    MASK = %02x\n",
            param_p->ace_entry.l2dsthit_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_L3Routable))
    {
        rule_printf("L3Routable\n");
        rule_printf("    DATA = %02x\n",
            param_p->ace_entry.l3routable_data);
        rule_printf("    MASK = %02x\n",
            param_p->ace_entry.l3routable_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_L3DestHostHit))
    {
        rule_printf("L3DestHostHit\n");
        rule_printf("    DATA = %02x\n",
            param_p->ace_entry.l3dsthosthit_data);
        rule_printf("    MASK = %02x\n",
            param_p->ace_entry.l3dsthosthit_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_HiGig))
    {
        rule_printf("HiGig\n");
        rule_printf("    DATA = %02x\n",
            param_p->ace_entry.higpacket_data);
        rule_printf("    MASK = %02x\n",
            param_p->ace_entry.higpacket_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpInfo))
    {
        rule_printf("IpInfo\n");
        rule_printf("    DATA = %08lx\n",
            param_p->ace_entry.ipinfo_data);
        rule_printf("    MASK = %08lx\n",
            param_p->ace_entry.ipinfo_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_PacketRes))
    {
        rule_printf("PacketRes\n");
        rule_printf("    DATA = %08lx\n",
            param_p->ace_entry.packetres_data);
        rule_printf("    MASK = %08lx\n",
            param_p->ace_entry.packetres_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_SrcIp))
    {
        UI8_T *ip;
        UI8_T *mask;

        ip   = (UI8_T*)&param_p->ace_entry.srcip_data;
        mask = (UI8_T*)&param_p->ace_entry.srcip_mask;

        rule_printf("SrcIp\n");
        rule_printf("    DATA = %08lx(%u.%u.%u.%u)\n",
            param_p->ace_entry.srcip_data,
            ip[0], ip[1], ip[2], ip[3]);
        rule_printf("    MASK = %08lx(%u.%u.%u.%u)\n",
            param_p->ace_entry.srcip_mask,
            mask[0], mask[1], mask[2], mask[3]);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstIp))
    {
        UI8_T *ip;
        UI8_T *mask;

        ip   = (UI8_T*)&param_p->ace_entry.dstip_data;
        mask = (UI8_T*)&param_p->ace_entry.dstip_mask;

        rule_printf("DstIp\n");
        rule_printf("    DATA = %08lx(%u.%u.%u.%u)\n",
            param_p->ace_entry.dstip_data,
            ip[0], ip[1], ip[2], ip[3]);
        rule_printf("    MASK = %08lx(%u.%u.%u.%u)\n",
            param_p->ace_entry.dstip_mask,
            mask[0], mask[1], mask[2], mask[3]);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DSCP))
    {
        rule_printf("DSCP\n");
        rule_printf("    DATA = %08lx\n",
            param_p->ace_entry.dscp_data);
        rule_printf("    MASK = %08lx\n",
            param_p->ace_entry.dscp_mask);
    }


    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_IpFlags))
    {
        rule_printf("IpFlags\n");
        rule_printf("    DATA = %08lx\n",
            param_p->ace_entry.ipflags_data);
        rule_printf("    MASK = %08lx\n",
            param_p->ace_entry.ipflags_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_TcpControl))
    {
        rule_printf("TcpControl\n");
        rule_printf("    DATA = %08lx\n",
            param_p->ace_entry.tcpcontrol_data);
        rule_printf("    MASK = %08lx\n",
            param_p->ace_entry.tcpcontrol_mask);
    }


    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_Ttl))
    {
        rule_printf("TTL\n");
        rule_printf("    DATA = %02x\n",
            param_p->ace_entry.ttl_data);
        rule_printf("    MASK = %02x\n",
            param_p->ace_entry.ttl_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_RangeCheck))
    {
        rule_printf("RangeCheck\n");
        rule_printf("    RANGE  = %08lx\n",
            param_p->ace_entry.range);
        rule_printf("    INVERT = %08lx\n",
            param_p->ace_entry.invert);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_SrcIp6))
    {
        rule_printf("SrcIp6\n");
        rule_printf("    DATA = %02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x\n",
            param_p->ace_entry.srcip6_data[0],
            param_p->ace_entry.srcip6_data[1],
            param_p->ace_entry.srcip6_data[2],
            param_p->ace_entry.srcip6_data[3],
            param_p->ace_entry.srcip6_data[4],
            param_p->ace_entry.srcip6_data[5],
            param_p->ace_entry.srcip6_data[6],
            param_p->ace_entry.srcip6_data[7],
            param_p->ace_entry.srcip6_data[8],
            param_p->ace_entry.srcip6_data[9],
            param_p->ace_entry.srcip6_data[10],
            param_p->ace_entry.srcip6_data[11],
            param_p->ace_entry.srcip6_data[12],
            param_p->ace_entry.srcip6_data[13],
            param_p->ace_entry.srcip6_data[14],
            param_p->ace_entry.srcip6_data[15]);
        rule_printf("    MASK = %02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x\n",
            param_p->ace_entry.srcip6_mask[0],
            param_p->ace_entry.srcip6_mask[1],
            param_p->ace_entry.srcip6_mask[2],
            param_p->ace_entry.srcip6_mask[3],
            param_p->ace_entry.srcip6_mask[4],
            param_p->ace_entry.srcip6_mask[5],
            param_p->ace_entry.srcip6_mask[6],
            param_p->ace_entry.srcip6_mask[7],
            param_p->ace_entry.srcip6_mask[8],
            param_p->ace_entry.srcip6_mask[9],
            param_p->ace_entry.srcip6_mask[10],
            param_p->ace_entry.srcip6_mask[11],
            param_p->ace_entry.srcip6_mask[12],
            param_p->ace_entry.srcip6_mask[13],
            param_p->ace_entry.srcip6_mask[14],
            param_p->ace_entry.srcip6_mask[15]);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstIp6))
    {
        rule_printf("SrcIp6\n");
        rule_printf("    DATA = %02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x\n",
            param_p->ace_entry.dstip6_data[0],
            param_p->ace_entry.dstip6_data[1],
            param_p->ace_entry.dstip6_data[2],
            param_p->ace_entry.dstip6_data[3],
            param_p->ace_entry.dstip6_data[4],
            param_p->ace_entry.dstip6_data[5],
            param_p->ace_entry.dstip6_data[6],
            param_p->ace_entry.dstip6_data[7],
            param_p->ace_entry.dstip6_data[8],
            param_p->ace_entry.dstip6_data[9],
            param_p->ace_entry.dstip6_data[10],
            param_p->ace_entry.dstip6_data[11],
            param_p->ace_entry.dstip6_data[12],
            param_p->ace_entry.dstip6_data[13],
            param_p->ace_entry.dstip6_data[14],
            param_p->ace_entry.dstip6_data[15]);
        rule_printf("    MASK = %02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x\n",
            param_p->ace_entry.dstip6_mask[0],
            param_p->ace_entry.dstip6_mask[1],
            param_p->ace_entry.dstip6_mask[2],
            param_p->ace_entry.dstip6_mask[3],
            param_p->ace_entry.dstip6_mask[4],
            param_p->ace_entry.dstip6_mask[5],
            param_p->ace_entry.dstip6_mask[6],
            param_p->ace_entry.dstip6_mask[7],
            param_p->ace_entry.dstip6_mask[8],
            param_p->ace_entry.dstip6_mask[9],
            param_p->ace_entry.dstip6_mask[10],
            param_p->ace_entry.dstip6_mask[11],
            param_p->ace_entry.dstip6_mask[12],
            param_p->ace_entry.dstip6_mask[13],
            param_p->ace_entry.dstip6_mask[14],
            param_p->ace_entry.dstip6_mask[15]);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstIp6High))
    {
        rule_printf("SrcIp6High\n");
        rule_printf("    DATA = %02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x\n",
            param_p->ace_entry.dstip6high_data[0],
            param_p->ace_entry.dstip6high_data[1],
            param_p->ace_entry.dstip6high_data[2],
            param_p->ace_entry.dstip6high_data[3],
            param_p->ace_entry.dstip6high_data[4],
            param_p->ace_entry.dstip6high_data[5],
            param_p->ace_entry.dstip6high_data[6],
            param_p->ace_entry.dstip6high_data[7],
            param_p->ace_entry.dstip6high_data[8],
            param_p->ace_entry.dstip6high_data[9],
            param_p->ace_entry.dstip6high_data[10],
            param_p->ace_entry.dstip6high_data[11],
            param_p->ace_entry.dstip6high_data[12],
            param_p->ace_entry.dstip6high_data[13],
            param_p->ace_entry.dstip6high_data[14],
            param_p->ace_entry.dstip6high_data[15]);
        rule_printf("    MASK = %02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x\n",
            param_p->ace_entry.dstip6high_mask[0],
            param_p->ace_entry.dstip6high_mask[1],
            param_p->ace_entry.dstip6high_mask[2],
            param_p->ace_entry.dstip6high_mask[3],
            param_p->ace_entry.dstip6high_mask[4],
            param_p->ace_entry.dstip6high_mask[5],
            param_p->ace_entry.dstip6high_mask[6],
            param_p->ace_entry.dstip6high_mask[7],
            param_p->ace_entry.dstip6high_mask[8],
            param_p->ace_entry.dstip6high_mask[9],
            param_p->ace_entry.dstip6high_mask[10],
            param_p->ace_entry.dstip6high_mask[11],
            param_p->ace_entry.dstip6high_mask[12],
            param_p->ace_entry.dstip6high_mask[13],
            param_p->ace_entry.dstip6high_mask[14],
            param_p->ace_entry.dstip6high_mask[15]);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_Ip6NextHeader))
    {
        rule_printf("Ip6NextHeader\n");
        rule_printf("    DATA = %02x\n",
            param_p->ace_entry.ip6nextheader_data);
        rule_printf("    MASK = %02x\n",
            param_p->ace_entry.ip6nextheader_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_Ip6TrafficClass))
    {
        rule_printf("Ip6TrafficClass\n");
        rule_printf("    DATA = %02x\n",
            param_p->ace_entry.ip6trafficclass_data);
        rule_printf("    MASK = %02x\n",
            param_p->ace_entry.ip6trafficclass_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_Ip6FlowLabel))
    {
        rule_printf("Ip6FlowLabel\n");
        rule_printf("    DATA = %08lx\n",
            param_p->ace_entry.ip6flowlabel_data);
        rule_printf("    MASK = %08lx\n",
            param_p->ace_entry.ip6flowlabel_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_Ip6HopLimit))
    {
        rule_printf("Ip6HopLimit\n");
        rule_printf("    DATA = %02x\n",
            param_p->ace_entry.ip6hoplimit_data);
        rule_printf("    MASK = %02x\n",
            param_p->ace_entry.ip6hoplimit_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_SrcMac))
    {
        rule_printf("SrcMac\n");
        rule_printf("    DATA = %02x-%02x-%02x-%02x-%02x-%02x\n",
            param_p->ace_entry.srcmac_data[0],
            param_p->ace_entry.srcmac_data[1],
            param_p->ace_entry.srcmac_data[2],
            param_p->ace_entry.srcmac_data[3],
            param_p->ace_entry.srcmac_data[4],
            param_p->ace_entry.srcmac_data[5]);
        rule_printf("    MASK = %02x-%02x-%02x-%02x-%02x-%02x\n",
            param_p->ace_entry.srcmac_mask[0],
            param_p->ace_entry.srcmac_mask[1],
            param_p->ace_entry.srcmac_mask[2],
            param_p->ace_entry.srcmac_mask[3],
            param_p->ace_entry.srcmac_mask[4],
            param_p->ace_entry.srcmac_mask[5]);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_DstMac))
    {
        rule_printf("DstMac\n");
        rule_printf("    DATA = %02x-%02x-%02x-%02x-%02x-%02x\n",
            param_p->ace_entry.dstmac_data[0],
            param_p->ace_entry.dstmac_data[1],
            param_p->ace_entry.dstmac_data[2],
            param_p->ace_entry.dstmac_data[3],
            param_p->ace_entry.dstmac_data[4],
            param_p->ace_entry.dstmac_data[5]);
        rule_printf("    MASK = %02x-%02x-%02x-%02x-%02x-%02x\n",
            param_p->ace_entry.dstmac_mask[0],
            param_p->ace_entry.dstmac_mask[1],
            param_p->ace_entry.dstmac_mask[2],
            param_p->ace_entry.dstmac_mask[3],
            param_p->ace_entry.dstmac_mask[4],
            param_p->ace_entry.dstmac_mask[5]);
    }

#if 0 /* obsolete by BCM SDK 6, use IpType, L2Format, VlanFormat instead. */
    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_PacketFormat))
    {
        rule_printf("PacketFormat\n");
        rule_printf("    DATA = %08lx\n",
            param_p->ace_entry.packetformat_data);
        rule_printf("    MASK = %08lx\n",
            param_p->ace_entry.packetformat_mask);
    }
#endif

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_L2Format))
    {
        char *l2format_strings[] = BCM_FIELD_L2FORMAT_STRINGS;

        rule_printf("L2Format\n");
        rule_printf("    DATA = %08lx(%s)\n",
            param_p->ace_entry.l2format,
            l2format_strings[param_p->ace_entry.l2format]);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_VlanFormat))
    {
        rule_printf("VlanFormat\n");
        rule_printf("    DATA = %02x\n",
            param_p->ace_entry.vlanformat_data);
        rule_printf("    MASK = %02x\n",
            param_p->ace_entry.vlanformat_mask);
    }

    if(DEVRM_SHR_BITGET(param_p->ace_entry.w, DEVRM_FIELD_QUALIFY_MHOpcode))
    {
        rule_printf("MHOpcode\n");
        rule_printf("    DATA = %02x\n",
            param_p->ace_entry.mhopcode_data);
        rule_printf("    MASK = %02x\n",
            param_p->ace_entry.mhopcode_mask);
    }

    {
        int uid;
        UI32_T _i;

        for (uid = 0; uid < DEVRM_FIELD_USER_QUALIFY_Count; uid++)
        {
            if (DEVRM_SHR_BITGET(param_p->ace_entry.udf_map, uid))
            {
                rule_printf("UDF%lu\n", param_p->ace_entry.udf[uid].udf_id);

                rule_printf("    DATA = ");

                for (_i=0; _i < sizeof(param_p->ace_entry.udf[uid].udf_data); _i++)
                {
                    rule_printf("%02x", param_p->ace_entry.udf[uid].udf_data[_i]);
                }

                rule_printf("\n");

                rule_printf("    MASK = ");

                for (_i=0; _i < sizeof(param_p->ace_entry.udf[uid].udf_mask); _i++)
                {
                    rule_printf("%02x", param_p->ace_entry.udf[uid].udf_mask[_i]);
                }

                rule_printf("\n");
            }
        }
    }

    {
        DEVRM_ActionEntry_T *action_p = &param_p->action_entries[0];
        char *action_string[] = BCM_FIELD_ACTION_STRINGS;

        do{
            if (action_p->action != 0)
            {
                rule_printf("Action %s(%lu)\n",
                    action_string[action_p->action],
                    action_p->action);
                rule_printf("    P0   = %08lx(%lu)\n",
                    action_p->param0, action_p->param0);
                rule_printf("    P1   = %08lx(%lu)\n",
                    action_p->param1, action_p->param1);
            }
            action_p = action_p->next_action;
        } while (NULL != action_p);
    }

    if (TRUE == param_p->meter_enabled)
    {
        rule_printf("Police\n");
        rule_printf("    MODE = %s(%u)\n",
            (param_p->meter_entry.meter_mode == BCM_FIELD_METER_MODE_DEFAULT)           ? "default"             :
            (param_p->meter_entry.meter_mode == BCM_FIELD_METER_MODE_FLOW)              ? "flow"                :
            (param_p->meter_entry.meter_mode == BCM_FIELD_METER_MODE_trTCM_COLOR_BLIND) ? "trTCM-color-blind"   :
            (param_p->meter_entry.meter_mode == BCM_FIELD_METER_MODE_trTCM_COLOR_AWARE) ? "trTCM-color-aware"   :
            (param_p->meter_entry.meter_mode == BCM_FIELD_METER_MODE_srTCM_COLOR_BLIND) ? "srTCM-color-blind"   :
            (param_p->meter_entry.meter_mode == BCM_FIELD_METER_MODE_srTCM_COLOR_AWARE) ? "srTCM-color-aware"   :
                                                                                          "unknown",
            param_p->meter_entry.meter_mode);
        rule_printf("    NUM  = %s(%u)\n",
            (param_p->meter_entry.meter_num == BCM_FIELD_METER_PEAK)        ? "peek"        :
            (param_p->meter_entry.meter_num == BCM_FIELD_METER_COMMITTED)   ? "committed"   :
                                                                              "unknown",
            param_p->meter_entry.meter_num);
        rule_printf("    CIS  = %lu kb/s CBS = %lu KB\n", param_p->meter_entry.kbits_sec, param_p->meter_entry.kbytes_burst);
        rule_printf("    PIS  = %lu kb/s PBS = %lu KB\n", param_p->meter_entry.peak_kbits_sec, param_p->meter_entry.peak_kbytes_burst);
    }

    return TRUE;
}

static BOOL_T RULE_CTRL_FindRuleLookupTable(
    RULE_CTRL_FindRuleLookupTable_T *find_p)
{
    RULE_CTRL_RuleLookupEntry_T *entry_p = NULL;
    UI32_T                      i;
    UI32_T                      unit;
    UI32_T                      device_id;
    UI32_T                      group_id;
    UI32_T                      rule_id;
    UI32_T                      flag;

    if (NULL == find_p)
    {
        return FALSE;
    }

    flag = 0;
    unit = find_p->unit;
    device_id = find_p->device_id;
    group_id = find_p->group_id;
    rule_id = find_p->rule_id;

    find_p->first_free_p = NULL;
    find_p->existed_p = NULL;

    if (0 == unit)
    {
        return FALSE;
    }

    unit -= 1;

    if (SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK <= unit ||
        SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT <= device_id ||
        SYS_ADPT_FP_MAX_NBR_OF_GROUP_PER_CHIP <= group_id)
    {
        return FALSE;
    }

    for (i=0; i < SYS_ADPT_FP_MAX_NBR_OF_RULE_PER_SELECTOR; i++)
    {
        entry_p = &shmem_data_p->rule_lookup_tbl[unit][device_id][group_id][i];

        if (0 == entry_p->code.valid)
        {
            if (find_p->flag & RULE_CTRL_FIND_FIRST_FREE_RULE_ENTRY)
            {
                if (NULL == find_p->first_free_p)
                {
                    find_p->first_free_p = entry_p;
                    flag |= RULE_CTRL_FIND_FIRST_FREE_RULE_ENTRY;
                }
            }
        }
        else
        {
            if (find_p->flag & RULE_CTRL_FIND_EXISTED_RULE_ENTRY)
            {
                if (entry_p->rule_id == rule_id)
                {
                    find_p->existed_p = entry_p;
                    flag |= RULE_CTRL_FIND_EXISTED_RULE_ENTRY;
                }
            }
        }

        if (flag == find_p->flag)
        {
            break;
        }
    }

    return TRUE;
}

static BOOL_T RULE_CTRL_GetNextRuleEntryInLookupTable(
    RULE_CTRL_FindRuleLookupTable_T *find_p)
{
    RULE_CTRL_RuleLookupEntry_T *entry_p = NULL;

    if (NULL == find_p)
    {
        return FALSE;
    }

    if (RULE_CTRL_FIND_NEXT_EXISTED_RULE_ENTRY != find_p->flag)
    {
        return FALSE;
    }

    if (RULE_CTRL_INVALID == find_p->unit)
    {
        find_p->unit = 1;
        find_p->device_id = 0;
        find_p->group_id = 0;
        find_p->_last_index = 0;
    }
    else if (RULE_CTRL_INVALID == find_p->device_id)
    {
        find_p->device_id = 0;
        find_p->group_id = 0;
        find_p->_last_index = 0;
    }
    else if (RULE_CTRL_INVALID == find_p->group_id)
    {
        find_p->group_id = 0;
        find_p->_last_index = 0;
    }
    else if (RULE_CTRL_INVALID == find_p->_last_index)
    {
        find_p->_last_index = 0;
    }
    else
    {
        find_p->_last_index ++;
    }

    if (0 == find_p->unit ||
        SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK < find_p->unit ||
        SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT <= find_p->device_id ||
        SYS_ADPT_FP_MAX_NBR_OF_GROUP_PER_CHIP <= find_p->group_id)
    {
        return FALSE;
    }

    find_p->first_free_p = NULL;
    find_p->existed_p = NULL;

    /*
        rule_lookup_tbl[SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK]
                       [SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT]
                       [SYS_ADPT_FP_MAX_NBR_OF_GROUP_PER_CHIP]
                       [SYS_ADPT_FP_MAX_NBR_OF_RULE_PER_SELECTOR];
    */

    for (; find_p->unit <= SYS_ADPT_MAX_NBR_OF_UNIT_PER_STACK; find_p->unit++, find_p->device_id=0)
    {
        for (; find_p->device_id < SYS_ADPT_MAX_NBR_OF_CHIP_PER_UNIT; find_p->device_id++, find_p->group_id=0)
        {
            for (; find_p->group_id < SYS_ADPT_FP_MAX_NBR_OF_GROUP_PER_CHIP; find_p->group_id++, find_p->_last_index=0)
            {
                for (; find_p->_last_index < SYS_ADPT_FP_MAX_NBR_OF_RULE_PER_SELECTOR; find_p->_last_index++)
                {
                    entry_p = &shmem_data_p->rule_lookup_tbl[find_p->unit - 1]
                                                            [find_p->device_id]
                                                            [find_p->group_id]
                                                            [find_p->_last_index];

                    if (1 == entry_p->code.valid)
                    {
                        find_p->existed_p = entry_p;
                        find_p->rule_id = entry_p->rule_id;
                        return TRUE;
                    }
                }
            }
        }
    }

    return FALSE;
}


static BOOL_T RULE_CTRL_AddRuleToLookupTable(
    UI32_T  unit,
    UI32_T  port,
    UI32_T  device_id,
    UI32_T  group_id,
    UI32_T  rule_id,
    RULE_CTRL_PARAM_PTR    param_p,
    RULE_CTRL_HANDLER      handler)
{
    RULE_CTRL_FindRuleLookupTable_T find;
    RULE_CTRL_RuleLookupEntry_T     *entry_p;

    find.flag = RULE_CTRL_FIND_EXISTED_RULE_ENTRY | RULE_CTRL_FIND_FIRST_FREE_RULE_ENTRY;
    find.unit = unit;
    find.device_id = device_id;
    find.group_id = group_id;
    find.rule_id = rule_id;

    if (FALSE == RULE_CTRL_FindRuleLookupTable(&find))
    {
        RULE_CTRL_LOG("FindRuleLookupTable(flag=%lu, unit=%lu, device_id=%lu, group_id=%lu, rule_id=%lu) failed",
            find.flag, unit, device_id, group_id, rule_id);
        return FALSE;
    }

    if (find.existed_p)
    {
        RULE_CTRL_LOG("Rule ID overlapping (unit=%lu, device_id=%lu, group_id=%lu, rule_id=%lu)",
            unit, device_id, group_id, rule_id);
        return FALSE;
    }

    if (NULL == find.first_free_p)
    {
        RULE_CTRL_LOG("No available rule on unit(%lu) device(%lu) group(%lu)",
            unit, device_id, group_id);
        return FALSE;
    }

    entry_p = find.first_free_p;
    memset(entry_p, 0, sizeof(*entry_p));

    if (param_p->flags & RULE_CTRL_OPT_ALL_DEVICES)
    {
        entry_p->code.type = RULE_CTRL_RT_GLOBAL_RULE;

        entry_p->GR.do_handler = handler;
        entry_p->GR.unit    = (UI16_T)unit;
        entry_p->GR.device  = (UI16_T)device_id;
    }
    else if (param_p->SPR.get_om_handler && param_p->SPR.cfg_rule_handler)
    {
        entry_p->code.type = RULE_CTRL_RT_SHARED_PORT_RULE;

        entry_p->SPR.get_om_handler = param_p->SPR.get_om_handler;
        entry_p->SPR.set_rule_handler = param_p->SPR.cfg_rule_handler;
        entry_p->SPR.unit = (UI16_T)unit;
        entry_p->SPR.port = (UI16_T)port;
    }
    else
    {
        entry_p->code.type = RULE_CTRL_RT_PORT_RULE;

        entry_p->PR.do_handler = handler;
        entry_p->PR.unit = (UI16_T)unit;
        entry_p->PR.port = (UI16_T)port;
    }

    entry_p->rule_id = rule_id;
    entry_p->code.valid = 1;

    return TRUE;
}

static BOOL_T RULE_CTRL_RemoveRuleFromLookupTable(
    UI32_T  unit,
    UI32_T  port,
    UI32_T  device_id,
    UI32_T  group_id,
    UI32_T  rule_id)
{
    RULE_CTRL_FindRuleLookupTable_T find;

    find.flag = RULE_CTRL_FIND_EXISTED_RULE_ENTRY;
    find.unit = unit;
    find.device_id = device_id;
    find.group_id = group_id;
    find.rule_id = rule_id;

    if (FALSE == RULE_CTRL_FindRuleLookupTable(&find))
    {
        RULE_CTRL_LOG("FindRuleLookupTable(flag=%lu, unit=%lu, device_id=%lu, group_id=%lu, rule_id=%lu) failed",
            find.flag, unit, device_id, group_id, rule_id);
        return FALSE;
    }

    if (NULL == find.existed_p)
    {
        RULE_CTRL_LOG("Can not find rule ID(%lu) on unit(%lu) device(%lu) group(%lu)",
            rule_id, unit, device_id, group_id);
        return TRUE;
    }

    /* RULE_CTRL_LOG("sizeof(*entry)=%d", sizeof(*find.existed_p)); */

    memset(find.existed_p, 0, sizeof(*find.existed_p));
    return TRUE;
}

void RULE_CTRL_InitFilter(
    RULE_CTRL_Filter_T *filter_p)
{
    memset(filter_p, 0, sizeof(*filter_p));

    filter_p->unit              = RULE_CTRL_INVALID;
    filter_p->device_id         = RULE_CTRL_INVALID;
    filter_p->group_id          = RULE_CTRL_INVALID;
    filter_p->port              = RULE_CTRL_INVALID;
    filter_p->func_type         = RULE_CTRL_INVALID;

    filter_p->rule_src_mac[0]   = 0XFF;
    filter_p->rule_src_mac[1]   = 0XFF;
    filter_p->rule_src_mac[2]   = 0XFF;
    filter_p->rule_src_mac[3]   = 0XFF;
    filter_p->rule_src_mac[4]   = 0XFF;
    filter_p->rule_src_mac[5]   = 0XFF;

    filter_p->rule_outer_vlan   = RULE_CTRL_INVALID;
    filter_p->rule_src_ip.w     = RULE_CTRL_INVALID;
    filter_p->rule_dst_ip6.w[0] = RULE_CTRL_INVALID;
    filter_p->rule_dst_ip6.w[1] = RULE_CTRL_INVALID;
    filter_p->rule_dst_ip6.w[2] = RULE_CTRL_INVALID;
    filter_p->rule_dst_ip6.w[3] = RULE_CTRL_INVALID;
}

void RULE_CTRL_DumpRule(
    RULE_CTRL_Filter_T *filter_p,
    BOOL_T (*rule_printf)(char*, ...))
{
    RULE_CTRL_FindRuleLookupTable_T find;

    memset(&find, 0, sizeof(find));

    find.flag = RULE_CTRL_FIND_NEXT_EXISTED_RULE_ENTRY;
    find.unit = RULE_CTRL_INVALID;
    find.device_id  = RULE_CTRL_INVALID;
    find.group_id   = RULE_CTRL_INVALID;
    find.rule_id    = RULE_CTRL_INVALID;

    /* filter by unit
     */
    if (filter_p && filter_p->unit != RULE_CTRL_INVALID)
    {
        find.unit = filter_p->unit;
    }

    while (TRUE == RULE_CTRL_GetNextRuleEntryInLookupTable(&find))
    {
        RULE_CTRL_RuleLookupEntry_T *rl_p = find.existed_p;
        RULE_CTRL_PARAM param;

        /* filter by unit
         */
        if (filter_p && filter_p->unit != RULE_CTRL_INVALID)
        {
            if (find.unit != filter_p->unit)
            {
                break;
            }
        }

        /* filter by device
         */
        if (filter_p && filter_p->device_id != RULE_CTRL_INVALID)
        {
            if (find.device_id != filter_p->device_id)
            {
                continue;
            }
        }

        /* filter by rule ID
         */
        if (filter_p && filter_p->rule_id_ar && 0 < filter_p->cch_rule_id_ar)
        {
#define __RULE_CTRL_FIND_IN_ARRAY(ar, cch_ar, elem, result) \
    {                                                       \
        UI32_T __i;                                         \
                                                            \
        result = FALSE;                                     \
        for (__i=0; __i < cch_ar; __i++)                    \
        {                                                   \
            if (elem == ar[__i])                            \
            {                                               \
                result = TRUE;                              \
                break;                                      \
            }                                               \
        }                                                   \
    }
            BOOL_T found;

            __RULE_CTRL_FIND_IN_ARRAY(filter_p->rule_id_ar, filter_p->cch_rule_id_ar, rl_p->rule_id, found);

            if (FALSE == found)
            {
                continue;
            }
#undef __RULE_CTRL_FIND_IN_ARRAY
        }

        if (FALSE == RULE_CTRL_GetParamFromLookupEntry(rl_p, &param))
        {
            continue;
        }

        /* filter by function type
         */
        if (filter_p && filter_p->func_type < RULE_TYPE_FUNCTION_TYPE_MAX)
        {
            if (param.func_type != filter_p->func_type)
            {
                continue;
            }
        }

        /* filter by group ID
         */
        if (filter_p && filter_p->group_id != RULE_CTRL_INVALID)
        {
            UI32_T  group_id;
            int     rule_pri;

            if (TRUE == RULE_CTRL_GetFunctionInfoByFunctionType(param.func_type, &group_id, &rule_pri))
            {
                if (group_id != filter_p->group_id)
                {
                    continue;
                }
            }
        }

        /* filter by port
         */
        if (filter_p && filter_p->port != RULE_CTRL_INVALID)
        {
            if (RULE_CTRL_RT_SHARED_PORT_RULE == rl_p->code.type)
            {
                UI32_T  param_device_id;
                UI32_T  module_id, device_id, phy_port;

                if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param.unit, param.port,
                                                                   &module_id, &param_device_id, &phy_port))
                {
                    rule_printf("Invalid unit(%lu), port(%lu)\n", param.unit, param.port);
                }
                else if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param.unit, filter_p->port,
                                                                         &module_id, &device_id, &phy_port))
                {
                    /* filter_p->port is invalid
                     * nothing to do
                     */
                }
                else if (param_device_id != device_id)
                {
                    /* device is not same, skip it
                     */
                    continue;
                }
                else
                {
                    RULE_CTRL_SPRRuleStorage_T *rs_p = (RULE_CTRL_SPRRuleStorage_T*)param.rule_storage_p;

                    if (!DEVRM_PBMP_MEMBER(rs_p->pbmp, phy_port))
                    {
                        continue;
                    }
                }
            }
            else if (RULE_CTRL_RT_PORT_RULE == rl_p->code.type)
            {
                if (param.port != filter_p->port)
                {
                    continue;
                }
            }
        }

        /* filter by tags
         */
        if (filter_p && filter_p->tag[0] != '\0')
        {
            char dup_tag[RULE_CTRL_FILTER_MAX_NAME_STR_LEN + 1] = {0};
            char *p;
            char *tag;
            BOOL_T tag_matched = TRUE;

            strncpy(dup_tag, filter_p->tag, RULE_CTRL_FILTER_MAX_NAME_STR_LEN);

            tag = &dup_tag[0];

            do
            {
                p = strchr(tag, ';');
                if (p)
                {
                    *p = '\0';
                }

                if (FALSE == RULE_CTRL_IsTagMatch(&param, tag))
                {
                    tag_matched = FALSE;
                    break;
                }

                /* last tag
                 */
                if (NULL == p)
                {
                    break;
                }

                ++p;
                tag = p;

            } while (tag[0] != '\0');

            if (FALSE == tag_matched)
            {
                continue;
            }

        }

        /* filter by rule attributes
         */
        if (filter_p &&
            filter_p->rule_src_mac[0] != 0XFF &&
            filter_p->rule_src_mac[1] != 0XFF &&
            filter_p->rule_src_mac[2] != 0XFF &&
            filter_p->rule_src_mac[3] != 0XFF &&
            filter_p->rule_src_mac[4] != 0XFF &&
            filter_p->rule_src_mac[5] != 0XFF)
        {
            if (!DEVRM_SHR_BITGET(param.ace_entry.w, DEVRM_FIELD_QUALIFY_SrcMac) ||
                memcmp(param.ace_entry.srcmac_data, filter_p->rule_src_mac, sizeof(param.ace_entry.srcmac_data)))
            {
                continue;
            }
        }

        if (filter_p && filter_p->rule_outer_vlan != RULE_CTRL_INVALID)
        {
            if (!DEVRM_SHR_BITGET(param.ace_entry.w, DEVRM_FIELD_QUALIFY_OuterVlan) ||
                param.ace_entry.outvlan_data != filter_p->rule_outer_vlan)
            {
                continue;
            }
        }

        if (filter_p &&
            filter_p->rule_src_ip.w != RULE_CTRL_INVALID)
        {
            if (!DEVRM_SHR_BITGET(param.ace_entry.w, DEVRM_FIELD_QUALIFY_SrcIp) ||
                param.ace_entry.srcip_data != filter_p->rule_src_ip.w)
            {
                continue;
            }
        }

        if (filter_p &&
            filter_p->rule_dst_ip6.w[0] != RULE_CTRL_INVALID &&
            filter_p->rule_dst_ip6.w[1] != RULE_CTRL_INVALID &&
            filter_p->rule_dst_ip6.w[2] != RULE_CTRL_INVALID &&
            filter_p->rule_dst_ip6.w[3] != RULE_CTRL_INVALID)
        {
            if (!DEVRM_SHR_BITGET(param.ace_entry.w, DEVRM_FIELD_QUALIFY_DstIp6) ||
                memcmp(param.ace_entry.dstip6_data, &filter_p->rule_dst_ip6, sizeof(param.ace_entry.dstip6_data)))
            {
                continue;
            }
        }

        /* TODO: The following code should be merge into an API like dump_rule_information ???
         */
        rule_printf("Rule ID   = %lu\n", rl_p->rule_id);

        switch (rl_p->code.type)
        {
        case RULE_CTRL_RT_GLOBAL_RULE:
            {
                rule_printf("Unit      = %lu\n", rl_p->GR.unit);
                rule_printf("Device    = %lu\n", rl_p->GR.device);
            }
            break;

        case RULE_CTRL_RT_PORT_RULE:
        case RULE_CTRL_RT_SHARED_PORT_RULE:
            {
                UI32_T  module_id, device_id, phy_port;

                rule_printf("Unit      = %lu\n", param.unit);

                if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param.unit, param.port,
                                                                    &module_id, &device_id, &phy_port))
                {
                    rule_printf("Invalid unit(%lu), port(%lu)\n", param.unit, param.port);
                }
                else
                {
                    rule_printf("Device    = %lu\n", device_id);
                }

                if (RULE_CTRL_RT_PORT_RULE == rl_p->code.type)
                {
                    /*rule_printf("Unit      = %lu\n", param.unit);*/
                    rule_printf("Port      = %lu\n", param.port);
                }
                else
                {
                    RULE_CTRL_SPRRuleStorage_T *rs_p = (RULE_CTRL_SPRRuleStorage_T*)param.rule_storage_p;

                    if (NULL == rs_p)
                    {
                        rule_printf("rule_storage is NULL\n");
                    }
                    else
                    {
                        /* TODO: PBMP to Unit/Port
                         */
                        rule_printf("Pbmp      = %08lx %08lx\n", rs_p->pbmp.pbits[0], rs_p->pbmp.pbits[1]);
                    }
                }
            }
            break;
        }

        rule_printf("Func Type = %lu\n", param.func_type);

        {
            UI32_T  group_id;
            int     rule_pri;

            if (FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(param.func_type, &group_id, &rule_pri))
            {
                rule_printf("Invalid func_type(%lu)\n", param.func_type);
            }
            else
            {
                rule_printf("Group ID  = %lu\n", group_id);
                rule_printf("Rule Pri  = %d\n", rule_pri);
            }
        }

        /* show tag
         */
        {
            UI32_T _i;

            rule_printf("Tag       = ");
            for (_i=0; _i < _countof(param.name.tag); _i++)
            {
                if ('\0' == param.name.tag[_i][0])
                {
                    break;
                }

                if (_i != 0)
                {
                    rule_printf(";");
                }
                rule_printf("%s", param.name.tag[_i]);
            }
            rule_printf("\n");
        }

        /* rule field in device
         */
        RULE_CTRL_DumpParam(&param, rule_printf);
        rule_printf("\n");
    }

}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - _rule_ctrl_set_rule_for_all_devices
 *------------------------------------------------------------------------------
 * PURPOSE:  This function is used to set a global rule(the rule will be set
 *           for all devices).
 * INPUT:    param_p, handler
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T
_rule_ctrl_set_rule_for_all_devices(
    RULE_CTRL_PARAM_PTR    param_p,
    RULE_CTRL_HANDLER      handler)
{
    UI32_T      unit;
    UI32_T      port     = 1;   /* Dummy port number */
    UI32_T      device_id;
    UI32_T      soc_ndev;
    UI32_T      group_id;
    int         rule_pri;
    char        *tag;           /* for debugging */

    if (FALSE == handler(param_p))
    {
        return FALSE;
    }

    if (param_p->flags & RULE_CTRL_OPT_ABORT)
    {
        RULE_CTRL_LOG("Nothing changed, aborting process");
        return TRUE;
    }

    /* show tag for debugging
     */
    tag = RULE_CTRL_GetLastTag(param_p);
    RULE_CTRL_LOG(" %s", tag ? tag : "no-tag");

    if (FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(param_p->func_type, &group_id, &rule_pri))
    {
        RULE_CTRL_LOG("RULE_CTRL_GetFunctionInfoByFunctionType(func_type = %d)",
                      param_p->func_type);
        return FALSE;
    }

    if (param_p->flags & RULE_CTRL_OPT_INSTALL
        && NULL == param_p->sys_rule_storage_p)
    {
        RULE_CTRL_LOG("param_p->rule_storage_p is NULL");
        return FALSE;
    }

    /* All rules have be bound
     */
    /* It is not true after hot removal
    if (param_p->flags & RULE_CTRL_OPT_INSTALL
        && !(param_p->flags & RULE_CTRL_OPT_FORCE_INSTALL)
        && param_p->sys_rule_storage_p->is_enable)
    {
        return TRUE;
    }
    */

    /* If RULE_CTRL_OPT_FORCE_INSTALL bit is set, then remove all exist rule first
     */
    if (param_p->flags & RULE_CTRL_OPT_INSTALL
        && param_p->flags & RULE_CTRL_OPT_FORCE_INSTALL
        && param_p->sys_rule_storage_p->is_enable)
    {
        unit = 0;
        while (STKTPLG_POM_GetNextDriverUnit(&unit))
        {
            soc_ndev = shmem_data_p->dev_info[unit-1].num_of_chips;
            for (device_id=0; device_id<soc_ndev; device_id++)
            {
                if (0 == param_p->sys_rule_storage_p->rule_id[unit-1][device_id])
                {
                    continue;
                }

                if (FALSE == RULE_CTRL_DESTROY_RULE(unit,
                                                    port,
                                                    device_id,
                                                    group_id,
                                                    param_p->func_type,
                                                    param_p->sys_rule_storage_p->rule_id[unit-1][device_id]))
                {
                    RULE_CTRL_LOG("RULE_CTRL_Destroy_Rule"
                                  "(unit=%lu,port=%lu,device_id=%lu,group_id=%lu,rule_id=%lu",
                                  unit,
                                  port,
                                  device_id,
                                  group_id,
                                  param_p->sys_rule_storage_p->rule_id[unit-1][device_id]);
                    return FALSE;
                }

                RULE_CTRL_RemoveRuleFromLookupTable(unit,
                                                    port,
                                                    device_id,
                                                    group_id,
                                                    param_p->sys_rule_storage_p->rule_id[unit-1][device_id]);

                param_p->sys_rule_storage_p->rule_id[unit-1][device_id] = 0;

                if (FALSE == RULE_CTRL_RequestRuleByQuota(unit, device_id, param_p->func_type,
                                                          RULE_CTRL_REQUEST_RESOURCE_FREE,
                                                          1))
                {
                    RULE_CTRL_LOG("RULE_CTRL_RequestRuleByQuota(func_type=%d) failed", param_p->func_type);
                    return FALSE;
                }
            }
        }

        param_p->sys_rule_storage_p->is_enable = FALSE;
    }

    /* No any rule have be bound
     */
    if (!(param_p->flags & RULE_CTRL_OPT_INSTALL)
        && ((NULL == param_p->sys_rule_storage_p || !param_p->sys_rule_storage_p->is_enable)))
    {
        return TRUE;
    }

    unit = 0;
    while (STKTPLG_POM_GetNextDriverUnit(&unit))
    {
        soc_ndev = shmem_data_p->dev_info[unit-1].num_of_chips;
        for (device_id=0; device_id<soc_ndev; device_id++)
        {
            if (param_p->flags & RULE_CTRL_OPT_INSTALL)
            {
                if (param_p->sys_rule_storage_p->rule_id[unit-1][device_id])
                {
                    continue;
                }

                if (FALSE == RULE_CTRL_RequestRuleByQuota(unit, device_id, param_p->func_type,
                                                          RULE_CTRL_REQUEST_RESOURCE_ALLOCATE_TEST,
                                                          1))
                {
                    RULE_CTRL_LOG("RULE_CTRL_RequestRuleByQuota(func_type=%d) failed", param_p->func_type);
                    goto about;
                }

                if (FALSE == RULE_CTRL_ALLOCATE_RULE(unit,
                                                     port,
                                                     device_id,
                                                     group_id,
                                                     param_p->func_type,
                                                     rule_pri,
                                                     &param_p->sys_rule_storage_p->rule_id[unit-1][device_id]))
                {
                    RULE_CTRL_LOG("RULE_CTRL_Allocate_Rule"
                                  "(unit=%lu,port=%lu,device_id=%lu,group_id=%lu,rule_pri=%d",
                                  unit,
                                  port,
                                  device_id,
                                  group_id,
                                  rule_pri);
                    goto about;
                }

                /* Occupty resource
                 */
                param_p->sys_rule_storage_p->is_enable = TRUE;
                RULE_CTRL_AddRuleToLookupTable(unit, port, device_id, group_id, param_p->sys_rule_storage_p->rule_id[unit-1][device_id], param_p, handler);

                if (FALSE == RULE_CTRL_SET_RULE(unit,
                                                port,
                                                device_id,
                                                group_id,
                                                param_p->sys_rule_storage_p->rule_id[unit-1][device_id],
                                                &param_p->ace_entry,
                                                (param_p->meter_enabled) ? &param_p->meter_entry : NULL,
                                                &param_p->action_entries[0],
                                                param_p->counter_enabled))
                {
                    RULE_CTRL_LOG("RULE_CTRL_Set_Rule"
                                  "(unit=%lu,port=%lu,device_id=%lu,group_id=%lu,rule_id=%lu",
                                  unit, port, device_id, group_id,
                                  param_p->sys_rule_storage_p->rule_id[unit-1][device_id]);
                    goto about;
                }

                if (FALSE == RULE_CTRL_RequestRuleByQuota(unit, device_id, param_p->func_type,
                                                          RULE_CTRL_REQUEST_RESOURCE_ALLOCATE,
                                                          1))
                {
                    RULE_CTRL_LOG("RULE_CTRL_RequestRuleByQuota(func_type=%d) failed", param_p->func_type);
                    goto about;
                }

            }
            else
            {
                if (0 == param_p->sys_rule_storage_p->rule_id[unit-1][device_id])
                {
                    continue;
                }

                if (FALSE == RULE_CTRL_DESTROY_RULE(unit,
                                                    port,
                                                    device_id,
                                                    group_id,
                                                    param_p->func_type,
                                                    param_p->sys_rule_storage_p->rule_id[unit-1][device_id]))
                {
                    RULE_CTRL_LOG("RULE_CTRL_Destroy_Rule"
                                  "(unit=%lu,port=%lu,device_id=%lu,group_id=%lu,rule_id=%lu",
                                  unit,
                                  port,
                                  device_id,
                                  group_id,
                                  param_p->sys_rule_storage_p->rule_id[unit-1][device_id]);
                    goto about;
                }

                RULE_CTRL_RemoveRuleFromLookupTable(unit, port, device_id, group_id, param_p->sys_rule_storage_p->rule_id[unit-1][device_id]);
                param_p->sys_rule_storage_p->rule_id[unit-1][device_id] = 0;

                if (FALSE == RULE_CTRL_RequestRuleByQuota(unit, device_id, param_p->func_type,
                                                          RULE_CTRL_REQUEST_RESOURCE_FREE,
                                                          1))
                {
                    RULE_CTRL_LOG("RULE_CTRL_RequestRuleByQuota(func_type=%d) failed", param_p->func_type);
                    goto about;
                }
            }

        }
    }

    if (!(param_p->flags & RULE_CTRL_OPT_INSTALL))
    {
        param_p->sys_rule_storage_p->is_enable = FALSE;
    }

    param_p->flags |= RULE_CTRL_OPT_RES_SUCCEEDED;

    if (param_p->callback)
    {
        param_p->callback(param_p);
    }

    return TRUE;

about:
    /* must do roll back ...
     */
    return FALSE;
}

/*------------------------------------------------------------------------------
 * ROUTINE NAME - _rule_ctrl_set_rule
 *------------------------------------------------------------------------------
 * PURPOSE:  This function is used to set a rule(the rule will be set
 *           for one device only).
 * INPUT:    param_p, handler
 * OUTPUT:   None
 * RETURN:   TRUE/FALSE.
 * NOTE:
 *------------------------------------------------------------------------------
 */
static BOOL_T
_rule_ctrl_set_rule(
    RULE_CTRL_PARAM_PTR    param_p,
    RULE_CTRL_HANDLER      handler)
{
    UI32_T      module_id, device_id, phy_port;
    UI32_T      group_id;
    int         rule_pri;
    char        *tag;

    if (RULE_CTRL_INVALID == param_p->unit && RULE_CTRL_INVALID == param_p->port)
    {
        param_p->flags |= RULE_CTRL_OPT_ALL_DEVICES;
    }

    /*****
     *****
     for RULE_CTRL_OPT_ALL_DEVICES
     *****
     *****/
    if (param_p->flags & RULE_CTRL_OPT_ALL_DEVICES)
    {
        return _rule_ctrl_set_rule_for_all_devices(param_p, handler);
    }

    if (FALSE == DEV_SWDRV_PMGR_Logical2PhyDevicePortID(param_p->unit, param_p->port,
                                                        &module_id, &device_id, &phy_port))
    {
        RULE_CTRL_LOG("DEV_SWDRV_PMGR_Logical2PhyDevicePortID(unit=%lu,port=%lu)",
                      param_p->unit, param_p->port);
        return FALSE;
    }

    if (FALSE == handler(param_p))
    {
        return FALSE;
    }

    if (param_p->flags & RULE_CTRL_OPT_ABORT)
    {
        RULE_CTRL_LOG("Nothing changed, aborting process");
        return TRUE;
    }

    /* show tag for debugging
     */
    tag = RULE_CTRL_GetLastTag(param_p);
    RULE_CTRL_LOG(" %s", tag ? tag : "no-tag");

    if (FALSE == RULE_CTRL_GetFunctionInfoByFunctionType(param_p->func_type, &group_id, &rule_pri))
    {
        RULE_CTRL_LOG("RULE_CTRL_GetFunctionInfoByFunctionType(func_type=%d)",
                      param_p->func_type);
        return FALSE;
    }

    if (param_p->flags & RULE_CTRL_OPT_INSTALL)
    {
        if (NULL == param_p->rule_storage_p)
        {
            RULE_CTRL_LOG("param_p->rule_storage_p is NULL");
            return FALSE;
        }

        if (param_p->rule_storage_p->is_enable)
        {
            if (param_p->flags & RULE_CTRL_OPT_FORCE_INSTALL)
            {
                if (FALSE == RULE_CTRL_DESTROY_RULE(param_p->unit,
                                                    param_p->port,
                                                    device_id,
                                                    group_id,
                                                    param_p->func_type,
                                                    param_p->rule_storage_p->rule_id))
                {
                    RULE_CTRL_LOG("RULE_CTRL_Destroy_Rule"
                                  "(unit=%lu,port=%lu,device_id=%lu,group_id=%lu,rule_id=%lu",
                                  param_p->unit,
                                  param_p->port,
                                  device_id,
                                  group_id,
                                  param_p->rule_storage_p->rule_id);
                    return FALSE;
                }

                RULE_CTRL_RemoveRuleFromLookupTable(param_p->unit, param_p->port, device_id, group_id, param_p->rule_storage_p->rule_id/*, param_p, handler*/);

                param_p->rule_storage_p->is_enable = FALSE;
                param_p->rule_storage_p->rule_id   = 0;

                if (FALSE == RULE_CTRL_RequestRuleByQuota(param_p->unit, device_id, param_p->func_type,
                                                          RULE_CTRL_REQUEST_RESOURCE_FREE,
                                                          1))
                {
                    RULE_CTRL_LOG("RULE_CTRL_RequestRuleByQuota failed\n");
                    return FALSE;
                }
            }
            else
            {
                return TRUE;
            }
        }

        if (FALSE == RULE_CTRL_RequestRuleByQuota(param_p->unit, device_id, param_p->func_type,
                                                  RULE_CTRL_REQUEST_RESOURCE_ALLOCATE_TEST,
                                                  1))
        {
            LOG("RULE_CTRL_RequestRuleByQuota failed\n");
            return FALSE;
        }

        /* TODO: Check lookup table before allocate a rule
         */
        if (FALSE == RULE_CTRL_ALLOCATE_RULE(param_p->unit,
                                             param_p->port,
                                             device_id,
                                             group_id,
                                             param_p->func_type,
                                             rule_pri,
                                             &param_p->rule_storage_p->rule_id))
        {
            RULE_CTRL_LOG("RULE_CTRL_Allocate_Rule(unit=%lu,port=%lu,device_id=%lu,group_id=%lu,rule_pri=%d",
                          param_p->unit,
                          param_p->port,
                          device_id,
                          group_id,
                          rule_pri);
            return FALSE;
        }

        if (FALSE == RULE_CTRL_SET_RULE(param_p->unit,
                                        param_p->port,
                                        device_id,
                                        group_id,
                                        param_p->rule_storage_p->rule_id,
                                        &param_p->ace_entry,
                                        (param_p->meter_enabled) ? &param_p->meter_entry : NULL,
                                        &param_p->action_entries[0],
                                        param_p->counter_enabled))
        {
            RULE_CTRL_LOG("Fail to RULE_CTRL_Set_Rule(unit=%lu,port=%lu,device_id=%lu,group_id=%lu,rule_id=%lu)",
                          param_p->unit, param_p->port, device_id, group_id,
                          param_p->rule_storage_p->rule_id);
            return FALSE;
        }

        if (FALSE == RULE_CTRL_RequestRuleByQuota(param_p->unit, device_id, param_p->func_type,
                                                  RULE_CTRL_REQUEST_RESOURCE_ALLOCATE,
                                                  1))
        {
            RULE_CTRL_LOG("RULE_CTRL_RequestRuleByQuota failed\n");
            return FALSE;
        }

        param_p->rule_storage_p->is_enable = TRUE;

        RULE_CTRL_AddRuleToLookupTable(param_p->unit, param_p->port, device_id, group_id, param_p->rule_storage_p->rule_id, param_p, handler);

    }
    else
    {
        if (NULL == param_p->rule_storage_p || !param_p->rule_storage_p->is_enable)
        {
            return TRUE;
        }

        if (FALSE == RULE_CTRL_DESTROY_RULE(param_p->unit,
                                            param_p->port,
                                            device_id,
                                            group_id,
                                            param_p->func_type,
                                            param_p->rule_storage_p->rule_id))
        {
            RULE_CTRL_LOG("RULE_CTRL_Destroy_Rule"
                          "(unit=%lu,port=%lu,device_id=%lu,group_id=%lu,rule_id=%lu",
                          param_p->unit,
                          param_p->port,
                          device_id,
                          group_id,
                          param_p->rule_storage_p->rule_id);
            return FALSE;
        }

        RULE_CTRL_RemoveRuleFromLookupTable(param_p->unit, param_p->port, device_id, group_id, param_p->rule_storage_p->rule_id/*, param_p, handler*/);

        param_p->rule_storage_p->is_enable = FALSE;
        param_p->rule_storage_p->rule_id   = 0;

        if (FALSE == RULE_CTRL_RequestRuleByQuota(param_p->unit, device_id,
                                                  param_p->func_type,
                                                  RULE_CTRL_REQUEST_RESOURCE_FREE,
                                                  1))
        {
            RULE_CTRL_LOG("RULE_CTRL_RequestRuleByQuota failed\n");
            return FALSE;
        }
    }

    param_p->flags |= RULE_CTRL_OPT_RES_SUCCEEDED;

    if (param_p->callback)
    {
        param_p->callback(param_p);
    }

    return TRUE;
}

static void
RULE_CTRL_GetTcamPoolCapabilityBitMap(
    UI32_T pool_id,
    RULE_TYPE_TCAM_CAP_BITMAP_T *bit_map_p)
{
    RULE_TYPE_TCAM_Capability_T function_type_to_tcam_cap[] =
    {
#define RULE_TYPE_FUNCTION_TYPE_CAP_MAPING(name, string, tcam_cap) tcam_cap,
        RULE_TYPE_FUNCTION_TYPE_LIST(RULE_TYPE_FUNCTION_TYPE_CAP_MAPING)
#undef RULE_TYPE_FUNCTION_TYPE_CAP_MAPING
    };

    UI32_T idx;

    ASSERT(bit_map_p != NULL);
    LOG("pool_id = %lu", pool_id);

    memset(bit_map_p, 0, sizeof(*bit_map_p));

    for (idx = 0; idx < FP_CONFIG_NumberOfFunctionType(); idx++)
    {
        FP_CONFIG_FunctionInfo_T    *fun_info_p = FP_CONFIG_GetFunctionInfo(idx);
        FP_CONFIG_GroupInfo_T       *grp_info_p;
        RULE_TYPE_TCAM_Capability_T tcam_cap;

        if(NULL == fun_info_p)
        {
            continue;
        }

        grp_info_p = FP_CONFIG_get_group_info_by_id(fun_info_p->group_id);
        if (NULL == grp_info_p || pool_id != grp_info_p->group_id)
        {
            continue;
        }

        tcam_cap = function_type_to_tcam_cap[fun_info_p->function_type];

        if (tcam_cap != RULE_TYPE_TCAM_CAP_RESERVED)
        {
            RULE_CTRL_SET_BIT_ON(bit_map_p->bits, tcam_cap);
        }
    }

    {
        /* If bitmap = 0, set the capability = RULE_TYPE_TCAM_CAP_RESERVED
         */
        int i;
        UI8_T cap_check = 0;

        for (i = 0; i < RULE_TYEP_TCAM_CAP_MAX_BITMAP_SIZE; ++i)
        {
            cap_check |= bit_map_p->bits[i];
        }

        if (0 == cap_check)
        {
            RULE_CTRL_SET_BIT_ON(bit_map_p->bits, RULE_TYPE_TCAM_CAP_RESERVED);
        }
        else
        {
            RULE_TYPE_TCAM_CAP_BITMAP_T all_bitmap;

            if (RULE_TYPE_OK == RULE_CTRL_GetSupportedTcamCapabilityBitMap(&all_bitmap))
            {
                if (0 == memcmp(&all_bitmap, bit_map_p, sizeof(all_bitmap)))
                {
                    RULE_CTRL_SET_BIT_ON(bit_map_p->bits, RULE_TYPE_TCAM_CAP_ALL);
                }
            }
        }
    }

    return;
}

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_SetMacMirrorEntry
 *------------------------------------------------------------------------------
 * PURPOSE : Add PCEs for MAC based MIRROR
 * INPUT   : mac_address        -- MAC address
 * OUTPUT  : None
 * RETURN  : TRUE - OK / FALSE - FAILED
 * NOTE    : PCE will be added /updated if PCE does not exist /exists.
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_SetMacMirrorEntry(UI8_T *mac_address)
{
    return FALSE;
}/* End of RULE_CTRL_SetMacMirrorEntry() */

/*------------------------------------------------------------------------------
 * FUNCTION NAME - RULE_CTRL_DeleteMacMirrorEntry
 *------------------------------------------------------------------------------
 * PURPOSE : Add PCEs for MAC based MIRROR
 * INPUT   : mac_address        -- MAC address
 * OUTPUT  : None
 * RETURN  : TRUE - OK / FALSE - FAILED
 * NOTE    : PCE will be added /updated if PCE does not exist /exists.
 *------------------------------------------------------------------------------
 */
BOOL_T RULE_CTRL_DeleteMacMirrorEntry(UI8_T *mac_address)
{
    return FALSE;
}/* End of RULE_CTRL_DeleteMacMirrorEntry() */

