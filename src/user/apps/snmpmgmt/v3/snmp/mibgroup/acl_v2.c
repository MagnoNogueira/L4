/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "sys_type.h"
#include "sys_adpt.h"
#include "sys_cpnt.h"

#if (SYS_CPNT_3COM_CLI == TRUE)
#include "sys_imghdr.h"
#endif

#include "sysfun.h"
#include "vlan_mgr.h"
#include "vlan_pmgr.h"
#include "vlan_pom.h"
#include "netcfg_type.h"
#include "stktplg_pmgr.h"
#include "stktplg_pom.h"
#include "stkctrl_task.h"
#include "swctrl_pom.h"
#include "swctrl_pmgr.h"
#include "acl_v2.h"
#include "amtr_pmgr.h"
#include "sys_pmgr.h"
#include "sys_dflt.h"
#include "leaf_sys.h"
#include "swctrl.h"
#include "trk_pmgr.h"
#include "telnet_pmgr.h"
#include "telnet_pom.h"
#include "lacp_pmgr.h"
#include "lacp_pom.h"
#include "ip_lib.h"
#include "ping_pom.h"
#include "ping_pmgr.h"

#include "sysfun.h"
#include  "xfer_pmgr.h"
#include "fs.h"
#include "fs_type.h"
//#include "igmpsnp_pmgr.h"

#if (SYS_CPNT_HTTPS == TRUE)
 #include "http_type.h"
#endif

#include "http_mgr.h"
#include "http_pmgr.h"
#include"dhcp_pmgr.h"

#if defined(ROOT_PVLAN)
  #include "pvlan_mgr.h"
#endif

#if (SYS_CPNT_COS == TRUE)
  #include "l4_pmgr.h"
  #include "cos_vm.h"
#endif

#include "snmp_mgr.h"
#if (SYS_CPNT_QOS == SYS_CPNT_QOS_MARKER)
  #include "l4_marker_mgr.h"
#endif

#if (SYS_CPNT_ACL == TRUE)
 #if(SYS_CPNT_QOS_V2 == TRUE)
  #include "l4_pmgr.h"
 #else
 #include "l4_acl_mgr.h"
#endif
#endif
#include "l_stdlib.h"

#if (SYS_CPNT_HSRP == TRUE)
    #include "Hsrp_mgr.h"
    #include "hsrp_sys_adpt.h"
#endif

#include "snmp_type.h"
#if (SYS_CPNT_QOS_V2 == TRUE)
#include "l4_pmgr.h"
#include "rule_type.h"
#endif
#if(SYS_CPNT_NETACCESS == TRUE)
#include "netaccess_pmgr.h"
#include "netaccess_type.h"
#endif

#include "userauth.h"
#include "leaf_es3626a.h"

#if ((SYS_CPNT_ACL == TRUE) && (SYS_CPNT_QOS_V2 == TRUE))

#define aclAceEntry_INSTANCE_LEN 1

/********************************************
 **************aclIpAceTable*****************
 ********************************************
 */

static BOOL_T 
aclIpAceTable_get(
   int  compc,
   oid  *compl,
   UI32_T  *ace_index,
   RULE_TYPE_UI_Ace_Entry_T *ace_p)
{
    if(compc != aclAceEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    memset(ace_p, 0, sizeof(*ace_p));
    *ace_index=compl[0];

    if(L4_PMGR_QoS_GetDiffServIpAceEntry(*ace_index, ace_p)!= RULE_TYPE_OK)
    {
        return FALSE;
    }
    
    return TRUE;
}

static BOOL_T 
aclIpAceTable_next(
    int  compc,
    oid  *compl,
    UI32_T  *ace_index,
    RULE_TYPE_UI_Ace_Entry_T *ace_p)
{
    memset(ace_p, 0, sizeof(*ace_p));

    if(compc == 0)
    {
        *ace_index = 0;
        if(L4_PMGR_QoS_GetDiffServIpAceEntry(*ace_index, ace_p) != RULE_TYPE_OK)
        {
            if(L4_PMGR_QoS_GetNextDiffServIpAceEntry(ace_index, ace_p) != RULE_TYPE_OK)
                return FALSE;
        }
    }
    else if(compc == aclAceEntry_INSTANCE_LEN)
    {
        *ace_index = compl[0];
        if(L4_PMGR_QoS_GetNextDiffServIpAceEntry(ace_index, ace_p) != RULE_TYPE_OK)
        {
            return FALSE;
        }
    }

    return TRUE;
}

/*
 * var_aclIpAceTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */

unsigned char  *
var_aclIpAceTable(struct variable *vp,
                  oid * name,
                  size_t * length,
                  int exact,
                  size_t * var_len,
                  WriteMethod ** write_method)
{
    /* variables we may use later */
    UI32_T  compc=0;
    UI32_T  index=0;
    oid  compl[aclAceEntry_INSTANCE_LEN];
    oid  next_inst[aclAceEntry_INSTANCE_LEN];
    RULE_TYPE_UI_Ace_Entry_T ace;

    switch (vp->magic)
    {
      case ACLIPACESOURCEIPADDR:
        *write_method = write_aclIpAceSourceIpAddr;
        break;
      case ACLIPACESOURCEIPADDRBITMASK:
        *write_method = write_aclIpAceSourceIpAddrBitmask;
        break;
      case ACLIPACEDESTIPADDR:
        *write_method = write_aclIpAceDestIpAddr;
        break;
      case ACLIPACEDESTIPADDRBITMASK:
        *write_method = write_aclIpAceDestIpAddrBitmask;
        break;
      case ACLIPACEPROTOCOL:
        *write_method = write_aclIpAceProtocol;
        break;
      case ACLIPACEPREC:
        *write_method = write_aclIpAcePrec;
        break;
      case ACLIPACETOS:
        *write_method = write_aclIpAceTos;
        break;
      case ACLIPACEDSCP:
        *write_method = write_aclIpAceDscp;
        break;
      case ACLIPACESOURCEPORTOP:
        *write_method = write_aclIpAceSourcePortOp;
        break;
      case ACLIPACEMINSOURCEPORT:
        *write_method = write_aclIpAceMinSourcePort;
        break;
      case ACLIPACEMAXSOURCEPORT:
        *write_method = write_aclIpAceMaxSourcePort;
        break;
      case ACLIPACESOURCEPORTBITMASK:
        *write_method = write_aclIpAceSourcePortBitmask;
        break;
      case ACLIPACEDESTPORTOP:
        *write_method = write_aclIpAceDestPortOp;
        break;
      case ACLIPACEMINDESTPORT:
        *write_method = write_aclIpAceMinDestPort;
        break;
      case ACLIPACEMAXDESTPORT:
        *write_method = write_aclIpAceMaxDestPort;
        break;
      case ACLIPACEDESTPORTBITMASK:
        *write_method = write_aclIpAceDestPortBitmask;
        break;
      case ACLIPACECONTROLCODE:
        *write_method = write_aclIpAceControlCode;
        break;
      case ACLIPACECONTROLCODEBITMASK:
        *write_method = write_aclIpAceControlCodeBitmask;
        break;
     case ACLIPACESTATUS:
        *write_method = write_aclIpAceStatus;
        break;
    default:
        *write_method = 0;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,
        aclAceEntry_INSTANCE_LEN);

    /*get entry */
    if (exact)/*get,set*/
    {
        if(aclIpAceTable_get(compc, compl, &index, &ace) != TRUE)
            return NULL;
    }
    else  /*getnext*/
    {
        if(aclIpAceTable_next(compc, compl, &index, &ace) != TRUE)
            return NULL;
     }

    next_inst[0]=index;
    memcpy (name, vp->name, ( vp->namelen) * sizeof (oid));
    memcpy(name + vp->namelen, next_inst, (aclAceEntry_INSTANCE_LEN)*sizeof(oid));
    *length = vp->namelen + aclAceEntry_INSTANCE_LEN;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    *var_len = 4;
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
        case ACLIPACEINDEX:
            long_return =index;
            return (u_char *) &long_return;
#endif
        case ACLIPACESOURCEIPADDR:
            {
                /* net byte order -> host byte order */
                UI32_T *ip_addr = (UI32_T *)& ace.ipv4.sip.addr;

                long_return = L_STDLIB_Ntoh32(*ip_addr);
            }
            return (u_char *) &long_return;
        case ACLIPACESOURCEIPADDRBITMASK:
            {
                /* net byte order -> host byte order */
                UI32_T *ip_mask = (UI32_T *)& ace.ipv4.sip.mask;

                long_return= L_STDLIB_Ntoh32(*ip_mask);
            }
            return (u_char *) &long_return;
        case ACLIPACEDESTIPADDR:
            {
                /* net byte order -> host byte order */
                UI32_T *ip_addr = (UI32_T *)& ace.ipv4.dip.addr;

                long_return = L_STDLIB_Ntoh32(*ip_addr);
            }
            return (u_char *) &long_return;
        case ACLIPACEDESTIPADDRBITMASK:
            {
                /* net byte order -> host byte order */
                UI32_T *ip_mask = (UI32_T *)& ace.ipv4.dip.mask;

                long_return= L_STDLIB_Ntoh32(*ip_mask);
            }
            return (u_char *) &long_return;
        case ACLIPACEPROTOCOL:
            long_return = ace.ipv4.protocol.u.s.data;
            return (u_char *) &long_return;
        case ACLIPACEPREC:
            long_return = ace.ipv4.dscp.u.tos.precedence;
            return (u_char *) &long_return;
        case ACLIPACETOS:
            long_return = ace.ipv4.dscp.u.tos.tos;
            return (u_char *) &long_return;
        case ACLIPACEDSCP:
            long_return = ace.ipv4.dscp.u.ds;
            return (u_char *) &long_return;
        case ACLIPACESOURCEPORTOP:
            long_return = ace.l4_common.sport.op;
            return (u_char *) &long_return;
        case ACLIPACEMINSOURCEPORT:
            long_return = (VAL_diffServIpAceSourcePortOp_range == ace.l4_common.sport.op) 
                          ? ace.l4_common.sport.u.range.min : ace.l4_common.sport.u.s.data;
            return (u_char *) &long_return;
        case ACLIPACEMAXSOURCEPORT:
            long_return = ace.l4_common.sport.u.range.max;
            return (u_char *) &long_return;
        case ACLIPACESOURCEPORTBITMASK:
            long_return = ace.l4_common.sport.u.s.mask;
            return (u_char *) &long_return;
        case ACLIPACEDESTPORTOP:
            long_return = ace.l4_common.dport.op;
            return (u_char *) &long_return;
        case ACLIPACEMINDESTPORT:
            long_return = (VAL_diffServIpAceDestPortOp_range == ace.l4_common.dport.op) 
                          ? ace.l4_common.dport.u.range.min : ace.l4_common.dport.u.s.data;
            return (u_char *) &long_return;
        case ACLIPACEMAXDESTPORT:
            long_return = ace.l4_common.dport.u.range.max;
            return (u_char *) &long_return;
        case ACLIPACEDESTPORTBITMASK:
            long_return = ace.l4_common.dport.u.s.mask;
            return (u_char *) &long_return;
        case ACLIPACECONTROLCODE:
            long_return = ace.tcp.flags.data.u.code;
            return (u_char *) &long_return;
        case ACLIPACECONTROLCODEBITMASK:
            long_return = ace.tcp.flags.mask.u.code;
            return (u_char *) &long_return;
        case ACLIPACESTATUS:
            long_return = ace.row_status;
            return (u_char *) &long_return;
        default:
            ERROR_MSG("");
    }
    return NULL;
}

int
write_aclIpAceSourceIpAddr(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value=0;
    UI32_T  index;

     /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLIPACESOURCEIPADDR)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: check if the input index is exactly match, if not return fail*/
    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to aclIpAceEntry*/
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
            index = name[oid_name_length];
            memcpy(&value,var_val,sizeof(UI32_T));
            if (L4_PMGR_QoS_SetDiffServIpAceSourceIpAddr(index, value)!=TRUE)
            {
                 return SNMP_ERR_COMMITFAILED;
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIpAceSourceIpAddrBitmask(int action,
                                  u_char * var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char * statP,
                                  oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value=0;
    UI32_T  index;

     /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLIPACESOURCEIPADDRBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: check if the input index is exactly match, if not return fail*/
    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclIpAceEntry*/
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
            index = name[oid_name_length];
            memcpy(&value,var_val,sizeof(UI32_T));
            if (L4_PMGR_QoS_SetDiffServIpAceSourceIpAddrBitmask(index, value)!=TRUE)
            {
                 return SNMP_ERR_COMMITFAILED;
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIpAceDestIpAddr(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value=0;
    UI32_T  index;

     /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLIPACEDESTIPADDR)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: check if the input index is exactly match, if not return fail*/
    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to aclIpAceEntry*/

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
            index = name[oid_name_length];
            memcpy(&value,var_val,sizeof(UI32_T));
            if (L4_PMGR_QoS_SetDiffServIpAceDestIpAddr(index, value)!=TRUE)
            {
                 return SNMP_ERR_COMMITFAILED;
            }
           break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }

    return SNMP_ERR_NOERROR;
}

int
write_aclIpAceDestIpAddrBitmask(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value=0;
    UI32_T  index;

     /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLIPACEDESTIPADDRBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: check if the input index is exactly match, if not return fail*/
    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        /* In reserve2, we overwrite the set value to aclIpAceEntry*/
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
            index = name[oid_name_length];
            memcpy(&value,var_val,sizeof(UI32_T));
            if (L4_PMGR_QoS_SetDiffServIpAceDestIpAddrBitmask(index, value)!=TRUE)
            {
                 return SNMP_ERR_COMMITFAILED;
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIpAceProtocol(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value=0;
    UI32_T  index;

     /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLIPACEPROTOCOL)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: check if the input index is exactly match, if not return fail*/
    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to aclIpAceEntry*/
          if ((*(long *)var_val < MIN_aclIpAceProtocol) || (*(long *)var_val> MAX_aclIpAceProtocol))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
            index = name[oid_name_length];
            value = *(long *)var_val;
            if (L4_PMGR_QoS_SetDiffServIpAceProtocol(index, value)!=TRUE)
            {
                 return SNMP_ERR_COMMITFAILED;
            }

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIpAcePrec(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value=0;
    UI32_T  index;

     /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLIPACEPREC)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: check if the input index is exactly match, if not return fail*/
    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclIpAceEntry*/
          if ((*(long *)var_val < MIN_aclIpAcePrec) || (*(long *)var_val> MAX_aclIpAcePrec))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
            index = name[oid_name_length];
            value = *(long *)var_val;
            if (L4_PMGR_QoS_SetDiffServIpAcePrec(index, value)!=TRUE)
            {
                 return SNMP_ERR_COMMITFAILED;
            }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIpAceTos(int action,
                  u_char * var_val,
                  u_char var_val_type,
                  size_t var_val_len,
                  u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value=0;
    UI32_T  index;

     /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLIPACETOS)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: check if the input index is exactly match, if not return fail*/
    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

           /* In reserve2, we overwrite the set value to aclIpAceEntry*/
          if ((*(long *)var_val< MIN_aclIpAceTos) || (*(long *)var_val> MAX_aclIpAceTos))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
            index = name[oid_name_length];
            value = *(long *)var_val;
            if (L4_PMGR_QoS_SetDiffServIpAceTos(index, value)!=TRUE)
            {
                 return SNMP_ERR_COMMITFAILED;
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIpAceDscp(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value=0;
    UI32_T  index;

     /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLIPACEDSCP)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: check if the input index is exactly match, if not return fail*/
    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to aclIpAceEntry*/

          if ((*(long *)var_val< MIN_aclIpAceDscp) || (*(long *)var_val> MAX_aclIpAceDscp))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
            index = name[oid_name_length];
            value = *(long *)var_val;
            if (L4_PMGR_QoS_SetDiffServIpAceDscp(index, value)!=TRUE)
            {
                 return SNMP_ERR_COMMITFAILED;
            }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_aclIpAceSourcePortOp(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value=0;
    UI32_T  index;

     /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLIPACESOURCEPORTOP)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: check if the input index is exactly match, if not return fail*/
    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclIpAceEntry*/
          if ((*(long *)var_val< VAL_aclIpAceSourcePortOp_noOperator) || (*(long *)var_val> VAL_aclIpAceSourcePortOp_range))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
            index = name[oid_name_length];
            value = *(long *)var_val;
            if (L4_PMGR_QoS_SetDiffServIpAceSourcePortOp(index, value)!=TRUE)
            {
                 return SNMP_ERR_COMMITFAILED;
            }
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIpAceMinSourcePort(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value=0;
    UI32_T  index;

     /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLIPACEMINSOURCEPORT)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: check if the input index is exactly match, if not return fail*/
    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

           /* In reserve2, we overwrite the set value to aclIpAceEntry*/
          if ((*(long *)var_val< MIN_aclIpAceMinSourcePort) || (*(long *)var_val > MAX_aclIpAceMinSourcePort))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
            index = name[oid_name_length];
            value = *(long *)var_val;
            if (L4_PMGR_QoS_SetDiffServIpAceMinSourcePort(index, value)!=TRUE)
                 return SNMP_ERR_COMMITFAILED;
            break;

             case UNDO:
                  /* Back out any changes made in the ACTION case */
               break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIpAceMaxSourcePort(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value=0;
    UI32_T  index;

     /* For the OCTET index function, here we should do some check to prevent crash*/

    if ((char) name[oid_name_length-1] != ACLIPACEMAXSOURCEPORT)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: check if the input index is exactly match, if not return fail*/
    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

           /* In reserve2, we overwrite the set value to aclIpAceEntry*/
          if ((*(long *)var_val < MIN_aclIpAceMaxSourcePort) || (*(long *)var_val > MAX_aclIpAceMaxSourcePort))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
            index = name[oid_name_length];
            value = *(long *)var_val;
            if (L4_PMGR_QoS_SetDiffServIpAceMaxSourcePort(index, value)!=TRUE)
                 return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIpAceSourcePortBitmask(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value=0;
    UI32_T  index;

     /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLIPACESOURCEPORTBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: check if the input index is exactly match, if not return fail*/
    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

           /* In reserve2, we overwrite the set value to aclIpAceEntry*/
          if ((*(long *)var_val < MIN_aclIpAceSourcePortBitmask) || (*(long *)var_val > MAX_aclIpAceSourcePortBitmask))
              return SNMP_ERR_WRONGVALUE;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
            index = name[oid_name_length];
            value = *(long *)var_val;
            if (L4_PMGR_QoS_SetDiffServIpAceSourcePortBitmask(index, value)!=TRUE)
            {
                 return SNMP_ERR_COMMITFAILED;
            }

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIpAceDestPortOp(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value=0;
    UI32_T  index;

     /* For the OCTET index function, here we should do some check to prevent crash*/

    if ((char) name[oid_name_length-1] != ACLIPACEDESTPORTOP)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: check if the input index is exactly match, if not return fail*/
    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

           /* In reserve2, we overwrite the set value to aclIpAceEntry*/
          if ((*(long *)var_val < VAL_aclIpAceDestPortOp_noOperator) || (*(long *)var_val > VAL_aclIpAceDestPortOp_range))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */

            index = name[oid_name_length];
            value = *(long *)var_val;
            if (L4_PMGR_QoS_SetDiffServIpAceDestPortOp(index, value)!=TRUE)
            {
                 return SNMP_ERR_COMMITFAILED;
            }

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_aclIpAceMinDestPort(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value=0;
    UI32_T  index;

     /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLIPACEMINDESTPORT)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: check if the input index is exactly match, if not return fail*/
    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

           /* In reserve2, we overwrite the set value to aclIpAceEntry*/
          if ((*(long *)var_val < MIN_aclIpAceMinDestPort) || (*(long *)var_val > MAX_aclIpAceMinDestPort))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */

            index = name[oid_name_length];
            value = *(long *)var_val;
            if ( L4_PMGR_QoS_SetDiffServIpAceMinDestPort(index, value)!=TRUE)
                 return SNMP_ERR_COMMITFAILED;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_aclIpAceMaxDestPort(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value=0;
    UI32_T  index;

     /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLIPACEMAXDESTPORT)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: check if the input index is exactly match, if not return fail*/
    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclIpAceEntry*/
          if ((*(long *)var_val< MIN_aclIpAceMaxDestPort) || (*(long *)var_val > MAX_aclIpAceMaxDestPort))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */

            index = name[oid_name_length];
            value = *(long *)var_val;
            if ( L4_PMGR_QoS_SetDiffServIpAceMaxDestPort(index, value)!=TRUE)
                 return SNMP_ERR_COMMITFAILED;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_aclIpAceDestPortBitmask(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value=0;
    UI32_T  index;

     /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLIPACEDESTPORTBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: check if the input index is exactly match, if not return fail*/
    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclIpAceEntry*/
          if ((*(long *)var_val < MIN_aclIpAceDestPortBitmask) || (*(long *)var_val > MAX_aclIpAceDestPortBitmask))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */

            index = name[oid_name_length];
            value = *(long *)var_val;
            if (L4_PMGR_QoS_SetDiffServIpAceDestPortBitmask(index, value)!=TRUE)
            {
                 return SNMP_ERR_COMMITFAILED;
            }

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_aclIpAceControlCode(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value=0;
    UI32_T  index;

     /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLIPACECONTROLCODE)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: check if the input index is exactly match, if not return fail*/
    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclIpAceEntry*/
          if ((*(long *)var_val < MIN_aclIpAceControlCode) || (*(long *)var_val > MAX_aclIpAceControlCode))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
            index = name[oid_name_length];
            value = *(long *)var_val;
            if (L4_PMGR_QoS_SetDiffServIpAceControlCode(index, value)!=TRUE)
            {
                 return SNMP_ERR_COMMITFAILED;
            }

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_aclIpAceControlCodeBitmask(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value=0;
    UI32_T  index;

     /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLIPACECONTROLCODEBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: check if the input index is exactly match, if not return fail*/
    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclIpAceEntry*/
          if ((*(long *)var_val < MIN_aclIpAceControlCodeBitmask) || (*(long *)var_val > MAX_aclIpAceControlCodeBitmask))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */

            index = name[oid_name_length];
            value = *(long *)var_val;
            if (L4_PMGR_QoS_SetDiffServIpAceControlCodeBitmask(index, value)!=TRUE)
            {
                 return SNMP_ERR_COMMITFAILED;
            }

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_aclIpAceStatus(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value=0;
    UI32_T  index;

     /* For the OCTET index function, here we should do some check to prevent crash*/

    if ((char) name[oid_name_length-1] != ACLIPACESTATUS)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 2: check if the input index is exactly match, if not return fail*/
    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long))
          {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
           /* In reserve2, we overwrite the set value to aclIpAceEntry*/
          if ((*(long *)var_val < VAL_aclIpAceStatus_active) || (*(long *)var_val > VAL_aclIpAceStatus_destroy))
              return SNMP_ERR_WRONGVALUE;
          else if (*(long *)var_val == VAL_aclIpAceStatus_notReady)
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

            index = name[oid_name_length];
            value = *(long *)var_val;
            if (L4_PMGR_QoS_SetDiffServIpAceStatus(index, value)!=TRUE)
            {
                 return SNMP_ERR_COMMITFAILED;
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }

    return SNMP_ERR_NOERROR;
}


/********************************************
 **************aclMacAceTable****************
 ********************************************
 */
static BOOL_T 
aclMacAceTable_get(
    int  compc,
    oid  *compl,
    UI32_T  *ace_index,
    RULE_TYPE_UI_Ace_Entry_T *ace_p)
{
    if (compc!=aclAceEntry_INSTANCE_LEN)
    {
        return FALSE;
    }

    memset(ace_p, 0, sizeof(*ace_p));
    *ace_index=compl[0];

    if(L4_PMGR_QoS_GetDiffServMacAceEntry(*ace_index, ace_p)!= RULE_TYPE_OK)
    {
        return FALSE;
    }

    return TRUE;
}

static BOOL_T 
aclMacAceTable_next(
    int  compc,
    oid  *compl,
    UI32_T  *ace_index,
    RULE_TYPE_UI_Ace_Entry_T *ace_p)
{
    memset(ace_p, 0, sizeof(*ace_p));

    if(compc==0)
    {
        *ace_index=0;
        if(L4_PMGR_QoS_GetDiffServMacAceEntry(*ace_index, ace_p)!= RULE_TYPE_OK)
        {
            if(L4_PMGR_QoS_GetNextDiffServMacAceEntry(ace_index, ace_p)!= RULE_TYPE_OK)
            {
                return FALSE;
            }
        }
    }
    else if(compc == aclAceEntry_INSTANCE_LEN)
    {
        *ace_index = compl[0];
        if(L4_PMGR_QoS_GetNextDiffServMacAceEntry(ace_index, ace_p)!= RULE_TYPE_OK)
        {
            return FALSE;
        }
    }

    return TRUE;
}

/*
 * var_aclMacAceTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */

unsigned char  *
var_aclMacAceTable(struct variable *vp,
                      oid * name,
                      size_t * length,
                      int exact,
                      size_t * var_len,
                      WriteMethod ** write_method)
{
    /* variables we may use later */
    UI32_T  compc=0;
    UI32_T  index=0;
    oid  compl[aclAceEntry_INSTANCE_LEN];
    oid  next_inst[aclAceEntry_INSTANCE_LEN];
    RULE_TYPE_UI_Ace_Entry_T ace;

    switch (vp->magic)
    {
        case ACLMACACEPKTFORMAT:
            *write_method = write_aclMacAcePktformat;
            break;
        case ACLMACACESOURCEMACADDR:
            *write_method = write_aclMacAceSourceMacAddr;
            break;
        case ACLMACACESOURCEMACADDRBITMASK:
            *write_method = write_aclMacAceSourceMacAddrBitmask;
            break;
        case ACLMACACEDESTMACADDR:
            *write_method = write_aclMacAceDestMacAddr;
            break;
        case ACLMACACEDESTMACADDRBITMASK:
            *write_method = write_aclMacAceDestMacAddrBitmask;
            break;
        case ACLMACACEVIDOP:
            *write_method = write_aclMacAceVidOp;
            break;
        case ACLMACACEMINVID:
            *write_method = write_aclMacAceMinVid;
            break;
        case ACLMACACEVIDBITMASK:
            *write_method = write_aclMacAceVidBitmask;
            break;
        case ACLMACACEMAXVID:
            *write_method = write_aclMacAceMaxVid;
            break;
        case ACLMACACEETHERTYPEOP:
            *write_method = write_aclMacAceEtherTypeOp;
            break;
        case ACLMACACEETHERTYPEBITMASK:
            *write_method = write_aclMacAceEtherTypeBitmask;
            break;
        case ACLMACACEMINETHERTYPE:
            *write_method = write_aclMacAceMinEtherType;
            break;
        case ACLMACACEMAXETHERTYPE:
            *write_method = write_aclMacAceMaxEtherType;
            break;
        case ACLMACACESTATUS:
            *write_method = write_aclMacAceStatus;
            break;
        default:
            *write_method = 0;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,aclAceEntry_INSTANCE_LEN);

    /*get entry */
    if (exact)/*get,set*/
    {
        if(aclMacAceTable_get(compc,compl,&index, &ace)!=TRUE)
            return NULL;
    }
    else  /*getnext*/
    {
        if(aclMacAceTable_next(compc,compl,&index, &ace)!=TRUE)
            return NULL;
    }

    next_inst[0]=index;
    memcpy (name, vp->name, ( vp->namelen) * sizeof (oid));
    memcpy(name + vp->namelen, next_inst, (aclAceEntry_INSTANCE_LEN)*sizeof(oid));
    *length = vp->namelen + aclAceEntry_INSTANCE_LEN;
    /*
     * * this is where we do the value assignments for the mib results.
     */
    *var_len = 4;
    switch (vp->magic)
    {

    #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
          case ACLMACACEINDEX:
           long_return =index;
           return (u_char *) &long_return;
    #endif
          case ACLMACACEPKTFORMAT:
            long_return = ace.pkt_format;
            return (u_char *) &long_return;
          case ACLMACACESOURCEMACADDR:
            memcpy(return_buf, ace.ether.sa.addr,
                SIZE_aclMacAceSourceMacAddr);
            *var_len  =  SIZE_diffServMacAceSourceMacAddr;
            return (u_char*)return_buf;
          case ACLMACACESOURCEMACADDRBITMASK:
            memcpy(return_buf, ace.ether.sa.mask,
                SIZE_aclMacAceSourceMacAddrBitmask);
            *var_len  =  SIZE_diffServMacAceSourceMacAddrBitmask;
            return (u_char*)return_buf;
          case ACLMACACEDESTMACADDR:
            memcpy(return_buf, ace.ether.da.addr,
                SIZE_aclMacAceDestMacAddr);
            *var_len  =  SIZE_diffServMacAceDestMacAddr;
            return (u_char*)return_buf;
          case ACLMACACEDESTMACADDRBITMASK:
            memcpy(return_buf, ace.ether.da.mask,
                SIZE_aclMacAceDestMacAddrBitmask);
            *var_len  =  SIZE_diffServMacAceDestMacAddr;
            return (u_char*)return_buf;
          case ACLMACACEVIDOP:
            long_return = ace.ether.vid.op;
            return (u_char *) &long_return;
          case ACLMACACEMINVID:
            long_return = ace.ether.vid.u.s.data;
            return (u_char *) &long_return;
          case ACLMACACEVIDBITMASK:
            long_return = ace.ether.vid.u.s.mask;
            return (u_char *) &long_return;
          case ACLMACACEMAXVID:
            long_return = ace.ether.vid.u.s.data;
            return (u_char *) &long_return;
          case ACLMACACEETHERTYPEOP:
            long_return = ace.ether.ethertype.op;
            return (u_char *) &long_return;
          case ACLMACACEETHERTYPEBITMASK:
            long_return = ace.ether.ethertype.u.s.mask;
            return (u_char *) &long_return;
          case ACLMACACEMINETHERTYPE:
           long_return = ace.ether.ethertype.u.s.data;
            return (u_char *) &long_return;
          case ACLMACACEMAXETHERTYPE:
            long_return = ace.ether.ethertype.u.s.data;
            return (u_char *) &long_return;
          case ACLMACACESTATUS:
            long_return = ace.row_status;
            return (u_char *) &long_return;
        default:
            ERROR_MSG("");
    }
    return NULL;
}

int
write_aclMacAcePktformat(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value;
    UI32_T  index;

    /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLMACACEPKTFORMAT)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action )
    {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long))
          {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclMacAceEntry*/
          if ((*(long *)var_val < VAL_aclMacAcePktformat_any) || (*(long *)var_val > VAL_aclMacAcePktformat_tagged802Dot3))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */

            index = name[oid_name_length];
            value = *(long *)var_val;
            if( L4_PMGR_QoS_SetDiffServMacAcePktformat(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclMacAceSourceMacAddr(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    UI32_T  index;
    UI8_T buffer[ SIZE_aclMacAceSourceMacAddr+1];
    /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLMACACESOURCEMACADDR)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action )
    {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != SIZE_aclMacAceSourceMacAddr)
          {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclMacAceEntry*/
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */

            index = name[oid_name_length];
            memcpy(buffer, var_val, var_val_len);
            buffer[var_val_len]='\0';
            if( L4_PMGR_QoS_SetDiffServMacAceSourceMacAddr(index, buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclMacAceSourceMacAddrBitmask(int action,
                                    u_char * var_val,
                                    u_char var_val_type,
                                    size_t var_val_len,
                                    u_char * statP,
                                    oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    UI32_T  index;
    UI8_T buffer[SIZE_aclMacAceSourceMacAddrBitmask+1];
    /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLMACACESOURCEMACADDRBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action )
    {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR)
          {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != SIZE_aclMacAceSourceMacAddrBitmask)
          {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclMacAceEntry*/
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */

            index = name[oid_name_length];
            memcpy(buffer, var_val, var_val_len);
            buffer[var_val_len]='\0';
            if(L4_PMGR_QoS_SetDiffServMacAceSourceMacAddrBitmask(index, buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclMacAceDestMacAddr(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    UI32_T  index;
    UI8_T buffer[ SIZE_aclMacAceDestMacAddr+1];
    /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLMACACEDESTMACADDR)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action )
    {
        case RESERVE1:
             if (var_val_type != ASN_OCTET_STR)
             {
                 return SNMP_ERR_WRONGTYPE;
             }
             if (var_val_len != SIZE_aclMacAceDestMacAddr)
             {
                 return SNMP_ERR_WRONGLENGTH;
             }
             break;

        case RESERVE2:
             /* In reserve2, we overwrite the set value to aclMacAceEntry*/
             break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            /* For row creation, if row_status =0, mean that this is a normal
             * operation, we do the normal set operation, otherwise it is a row
             * creation operation, will do nothing here, and the overall entry
             * will perform in the write_xxxRowStatus function.
             */

                 index = name[oid_name_length];
                 memcpy(buffer, var_val, var_val_len);
                 buffer[var_val_len]='\0';
                 if(L4_PMGR_QoS_SetDiffServMacAceDestMacAddr(index, buffer) != TRUE)
                     return SNMP_ERR_COMMITFAILED;

             break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclMacAceDestMacAddrBitmask(int action,
                                  u_char * var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char * statP,
                                  oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    UI32_T  index;
    UI8_T buffer[ SIZE_aclMacAceDestMacAddrBitmask+1];
    /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLMACACEDESTMACADDRBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != SIZE_aclMacAceDestMacAddrBitmask) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to aclMacAceEntry*/
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */

            index = name[oid_name_length];
            memcpy(buffer, var_val, var_val_len);
            buffer[var_val_len]='\0';
            if(L4_PMGR_QoS_SetDiffServMacAceDestMacAddrBitmask(index, buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclMacAceVidOp(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value;
    UI32_T  index;

    /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLMACACEVIDOP)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclMacAceEntry*/
          if ((*(long *)var_val < VAL_aclMacAceVidOp_noOperator) || (*(long *)var_val > VAL_aclMacAceVidOp_range))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */

            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServMacAceVidOp(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclMacAceMinVid(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value;
    UI32_T  index;

    /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLMACACEMINVID)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

           /* In reserve2, we overwrite the set value to aclMacAceEntry*/
          if ((*(long *)var_val < MIN_aclMacAceMinVid) || (*(long *)var_val > MAX_aclMacAceMinVid))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */

            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServMacAceMinVid(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclMacAceVidBitmask(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value;
    UI32_T  index;

    /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLMACACEVIDBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclMacAceEntry*/
          if ((*(long *)var_val < MIN_aclMacAceVidBitmask) || (*(long *)var_val > MAX_aclMacAceVidBitmask))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */

            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServMacAceVidBitmask(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_aclMacAceMaxVid(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value;
    UI32_T  index;

    /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLMACACEMAXVID)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

           /* In reserve2, we overwrite the set value to aclMacAceEntry*/
          if ((*(long *)var_val < MIN_aclMacAceMaxVid) || (*(long *)var_val > MAX_aclMacAceMaxVid))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */

            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServMacAceMaxVid(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclMacAceEtherTypeOp(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value;
    UI32_T  index;

    /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLMACACEETHERTYPEOP)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

           /* In reserve2, we overwrite the set value to aclMacAceEntry*/
          if ((*(long *)var_val < VAL_aclMacAceEtherTypeOp_noOperator) || (*(long *)var_val > VAL_aclMacAceEtherTypeOp_range))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */

            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServMacAceEtherTypeOp(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclMacAceEtherTypeBitmask(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value;
    UI32_T  index;

    /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLMACACEETHERTYPEBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

           /* In reserve2, we overwrite the set value to aclMacAceEntry*/
          if ((*(long *)var_val < MIN_aclMacAceEtherTypeBitmask) || (*(long *)var_val > MAX_aclMacAceEtherTypeBitmask))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */

            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServMacAceEtherTypeBitmask(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_aclMacAceMinEtherType(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value;
    UI32_T  index;

    /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLMACACEMINETHERTYPE)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclMacAceEntry*/
          if ((*(long *)var_val < MIN_aclMacAceMinEtherType) || (*(long *)var_val > MAX_aclMacAceMinEtherType))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */

            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServMacAceMinEtherType(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclMacAceMaxEtherType(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value;
    UI32_T  index;

    /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLMACACEMAXETHERTYPE)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclMacAceEntry*/
          if ((*(long *)var_val < MIN_aclMacAceMaxEtherType) || (*(long *)var_val > MAX_aclMacAceMaxEtherType))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */

            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServMacAceMaxEtherType(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclMacAceStatus(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    long value;
    UI32_T  index;

    /* For the OCTET index function, here we should do some check to prevent crash*/
    if ((char) name[oid_name_length-1] != ACLMACACESTATUS)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    if (name_len!= oid_name_length+aclAceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long)) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclMacAceEntry*/
          if ((*(long *)var_val< VAL_aclMacAceStatus_active) || (*(long*)var_val> VAL_aclMacAceStatus_destroy))
              return SNMP_ERR_WRONGVALUE;
          else if (*(long *)var_val == VAL_aclIpAceStatus_notReady)
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            index = name[oid_name_length];
            value = *(long *)var_val;

            if(L4_PMGR_QoS_SetDiffServMacAceStatus(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
              break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 **************aclAclGroupTable**************
 ********************************************
 */
#define aclGroupEntry_INSTANCE_LEN 1

static BOOL_T aclAclGroupTable_get(UI32_T  preced,
                                int  compc,
                                oid  *compl,
                                UI32_T  *interface,
                                RULE_TYPE_UI_AclEntry_T  *acl_entry)
{
    UI32_T  acl_index=0;
    UI32_T  precedence=0;
    RULE_TYPE_COUNTER_ENABLE_T counter_enable;
    UI16_T  time_range_index;

    if (compc!=aclGroupEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    memset(acl_entry, 0, sizeof(RULE_TYPE_UI_AclEntry_T));
   *interface=compl[0];

    /* FIXIT: aclAclGroupTable_get */
    while(L4_PMGR_ACL_GetNextAclByPort(*interface, RULE_TYPE_INBOUND, &acl_index, acl_entry,&precedence, &time_range_index, &counter_enable)==TRUE)
    {
         if (precedence==preced)
            return TRUE;
    }

    return FALSE;
}

static BOOL_T aclAclGroupTable_next(UI32_T  preced,
                                int  compc,
                                oid  *compl,
                                UI32_T  *interface,
                                RULE_TYPE_UI_AclEntry_T  *acl_entry)
{
    UI16_T time_range_index;

    if(NULL == compl || NULL == interface || NULL == acl_entry)
        return FALSE;

    memset(acl_entry, 0, sizeof(*acl_entry));

    if(0 == compc)
        *interface = 0;
    else if(aclGroupEntry_INSTANCE_LEN == compc)
        *interface = compl[0];
    else
        return FALSE;

    if(RULE_TYPE_OK != L4_PMGR_ACL_GetNextUIAclByPortAndBindingType(preced, interface, acl_entry, &time_range_index))
        return FALSE;

    return TRUE;
}

/*
 * var_aclAclGroupTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_aclAclGroupTable(struct variable *vp,
                     oid * name,
                     size_t * length,
                     int exact,
                     size_t * var_len, WriteMethod ** write_method)
{
    RULE_TYPE_UI_AclEntry_T entry;
    UI32_T interface = 0;
    UI32_T compc=0;
    UI32_T  preced = 0;
    oid compl[aclGroupEntry_INSTANCE_LEN];
    oid  next_inst[aclGroupEntry_INSTANCE_LEN];

    switch (vp->magic)
    {
      case ACLACLGROUPINGRESSIPACL:
           *write_method = write_aclAclGroupIngressIpAcl;
           break;
      case ACLACLGROUPEGRESSIPACL:
           *write_method = write_aclAclGroupEgressIpAcl;
           break;
      case ACLACLGROUPINGRESSMACACL:
           *write_method = write_aclAclGroupIngressMacAcl;
           break;
      case ACLACLGROUPEGRESSMACACL:
           *write_method = write_aclAclGroupEgressMacAcl;
           break;
      default:
           *write_method = 0;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,aclGroupEntry_INSTANCE_LEN);

       switch (vp->magic)
       {
         case ACLACLGROUPINGRESSIPACL:
            preced=INGRESS_IP_ACL_PRECEDENCE;
            break;

         case ACLACLGROUPEGRESSIPACL:
             preced=EGRESS_IP_ACL_PRECEDENCE;
             break;

         case ACLACLGROUPINGRESSMACACL:
             preced=INGRESS_MAC_ACL_PRECEDENCE;
             break;

         case ACLACLGROUPEGRESSMACACL:
             preced=EGRESS_MAC_ACL_PRECEDENCE;
             break;
         default:
             break;
       }

      if (exact)/*get,set*/
      {
          if(aclAclGroupTable_get(preced,compc, compl, &interface, &entry)!=TRUE)
            return NULL;
      }
      else  /*getnext*/
      {
          if(aclAclGroupTable_next(preced,compc, compl, &interface, &entry)!=TRUE)
            return NULL;
      }

      memcpy (name, vp->name, ( vp->namelen) * sizeof (oid));
      next_inst[0]=interface;
      memcpy(name + vp->namelen, next_inst, (aclGroupEntry_INSTANCE_LEN)*sizeof(oid));
      *length = vp->namelen+aclGroupEntry_INSTANCE_LEN;
    /*
     * * this is where we do the value assignments for the mib results.
     */
   *var_len = 4;

    switch (vp->magic)
    {
 #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case ACLACLGROUPIFINDEX:
           long_return = interface;
           return (u_char*) &long_return;
 #endif
      case ACLACLGROUPINGRESSIPACL:
           strcpy((char *)return_buf,(char *)entry.acl_name);
           *var_len = strlen((char *)return_buf);
           return (u_char*) return_buf;

      case ACLACLGROUPEGRESSIPACL:
           strcpy((char *)return_buf,(char *)entry.acl_name);
           *var_len = strlen((char *)return_buf);
           return (u_char*) return_buf;

      case ACLACLGROUPINGRESSMACACL:
           strcpy((char *)return_buf,(char *)entry.acl_name);
           *var_len = strlen((char *)return_buf);
           return (u_char*) return_buf;

      case ACLACLGROUPEGRESSMACACL:
           strcpy((char *)return_buf,(char *)entry.acl_name);
           *var_len = strlen((char *)return_buf);
           return (u_char*) return_buf;

      default:
           ERROR_MSG("");
    }
    return NULL;
}


int
write_aclAclGroupIngressIpAcl(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    char  value[MAXSIZE_aclAclGroupIngressIpAcl+1];
    char  time_range_name[SYS_ADPT_MAX_LENGTH_OF_TIME_ACL_TABLE_NAME+1] = {0};
    int size;
    UI32_T oid_name_length;
    UI32_T index;
    RULE_TYPE_COUNTER_ENABLE_T counter_enable = RULE_TYPE_COUNTER_DISABLE;

    memset(value, 0x0, MAXSIZE_aclAclGroupIngressIpAcl+1);
    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action )
    {
        case RESERVE1:
             if (var_val_type != ASN_OCTET_STR)
             {
                 return SNMP_ERR_WRONGTYPE;
             }
             if (var_val_len > sizeof(UI8_T)*MAXSIZE_aclAclGroupIngressIpAcl)
             {
               return SNMP_ERR_WRONGLENGTH;
             }
             break;

        case RESERVE2:
             size  = var_val_len;
             memcpy(value, var_val, size);
             value[size] = '\0';

             if (!L_STDLIB_StrIsAsciiPrintWithCount((char *)value,size))
             {
                   return SNMP_ERR_WRONGVALUE;
             }
             break;

        case FREE:
             /* Release any resources that have been allocated */
             break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             index=name[oid_name_length];
             size  = var_val_len;
             memcpy(value, var_val, size);
             value[size] ='\0';

             if (L4_PMGR_ACL_BindPort2Acl(index, value, RULE_TYPE_IP_ACL, TRUE, time_range_name, counter_enable)!= TRUE)
                 return SNMP_ERR_COMMITFAILED;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclAclGroupEgressIpAcl(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    char  value[MAXSIZE_aclAclGroupEgressIpAcl+1];
    char  time_range_name[SYS_ADPT_MAX_LENGTH_OF_TIME_ACL_TABLE_NAME+1] = {0};
    int size;
    UI32_T oid_name_length;
    UI32_T index;
    RULE_TYPE_COUNTER_ENABLE_T counter_enable = RULE_TYPE_COUNTER_DISABLE;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(UI8_T)*MAXSIZE_aclAclGroupEgressIpAcl) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          memcpy(value, var_val, size);
          value[size] = '\0';
          if (!L_STDLIB_StrIsAsciiPrintWithCount((char *)value,size))
          {
                   return SNMP_ERR_WRONGVALUE;
          }
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
               index=name[oid_name_length];
               size  = var_val_len;
               memcpy(value, var_val, size);
               value[size] = '\0';

                  if (L4_PMGR_ACL_BindPort2Acl(index, value, RULE_TYPE_IP_ACL, FALSE, time_range_name, counter_enable)!=TRUE)
                    return SNMP_ERR_COMMITFAILED;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclAclGroupIngressMacAcl(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    char  value[MAXSIZE_aclAclGroupIngressMacAcl+1];
    char  time_range_name[SYS_ADPT_MAX_LENGTH_OF_TIME_ACL_TABLE_NAME+1] = {0};
    int size;
    UI32_T oid_name_length;
    UI32_T index;
    RULE_TYPE_COUNTER_ENABLE_T counter_enable = RULE_TYPE_COUNTER_DISABLE;

    memset(value, 0x0, MAXSIZE_aclAclGroupIngressMacAcl+1);
    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(UI8_T)*MAXSIZE_aclAclGroupIngressMacAcl) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          memcpy(value, var_val, size);
          value[size] =  '\0';
          if (!L_STDLIB_StrIsAsciiPrintWithCount((char *)value,size))
          {
                   return SNMP_ERR_WRONGVALUE;
          }
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
               index=name[oid_name_length];
               size  = var_val_len;
               memcpy(value, var_val, size);
               value[size] = '\0';

               if (L4_PMGR_ACL_BindPort2Acl(index, value, RULE_TYPE_MAC_ACL, TRUE, time_range_name, counter_enable)!=TRUE)
                   return SNMP_ERR_COMMITFAILED;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_aclAclGroupEgressMacAcl(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    char  value[MAXSIZE_aclAclGroupEgressMacAcl+1];
    char  time_range_name[SYS_ADPT_MAX_LENGTH_OF_TIME_ACL_TABLE_NAME+1] = {0};
    int size;
    UI32_T oid_name_length;
    UI32_T index;
    RULE_TYPE_COUNTER_ENABLE_T counter_enable = RULE_TYPE_COUNTER_DISABLE;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(UI8_T)*MAXSIZE_aclAclGroupEgressMacAcl) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          memcpy(value, var_val, size);
          value[size] = '\0';
          if (!L_STDLIB_StrIsAsciiPrintWithCount((char *)value,size))
          {
                   return SNMP_ERR_WRONGVALUE;
          }
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
               index=name[oid_name_length];
               size  = var_val_len;
               memcpy(value, var_val, size);
               value[size] = '\0';

               if (L4_PMGR_ACL_BindPort2Acl(index, value, RULE_TYPE_MAC_ACL, FALSE, time_range_name, counter_enable)!=TRUE)
                   return SNMP_ERR_COMMITFAILED;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif

#if ((SYS_CPNT_ACL == TRUE) && (SYS_CPNT_QOS_V2 != TRUE))

/********************************************
 *************aclIngressIpMaskTable**********
 ********************************************
 */
static int
header_aclIngressIpMaskTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
    oid             newname[MAX_OID_LEN];
    int    interface;
    int             result;
   ACL_MaskEntry_T  entry;
   BOOL_T return_val;
   UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

    memset(&entry, 0, sizeof(entry));

    while (  (return_val= L4_ACL_MGR_GetNextMaskEntry_ByIndex( ACL_IP_MASK, ACL_INGRESS_MASK, &entry))==TRUE)
     {

        newname[oid_name_length] = (oid) entry.u.ip_mask.EntryIndex;
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {

        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[oid_name_length];

    return interface;
}


/* This entry is used for entry which have the ability to row create*/
static ACL_MaskEntry_T aclIngressIpMaskEntry;

/*
 * var_aclIngressIpMaskTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_aclIngressIpMaskTable(struct variable *vp,
                          oid * name,
                          size_t * length,
                          int exact,
                          size_t * var_len, WriteMethod ** write_method)
{
    ACL_MaskEntry_T  entry;
    int             interface;

    /* Give default value for the record first.
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */
    L4_ACL_MGR_InitMask(ACL_IP_MASK,&aclIngressIpMaskEntry);
    aclIngressIpMaskEntry.u.ip_mask.RowStatus=0;

   memset( &entry, 0, sizeof(entry));


   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch(vp->magic)
     {

      case ACLINGRESSIPMASKISENABLETOS:
        *write_method = write_aclIngressIpMaskIsEnableTos;
        break;
      case ACLINGRESSIPMASKISENABLEDSCP:
        *write_method = write_aclIngressIpMaskIsEnableDscp;
        break;
      case ACLINGRESSIPMASKISENABLEPRECEDENCE:
        *write_method = write_aclIngressIpMaskIsEnablePrecedence;
        break;
     case ACLINGRESSIPMASKISENABLEPROTOCOL:
        *write_method = write_aclIngressIpMaskIsEnableProtocol;
        break;
      case ACLINGRESSIPMASKSOURCEIPADDRBITMASK:
        *write_method = write_aclIngressIpMaskSourceIpAddrBitmask;
        break;
      case ACLINGRESSIPMASKDESTIPADDRBITMASK:
        *write_method = write_aclIngressIpMaskDestIpAddrBitmask;
        break;
      case ACLINGRESSIPMASKSOURCEPORTBITMASK:
        *write_method = write_aclIngressIpMaskSourcePortBitmask;
        break;
      case ACLINGRESSIPMASKDESTPORTBITMASK:
        *write_method = write_aclIngressIpMaskDestPortBitmask;
        break;
      case ACLINGRESSIPMASKCONTROLCODEBITMASK:
        *write_method = write_aclIngressIpMaskControlCodeBitmask;
        break;
      case ACLINGRESSIPMASKSTATUS:
        *write_method = write_aclIngressIpMaskStatus;
        break;
    default:
      ERROR_MSG("");
    }

    interface =
        header_aclIngressIpMaskTable(vp, name, length, exact, var_len, write_method);
    if (interface == MATCH_FAILED)
        return NULL;


     entry.u.ip_mask.EntryIndex= interface;
   if (L4_ACL_MGR_GetMaskEntry_ByIndex( ACL_IP_MASK, ACL_INGRESS_MASK, &entry)!= TRUE)
            return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case ACLINGRESSIPMASKINDEX:
        long_return = interface;
        return (u_char *) &long_return;
#endif
      case ACLINGRESSIPMASKPRECEDENCE:
        long_return =entry.u.ip_mask.Precedence;
        return (u_char *) &long_return;
      case ACLINGRESSIPMASKISENABLETOS:
        *write_method = write_aclIngressIpMaskIsEnableTos;
        long_return =entry.u.ip_mask.isEnableTos;
        if (long_return==TRUE)
        {
            long_return = VAL_aclIngressIpMaskIsEnableTos_enabled;
        }
        else if (long_return == FALSE)
        {
            long_return = VAL_aclIngressIpMaskIsEnableTos_disabled;
        }
        return (u_char *) &long_return;
      case ACLINGRESSIPMASKISENABLEDSCP:
        *write_method = write_aclIngressIpMaskIsEnableDscp;
       long_return =entry.u.ip_mask.isEnableDscp;
        if (long_return==TRUE)
        {
            long_return = VAL_aclIngressIpMaskIsEnableDscp_enabled;
        }
        else if (long_return == FALSE)
        {
            long_return = VAL_aclIngressIpMaskIsEnableDscp_disabled;
        }
        return (u_char *) &long_return;
      case ACLINGRESSIPMASKISENABLEPRECEDENCE:
        *write_method = write_aclIngressIpMaskIsEnablePrecedence;
         long_return =entry.u.ip_mask.isEnablePrecedence;
        if (long_return==TRUE)
        {
            long_return = VAL_aclIngressIpMaskIsEnablePrecedence_enabled;
        }
        else if (long_return == FALSE)
        {
            long_return = VAL_aclIngressIpMaskIsEnablePrecedence_disabled;
        }
        return (u_char *) &long_return;
     case ACLINGRESSIPMASKISENABLEPROTOCOL:
        *write_method = write_aclIngressIpMaskIsEnableProtocol;
         long_return =entry.u.ip_mask.isEnableProtocol;
        if (long_return==TRUE)
        {
            long_return = VAL_aclIngressIpMaskIsEnableProtocol_enabled;
        }
        else if (long_return == FALSE)
        {
            long_return = VAL_aclIngressIpMaskIsEnableProtocol_disabled;
        }
        return (u_char *) &long_return;
      case ACLINGRESSIPMASKSOURCEIPADDRBITMASK:
        *write_method = write_aclIngressIpMaskSourceIpAddrBitmask;
        long_return =entry.u.ip_mask.SourceIpAddrBitmask;
        return (u_char *) &long_return;
      case ACLINGRESSIPMASKDESTIPADDRBITMASK:
        *write_method = write_aclIngressIpMaskDestIpAddrBitmask;
        long_return =entry.u.ip_mask.DestIpAddrBitmask;
        return (u_char *) &long_return;
      case ACLINGRESSIPMASKSOURCEPORTBITMASK:
        *write_method = write_aclIngressIpMaskSourcePortBitmask;
        long_return =entry.u.ip_mask.SourcePortBitmask;
        return (u_char *) &long_return;
      case ACLINGRESSIPMASKDESTPORTBITMASK:
        *write_method = write_aclIngressIpMaskDestPortBitmask;
        long_return =entry.u.ip_mask.DestPortBitmask;
        return (u_char *) &long_return;
      case ACLINGRESSIPMASKCONTROLCODEBITMASK:
        *write_method = write_aclIngressIpMaskControlCodeBitmask;
        long_return =entry.u.ip_mask.ControlCodeBitmask;
        return (u_char *) &long_return;
      case ACLINGRESSIPMASKSTATUS:
        *write_method = write_aclIngressIpMaskStatus;
        long_return =entry.u.ip_mask.RowStatus;
        return (u_char *) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_aclIngressIpMaskIsEnableTos(int action,
                                  u_char * var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char * statP,
                                  oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLINGRESSIPMASKISENABLETOS)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >4) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        {
             long value;

             value = * (long *) var_val;
             aclIngressIpMaskEntry.u.ip_mask.isEnableTos = value;

             if ((aclIngressIpMaskEntry.u.ip_mask.isEnableTos < VAL_aclIngressIpMaskIsEnableTos_enabled) || (aclIngressIpMaskEntry.u.ip_mask.isEnableTos > VAL_aclIngressIpMaskIsEnableTos_disabled))
                 return SNMP_ERR_WRONGVALUE;
             break;
        }
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /* For row creation, if row_status =0, mean that this is a normal
              * operation, we do the normal set operation, otherwise it is a row
              * creation operation, will do nothing here, and the overall entry
              * will perform in the write_xxxRowStatus function.
              */
             if ( aclIngressIpMaskEntry.u.ip_mask.RowStatus == 0)
             {
                  ACL_MaskEntry_T currentdata;

                  memset(&currentdata, 0, sizeof(ACL_MaskEntry_T));

                  if (aclIngressIpMaskEntry.u.ip_mask.isEnableTos == VAL_aclIngressIpMaskIsEnableTos_enabled)
                  {
                      aclIngressIpMaskEntry.u.ip_mask.isEnableTos = TRUE;
                  }
                  else if (aclIngressIpMaskEntry.u.ip_mask.isEnableTos == VAL_aclIngressIpMaskIsEnableTos_disabled)
                  {
                      aclIngressIpMaskEntry.u.ip_mask.isEnableTos = FALSE;
                  }
                  currentdata.u.ip_mask.EntryIndex=name[oid_name_length];
                  if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_IP_MASK, ACL_INGRESS_MASK, &currentdata))
                  {
                      currentdata.u.ip_mask.isEnableTos =aclIngressIpMaskEntry.u.ip_mask.isEnableTos;
                      if (L4_ACL_MGR_SetMaskEntry(ACL_IP_MASK, ACL_INGRESS_MASK, &currentdata)!= TRUE)
                      {
                           return SNMP_ERR_COMMITFAILED;
                      }
                  }
                  else
                  {
                      return SNMP_ERR_COMMITFAILED;
                  }
              }
              break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIngressIpMaskIsEnableDscp(int action,
                                   u_char * var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char * statP,
                                   oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLINGRESSIPMASKISENABLEDSCP)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    switch ( action )
    {
        case RESERVE1:
             if (var_val_type != ASN_INTEGER)
             {
                 return SNMP_ERR_WRONGTYPE;
             }
             if (var_val_len >4)
             {
                 return SNMP_ERR_WRONGLENGTH;
             }
             break;

        case RESERVE2:
        {
             long value;

             value = * (long *) var_val;

             aclIngressIpMaskEntry.u.ip_mask.isEnableDscp = value;

             if ((aclIngressIpMaskEntry.u.ip_mask.isEnableDscp < VAL_aclIngressIpMaskIsEnableDscp_enabled) || (aclIngressIpMaskEntry.u.ip_mask.isEnableDscp > VAL_aclIngressIpMaskIsEnableDscp_disabled))
                  return SNMP_ERR_WRONGVALUE;
             break;
        }
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
         if ( aclIngressIpMaskEntry.u.ip_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;

              if (aclIngressIpMaskEntry.u.ip_mask.isEnableDscp == VAL_aclIngressIpMaskIsEnableDscp_enabled)
          {
                  aclIngressIpMaskEntry.u.ip_mask.isEnableDscp = TRUE;
          }
              else if (aclIngressIpMaskEntry.u.ip_mask.isEnableDscp == VAL_aclIngressIpMaskIsEnableDscp_disabled)
          {
                  aclIngressIpMaskEntry.u.ip_mask.isEnableDscp = FALSE;
          }
          currentdata.u.ip_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_IP_MASK, ACL_INGRESS_MASK, &currentdata))
          {

                  currentdata.u.ip_mask.isEnableDscp =aclIngressIpMaskEntry.u.ip_mask.isEnableDscp;
              if (L4_ACL_MGR_SetMaskEntry(ACL_IP_MASK, ACL_INGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIngressIpMaskIsEnablePrecedence(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLINGRESSIPMASKISENABLEPRECEDENCE)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    switch ( action )
    {
        case RESERVE1:
             if (var_val_type != ASN_INTEGER)
             {
                 return SNMP_ERR_WRONGTYPE;
             }
             if (var_val_len >4) {
                 return SNMP_ERR_WRONGLENGTH;
             }
             break;

        case RESERVE2:
        {
             long value;

             value = * (long *) var_val;
             aclIngressIpMaskEntry.u.ip_mask.isEnablePrecedence = value;
             if ((aclIngressIpMaskEntry.u.ip_mask.isEnablePrecedence < VAL_aclIngressIpMaskIsEnablePrecedence_enabled) || (aclIngressIpMaskEntry.u.ip_mask.isEnablePrecedence > VAL_aclIngressIpMaskIsEnablePrecedence_disabled))
                 return SNMP_ERR_WRONGVALUE;
             break;
        }
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
         if ( aclIngressIpMaskEntry.u.ip_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;

              if (aclIngressIpMaskEntry.u.ip_mask.isEnablePrecedence == VAL_aclIngressIpMaskIsEnablePrecedence_enabled)
          {
                  aclIngressIpMaskEntry.u.ip_mask.isEnablePrecedence = TRUE;
          }
              else if (aclIngressIpMaskEntry.u.ip_mask.isEnablePrecedence == VAL_aclIngressIpMaskIsEnablePrecedence_disabled)
          {
                  aclIngressIpMaskEntry.u.ip_mask.isEnablePrecedence = FALSE;
          }
          currentdata.u.ip_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_IP_MASK, ACL_INGRESS_MASK, &currentdata))
          {
                  currentdata.u.ip_mask.isEnablePrecedence =aclIngressIpMaskEntry.u.ip_mask.isEnablePrecedence;
              if (L4_ACL_MGR_SetMaskEntry(ACL_IP_MASK, ACL_INGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_aclIngressIpMaskIsEnableProtocol(int action,
                                       u_char * var_val,
                                       u_char var_val_type,
                                       size_t var_val_len,
                                       u_char * statP,
                                       oid * name, size_t name_len)
{
    UI32_T nValue = 0;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLINGRESSIPMASKISENABLEPROTOCOL)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action )
    {
        case RESERVE1:
             if (var_val_type != ASN_INTEGER)
             {
                return SNMP_ERR_WRONGTYPE;
             }
             if (var_val_len >4)
             {
                return SNMP_ERR_WRONGLENGTH;
             }
             break;

        case RESERVE2:

             /* In reserve2, we overwrite the set value to aclIngressIpMaskEntry*/
             nValue = * (long *) var_val;

             switch(nValue)
             {
                case VAL_aclIngressIpMaskIsEnableProtocol_enabled:
                case VAL_aclIngressIpMaskIsEnableProtocol_disabled:
                     break;

                default:
                     return SNMP_ERR_WRONGVALUE;
             }
             break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
         if ( aclIngressIpMaskEntry.u.ip_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;
          UI32_T long_var_val;
          memcpy(&long_var_val, var_val, 4);
          if (long_var_val == VAL_aclIngressIpMaskIsEnableProtocol_enabled)
          {
                  aclIngressIpMaskEntry.u.ip_mask.isEnableProtocol = TRUE;
          }
              else if (long_var_val== VAL_aclIngressIpMaskIsEnableProtocol_disabled)
          {
                  aclIngressIpMaskEntry.u.ip_mask.isEnableProtocol = FALSE;
          }
            else
            {
                  return SNMP_ERR_WRONGVALUE;
          }
          currentdata.u.ip_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_IP_MASK, ACL_INGRESS_MASK, &currentdata))
          {
                  currentdata.u.ip_mask.isEnableProtocol =aclIngressIpMaskEntry.u.ip_mask.isEnableProtocol;
              if (L4_ACL_MGR_SetMaskEntry(ACL_IP_MASK, ACL_INGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIngressIpMaskSourceIpAddrBitmask(int action,
                                          u_char * var_val,
                                          u_char var_val_type,
                                          size_t var_val_len,
                                          u_char * statP,
                                          oid * name, size_t name_len)
{

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLINGRESSIPMASKSOURCEIPADDRBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >4) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to aclIngressIpMaskEntry*/
          memcpy(&aclIngressIpMaskEntry.u.ip_mask.SourceIpAddrBitmask, var_val, 4);

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
         if ( aclIngressIpMaskEntry.u.ip_mask.RowStatus == 0)
         {
          ACL_MaskEntry_T currentdata;

          currentdata.u.ip_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_IP_MASK, ACL_INGRESS_MASK, &currentdata))
          {
                  currentdata.u.ip_mask.SourceIpAddrBitmask =aclIngressIpMaskEntry.u.ip_mask.SourceIpAddrBitmask;
              if (L4_ACL_MGR_SetMaskEntry(ACL_IP_MASK, ACL_INGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIngressIpMaskDestIpAddrBitmask(int action,
                                        u_char * var_val,
                                        u_char var_val_type,
                                        size_t var_val_len,
                                        u_char * statP,
                                        oid * name, size_t name_len)
{

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLINGRESSIPMASKDESTIPADDRBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >4) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to aclIngressIpMaskEntry*/
          memcpy(&aclIngressIpMaskEntry.u.ip_mask.DestIpAddrBitmask, var_val, 4);
          break;
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
         if ( aclIngressIpMaskEntry.u.ip_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;

          currentdata.u.ip_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_IP_MASK, ACL_INGRESS_MASK, &currentdata))
          {
                  currentdata.u.ip_mask.DestIpAddrBitmask =aclIngressIpMaskEntry.u.ip_mask.DestIpAddrBitmask;
              if (L4_ACL_MGR_SetMaskEntry(ACL_IP_MASK, ACL_INGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIngressIpMaskSourcePortBitmask(int action,
                                        u_char * var_val,
                                        u_char var_val_type,
                                        size_t var_val_len,
                                        u_char * statP,
                                        oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLINGRESSIPMASKSOURCEPORTBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >4) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclIngressIpMaskEntry*/
          memcpy(&aclIngressIpMaskEntry.u.ip_mask.DestIpAddrBitmask, var_val, 4);
          if ((aclIngressIpMaskEntry.u.ip_mask.DestIpAddrBitmask < MIN_aclIngressIpMaskSourcePortBitmask) || (aclIngressIpMaskEntry.u.ip_mask.DestIpAddrBitmask > MAX_aclIngressIpMaskSourcePortBitmask))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
         if ( aclIngressIpMaskEntry.u.ip_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;
          currentdata.u.ip_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_IP_MASK, ACL_INGRESS_MASK, &currentdata))
          {
                  currentdata.u.ip_mask.SourcePortBitmask =aclIngressIpMaskEntry.u.ip_mask.DestIpAddrBitmask;
              if (L4_ACL_MGR_SetMaskEntry(ACL_IP_MASK, ACL_INGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIngressIpMaskDestPortBitmask(int action,
                                      u_char * var_val,
                                      u_char var_val_type,
                                      size_t var_val_len,
                                      u_char * statP,
                                      oid * name, size_t name_len)
{

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLINGRESSIPMASKDESTPORTBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >4) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

           /* In reserve2, we overwrite the set value to aclIngressIpMaskEntry*/
          memcpy(&aclIngressIpMaskEntry.u.ip_mask.DestPortBitmask, var_val, 4);
          if ((aclIngressIpMaskEntry.u.ip_mask.DestPortBitmask < MIN_aclIngressIpMaskDestPortBitmask) || (aclIngressIpMaskEntry.u.ip_mask.DestPortBitmask > MAX_aclIngressIpMaskDestPortBitmask))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
         if ( aclIngressIpMaskEntry.u.ip_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;
          currentdata.u.ip_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_IP_MASK, ACL_INGRESS_MASK, &currentdata))
          {
                  currentdata.u.ip_mask.DestPortBitmask =aclIngressIpMaskEntry.u.ip_mask.DestPortBitmask;
              if (L4_ACL_MGR_SetMaskEntry(ACL_IP_MASK, ACL_INGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIngressIpMaskControlCodeBitmask(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLINGRESSIPMASKCONTROLCODEBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >4) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclIngressIpMaskEntry*/
          memcpy(&aclIngressIpMaskEntry.u.ip_mask.ControlCodeBitmask, var_val, 4);
          if ((aclIngressIpMaskEntry.u.ip_mask.ControlCodeBitmask < MIN_aclIngressIpMaskControlCodeBitmask) || (aclIngressIpMaskEntry.u.ip_mask.ControlCodeBitmask > MAX_aclIngressIpMaskControlCodeBitmask))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
         if ( aclIngressIpMaskEntry.u.ip_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;
          currentdata.u.ip_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_IP_MASK, ACL_INGRESS_MASK, &currentdata))
          {
                  currentdata.u.ip_mask.ControlCodeBitmask =aclIngressIpMaskEntry.u.ip_mask.ControlCodeBitmask;
              if (L4_ACL_MGR_SetMaskEntry(ACL_IP_MASK, ACL_INGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIngressIpMaskStatus(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLINGRESSIPMASKSTATUS)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >4) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

           /* In reserve2, we overwrite the set value to aclIngressIpMaskEntry*/
          memcpy(&aclIngressIpMaskEntry.u.ip_mask.RowStatus, var_val, 4);
          if ((aclIngressIpMaskEntry.u.ip_mask.RowStatus < VAL_aclIngressIpMaskStatus_active) || (aclIngressIpMaskEntry.u.ip_mask.RowStatus > VAL_aclIngressIpMaskStatus_destroy))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            aclIngressIpMaskEntry.u.ip_mask.EntryIndex=name[oid_name_length];
            if (!L4_ACL_MGR_SetMaskEntry_RowStatus(ACL_IP_MASK, ACL_INGRESS_MASK, aclIngressIpMaskEntry.u.ip_mask.RowStatus, &aclIngressIpMaskEntry))
            {
                return SNMP_ERR_COMMITFAILED;
            }
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 ************aclEgressIpMaskTable************
 ********************************************
 */
static int
header_aclEgressIpMaskTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
    oid             newname[MAX_OID_LEN];
    int    interface;
    int             result;
    ACL_MaskEntry_T  entry;
    BOOL_T return_val;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    memcpy((char *) newname, (char *) vp->name, (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

    memset(&entry, 0, sizeof(entry));

    while (  (return_val= L4_ACL_MGR_GetNextMaskEntry_ByIndex( ACL_IP_MASK, ACL_EGRESS_MASK, &entry))==TRUE)
    {

        newname[oid_name_length] = (oid) entry.u.ip_mask.EntryIndex;
        result = snmp_oid_compare(name, *length, newname, (int) vp->namelen + 1);

        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }

    if (!return_val )
    {
        return MATCH_FAILED;
    }

    memcpy((char *) name, (char *) newname, ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[oid_name_length];
    return interface;
}

/* This entry is used for entry which have the ability to row create*/
static ACL_MaskEntry_T aclEngressIpMaskEntry;

/*
 * var_aclEgressIpMaskTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_aclEgressIpMaskTable(struct variable *vp,
                         oid * name,
                         size_t * length,
                         int exact,
                         size_t * var_len, WriteMethod ** write_method)
{
    ACL_MaskEntry_T  entry;
    int             interface;


   /* Give default value for the record first.
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */
    L4_ACL_MGR_InitMask(ACL_IP_MASK,&aclEngressIpMaskEntry);
    aclEngressIpMaskEntry.u.ip_mask.RowStatus=0;

    memset( &entry, 0, sizeof(entry));

    /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch(vp->magic)
    {
      case ACLEGRESSIPMASKISENABLETOS:
           *write_method = write_aclEgressIpMaskIsEnableTos;
           break;

      case ACLEGRESSIPMASKISENABLEDSCP:
           *write_method = write_aclEgressIpMaskIsEnableDscp;
           break;

      case ACLEGRESSIPMASKISENABLEPRECEDENCE:
           *write_method = write_aclEgressIpMaskIsEnablePrecedence;
           break;

      case ACLEGRESSIPMASKISENABLEPROTOCOL:
           *write_method = write_aclEgressIpMaskIsEnableProtocol;
           break;

      case ACLEGRESSIPMASKSOURCEIPADDRBITMASK:
           *write_method = write_aclEgressIpMaskSourceIpAddrBitmask;
           break;

      case ACLEGRESSIPMASKDESTIPADDRBITMASK:
           *write_method = write_aclEgressIpMaskDestIpAddrBitmask;
           break;

      case ACLEGRESSIPMASKSOURCEPORTBITMASK:
           *write_method = write_aclEgressIpMaskSourcePortBitmask;
           break;

      case ACLEGRESSIPMASKDESTPORTBITMASK:
           *write_method = write_aclEgressIpMaskDestPortBitmask;
           break;

      case ACLEGRESSIPMASKCONTROLCODEBITMASK:
           *write_method = write_aclEgressIpMaskControlCodeBitmask;
           break;

      case ACLEGRESSIPMASKSTATUS:
           *write_method = write_aclEgressIpMaskStatus;
           break;
      default:
           ERROR_MSG("");
    }

    interface = header_aclEgressIpMaskTable(vp, name, length, exact, var_len, write_method);

    if (interface == MATCH_FAILED)
        return NULL;

    entry.u.ip_mask.EntryIndex= interface;

    if (L4_ACL_MGR_GetMaskEntry_ByIndex( ACL_IP_MASK, ACL_EGRESS_MASK, &entry)!= TRUE)
        return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic)
    {
     #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case ACLEGRESSIPMASKINDEX:
           VAR = VALUE;            /* XXX */
           return (u_char *) & VAR;
     #endif
      case ACLEGRESSIPMASKPRECEDENCE:
           long_return = interface;
           return (u_char *) &long_return;

      case ACLEGRESSIPMASKISENABLETOS:
           long_return = entry.u.ip_mask.isEnableTos;
           if (long_return==TRUE)
           {
               long_return = VAL_aclEgressIpMaskIsEnableTos_enabled;
           }
           else if (long_return == FALSE)
           {
               long_return = VAL_aclEgressIpMaskIsEnableTos_disabled;
           }
           return (u_char *) &long_return;

      case ACLEGRESSIPMASKISENABLEDSCP:
           long_return =entry.u.ip_mask.isEnableDscp;
           if (long_return==TRUE)
           {
               long_return = VAL_aclEgressIpMaskIsEnableDscp_enabled;
           }
           else if (long_return == FALSE)
           {
               long_return = VAL_aclEgressIpMaskIsEnableDscp_disabled;
           }
           return (u_char *) &long_return;

      case ACLEGRESSIPMASKISENABLEPRECEDENCE:
           long_return =entry.u.ip_mask.isEnablePrecedence;
           if (long_return==TRUE)
           {
               long_return = VAL_aclEgressIpMaskIsEnablePrecedence_enabled;
           }
           else if (long_return == FALSE)
           {
               long_return = VAL_aclEgressIpMaskIsEnablePrecedence_disabled;
           }
           return (u_char *) &long_return;

      case ACLEGRESSIPMASKISENABLEPROTOCOL:
           long_return =entry.u.ip_mask.isEnableProtocol;
           if (long_return==TRUE)
           {
               long_return = VAL_aclEgressIpMaskIsEnableProtocol_enabled;
           }
           else if (long_return == FALSE)
           {
               long_return = VAL_aclEgressIpMaskIsEnableProtocol_disabled;
           }
           return (u_char *) &long_return;

      case ACLEGRESSIPMASKSOURCEIPADDRBITMASK:
           long_return =entry.u.ip_mask.SourceIpAddrBitmask;
           return (u_char *) &long_return;

      case ACLEGRESSIPMASKDESTIPADDRBITMASK:
           long_return =entry.u.ip_mask.DestIpAddrBitmask;
           return (u_char *) &long_return;

      case ACLEGRESSIPMASKSOURCEPORTBITMASK:
           long_return =entry.u.ip_mask.SourcePortBitmask;
           return (u_char *) &long_return;

      case ACLEGRESSIPMASKDESTPORTBITMASK:
           long_return =entry.u.ip_mask.DestPortBitmask;
           return (u_char *) &long_return;

      case ACLEGRESSIPMASKCONTROLCODEBITMASK:
           long_return =entry.u.ip_mask.ControlCodeBitmask;
           return (u_char *) &long_return;

      case ACLEGRESSIPMASKSTATUS:
           long_return =entry.u.ip_mask.RowStatus;
           return (u_char *) &long_return;

      default:
           ERROR_MSG("");
    }
    return NULL;
}


int
write_aclEgressIpMaskIsEnableTos(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLEGRESSIPMASKISENABLETOS)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch ( action )
    {
        case RESERVE1:
             if (var_val_type != ASN_INTEGER)
             {
                 return SNMP_ERR_WRONGTYPE;
             }
             if (var_val_len >4)
             {
                 return SNMP_ERR_WRONGLENGTH;
             }
             break;

        case RESERVE2:
        {
             long value;

             value = * (long *) var_val;
             aclEngressIpMaskEntry.u.ip_mask.isEnableTos = value;

             if ((aclEngressIpMaskEntry.u.ip_mask.isEnableTos < VAL_aclEgressIpMaskIsEnableTos_enabled) || (aclEngressIpMaskEntry.u.ip_mask.isEnableTos > VAL_aclEgressIpMaskIsEnableTos_disabled))
                 return SNMP_ERR_WRONGVALUE;
          break;
        }
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
         if ( aclEngressIpMaskEntry.u.ip_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;
              if (aclEngressIpMaskEntry.u.ip_mask.isEnableTos == VAL_aclEgressIpMaskIsEnableTos_enabled)
          {
                  aclEngressIpMaskEntry.u.ip_mask.isEnableTos = TRUE;
          }
              else if (aclEngressIpMaskEntry.u.ip_mask.isEnableTos == VAL_aclEgressIpMaskIsEnableTos_disabled)
          {
                  aclEngressIpMaskEntry.u.ip_mask.isEnableTos = FALSE;
          }
          currentdata.u.ip_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_IP_MASK, ACL_EGRESS_MASK, &currentdata))
          {
                  currentdata.u.ip_mask.isEnableTos =aclEngressIpMaskEntry.u.ip_mask.isEnableTos;
              if (L4_ACL_MGR_SetMaskEntry(ACL_IP_MASK, ACL_EGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclEgressIpMaskIsEnableDscp(int action,
                                  u_char * var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char * statP,
                                  oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLEGRESSIPMASKISENABLEDSCP)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    switch ( action )
    {
        case RESERVE1:
             if (var_val_type != ASN_INTEGER)
             {
                 return SNMP_ERR_WRONGTYPE;
             }
             if (var_val_len >4) {
                 return SNMP_ERR_WRONGLENGTH;
             }
             break;

        case RESERVE2:
        {
             long value;

             value = * (long *) var_val;
             aclEngressIpMaskEntry.u.ip_mask.isEnableDscp = value;

             if ((aclEngressIpMaskEntry.u.ip_mask.isEnableDscp < VAL_aclEgressIpMaskIsEnableDscp_enabled) || (aclEngressIpMaskEntry.u.ip_mask.isEnableDscp > VAL_aclEgressIpMaskIsEnableDscp_disabled))
                  return SNMP_ERR_WRONGVALUE;
             break;
        }
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
         if ( aclEngressIpMaskEntry.u.ip_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;
              if (aclEngressIpMaskEntry.u.ip_mask.isEnableDscp == VAL_aclEgressIpMaskIsEnableDscp_enabled)
          {
                  aclEngressIpMaskEntry.u.ip_mask.isEnableDscp = TRUE;
          }
              else if (aclEngressIpMaskEntry.u.ip_mask.isEnableDscp == VAL_aclEgressIpMaskIsEnableDscp_disabled)
          {
                  aclEngressIpMaskEntry.u.ip_mask.isEnableDscp = FALSE;
          }
          currentdata.u.ip_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_IP_MASK, ACL_EGRESS_MASK, &currentdata))
          {

                  currentdata.u.ip_mask.isEnableDscp =aclEngressIpMaskEntry.u.ip_mask.isEnableDscp;
              if (L4_ACL_MGR_SetMaskEntry(ACL_IP_MASK, ACL_EGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclEgressIpMaskIsEnablePrecedence(int action,
                                        u_char * var_val,
                                        u_char var_val_type,
                                        size_t var_val_len,
                                        u_char * statP,
                                        oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLEGRESSIPMASKISENABLEPRECEDENCE)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    switch ( action )
    {
        case RESERVE1:
             if (var_val_type != ASN_INTEGER)
             {
                 return SNMP_ERR_WRONGTYPE;
             }
             if (var_val_len >4)
             {
                 return SNMP_ERR_WRONGLENGTH;
             }
             break;

        case RESERVE2:
        {
             long value;

             value = * (long *) var_val;
             aclEngressIpMaskEntry.u.ip_mask.isEnablePrecedence = value;

             if ((aclEngressIpMaskEntry.u.ip_mask.isEnablePrecedence < VAL_aclEgressIpMaskIsEnablePrecedence_enabled) || (aclEngressIpMaskEntry.u.ip_mask.isEnablePrecedence > VAL_aclEgressIpMaskIsEnablePrecedence_disabled))
                  return SNMP_ERR_WRONGVALUE;
             break;
        }
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
         if ( aclEngressIpMaskEntry.u.ip_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;
              if (aclEngressIpMaskEntry.u.ip_mask.isEnablePrecedence == VAL_aclEgressIpMaskIsEnablePrecedence_enabled)
          {
                  aclEngressIpMaskEntry.u.ip_mask.isEnablePrecedence = TRUE;
          }
              else if (aclEngressIpMaskEntry.u.ip_mask.isEnablePrecedence == VAL_aclEgressIpMaskIsEnablePrecedence_disabled)
          {
                  aclEngressIpMaskEntry.u.ip_mask.isEnablePrecedence = FALSE;
          }
          currentdata.u.ip_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_IP_MASK, ACL_EGRESS_MASK, &currentdata))
          {
                  currentdata.u.ip_mask.isEnablePrecedence =aclEngressIpMaskEntry.u.ip_mask.isEnablePrecedence;
              if (L4_ACL_MGR_SetMaskEntry(ACL_IP_MASK, ACL_EGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclEgressIpMaskIsEnableProtocol(int action,
                                      u_char * var_val,
                                      u_char var_val_type,
                                      size_t var_val_len,
                                      u_char * statP,
                                      oid * name, size_t name_len)
{
    UI32_T nValue = 0;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLEGRESSIPMASKISENABLEPROTOCOL)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    switch ( action )
    {
        case RESERVE1:
             if (var_val_type != ASN_INTEGER)
             {
                 return SNMP_ERR_WRONGTYPE;
             }
             if (var_val_len >4)
             {
                 return SNMP_ERR_WRONGLENGTH;
             }
             break;

        case RESERVE2:
             nValue = * (long *) var_val;

             switch(nValue)
             {
                case VAL_aclEgressIpMaskIsEnableProtocol_enabled:
                case VAL_aclEgressIpMaskIsEnableProtocol_disabled:
                     break;

                default:
                     return SNMP_ERR_WRONGVALUE;
             }
             aclEngressIpMaskEntry.u.ip_mask.isEnableProtocol = nValue;
             break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
        if ( aclEngressIpMaskEntry.u.ip_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;

          memset(&currentdata, 0, sizeof(ACL_MaskEntry_T));

          if (aclEngressIpMaskEntry.u.ip_mask.isEnableProtocol == VAL_aclEgressIpMaskIsEnableProtocol_enabled)
          {
                  aclEngressIpMaskEntry.u.ip_mask.isEnableProtocol = TRUE;
          }
              else if (aclEngressIpMaskEntry.u.ip_mask.isEnableProtocol == VAL_aclEgressIpMaskIsEnableProtocol_disabled)
          {
                  aclEngressIpMaskEntry.u.ip_mask.isEnableProtocol = FALSE;
          }
          currentdata.u.ip_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_IP_MASK, ACL_EGRESS_MASK, &currentdata))
          {
                  currentdata.u.ip_mask.isEnableProtocol =aclEngressIpMaskEntry.u.ip_mask.isEnableProtocol;
              if (L4_ACL_MGR_SetMaskEntry(ACL_IP_MASK, ACL_EGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclEgressIpMaskSourceIpAddrBitmask(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLEGRESSIPMASKSOURCEIPADDRBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >4) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to aclEngressIpMaskEntry*/
          memcpy(&aclEngressIpMaskEntry.u.ip_mask.SourceIpAddrBitmask, var_val, 4);
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
        if ( aclEngressIpMaskEntry.u.ip_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;
          currentdata.u.ip_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_IP_MASK, ACL_EGRESS_MASK, &currentdata))
          {
                  currentdata.u.ip_mask.SourceIpAddrBitmask =aclEngressIpMaskEntry.u.ip_mask.SourceIpAddrBitmask;
              if (L4_ACL_MGR_SetMaskEntry(ACL_IP_MASK, ACL_EGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_aclEgressIpMaskDestIpAddrBitmask(int action,
                                       u_char * var_val,
                                       u_char var_val_type,
                                       size_t var_val_len,
                                       u_char * statP,
                                       oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLEGRESSIPMASKDESTIPADDRBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_UNSIGNED) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >4) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          /* In reserve2, we overwrite the set value to aclEngressIpMaskEntry*/
          memcpy(&aclEngressIpMaskEntry.u.ip_mask.DestIpAddrBitmask, var_val, 4);
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
        if ( aclEngressIpMaskEntry.u.ip_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;
          currentdata.u.ip_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_IP_MASK, ACL_EGRESS_MASK, &currentdata))
          {
                  currentdata.u.ip_mask.DestIpAddrBitmask =aclEngressIpMaskEntry.u.ip_mask.DestIpAddrBitmask;
              if (L4_ACL_MGR_SetMaskEntry(ACL_IP_MASK, ACL_EGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclEgressIpMaskSourcePortBitmask(int action,
                                       u_char * var_val,
                                       u_char var_val_type,
                                       size_t var_val_len,
                                       u_char * statP,
                                       oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLEGRESSIPMASKSOURCEPORTBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >4) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

           /* In reserve2, we overwrite the set value to aclEngressIpMaskEntry*/
          memcpy(&aclEngressIpMaskEntry.u.ip_mask.SourcePortBitmask, var_val, 4);
          if ((aclEngressIpMaskEntry.u.ip_mask.SourcePortBitmask < MIN_aclEgressIpMaskSourcePortBitmask) || (aclEngressIpMaskEntry.u.ip_mask.SourcePortBitmask > MAX_aclEgressIpMaskSourcePortBitmask))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
        if ( aclEngressIpMaskEntry.u.ip_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;
          currentdata.u.ip_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_IP_MASK, ACL_EGRESS_MASK, &currentdata))
          {
                  currentdata.u.ip_mask.SourcePortBitmask =aclEngressIpMaskEntry.u.ip_mask.SourcePortBitmask;
              if (L4_ACL_MGR_SetMaskEntry(ACL_IP_MASK, ACL_EGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclEgressIpMaskDestPortBitmask(int action,
                                     u_char * var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char * statP,
                                     oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLEGRESSIPMASKDESTPORTBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >4) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclEngressIpMaskEntry*/
          memcpy(&aclEngressIpMaskEntry.u.ip_mask.DestPortBitmask, var_val, 4);
          if ((aclEngressIpMaskEntry.u.ip_mask.DestPortBitmask < MIN_aclEgressIpMaskDestPortBitmask) || (aclEngressIpMaskEntry.u.ip_mask.DestPortBitmask > MAX_aclEgressIpMaskDestPortBitmask))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
        if ( aclEngressIpMaskEntry.u.ip_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;
          currentdata.u.ip_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_IP_MASK, ACL_EGRESS_MASK, &currentdata))
          {
                  currentdata.u.ip_mask.DestPortBitmask =aclEngressIpMaskEntry.u.ip_mask.DestPortBitmask;
              if (L4_ACL_MGR_SetMaskEntry(ACL_IP_MASK, ACL_EGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclEgressIpMaskControlCodeBitmask(int action,
                                        u_char * var_val,
                                        u_char var_val_type,
                                        size_t var_val_len,
                                        u_char * statP,
                                        oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLEGRESSIPMASKCONTROLCODEBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >4) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclEngressIpMaskEntry*/
          memcpy(&aclEngressIpMaskEntry.u.ip_mask.ControlCodeBitmask, var_val, 4);
          if ((aclEngressIpMaskEntry.u.ip_mask.ControlCodeBitmask < MIN_aclEgressIpMaskControlCodeBitmask) || (aclEngressIpMaskEntry.u.ip_mask.ControlCodeBitmask > MAX_aclEgressIpMaskControlCodeBitmask))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
        if ( aclEngressIpMaskEntry.u.ip_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;
          currentdata.u.ip_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_IP_MASK, ACL_EGRESS_MASK, &currentdata))
          {
                  currentdata.u.ip_mask.ControlCodeBitmask =aclEngressIpMaskEntry.u.ip_mask.ControlCodeBitmask;
              if (L4_ACL_MGR_SetMaskEntry(ACL_IP_MASK, ACL_EGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclEgressIpMaskStatus(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLEGRESSIPMASKSTATUS)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action )
    {
        case RESERVE1:
             if (var_val_type != ASN_INTEGER)
             {
                return SNMP_ERR_WRONGTYPE;
             }
             if (var_val_len >4)
             {
                return SNMP_ERR_WRONGLENGTH;
             }
             break;

        case RESERVE2:
             /* In reserve2, we overwrite the set value to aclEngressIpMaskEntry*/
             memcpy(&aclEngressIpMaskEntry.u.ip_mask.RowStatus, var_val, 4);
             if ((aclEngressIpMaskEntry.u.ip_mask.RowStatus < VAL_aclEgressIpMaskStatus_active) ||
                 (aclEngressIpMaskEntry.u.ip_mask.RowStatus > VAL_aclEgressIpMaskStatus_destroy))
                return SNMP_ERR_WRONGVALUE;
             break;

        case FREE:
             /* Release any resources that have been allocated */
             break;

        case ACTION:
             aclEngressIpMaskEntry.u.ip_mask.EntryIndex=name[oid_name_length];
             if (!L4_ACL_MGR_SetMaskEntry_RowStatus(ACL_IP_MASK, ACL_EGRESS_MASK, aclEngressIpMaskEntry.u.ip_mask.RowStatus, &aclEngressIpMaskEntry))
             {
                return SNMP_ERR_COMMITFAILED;
             }
        case UNDO:
             /* Back out any changes made in the ACTION case */
             break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 ************aclIngressMacMaskTable**********
 ********************************************
 */
static int
header_aclIngressMacMaskTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
    oid             newname[MAX_OID_LEN];
    int    interface;
    int             result;
   ACL_MaskEntry_T  entry;
   BOOL_T return_val;
   UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    memcpy((char *) newname, (char *) vp->name,
           (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */

    memset(&entry, 0, sizeof(entry));

    while (  (return_val= L4_ACL_MGR_GetNextMaskEntry_ByIndex( ACL_MAC_MASK, ACL_INGRESS_MASK, &entry))==TRUE)
     {

        newname[oid_name_length] = (oid) entry.u.mac_mask.EntryIndex;
        result =
            snmp_oid_compare(name, *length, newname,
                             (int) vp->namelen + 1);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }
    if (!return_val ) {

        return MATCH_FAILED;
    }


    memcpy((char *) name, (char *) newname,
           ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[oid_name_length];

    return interface;
}

/* This entry is used for entry which have the ability to row create*/
static ACL_MaskEntry_T aclIngressMacMaskEntry;

/*
 * var_():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_aclIngressMacMaskTable(struct variable *vp,
                           oid * name,
                           size_t * length,
                           int exact,
                           size_t * var_len, WriteMethod ** write_method)
{
    ACL_MaskEntry_T  entry;
    int             interface;


    /* Give default value for the record first.
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */
    L4_ACL_MGR_InitMask(ACL_MAC_MASK,&aclIngressMacMaskEntry);
    aclIngressMacMaskEntry.u.mac_mask.RowStatus = 0;

   memset( &entry, 0, sizeof(entry));


   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch(vp->magic)
     {
       case ACLINGRESSMACMASKSOURCEMACADDRBITMASK:
        *write_method = write_aclIngressMacMaskSourceMacAddrBitmask;
        break;
      case ACLINGRESSMACMASKDESTMACADDRBITMASK:
        *write_method = write_aclIngressMacMaskDestMacAddrBitmask;
        break;
      case ACLINGRESSMACMASKVIDBITMASK:
        *write_method = write_aclIngressMacMaskVidBitmask;
        break;
      case ACLINGRESSMACMASKETHERTYPEBITMASK:
        *write_method = write_aclIngressMacMaskEtherTypeBitmask;
        break;
      case ACLINGRESSMACMASKISENABLEPKTFORMAT:
        *write_method = write_aclIngressMacMaskIsEnablePktformat;
        break;
      case ACLINGRESSMACMASKSTATUS:
        *write_method = write_aclIngressMacMaskStatus;
        break;
    default:
      ERROR_MSG("");
    }

    interface =
        header_aclIngressMacMaskTable(vp, name, length, exact, var_len, write_method);
    if (interface == MATCH_FAILED)
        return NULL;


     entry.u.mac_mask.EntryIndex= interface;
   if (L4_ACL_MGR_GetMaskEntry_ByIndex( ACL_MAC_MASK, ACL_INGRESS_MASK, &entry)!= TRUE)
            return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case ACLINGRESSMACMASKINDEX:
        long_return = interface;
        return (u_char *) &long_return;
#endif
      case ACLINGRESSMACMASKPRECEDENCE:
        long_return= entry.u.mac_mask.Precedence;
        return (u_char *) &long_return;
      case ACLINGRESSMACMASKSOURCEMACADDRBITMASK:
        *write_method = write_aclIngressMacMaskSourceMacAddrBitmask;
        memcpy(return_buf, entry.u.mac_mask.SourceMacAddrBitmask, SIZE_aclIngressMacMaskSourceMacAddrBitmask);
        *var_len = SIZE_aclIngressMacMaskSourceMacAddrBitmask;
        return (u_char *) return_buf;
      case ACLINGRESSMACMASKDESTMACADDRBITMASK:
        *write_method = write_aclIngressMacMaskDestMacAddrBitmask;
        memcpy(return_buf, entry.u.mac_mask.DestMacAddrBitmask, SIZE_aclIngressMacMaskDestMacAddrBitmask);
        *var_len = SIZE_aclIngressMacMaskDestMacAddrBitmask;
        return (u_char *) return_buf;
      case ACLINGRESSMACMASKVIDBITMASK:
        *write_method = write_aclIngressMacMaskVidBitmask;
        long_return= entry.u.mac_mask.VidBitmask;
        return (u_char *) &long_return;
      case ACLINGRESSMACMASKETHERTYPEBITMASK:
        *write_method = write_aclIngressMacMaskEtherTypeBitmask;
        long_return= entry.u.mac_mask.EtherTypeBitmask;
        return (u_char *) &long_return;
      case ACLINGRESSMACMASKISENABLEPKTFORMAT:
        *write_method = write_aclIngressMacMaskIsEnablePktformat;
        long_return =entry.u.mac_mask.isEnablePktformat;
        if (long_return==TRUE)
        {
            long_return = VAL_aclIngressMacMaskIsEnablePktformat_enabled;
        }
        else if (long_return == FALSE)
        {
            long_return = VAL_aclIngressMacMaskIsEnablePktformat_disabled;
        }
        return (u_char *) &long_return;
      case ACLINGRESSMACMASKSTATUS:
        *write_method = write_aclIngressMacMaskStatus;
        long_return =entry.u.mac_mask.RowStatus;
        return (u_char *) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_aclIngressMacMaskSourceMacAddrBitmask(int action,
                                            u_char * var_val,
                                            u_char var_val_type,
                                            size_t var_val_len,
                                            u_char * statP,
                                            oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLINGRESSMACMASKSOURCEMACADDRBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len!=SIZE_aclIngressMacMaskSourceMacAddrBitmask) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to aclIngressMacMaskEntry*/
          memcpy(aclIngressMacMaskEntry.u.mac_mask.SourceMacAddrBitmask, var_val, SIZE_aclIngressMacMaskSourceMacAddrBitmask);
          break;
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
        if ( aclIngressMacMaskEntry.u.mac_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;
          currentdata.u.mac_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_MAC_MASK, ACL_INGRESS_MASK, &currentdata))
          {
                  memcpy(currentdata.u.mac_mask.SourceMacAddrBitmask,aclIngressMacMaskEntry.u.mac_mask.SourceMacAddrBitmask, SIZE_aclIngressMacMaskSourceMacAddrBitmask);
              if (L4_ACL_MGR_SetMaskEntry(ACL_MAC_MASK, ACL_INGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIngressMacMaskDestMacAddrBitmask(int action,
                                          u_char * var_val,
                                          u_char var_val_type,
                                          size_t var_val_len,
                                          u_char * statP,
                                          oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLINGRESSMACMASKDESTMACADDRBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len!=SIZE_aclIngressMacMaskDestMacAddrBitmask) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        /* In reserve2, we overwrite the set value to aclIngressMacMaskEntry*/
          memcpy(aclIngressMacMaskEntry.u.mac_mask.DestMacAddrBitmask, var_val, SIZE_aclIngressMacMaskDestMacAddrBitmask);
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
        if ( aclIngressMacMaskEntry.u.mac_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;
          currentdata.u.mac_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_MAC_MASK, ACL_INGRESS_MASK, &currentdata))
          {
                  memcpy(currentdata.u.mac_mask.DestMacAddrBitmask,aclIngressMacMaskEntry.u.mac_mask.DestMacAddrBitmask, SIZE_aclIngressMacMaskDestMacAddrBitmask);
              if (L4_ACL_MGR_SetMaskEntry(ACL_MAC_MASK, ACL_INGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIngressMacMaskVidBitmask(int action,
                                  u_char * var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char * statP,
                                  oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLINGRESSMACMASKVIDBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >4) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclIngressMacMaskEntry*/
          memcpy(&aclIngressMacMaskEntry.u.mac_mask.VidBitmask, var_val, 4);

          if ((aclIngressMacMaskEntry.u.mac_mask.VidBitmask < MIN_aclIngressMacMaskVidBitmask) || (aclIngressMacMaskEntry.u.mac_mask.VidBitmask > MAX_aclIngressMacMaskVidBitmask))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
        if ( aclIngressMacMaskEntry.u.mac_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;
          currentdata.u.mac_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_MAC_MASK, ACL_INGRESS_MASK, &currentdata))
          {
                  currentdata.u.mac_mask.VidBitmask =aclIngressMacMaskEntry.u.mac_mask.VidBitmask;
              if (L4_ACL_MGR_SetMaskEntry(ACL_MAC_MASK, ACL_INGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_aclIngressMacMaskEtherTypeBitmask(int action,
                                        u_char * var_val,
                                        u_char var_val_type,
                                        size_t var_val_len,
                                        u_char * statP,
                                        oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLINGRESSMACMASKETHERTYPEBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >4) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclIngressMacMaskEntry*/
          memcpy(&aclIngressMacMaskEntry.u.mac_mask.EtherTypeBitmask, var_val, 4);

          if ((aclIngressMacMaskEntry.u.mac_mask.EtherTypeBitmask < MIN_aclIngressMacMaskEtherTypeBitmask) || (aclIngressMacMaskEntry.u.mac_mask.EtherTypeBitmask > MAX_aclIngressMacMaskEtherTypeBitmask))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
        if ( aclIngressMacMaskEntry.u.mac_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;
          currentdata.u.mac_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_MAC_MASK, ACL_INGRESS_MASK, &currentdata))
          {
                  currentdata.u.mac_mask.EtherTypeBitmask =aclIngressMacMaskEntry.u.mac_mask.EtherTypeBitmask;
              if (L4_ACL_MGR_SetMaskEntry(ACL_MAC_MASK, ACL_INGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIngressMacMaskIsEnablePktformat(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLINGRESSMACMASKISENABLEPKTFORMAT)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >4) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        {
             /* In reserve2, we overwrite the set value to aclIngressMacMaskEntry*/
             long value;

             value = * (long *) var_val;

             switch(value)
             {
                case VAL_aclIngressMacMaskIsEnablePktformat_enabled:
                     aclIngressMacMaskEntry.u.mac_mask.isEnablePktformat = TRUE;
                     break;

                case VAL_aclIngressMacMaskIsEnablePktformat_disabled:
                     aclIngressMacMaskEntry.u.mac_mask.isEnablePktformat = FALSE;
                     break;

                default:
                     return SNMP_ERR_WRONGVALUE;
             }
             break;
        }
        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
        if ( aclIngressMacMaskEntry.u.mac_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;

          currentdata.u.mac_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_MAC_MASK, ACL_INGRESS_MASK, &currentdata))
          {

                  currentdata.u.mac_mask.isEnablePktformat = aclIngressMacMaskEntry.u.mac_mask.isEnablePktformat;
              if (L4_ACL_MGR_SetMaskEntry(ACL_MAC_MASK, ACL_INGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_aclIngressMacMaskStatus(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLINGRESSMACMASKSTATUS)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >4) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

           /* In reserve2, we overwrite the set value to aclIngressMacMaskEntry*/
          memcpy(&aclIngressMacMaskEntry.u.mac_mask.RowStatus, var_val, 4);
          if ((aclIngressMacMaskEntry.u.mac_mask.RowStatus < VAL_aclIngressMacMaskStatus_active) || (aclIngressMacMaskEntry.u.mac_mask.RowStatus > VAL_aclIngressMacMaskStatus_destroy))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            aclIngressMacMaskEntry.u.mac_mask.EntryIndex=name[oid_name_length];
            if (!L4_ACL_MGR_SetMaskEntry_RowStatus(ACL_MAC_MASK, ACL_INGRESS_MASK, aclIngressMacMaskEntry.u.mac_mask.RowStatus, &aclIngressMacMaskEntry))
            {
                return SNMP_ERR_COMMITFAILED;
            }
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/********************************************
 ************aclEgressMacMaskTable***********
 ********************************************
 */
static int
header_aclEgressMacMaskTable(struct variable *vp,
               oid * name,
               size_t * length,
               int exact, size_t * var_len, WriteMethod ** write_method)
{
    oid    newname[MAX_OID_LEN];
    int    interface;
    int    result;
    ACL_MaskEntry_T  entry;
    BOOL_T return_val;
    UI32_T oid_name_length;

    oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    memcpy((char *) newname, (char *) vp->name, (int) vp->namelen * sizeof(oid));
    /*
     * find "next" interface
     */
    memset(&entry, 0, sizeof(entry));

    while ((return_val= L4_ACL_MGR_GetNextMaskEntry_ByIndex( ACL_MAC_MASK, ACL_EGRESS_MASK, &entry))==TRUE)
    {
        newname[oid_name_length] = (oid) entry.u.mac_mask.EntryIndex;
        result = snmp_oid_compare(name, *length, newname, (int) vp->namelen + 1);
        if ((exact && (result == 0)) || (!exact && (result < 0)))
            break;
    }

    if (!return_val)
    {
        return MATCH_FAILED;
    }

    memcpy((char *) name, (char *) newname, ((int) vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *var_len = sizeof(long);    /* default to 'long' results */
    interface = newname[oid_name_length];

    return interface;
}

/* This entry is used for entry which have the ability to row create*/
static ACL_MaskEntry_T aclEgressMacMaskEntry;

/*
 * var_aclEgressMacMaskTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_aclEgressMacMaskTable(struct variable *vp,
                          oid * name,
                          size_t * length,
                          int exact,
                          size_t * var_len, WriteMethod ** write_method)
{
    ACL_MaskEntry_T  entry;
    int             interface;

    /* Give default value for the record first.
     * We use the row_status = 0 to indicate if this set operation is Set by field
     * or set by record(included row creation), if the row_status =0, this record
     * mean set by field, otherwise, we just think it is a normal set operation
     */
    L4_ACL_MGR_InitMask(ACL_MAC_MASK,&aclEgressMacMaskEntry);
    aclEgressMacMaskEntry.u.mac_mask.RowStatus = 0;
    memset( &entry, 0, sizeof(entry));

   /*Since this table allow for entry that does not exist, (creation). we need to know the write method first*/
    switch(vp->magic)
     {
      case ACLEGRESSMACMASKSOURCEMACADDRBITMASK:
           *write_method = write_aclEgressMacMaskSourceMacAddrBitmask;
           break;

      case ACLEGRESSMACMASKDESTMACADDRBITMASK:
           *write_method = write_aclEgressMacMaskDestMacAddrBitmask;
           break;

      case ACLEGRESSMACMASKVIDBITMASK:
           *write_method = write_aclEgressMacMaskVidBitmask;
           break;

      case ACLEGRESSMACMASKETHERTYPEBITMASK:
           *write_method = write_aclEgressMacMaskEtherTypeBitmask;
           break;

      case ACLEGRESSMACMASKISENABLEPKTFORMAT:
           *write_method = write_aclEgressMacMaskIsEnablePktformat;
           break;

      case ACLEGRESSMACMASKSTATUS:
           *write_method = write_aclEgressMacMaskStatus;
           break;

      default:
           ERROR_MSG("");
    }

    interface = header_aclEgressMacMaskTable(vp, name, length, exact, var_len, write_method);

    if (interface == MATCH_FAILED)
        return NULL;

    entry.u.mac_mask.EntryIndex= interface;

    if (L4_ACL_MGR_GetMaskEntry_ByIndex( ACL_MAC_MASK, ACL_EGRESS_MASK, &entry)!= TRUE)
        return NULL;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic)
    {
 #if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case ACLEGRESSMACMASKINDEX:
           long_return = interface;
           return (u_char *) &long_return;
 #endif
      case ACLEGRESSMACMASKPRECEDENCE:
           long_return= entry.u.mac_mask.Precedence;
           return (u_char *) &long_return;

      case ACLEGRESSMACMASKSOURCEMACADDRBITMASK:
           memcpy(return_buf, entry.u.mac_mask.SourceMacAddrBitmask, SIZE_aclEgressMacMaskSourceMacAddrBitmask);
           *var_len = SIZE_aclEgressMacMaskSourceMacAddrBitmask;
           return (u_char *) return_buf;

      case ACLEGRESSMACMASKDESTMACADDRBITMASK:
           memcpy(return_buf, entry.u.mac_mask.DestMacAddrBitmask, SIZE_aclEgressMacMaskDestMacAddrBitmask);
           *var_len = SIZE_aclEgressMacMaskDestMacAddrBitmask;
           return (u_char *) return_buf;

      case ACLEGRESSMACMASKVIDBITMASK:
           long_return= entry.u.mac_mask.VidBitmask;
           return (u_char *) &long_return;

      case ACLEGRESSMACMASKETHERTYPEBITMASK:
           long_return= entry.u.mac_mask.EtherTypeBitmask;
           return (u_char *) &long_return;

      case ACLEGRESSMACMASKISENABLEPKTFORMAT:
           long_return =entry.u.mac_mask.isEnablePktformat;
           if (long_return==TRUE)
           {
            long_return = VAL_aclEgressMacMaskIsEnablePktformat_enabled;
           }
           else if (long_return == FALSE)
           {
            long_return = VAL_aclEgressMacMaskIsEnablePktformat_disabled;
           }
           return (u_char *) &long_return;

      case ACLEGRESSMACMASKSTATUS:
           long_return =entry.u.mac_mask.RowStatus;
           return (u_char *) &long_return;

      default:
           ERROR_MSG("");
    }
    return NULL;
}


int
write_aclEgressMacMaskSourceMacAddrBitmask(int action,
                                           u_char * var_val,
                                           u_char var_val_type,
                                           size_t var_val_len,
                                           u_char * statP,
                                           oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLEGRESSMACMASKSOURCEMACADDRBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len!=SIZE_aclEgressMacMaskSourceMacAddrBitmask) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         /* In reserve2, we overwrite the set value to aclEgressMacMaskEntry*/
          memcpy(aclEgressMacMaskEntry.u.mac_mask.SourceMacAddrBitmask, var_val, SIZE_aclEgressMacMaskSourceMacAddrBitmask);
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
        if ( aclEgressMacMaskEntry.u.mac_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;
          currentdata.u.mac_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_MAC_MASK, ACL_EGRESS_MASK, &currentdata))
          {
                  memcpy(currentdata.u.mac_mask.SourceMacAddrBitmask,aclEgressMacMaskEntry.u.mac_mask.SourceMacAddrBitmask, SIZE_aclEgressMacMaskSourceMacAddrBitmask);
              if (L4_ACL_MGR_SetMaskEntry(ACL_MAC_MASK, ACL_EGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclEgressMacMaskDestMacAddrBitmask(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLEGRESSMACMASKDESTMACADDRBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len!=SIZE_aclEgressMacMaskDestMacAddrBitmask) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        /* In reserve2, we overwrite the set value to aclEgressMacMaskEntry*/
          memcpy(aclEgressMacMaskEntry.u.mac_mask.DestMacAddrBitmask, var_val, SIZE_aclEgressMacMaskDestMacAddrBitmask);
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
        if ( aclEgressMacMaskEntry.u.mac_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;

          currentdata.u.mac_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_MAC_MASK, ACL_EGRESS_MASK, &currentdata))
          {
                  memcpy(currentdata.u.mac_mask.DestMacAddrBitmask,aclEgressMacMaskEntry.u.mac_mask.DestMacAddrBitmask, SIZE_aclEgressMacMaskDestMacAddrBitmask);
              if (L4_ACL_MGR_SetMaskEntry(ACL_MAC_MASK, ACL_EGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclEgressMacMaskVidBitmask(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLEGRESSMACMASKVIDBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >4) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

           /* In reserve2, we overwrite the set value to aclEgressMacMaskEntry*/
          memcpy(&aclEgressMacMaskEntry.u.mac_mask.VidBitmask, var_val, 4);
          if ((aclEgressMacMaskEntry.u.mac_mask.VidBitmask < MIN_aclEgressMacMaskVidBitmask) || (aclEgressMacMaskEntry.u.mac_mask.VidBitmask > MAX_aclEgressMacMaskVidBitmask))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
        if ( aclEgressMacMaskEntry.u.mac_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;
          currentdata.u.mac_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_MAC_MASK, ACL_EGRESS_MASK, &currentdata))
          {
                  currentdata.u.mac_mask.VidBitmask =aclEgressMacMaskEntry.u.mac_mask.VidBitmask;
              if (L4_ACL_MGR_SetMaskEntry(ACL_MAC_MASK, ACL_EGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclEgressMacMaskEtherTypeBitmask(int action,
                                       u_char * var_val,
                                       u_char var_val_type,
                                       size_t var_val_len,
                                       u_char * statP,
                                       oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLEGRESSMACMASKETHERTYPEBITMASK)
    {
        return SNMP_ERR_NOTWRITABLE;
    }
    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >4) {
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          /* In reserve2, we overwrite the set value to aclEgressMacMaskEntry*/
          memcpy(&aclEgressMacMaskEntry.u.mac_mask.EtherTypeBitmask, var_val, 4);
          if ((aclEgressMacMaskEntry.u.mac_mask.EtherTypeBitmask < MIN_aclEgressMacMaskEtherTypeBitmask) || (aclEgressMacMaskEntry.u.mac_mask.EtherTypeBitmask > MAX_aclEgressMacMaskEtherTypeBitmask))
              return SNMP_ERR_WRONGVALUE;
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         /* For row creation, if row_status =0, mean that this is a normal
          * operation, we do the normal set operation, otherwise it is a row
          * creation operation, will do nothing here, and the overall entry
          * will perform in the write_xxxRowStatus function.
          */
        if ( aclEgressMacMaskEntry.u.mac_mask.RowStatus == 0)
        {
          ACL_MaskEntry_T currentdata;
          currentdata.u.mac_mask.EntryIndex=name[oid_name_length];
          if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_MAC_MASK, ACL_EGRESS_MASK, &currentdata))
          {
                  currentdata.u.mac_mask.EtherTypeBitmask =aclEgressMacMaskEntry.u.mac_mask.EtherTypeBitmask;
              if (L4_ACL_MGR_SetMaskEntry(ACL_MAC_MASK, ACL_EGRESS_MASK, &currentdata)!= TRUE)
              {
                   return SNMP_ERR_COMMITFAILED;
              }
          }
          else
          {
              return SNMP_ERR_COMMITFAILED;
          }
        }
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclEgressMacMaskIsEnablePktformat(int action,
                                        u_char * var_val,
                                        u_char var_val_type,
                                        size_t var_val_len,
                                        u_char * statP,
                                        oid * name, size_t name_len)
{
    UI32_T nValue = 0;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLEGRESSMACMASKISENABLEPKTFORMAT)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action )
    {
        case RESERVE1:
             if (var_val_type != ASN_INTEGER)
             {
                return SNMP_ERR_WRONGTYPE;
             }
             if (var_val_len >4)
             {
                return SNMP_ERR_WRONGLENGTH;
             }
             break;

        case RESERVE2:
             /* In reserve2, we overwrite the set value to aclEgressMacMaskEntry*/
             nValue = * (long *) var_val;

             switch(nValue)
             {
                case VAL_aclEgressMacMaskIsEnablePktformat_enabled:
                case VAL_aclEgressMacMaskIsEnablePktformat_disabled:
                     break;

                default:
                     return SNMP_ERR_WRONGVALUE;
             }
             aclEgressMacMaskEntry.u.mac_mask.isEnablePktformat = nValue;
             break;

        case FREE:
             /* Release any resources that have been allocated */
             break;

        case ACTION:
              /* For row creation, if row_status =0, mean that this is a normal
               * operation, we do the normal set operation, otherwise it is a row
               * creation operation, will do nothing here, and the overall entry
               * will perform in the write_xxxRowStatus function.
               */
             if ( aclEgressMacMaskEntry.u.mac_mask.RowStatus == 0)
             {
                  ACL_MaskEntry_T currentdata;

                  memset(&currentdata, 0, sizeof(ACL_MaskEntry_T));

                  if (aclEgressMacMaskEntry.u.mac_mask.isEnablePktformat == VAL_aclEgressMacMaskIsEnablePktformat_enabled)
                  {
                       aclEgressMacMaskEntry.u.mac_mask.isEnablePktformat = TRUE;
                  }
                  else if (aclEgressMacMaskEntry.u.mac_mask.isEnablePktformat == VAL_aclEgressMacMaskIsEnablePktformat_disabled)
                  {
                       aclEgressMacMaskEntry.u.mac_mask.isEnablePktformat = FALSE;
                  }
                  currentdata.u.mac_mask.EntryIndex=name[oid_name_length];

                  if (L4_ACL_MGR_GetMaskEntry_ByIndex(ACL_MAC_MASK, ACL_EGRESS_MASK, &currentdata))
                  {
                     currentdata.u.mac_mask.isEnablePktformat = aclEgressMacMaskEntry.u.mac_mask.isEnablePktformat;
                     if (L4_ACL_MGR_SetMaskEntry(ACL_MAC_MASK, ACL_EGRESS_MASK, &currentdata)!= TRUE)
                     {
                        return SNMP_ERR_COMMITFAILED;
                     }
                  }
                  else
                  {
                     return SNMP_ERR_COMMITFAILED;
                  }
             }
             break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
             break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
             break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclEgressMacMaskStatus(int action,
                             u_char * var_val,
                             u_char var_val_type,
                             size_t var_val_len,
                             u_char * statP, oid * name, size_t name_len)
{

    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    if ((char) name[oid_name_length-1] != ACLEGRESSMACMASKSTATUS)
    {
        return SNMP_ERR_NOTWRITABLE;
    }

    /* check 1: check if the input index is exactly match, if not return fail*/
    if (name_len!=  1 + oid_name_length)
    {
        return SNMP_ERR_WRONGLENGTH;
    }

    switch ( action )
    {
        case RESERVE1:
             if (var_val_type != ASN_INTEGER)
             {
                 return SNMP_ERR_WRONGTYPE;
             }
             if (var_val_len >4)
             {
                 return SNMP_ERR_WRONGLENGTH;
             }
             break;

        case RESERVE2:
             /* In reserve2, we overwrite the set value to aclEgressMacMaskEntry*/
             memcpy(&aclEgressMacMaskEntry.u.mac_mask.RowStatus, var_val, 4);
             if ((aclEgressMacMaskEntry.u.mac_mask.RowStatus < VAL_aclEgressMacMaskStatus_active) || (aclEgressMacMaskEntry.u.mac_mask.RowStatus > VAL_aclEgressMacMaskStatus_destroy))
                 return SNMP_ERR_WRONGVALUE;
             break;

        case FREE:
             /* Release any resources that have been allocated */
             break;

        case ACTION:
             aclEgressMacMaskEntry.u.mac_mask.EntryIndex=name[oid_name_length];
             if (!L4_ACL_MGR_SetMaskEntry_RowStatus(ACL_MAC_MASK, ACL_EGRESS_MASK, aclEgressMacMaskEntry.u.mac_mask.RowStatus, &aclEgressMacMaskEntry))
             {
                 return SNMP_ERR_COMMITFAILED;
             }

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

#endif

#if ((SYS_CPNT_ACL == TRUE) && (SYS_CPNT_QOS_V2 == TRUE))

/*
 * var_aclTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */

#define aclEntry_INSTANCE_LEN 1

static BOOL_T aclTable_get(int      compc,
                           oid     *compl,
                           UI32_T  *acl_index,
                           RULE_TYPE_MIB_Acl_T  *acl_entry)
{
    if (compc !=aclEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    *acl_index = compl[0];
    memset(acl_entry, 0, sizeof(RULE_TYPE_MIB_Acl_T));

    /*get entry
     */
    if (L4_PMGR_QoS_GetDiffServAclEntry(*acl_index, acl_entry)!=TRUE)
        return FALSE;
    else
        return TRUE;
}

static BOOL_T aclTable_next(int      compc,
                            oid     *compl,
                            UI32_T  *acl_index,
                            RULE_TYPE_MIB_Acl_T   *acl_entry)
{
    memset(acl_entry, 0, sizeof(RULE_TYPE_MIB_Acl_T));

    if(compc==0)
    {
        *acl_index=0;
        if (L4_PMGR_QoS_GetDiffServAclEntry(*acl_index, acl_entry)!=TRUE)
        {
            if (L4_PMGR_QoS_GetNextDiffServAclEntry(acl_index, acl_entry)!=TRUE)
            {
                return FALSE;
            }
        }
    }
    else if(compc== aclEntry_INSTANCE_LEN)
    {
        *acl_index = compl[0];
        if (L4_PMGR_QoS_GetNextDiffServAclEntry(acl_index, acl_entry)!=TRUE)
        {
            return FALSE;
        }
    }

    return TRUE;
}

unsigned char  *
var_aclTable(struct variable *vp,
                   oid * name,
                   size_t * length,
                   int exact,
                   size_t * var_len, WriteMethod ** write_method)
{
    //int result;
    UI32_T index=0;
    UI32_T compc=0;
    oid compl[aclEntry_INSTANCE_LEN];
    oid  next_inst[aclEntry_INSTANCE_LEN];
    RULE_TYPE_MIB_Acl_T entry;

    switch (vp->magic)
    {
      case ACLNAME:
        *write_method = write_aclName;
        break;
      case ACLTYPE:
        *write_method = write_aclType;
        break;
      case ACLSTATUS:
        *write_method = write_aclStatus;
        break;
    default:
        *write_method = 0;
    }

    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc, compl,aclEntry_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if (aclTable_get(compc, compl, &index, &entry)!=TRUE)
            return NULL;
    }
    else  /*getnext*/
    {
        if (aclTable_next(compc, compl, &index, &entry)!=TRUE)
            return NULL;
    }

    next_inst[0]=index;
    memcpy (name, vp->name, ( vp->namelen) * sizeof (oid));
    memcpy(name + vp->namelen, next_inst, (aclEntry_INSTANCE_LEN)*sizeof(oid));
    *length = vp->namelen + aclEntry_INSTANCE_LEN;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    *var_len = 4;
    switch (vp->magic)
    {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case ACLINDEX:
        long_return = index;
        return (u_char *) &long_return;
#endif
      case ACLNAME:
        strcpy((char *)return_buf, (char *)entry.acl_name);
        *var_len = strlen((char *)return_buf);
        return (u_char*)return_buf;
      case ACLTYPE:
        long_return = entry.acl_type;
        return (u_char *) &long_return;
      case ACLACEINDEXLIST:
        memcpy(return_buf,  entry.ace_index_list,MAXSIZE_diffServAclAceIndexList);
        *var_len  = entry.size_of_ace_index_list;
        return (u_char*)return_buf;
      case ACLSTATUS:
        long_return = entry.row_status;
        return (u_char *) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

int write_aclName(int       action,
                  u_char    *var_val,
                  u_char    var_val_type,
                  size_t    var_val_len,
                  u_char    *statP,
                  oid       *name,
                  size_t    name_len)
{
    UI32_T  index;
    UI32_T  ace_index=0;
    UI8_T buffer[SYS_ADPT_ACL_MAX_NAME_LEN+1];
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    RULE_TYPE_Ace_Entry_T ace_entry;

    index = name[oid_name_length];
    memset(&ace_entry, 0, sizeof(RULE_TYPE_Ace_Entry_T));

    if(L4_PMGR_ACL_GetNextAceByAcl( index, &ace_index, &ace_entry)==TRUE)
        return SNMP_ERR_COMMITFAILED;

    /*check max length of the inputing index */
    if(name_len > oid_name_length+aclEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if(var_val_len > SYS_ADPT_ACL_MAX_NAME_LEN)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }
        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:

            memcpy(buffer, var_val, var_val_len);
            buffer[var_val_len]='\0';
            if(!L_STDLIB_StrIsAsciiPrintWithCount((char *)buffer, var_val_len))
            {
                return SNMP_ERR_COMMITFAILED;
            }
            if( L4_PMGR_QoS_SetDiffServAclName(index, buffer)!= TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_aclType(int       action,
                  u_char    *var_val,
                  u_char    var_val_type,
                  size_t    var_val_len,
                  u_char    *statP,
                  oid       *name,
                  size_t    name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    UI32_T  index;
    UI32_T  ace_index=0;
    RULE_TYPE_Ace_Entry_T ace_entry;

    index = name[oid_name_length];
    memset(&ace_entry, 0, sizeof(RULE_TYPE_Ace_Entry_T));

    if(L4_PMGR_ACL_GetNextAceByAcl( index, &ace_index, &ace_entry)==TRUE)
        return SNMP_ERR_COMMITFAILED;

    /*check max length of the inputing index */
    if(name_len > oid_name_length+aclEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
#if(SYS_CPNT_ACL_IPV6 == TRUE)
	     if (*(long *)var_val < VAL_diffServAclType_mac || *(long *)var_val>VAL_diffServAclType_ipv6extended )
#else
         if (*(long *)var_val < VAL_diffServAclType_mac || *(long *)var_val>VAL_diffServAclType_ipextended )
#endif
            {
                return SNMP_ERR_WRONGVALUE;
            }

            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
            index = name[oid_name_length];
            value = *(long *)var_val;
            if( L4_PMGR_QoS_SetDiffServAclType(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;

        break;
        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int write_aclStatus(int       action,
                  u_char    *var_val,
                  u_char    var_val_type,
                  size_t    var_val_len,
                  u_char    *statP,
                  oid       *name,
                  size_t    name_len)
{
    long value;
    UI32_T  index;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;

    /*check max length of the inputing index */
    if(name_len > oid_name_length+aclEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }

        case RESERVE2:
          if ((*(long *)var_val < VAL_aclIpAceStatus_active) || (*(long *)var_val > VAL_aclIpAceStatus_destroy))
              return SNMP_ERR_WRONGVALUE;
          if (*(long *)var_val == VAL_aclIpAceStatus_notReady)
              return SNMP_ERR_WRONGVALUE;
            break;

        case FREE:
            break;

        case ACTION:
            index = name[oid_name_length];
            value = *(long *)var_val;
           if( L4_PMGR_QoS_SetDiffServAclStatus(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}


static UI32_T aclAttachCtlIndex=0;
static UI32_T aclAttachCtlAceType=0;
static UI32_T aclAttachCtlAceIndex=0;
static UI32_T aclAttachCtlAction=VAL_diffServAclAttachCtlAction_notAction;

int do_aclAttachCtlIndex(netsnmp_mib_handler          *handler,
                                       netsnmp_handler_registration *reginfo,
                                       netsnmp_agent_request_info   *reqinfo,
                                       netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            long_return = aclAttachCtlIndex;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, 4);

            break;
        }

        case MODE_SET_RESERVE1:
            if ((requests->requestvb->type)!= ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            aclAttachCtlIndex = (*requests->requestvb->val.integer);
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_aclAttachCtlAceType(netsnmp_mib_handler          *handler,
                                       netsnmp_handler_registration *reginfo,
                                       netsnmp_agent_request_info   *reqinfo,
                                       netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            long_return = aclAttachCtlAceType;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, 4);

            break;
        }

        case MODE_SET_RESERVE1:
            if ((requests->requestvb->type)!= ASN_INTEGER)
        	{
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
				break;
        	}

#if(SYS_CPNT_ACL_IPV6 == TRUE)
            if( VAL_diffServAclAttachCtlAceType_macAce >(*requests->requestvb->val.integer) || VAL_diffServAclAttachCtlAceType_ipv6Ace<(*requests->requestvb->val.integer))
#else
            if( VAL_diffServAclAttachCtlAceType_macAce >(*requests->requestvb->val.integer) || VAL_diffServAclAttachCtlAceType_ipAce<(*requests->requestvb->val.integer))
#endif
            {
                if( 0 == (*requests->requestvb->val.integer))
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_INCONSISTENTVALUE);
                else
                    netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);
            }
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            aclAttachCtlAceType = (*requests->requestvb->val.integer);
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_aclAttachCtlAceIndex(netsnmp_mib_handler          *handler,
                                       netsnmp_handler_registration *reginfo,
                                       netsnmp_agent_request_info   *reqinfo,
                                       netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            long_return = aclAttachCtlAceIndex;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, 4);

            break;
        }

        case MODE_SET_RESERVE1:
            if ((requests->requestvb->type)!= ASN_INTEGER)
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            aclAttachCtlAceIndex = (*requests->requestvb->val.integer);
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int do_aclAttachCtlAction(netsnmp_mib_handler          *handler,
                                       netsnmp_handler_registration *reginfo,
                                       netsnmp_agent_request_info   *reqinfo,
                                       netsnmp_request_info         *requests)
{
    switch (reqinfo->mode)
    {
        case MODE_GET:
        {
            long_return = VAL_diffServAclAttachCtlAction_notAction;
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *) &long_return, 4);

            break;
        }

        case MODE_SET_RESERVE1:
            if ((requests->requestvb->type)!= ASN_INTEGER)
        	{
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGTYPE);
				break;
        	}

            if (((*requests->requestvb->val.integer)<VAL_diffServAclAttachCtlAction_notAction)  || ((*requests->requestvb->val.integer)>VAL_diffServAclAttachCtlAction_notAttaching))
                netsnmp_set_request_error(reqinfo, requests,  SNMP_ERR_WRONGVALUE);

            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
        {
            aclAttachCtlAction = (*requests->requestvb->val.integer);
            if(L4_PMGR_QoS_SetDiffServAclAttachCtlAction(aclAttachCtlIndex,aclAttachCtlAceType,aclAttachCtlAceIndex,aclAttachCtlAction )!=TRUE)
                return SNMP_ERR_COMMITFAILED;
            aclAttachCtlAction=VAL_diffServAclAttachCtlAction_notAction;
            break;
        }

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_ACL_IPV6 == TRUE)
#define aclIpv6AceEntry_INSTANCE_LEN 1
/*
 * var_diffServMeterTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */

static BOOL_T 
aclIpv6AceTable_get(
    int      compc,
    oid     *compl,
    UI32_T *index,
    RULE_TYPE_UI_Ace_Entry_T *ace_p)
{
    if (compc !=aclIpv6AceEntry_INSTANCE_LEN)
    {
        return FALSE;
    }
    *index = compl[0];
    memset(ace_p, 0, sizeof(*ace_p));


    /*get data
     */
    if (L4_PMGR_QoS_GetDiffServIpv6AceEntry(*index, ace_p) != RULE_TYPE_OK)
    {
        return FALSE;
    }

    switch (ace_p->ace_type)
    {
        case RULE_TYPE_IPV6_EXT_ACL:
            ace_p->ace_type   = VAL_diffServIpv6AceType_extended;
            break;

        case RULE_TYPE_IPV6_STD_ACL:
            ace_p->ace_type   = VAL_diffServIpv6AceType_standard;
            break;

        default:
            break;
    }

    return TRUE;
}

static BOOL_T
aclIpv6AceTable_next(
    int      compc,
    oid     *compl,
    UI32_T *index,
    RULE_TYPE_UI_Ace_Entry_T *ace_p)
{
    *index = compl[0];
    memset(ace_p, 0, sizeof(*ace_p));
    /*check  the length of inputing index,if <1 we should try get {0.0.0.0.0...} */
    if (compc < 1)
    {
        /*get data*/
        if (L4_PMGR_QoS_GetDiffServIpv6AceEntry(*index, ace_p) != RULE_TYPE_OK)
        {
            /*get data*/
            if (L4_PMGR_QoS_GetNextDiffServIpv6AceEntry(index, ace_p) != RULE_TYPE_OK)
            {
                return FALSE;
            }
        }
    }
    else
    {
        /*get data*/
        if (L4_PMGR_QoS_GetNextDiffServIpv6AceEntry(index, ace_p) != RULE_TYPE_OK)
        {
            return FALSE;
        }
    }

    switch (ace_p->ace_type)
    {
        case RULE_TYPE_IPV6_EXT_ACL:
            ace_p->ace_type   = VAL_diffServIpv6AceType_extended;
            break;

        case RULE_TYPE_IPV6_STD_ACL:
            ace_p->ace_type   = VAL_diffServIpv6AceType_standard;
            break;

        default:
            break;
    }

    return TRUE;
}

/*
 * var_diffServIpv6AceTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ above.
 */
unsigned char  *
var_aclIpv6AceTable(struct variable *vp,
                         oid * name,
                         size_t * length,
                         int exact,
                         size_t * var_len, WriteMethod ** write_method)
{
    UI32_T compc=0;
    UI32_T index=0;
    oid compl[aclIpv6AceEntry_INSTANCE_LEN];
    oid best_inst[aclIpv6AceEntry_INSTANCE_LEN];
    RULE_TYPE_UI_Ace_Entry_T ace;

    switch (vp->magic) {
         case ACLIPV6ACETYPE:
           *write_method = write_aclIpv6AceType;
           break;
         case ACLIPV6ACEACCESS:
           *write_method = write_aclIpv6AceAccess;
           break;
         case ACLIPV6ACESOURCEIPADDR:
           *write_method = write_aclIpv6AceSourceIpAddr;
           break;
         case ACLIPV6ACESOURCEIPADDRPREFIXLEN:
           *write_method = write_aclIpv6AceSourceIpAddrPrefixLen;
           break;
         case ACLIPV6ACEDESTIPADDR:
           *write_method = write_aclIpv6AceDestIpAddr;
           break;
         case ACLIPV6ACEDESTIPADDRPREFIXLEN:
           *write_method = write_aclIpv6AceDestIpAddrPrefixLen;
           break;

#if (SYS_CPNT_ACL_IPV6_NEXT_HEADER == TRUE)
         case ACLIPV6ACENEXTHEADER:
           *write_method = write_aclIpv6AceNextHeader;
           break;
#endif /* end of #if (SYS_CPNT_ACL_IPV6_NEXT_HEADER == TRUE) */

         case ACLIPV6ACEDSCP:
           *write_method = write_aclIpv6AceDscp;
           break;

#if (SYS_CPNT_ACL_IPV6_FLOW_LABEL == TRUE)
         case ACLIPV6ACEFLOWLABEL:
           *write_method = write_aclIpv6AceFlowLabel;
           break;
#endif /* end of #if (SYS_CPNT_ACL_IPV6_FLOW_LABEL == TRUE) */

         case ACLIPV6ACESTATUS:
           *write_method = write_aclIpv6AceStatus;
           break;
       default:
           *write_method = 0;
           break;
       }
    
    SNMP_MGR_RetrieveCompl(vp->name, vp->namelen, name, *length, &compc,compl, aclIpv6AceEntry_INSTANCE_LEN);

    if (exact)/*get,set*/
    {
        if (!aclIpv6AceTable_get(compc, compl, &index, &ace))
            return NULL;
    }
    else/*getnext*/
    {
        if (!aclIpv6AceTable_next(compc, compl, &index, &ace))
        {
            return NULL;
        }
    }

    memcpy(name, vp->name, vp->namelen*sizeof(oid));
    best_inst[0] = index;
    memcpy(name + vp->namelen, best_inst, aclIpv6AceEntry_INSTANCE_LEN*sizeof(oid));
    *length = vp->namelen + aclIpv6AceEntry_INSTANCE_LEN;

    /*
     * * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
#if (SYS_ADPT_PRIVATEMIB_INDEX_ACCESSIBLE == 1)
      case ACLIPV6ACEINDEX:
        long_return = index;
        *var_len = 4;
        return (u_char *) &long_return;
#endif
      case ACLIPV6ACETYPE:
        long_return = (UI32_T)ace.ace_type;
        *var_len = 4;
        return (u_char *) &long_return;
      case ACLIPV6ACEACCESS:
        long_return = (UI32_T)ace.access;
        *var_len = 4;
        return (u_char *) &long_return;
      case ACLIPV6ACESOURCEIPADDR:
        memcpy(return_buf, ace.ipv6.sip.addr, MAXSIZE_diffServIpv6AceSourceIpAddr);
        *var_len = MAXSIZE_diffServIpv6AceSourceIpAddr;
        return (u_char *) &return_buf;
      case ACLIPV6ACESOURCEIPADDRPREFIXLEN:
        long_return = (UI32_T)ace.ipv6.sip.prefix_len;
        *var_len = 4;
        return (u_char *) &long_return;
      case ACLIPV6ACEDESTIPADDR:
        memcpy(return_buf, ace.ipv6.dip.addr, MAXSIZE_diffServIpv6AceDestIpAddr);
        *var_len = MAXSIZE_diffServIpv6AceDestIpAddr;
        return (u_char *) &return_buf;
      case ACLIPV6ACEDESTIPADDRPREFIXLEN:
        long_return = (UI32_T)ace.ipv6.dip.prefix_len;
        *var_len = 4;
        return (u_char *) &long_return;

#if (SYS_CPNT_ACL_IPV6_NEXT_HEADER == TRUE)
      case ACLIPV6ACENEXTHEADER:
        long_return = (UI32_T)ace.ipv6.next_header.u.s.data;
        *var_len = 4;
        return (u_char *) &long_return;
#endif /* end of #if (SYS_CPNT_ACL_IPV6_NEXT_HEADER == TRUE) */

      case ACLIPV6ACEDSCP:
        /* traffic class =  DS field(6 bits) + ECN (2 bits)
         */
        long_return = (UI32_T)ace.ipv6.traffic_class.u.s.data >> 2;
        *var_len = 4;
        return (u_char *) &long_return;

#if (SYS_CPNT_ACL_IPV6_FLOW_LABEL == TRUE)
      case ACLIPV6ACEFLOWLABEL:
        long_return = (UI32_T)ace.ipv6.flow_label.u.s.data;
        *var_len = 4;
        return (u_char *) &long_return;
#endif /* end of #if (SYS_CPNT_ACL_IPV6_FLOW_LABEL == TRUE) */

      case ACLIPV6ACESTATUS:
        long_return = (UI32_T)ace.row_status;
        *var_len = 4;
        return (u_char *) &long_return;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

int
write_aclIpv6AceType(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+aclIpv6AceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val  < VAL_diffServIpv6AceType_standard || *(long *)var_val  > VAL_diffServIpv6AceType_extended)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServIpv6AceType(index, (UI8_T)value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_aclIpv6AceAccess(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+aclIpv6AceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val  < VAL_diffServIpv6AceAccess_permit || *(long *)var_val  > VAL_diffServIpv6AceAccess_deny)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServIpv6AceAccess(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIpv6AceSourceIpAddr(int action,
                                  u_char * var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char * statP,
                                  oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+aclIpv6AceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > MAXSIZE_diffServIpv6AceSourceIpAddr)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            UI8_T buffer[MAXSIZE_diffServIpv6AceSourceIpAddr] = {0};
            index = name[oid_name_length];
            memcpy(buffer,var_val,var_val_len);
            if(L4_PMGR_QoS_SetDiffServIpv6AceSourceIpAddr(index, buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIpv6AceSourceIpAddrPrefixLen(int action,
                                           u_char * var_val,
                                           u_char var_val_type,
                                           size_t var_val_len,
                                           u_char * statP,
                                           oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+aclIpv6AceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if ( *(long *)var_val  > MAX_diffServIpv6AceSourceIpAddrPrefixLen)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServIpv6AceSourceIpAddrPrefix(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIpv6AceDestIpAddr(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+aclIpv6AceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_OCTET_STR)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > MAXSIZE_diffServIpv6AceDestIpAddr)
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            UI8_T buffer[MAXSIZE_diffServIpv6AceDestIpAddr] = {0};
            index = name[oid_name_length];
            memcpy(buffer,var_val,var_val_len);
            if(L4_PMGR_QoS_SetDiffServIpv6AceDestIpAddr(index, buffer) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_aclIpv6AceDestIpAddrPrefixLen(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+aclIpv6AceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if ( *(long *)var_val  > SYS_ADPT_ACL_MAX_DST_IPV6_PREFIX_LEN)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if( L4_PMGR_QoS_SetDiffServIpv6AceDestIpAddrPrefix(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_ACL_IPV6_NEXT_HEADER == TRUE)
int
write_aclIpv6AceNextHeader(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+aclIpv6AceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if ( *(long *)var_val  > MAX_diffServIpv6AceNextHeader)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServIpv6AceNextHeader(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* end of #if (SYS_CPNT_ACL_IPV6_NEXT_HEADER == TRUE) */

int
write_aclIpv6AceDscp(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+aclIpv6AceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if ( *(long *)var_val  > MAX_diffServIpv6AceDscp)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServIpv6AceDscp(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}

#if (SYS_CPNT_ACL_IPV6_FLOW_LABEL == TRUE)
int
write_aclIpv6AceFlowLabel(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+aclIpv6AceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(UI32_T *) var_val < MIN_diffServIpv6AceFlowLabel|| *(UI32_T *) var_val > MAX_diffServIpv6AceFlowLabel)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServIpv6AceFlowLabel(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* end of #if (SYS_CPNT_ACL_IPV6_FLOW_LABEL == TRUE) */

int
write_aclIpv6AceStatus(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long value;
    UI32_T oid_name_length = SNMP_MGR_Get_PrivateMibRootLen() + 6;
    /*check max length of the inputing index */
    if(name_len > oid_name_length+aclIpv6AceEntry_INSTANCE_LEN)
    {
        return SNMP_ERR_WRONGLENGTH;
    }
    switch (action)
    {
        case RESERVE1:
        {
            if (var_val_type != ASN_INTEGER)
            {
                return SNMP_ERR_WRONGTYPE;
            }
            if (var_val_len > sizeof(long))
            {
                return SNMP_ERR_WRONGLENGTH;
            }
            if (*(long *)var_val  < VAL_diffServIpv6AceStatus_active || *(long *)var_val > VAL_diffServIpv6AceStatus_destroy)
            {
                return SNMP_ERR_WRONGVALUE;
            }
            else if (*(long *)var_val == VAL_aclIpAceStatus_notReady)
              return SNMP_ERR_WRONGVALUE;
            break;
        }

        case RESERVE2:
        {
            break;
        }

        case FREE:
            break;

        case ACTION:
        {
            UI32_T  index;
            index = name[oid_name_length];
            value = *(long *)var_val;
            if(L4_PMGR_QoS_SetDiffServIpv6AceStatus(index, value) != TRUE)
                return SNMP_ERR_COMMITFAILED;
            break;
        }

        case UNDO:
            /* Back out any changes made in the ACTION case */
            break;

        case COMMIT:
            /*
             * Things are working well, so it's now safe to make the change
             * permanently.  Make sure that anything done here can't fail!
             */
            break;
    }
    return SNMP_ERR_NOERROR;
}
#endif /* end of #if (SYS_CPNT_ACL_IPV6 == TRUE) */
#endif /* end of #if (SYS_CPNT_ACL == TRUE)*/

